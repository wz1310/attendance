(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))a(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&a(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function a(r){if(r.ep)return;r.ep=!0;const s=n(r);fetch(r.href,s)}})();function wF(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var _F={exports:{}},vw={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var D8=Symbol.for("react.transitional.element"),$8=Symbol.for("react.fragment");function SF(e,t,n){var a=null;if(n!==void 0&&(a=""+n),t.key!==void 0&&(a=""+t.key),"key"in t){n={};for(var r in t)r!=="key"&&(n[r]=t[r])}else n=t;return t=n.ref,{$$typeof:D8,type:e,key:a,ref:t!==void 0?t:null,props:n}}vw.Fragment=$8;vw.jsx=SF;vw.jsxs=SF;_F.exports=vw;var P=_F.exports,IF={exports:{}},ct={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var IT=Symbol.for("react.transitional.element"),M8=Symbol.for("react.portal"),O8=Symbol.for("react.fragment"),F8=Symbol.for("react.strict_mode"),L8=Symbol.for("react.profiler"),z8=Symbol.for("react.consumer"),P8=Symbol.for("react.context"),V8=Symbol.for("react.forward_ref"),B8=Symbol.for("react.suspense"),U8=Symbol.for("react.memo"),kF=Symbol.for("react.lazy"),W8=Symbol.for("react.activity"),HR=Symbol.iterator;function j8(e){return e===null||typeof e!="object"?null:(e=HR&&e[HR]||e["@@iterator"],typeof e=="function"?e:null)}var TF={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},EF=Object.assign,NF={};function ff(e,t,n){this.props=e,this.context=t,this.refs=NF,this.updater=n||TF}ff.prototype.isReactComponent={};ff.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};ff.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function CF(){}CF.prototype=ff.prototype;function kT(e,t,n){this.props=e,this.context=t,this.refs=NF,this.updater=n||TF}var TT=kT.prototype=new CF;TT.constructor=kT;EF(TT,ff.prototype);TT.isPureReactComponent=!0;var qR=Array.isArray;function ZS(){}var mn={H:null,A:null,T:null,S:null},AF=Object.prototype.hasOwnProperty;function ET(e,t,n){var a=n.ref;return{$$typeof:IT,type:e,key:t,ref:a!==void 0?a:null,props:n}}function G8(e,t){return ET(e.type,t,e.props)}function NT(e){return typeof e=="object"&&e!==null&&e.$$typeof===IT}function H8(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var KR=/\/+/g;function P_(e,t){return typeof e=="object"&&e!==null&&e.key!=null?H8(""+e.key):t.toString(36)}function q8(e){switch(e.status){case"fulfilled":return e.value;case"rejected":throw e.reason;default:switch(typeof e.status=="string"?e.then(ZS,ZS):(e.status="pending",e.then(function(t){e.status==="pending"&&(e.status="fulfilled",e.value=t)},function(t){e.status==="pending"&&(e.status="rejected",e.reason=t)})),e.status){case"fulfilled":return e.value;case"rejected":throw e.reason}}throw e}function Kd(e,t,n,a,r){var s=typeof e;(s==="undefined"||s==="boolean")&&(e=null);var i=!1;if(e===null)i=!0;else switch(s){case"bigint":case"string":case"number":i=!0;break;case"object":switch(e.$$typeof){case IT:case M8:i=!0;break;case kF:return i=e._init,Kd(i(e._payload),t,n,a,r)}}if(i)return r=r(e),i=a===""?"."+P_(e,0):a,qR(r)?(n="",i!=null&&(n=i.replace(KR,"$&/")+"/"),Kd(r,t,n,"",function(c){return c})):r!=null&&(NT(r)&&(r=G8(r,n+(r.key==null||e&&e.key===r.key?"":(""+r.key).replace(KR,"$&/")+"/")+i)),t.push(r)),1;i=0;var o=a===""?".":a+":";if(qR(e))for(var l=0;l<e.length;l++)a=e[l],s=o+P_(a,l),i+=Kd(a,t,n,s,r);else if(l=j8(e),typeof l=="function")for(e=l.call(e),l=0;!(a=e.next()).done;)a=a.value,s=o+P_(a,l++),i+=Kd(a,t,n,s,r);else if(s==="object"){if(typeof e.then=="function")return Kd(q8(e),t,n,a,r);throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.")}return i}function Ov(e,t,n){if(e==null)return e;var a=[],r=0;return Kd(e,a,"","",function(s){return t.call(n,s,r++)}),a}function K8(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var XR=typeof reportError=="function"?reportError:function(e){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof e=="object"&&e!==null&&typeof e.message=="string"?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",e);return}console.error(e)},X8={map:Ov,forEach:function(e,t,n){Ov(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return Ov(e,function(){t++}),t},toArray:function(e){return Ov(e,function(t){return t})||[]},only:function(e){if(!NT(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};ct.Activity=W8;ct.Children=X8;ct.Component=ff;ct.Fragment=O8;ct.Profiler=L8;ct.PureComponent=kT;ct.StrictMode=F8;ct.Suspense=B8;ct.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=mn;ct.__COMPILER_RUNTIME={__proto__:null,c:function(e){return mn.H.useMemoCache(e)}};ct.cache=function(e){return function(){return e.apply(null,arguments)}};ct.cacheSignal=function(){return null};ct.cloneElement=function(e,t,n){if(e==null)throw Error("The argument must be a React element, but you passed "+e+".");var a=EF({},e.props),r=e.key;if(t!=null)for(s in t.key!==void 0&&(r=""+t.key),t)!AF.call(t,s)||s==="key"||s==="__self"||s==="__source"||s==="ref"&&t.ref===void 0||(a[s]=t[s]);var s=arguments.length-2;if(s===1)a.children=n;else if(1<s){for(var i=Array(s),o=0;o<s;o++)i[o]=arguments[o+2];a.children=i}return ET(e.type,r,a)};ct.createContext=function(e){return e={$$typeof:P8,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null},e.Provider=e,e.Consumer={$$typeof:z8,_context:e},e};ct.createElement=function(e,t,n){var a,r={},s=null;if(t!=null)for(a in t.key!==void 0&&(s=""+t.key),t)AF.call(t,a)&&a!=="key"&&a!=="__self"&&a!=="__source"&&(r[a]=t[a]);var i=arguments.length-2;if(i===1)r.children=n;else if(1<i){for(var o=Array(i),l=0;l<i;l++)o[l]=arguments[l+2];r.children=o}if(e&&e.defaultProps)for(a in i=e.defaultProps,i)r[a]===void 0&&(r[a]=i[a]);return ET(e,s,r)};ct.createRef=function(){return{current:null}};ct.forwardRef=function(e){return{$$typeof:V8,render:e}};ct.isValidElement=NT;ct.lazy=function(e){return{$$typeof:kF,_payload:{_status:-1,_result:e},_init:K8}};ct.memo=function(e,t){return{$$typeof:U8,type:e,compare:t===void 0?null:t}};ct.startTransition=function(e){var t=mn.T,n={};mn.T=n;try{var a=e(),r=mn.S;r!==null&&r(n,a),typeof a=="object"&&a!==null&&typeof a.then=="function"&&a.then(ZS,XR)}catch(s){XR(s)}finally{t!==null&&n.types!==null&&(t.types=n.types),mn.T=t}};ct.unstable_useCacheRefresh=function(){return mn.H.useCacheRefresh()};ct.use=function(e){return mn.H.use(e)};ct.useActionState=function(e,t,n){return mn.H.useActionState(e,t,n)};ct.useCallback=function(e,t){return mn.H.useCallback(e,t)};ct.useContext=function(e){return mn.H.useContext(e)};ct.useDebugValue=function(){};ct.useDeferredValue=function(e,t){return mn.H.useDeferredValue(e,t)};ct.useEffect=function(e,t){return mn.H.useEffect(e,t)};ct.useEffectEvent=function(e){return mn.H.useEffectEvent(e)};ct.useId=function(){return mn.H.useId()};ct.useImperativeHandle=function(e,t,n){return mn.H.useImperativeHandle(e,t,n)};ct.useInsertionEffect=function(e,t){return mn.H.useInsertionEffect(e,t)};ct.useLayoutEffect=function(e,t){return mn.H.useLayoutEffect(e,t)};ct.useMemo=function(e,t){return mn.H.useMemo(e,t)};ct.useOptimistic=function(e,t){return mn.H.useOptimistic(e,t)};ct.useReducer=function(e,t,n){return mn.H.useReducer(e,t,n)};ct.useRef=function(e){return mn.H.useRef(e)};ct.useState=function(e){return mn.H.useState(e)};ct.useSyncExternalStore=function(e,t,n){return mn.H.useSyncExternalStore(e,t,n)};ct.useTransition=function(){return mn.H.useTransition()};ct.version="19.2.3";IF.exports=ct;var We=IF.exports;const RF=wF(We);var DF={exports:{}},xw={},$F={exports:{}},MF={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function t(B,Q){var H=B.length;B.push(Q);e:for(;0<H;){var J=H-1>>>1,ae=B[J];if(0<r(ae,Q))B[J]=Q,B[H]=ae,H=J;else break e}}function n(B){return B.length===0?null:B[0]}function a(B){if(B.length===0)return null;var Q=B[0],H=B.pop();if(H!==Q){B[0]=H;e:for(var J=0,ae=B.length,ne=ae>>>1;J<ne;){var ue=2*(J+1)-1,le=B[ue],he=ue+1,me=B[he];if(0>r(le,H))he<ae&&0>r(me,le)?(B[J]=me,B[he]=H,J=he):(B[J]=le,B[ue]=H,J=ue);else if(he<ae&&0>r(me,H))B[J]=me,B[he]=H,J=he;else break e}}return Q}function r(B,Q){var H=B.sortIndex-Q.sortIndex;return H!==0?H:B.id-Q.id}if(e.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var s=performance;e.unstable_now=function(){return s.now()}}else{var i=Date,o=i.now();e.unstable_now=function(){return i.now()-o}}var l=[],c=[],u=1,h=null,d=3,p=!1,f=!1,m=!1,g=!1,y=typeof setTimeout=="function"?setTimeout:null,v=typeof clearTimeout=="function"?clearTimeout:null,x=typeof setImmediate<"u"?setImmediate:null;function w(B){for(var Q=n(c);Q!==null;){if(Q.callback===null)a(c);else if(Q.startTime<=B)a(c),Q.sortIndex=Q.expirationTime,t(l,Q);else break;Q=n(c)}}function k(B){if(m=!1,w(B),!f)if(n(l)!==null)f=!0,M||(M=!0,_());else{var Q=n(c);Q!==null&&q(k,Q.startTime-B)}}var M=!1,S=-1,I=5,E=-1;function R(){return g?!0:!(e.unstable_now()-E<I)}function A(){if(g=!1,M){var B=e.unstable_now();E=B;var Q=!0;try{e:{f=!1,m&&(m=!1,v(S),S=-1),p=!0;var H=d;try{t:{for(w(B),h=n(l);h!==null&&!(h.expirationTime>B&&R());){var J=h.callback;if(typeof J=="function"){h.callback=null,d=h.priorityLevel;var ae=J(h.expirationTime<=B);if(B=e.unstable_now(),typeof ae=="function"){h.callback=ae,w(B),Q=!0;break t}h===n(l)&&a(l),w(B)}else a(l);h=n(l)}if(h!==null)Q=!0;else{var ne=n(c);ne!==null&&q(k,ne.startTime-B),Q=!1}}break e}finally{h=null,d=H,p=!1}Q=void 0}}finally{Q?_():M=!1}}}var _;if(typeof x=="function")_=function(){x(A)};else if(typeof MessageChannel<"u"){var D=new MessageChannel,j=D.port2;D.port1.onmessage=A,_=function(){j.postMessage(null)}}else _=function(){y(A,0)};function q(B,Q){S=y(function(){B(e.unstable_now())},Q)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(B){B.callback=null},e.unstable_forceFrameRate=function(B){0>B||125<B?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):I=0<B?Math.floor(1e3/B):5},e.unstable_getCurrentPriorityLevel=function(){return d},e.unstable_next=function(B){switch(d){case 1:case 2:case 3:var Q=3;break;default:Q=d}var H=d;d=Q;try{return B()}finally{d=H}},e.unstable_requestPaint=function(){g=!0},e.unstable_runWithPriority=function(B,Q){switch(B){case 1:case 2:case 3:case 4:case 5:break;default:B=3}var H=d;d=B;try{return Q()}finally{d=H}},e.unstable_scheduleCallback=function(B,Q,H){var J=e.unstable_now();switch(typeof H=="object"&&H!==null?(H=H.delay,H=typeof H=="number"&&0<H?J+H:J):H=J,B){case 1:var ae=-1;break;case 2:ae=250;break;case 5:ae=1073741823;break;case 4:ae=1e4;break;default:ae=5e3}return ae=H+ae,B={id:u++,callback:Q,priorityLevel:B,startTime:H,expirationTime:ae,sortIndex:-1},H>J?(B.sortIndex=H,t(c,B),n(l)===null&&B===n(c)&&(m?(v(S),S=-1):m=!0,q(k,H-J))):(B.sortIndex=ae,t(l,B),f||p||(f=!0,M||(M=!0,_()))),B},e.unstable_shouldYield=R,e.unstable_wrapCallback=function(B){var Q=d;return function(){var H=d;d=Q;try{return B.apply(this,arguments)}finally{d=H}}}})(MF);$F.exports=MF;var Q8=$F.exports,OF={exports:{}},vr={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Y8=We;function FF(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function qo(){}var dr={d:{f:qo,r:function(){throw Error(FF(522))},D:qo,C:qo,L:qo,m:qo,X:qo,S:qo,M:qo},p:0,findDOMNode:null},Z8=Symbol.for("react.portal");function J8(e,t,n){var a=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Z8,key:a==null?null:""+a,children:e,containerInfo:t,implementation:n}}var Lg=Y8.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function ww(e,t){if(e==="font")return"";if(typeof t=="string")return t==="use-credentials"?t:""}vr.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=dr;vr.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11)throw Error(FF(299));return J8(e,t,null,n)};vr.flushSync=function(e){var t=Lg.T,n=dr.p;try{if(Lg.T=null,dr.p=2,e)return e()}finally{Lg.T=t,dr.p=n,dr.d.f()}};vr.preconnect=function(e,t){typeof e=="string"&&(t?(t=t.crossOrigin,t=typeof t=="string"?t==="use-credentials"?t:"":void 0):t=null,dr.d.C(e,t))};vr.prefetchDNS=function(e){typeof e=="string"&&dr.d.D(e)};vr.preinit=function(e,t){if(typeof e=="string"&&t&&typeof t.as=="string"){var n=t.as,a=ww(n,t.crossOrigin),r=typeof t.integrity=="string"?t.integrity:void 0,s=typeof t.fetchPriority=="string"?t.fetchPriority:void 0;n==="style"?dr.d.S(e,typeof t.precedence=="string"?t.precedence:void 0,{crossOrigin:a,integrity:r,fetchPriority:s}):n==="script"&&dr.d.X(e,{crossOrigin:a,integrity:r,fetchPriority:s,nonce:typeof t.nonce=="string"?t.nonce:void 0})}};vr.preinitModule=function(e,t){if(typeof e=="string")if(typeof t=="object"&&t!==null){if(t.as==null||t.as==="script"){var n=ww(t.as,t.crossOrigin);dr.d.M(e,{crossOrigin:n,integrity:typeof t.integrity=="string"?t.integrity:void 0,nonce:typeof t.nonce=="string"?t.nonce:void 0})}}else t==null&&dr.d.M(e)};vr.preload=function(e,t){if(typeof e=="string"&&typeof t=="object"&&t!==null&&typeof t.as=="string"){var n=t.as,a=ww(n,t.crossOrigin);dr.d.L(e,n,{crossOrigin:a,integrity:typeof t.integrity=="string"?t.integrity:void 0,nonce:typeof t.nonce=="string"?t.nonce:void 0,type:typeof t.type=="string"?t.type:void 0,fetchPriority:typeof t.fetchPriority=="string"?t.fetchPriority:void 0,referrerPolicy:typeof t.referrerPolicy=="string"?t.referrerPolicy:void 0,imageSrcSet:typeof t.imageSrcSet=="string"?t.imageSrcSet:void 0,imageSizes:typeof t.imageSizes=="string"?t.imageSizes:void 0,media:typeof t.media=="string"?t.media:void 0})}};vr.preloadModule=function(e,t){if(typeof e=="string")if(t){var n=ww(t.as,t.crossOrigin);dr.d.m(e,{as:typeof t.as=="string"&&t.as!=="script"?t.as:void 0,crossOrigin:n,integrity:typeof t.integrity=="string"?t.integrity:void 0})}else dr.d.m(e)};vr.requestFormReset=function(e){dr.d.r(e)};vr.unstable_batchedUpdates=function(e,t){return e(t)};vr.useFormState=function(e,t,n){return Lg.H.useFormState(e,t,n)};vr.useFormStatus=function(){return Lg.H.useHostTransitionStatus()};vr.version="19.2.3";function LF(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(LF)}catch(e){console.error(e)}}LF(),OF.exports=vr;var e9=OF.exports;/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ba=Q8,zF=We,t9=e9;function pe(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function PF(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function Xy(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function VF(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function BF(e){if(e.tag===31){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function QR(e){if(Xy(e)!==e)throw Error(pe(188))}function n9(e){var t=e.alternate;if(!t){if(t=Xy(e),t===null)throw Error(pe(188));return t!==e?null:e}for(var n=e,a=t;;){var r=n.return;if(r===null)break;var s=r.alternate;if(s===null){if(a=r.return,a!==null){n=a;continue}break}if(r.child===s.child){for(s=r.child;s;){if(s===n)return QR(r),e;if(s===a)return QR(r),t;s=s.sibling}throw Error(pe(188))}if(n.return!==a.return)n=r,a=s;else{for(var i=!1,o=r.child;o;){if(o===n){i=!0,n=r,a=s;break}if(o===a){i=!0,a=r,n=s;break}o=o.sibling}if(!i){for(o=s.child;o;){if(o===n){i=!0,n=s,a=r;break}if(o===a){i=!0,a=s,n=r;break}o=o.sibling}if(!i)throw Error(pe(189))}}if(n.alternate!==a)throw Error(pe(190))}if(n.tag!==3)throw Error(pe(188));return n.stateNode.current===n?e:t}function UF(e){var t=e.tag;if(t===5||t===26||t===27||t===6)return e;for(e=e.child;e!==null;){if(t=UF(e),t!==null)return t;e=e.sibling}return null}var bn=Object.assign,a9=Symbol.for("react.element"),Fv=Symbol.for("react.transitional.element"),bg=Symbol.for("react.portal"),rp=Symbol.for("react.fragment"),WF=Symbol.for("react.strict_mode"),JS=Symbol.for("react.profiler"),jF=Symbol.for("react.consumer"),ho=Symbol.for("react.context"),CT=Symbol.for("react.forward_ref"),eI=Symbol.for("react.suspense"),tI=Symbol.for("react.suspense_list"),AT=Symbol.for("react.memo"),tl=Symbol.for("react.lazy"),nI=Symbol.for("react.activity"),r9=Symbol.for("react.memo_cache_sentinel"),YR=Symbol.iterator;function ig(e){return e===null||typeof e!="object"?null:(e=YR&&e[YR]||e["@@iterator"],typeof e=="function"?e:null)}var s9=Symbol.for("react.client.reference");function aI(e){if(e==null)return null;if(typeof e=="function")return e.$$typeof===s9?null:e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case rp:return"Fragment";case JS:return"Profiler";case WF:return"StrictMode";case eI:return"Suspense";case tI:return"SuspenseList";case nI:return"Activity"}if(typeof e=="object")switch(e.$$typeof){case bg:return"Portal";case ho:return e.displayName||"Context";case jF:return(e._context.displayName||"Context")+".Consumer";case CT:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case AT:return t=e.displayName||null,t!==null?t:aI(e.type)||"Memo";case tl:t=e._payload,e=e._init;try{return aI(e(t))}catch{}}return null}var vg=Array.isArray,Qe=zF.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,zt=t9.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,uc={pending:!1,data:null,method:null,action:null},rI=[],sp=-1;function Ui(e){return{current:e}}function Aa(e){0>sp||(e.current=rI[sp],rI[sp]=null,sp--)}function cn(e,t){sp++,rI[sp]=e.current,e.current=t}var Ni=Ui(null),oy=Ui(null),xl=Ui(null),Yx=Ui(null);function Zx(e,t){switch(cn(xl,t),cn(oy,e),cn(Ni,null),t.nodeType){case 9:case 11:e=(e=t.documentElement)&&(e=e.namespaceURI)?a$(e):0;break;default:if(e=t.tagName,t=t.namespaceURI)t=a$(t),e=cz(t,e);else switch(e){case"svg":e=1;break;case"math":e=2;break;default:e=0}}Aa(Ni),cn(Ni,e)}function Dp(){Aa(Ni),Aa(oy),Aa(xl)}function sI(e){e.memoizedState!==null&&cn(Yx,e);var t=Ni.current,n=cz(t,e.type);t!==n&&(cn(oy,e),cn(Ni,n))}function Jx(e){oy.current===e&&(Aa(Ni),Aa(oy)),Yx.current===e&&(Aa(Yx),by._currentValue=uc)}var V_,ZR;function qu(e){if(V_===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);V_=t&&t[1]||"",ZR=-1<n.stack.indexOf(`
    at`)?" (<anonymous>)":-1<n.stack.indexOf("@")?"@unknown:0:0":""}return`
`+V_+e+ZR}var B_=!1;function U_(e,t){if(!e||B_)return"";B_=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var a={DetermineComponentFrameRoot:function(){try{if(t){var h=function(){throw Error()};if(Object.defineProperty(h.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(h,[])}catch(p){var d=p}Reflect.construct(e,[],h)}else{try{h.call()}catch(p){d=p}e.call(h.prototype)}}else{try{throw Error()}catch(p){d=p}(h=e())&&typeof h.catch=="function"&&h.catch(function(){})}}catch(p){if(p&&d&&typeof p.stack=="string")return[p.stack,d.stack]}return[null,null]}};a.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var r=Object.getOwnPropertyDescriptor(a.DetermineComponentFrameRoot,"name");r&&r.configurable&&Object.defineProperty(a.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var s=a.DetermineComponentFrameRoot(),i=s[0],o=s[1];if(i&&o){var l=i.split(`
`),c=o.split(`
`);for(r=a=0;a<l.length&&!l[a].includes("DetermineComponentFrameRoot");)a++;for(;r<c.length&&!c[r].includes("DetermineComponentFrameRoot");)r++;if(a===l.length||r===c.length)for(a=l.length-1,r=c.length-1;1<=a&&0<=r&&l[a]!==c[r];)r--;for(;1<=a&&0<=r;a--,r--)if(l[a]!==c[r]){if(a!==1||r!==1)do if(a--,r--,0>r||l[a]!==c[r]){var u=`
`+l[a].replace(" at new "," at ");return e.displayName&&u.includes("<anonymous>")&&(u=u.replace("<anonymous>",e.displayName)),u}while(1<=a&&0<=r);break}}}finally{B_=!1,Error.prepareStackTrace=n}return(n=e?e.displayName||e.name:"")?qu(n):""}function i9(e,t){switch(e.tag){case 26:case 27:case 5:return qu(e.type);case 16:return qu("Lazy");case 13:return e.child!==t&&t!==null?qu("Suspense Fallback"):qu("Suspense");case 19:return qu("SuspenseList");case 0:case 15:return U_(e.type,!1);case 11:return U_(e.type.render,!1);case 1:return U_(e.type,!0);case 31:return qu("Activity");default:return""}}function JR(e){try{var t="",n=null;do t+=i9(e,n),n=e,e=e.return;while(e);return t}catch(a){return`
Error generating stack: `+a.message+`
`+a.stack}}var iI=Object.prototype.hasOwnProperty,RT=ba.unstable_scheduleCallback,W_=ba.unstable_cancelCallback,o9=ba.unstable_shouldYield,l9=ba.unstable_requestPaint,ns=ba.unstable_now,u9=ba.unstable_getCurrentPriorityLevel,GF=ba.unstable_ImmediatePriority,HF=ba.unstable_UserBlockingPriority,e0=ba.unstable_NormalPriority,c9=ba.unstable_LowPriority,qF=ba.unstable_IdlePriority,h9=ba.log,d9=ba.unstable_setDisableYieldValue,Qy=null,as=null;function cl(e){if(typeof h9=="function"&&d9(e),as&&typeof as.setStrictMode=="function")try{as.setStrictMode(Qy,e)}catch{}}var rs=Math.clz32?Math.clz32:m9,p9=Math.log,f9=Math.LN2;function m9(e){return e>>>=0,e===0?32:31-(p9(e)/f9|0)|0}var Lv=256,zv=262144,Pv=4194304;function Ku(e){var t=e&42;if(t!==0)return t;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return e&261888;case 262144:case 524288:case 1048576:case 2097152:return e&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return e&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function _w(e,t,n){var a=e.pendingLanes;if(a===0)return 0;var r=0,s=e.suspendedLanes,i=e.pingedLanes;e=e.warmLanes;var o=a&134217727;return o!==0?(a=o&~s,a!==0?r=Ku(a):(i&=o,i!==0?r=Ku(i):n||(n=o&~e,n!==0&&(r=Ku(n))))):(o=a&~s,o!==0?r=Ku(o):i!==0?r=Ku(i):n||(n=a&~e,n!==0&&(r=Ku(n)))),r===0?0:t!==0&&t!==r&&!(t&s)&&(s=r&-r,n=t&-t,s>=n||s===32&&(n&4194048)!==0)?t:r}function Yy(e,t){return(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&t)===0}function g9(e,t){switch(e){case 1:case 2:case 4:case 8:case 64:return t+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function KF(){var e=Pv;return Pv<<=1,!(Pv&62914560)&&(Pv=4194304),e}function j_(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Zy(e,t){e.pendingLanes|=t,t!==268435456&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function y9(e,t,n,a,r,s){var i=e.pendingLanes;e.pendingLanes=n,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=n,e.entangledLanes&=n,e.errorRecoveryDisabledLanes&=n,e.shellSuspendCounter=0;var o=e.entanglements,l=e.expirationTimes,c=e.hiddenUpdates;for(n=i&~n;0<n;){var u=31-rs(n),h=1<<u;o[u]=0,l[u]=-1;var d=c[u];if(d!==null)for(c[u]=null,u=0;u<d.length;u++){var p=d[u];p!==null&&(p.lane&=-536870913)}n&=~h}a!==0&&XF(e,a,0),s!==0&&r===0&&e.tag!==0&&(e.suspendedLanes|=s&~(i&~t))}function XF(e,t,n){e.pendingLanes|=t,e.suspendedLanes&=~t;var a=31-rs(t);e.entangledLanes|=t,e.entanglements[a]=e.entanglements[a]|1073741824|n&261930}function QF(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var a=31-rs(n),r=1<<a;r&t|e[a]&t&&(e[a]|=t),n&=~r}}function YF(e,t){var n=t&-t;return n=n&42?1:DT(n),n&(e.suspendedLanes|t)?0:n}function DT(e){switch(e){case 2:e=1;break;case 8:e=4;break;case 32:e=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:e=128;break;case 268435456:e=134217728;break;default:e=0}return e}function $T(e){return e&=-e,2<e?8<e?e&134217727?32:268435456:8:2}function ZF(){var e=zt.p;return e!==0?e:(e=window.event,e===void 0?32:wz(e.type))}function eD(e,t){var n=zt.p;try{return zt.p=e,t()}finally{zt.p=n}}var lu=Math.random().toString(36).slice(2),Oa="__reactFiber$"+lu,Fr="__reactProps$"+lu,mf="__reactContainer$"+lu,oI="__reactEvents$"+lu,b9="__reactListeners$"+lu,v9="__reactHandles$"+lu,tD="__reactResources$"+lu,Jy="__reactMarker$"+lu;function MT(e){delete e[Oa],delete e[Fr],delete e[oI],delete e[b9],delete e[v9]}function ip(e){var t=e[Oa];if(t)return t;for(var n=e.parentNode;n;){if(t=n[mf]||n[Oa]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=l$(e);e!==null;){if(n=e[Oa])return n;e=l$(e)}return t}e=n,n=e.parentNode}return null}function gf(e){if(e=e[Oa]||e[mf]){var t=e.tag;if(t===5||t===6||t===13||t===31||t===26||t===27||t===3)return e}return null}function xg(e){var t=e.tag;if(t===5||t===26||t===27||t===6)return e.stateNode;throw Error(pe(33))}function yp(e){var t=e[tD];return t||(t=e[tD]={hoistableStyles:new Map,hoistableScripts:new Map}),t}function Ta(e){e[Jy]=!0}var JF=new Set,e3={};function Hc(e,t){$p(e,t),$p(e+"Capture",t)}function $p(e,t){for(e3[e]=t,e=0;e<t.length;e++)JF.add(t[e])}var x9=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),nD={},aD={};function w9(e){return iI.call(aD,e)?!0:iI.call(nD,e)?!1:x9.test(e)?aD[e]=!0:(nD[e]=!0,!1)}function wx(e,t,n){if(w9(t))if(n===null)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":e.removeAttribute(t);return;case"boolean":var a=t.toLowerCase().slice(0,5);if(a!=="data-"&&a!=="aria-"){e.removeAttribute(t);return}}e.setAttribute(t,""+n)}}function Vv(e,t,n){if(n===null)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":case"boolean":e.removeAttribute(t);return}e.setAttribute(t,""+n)}}function Zi(e,t,n,a){if(a===null)e.removeAttribute(n);else{switch(typeof a){case"undefined":case"function":case"symbol":case"boolean":e.removeAttribute(n);return}e.setAttributeNS(t,n,""+a)}}function _s(e){switch(typeof e){case"bigint":case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function t3(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function _9(e,t,n){var a=Object.getOwnPropertyDescriptor(e.constructor.prototype,t);if(!e.hasOwnProperty(t)&&typeof a<"u"&&typeof a.get=="function"&&typeof a.set=="function"){var r=a.get,s=a.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return r.call(this)},set:function(i){n=""+i,s.call(this,i)}}),Object.defineProperty(e,t,{enumerable:a.enumerable}),{getValue:function(){return n},setValue:function(i){n=""+i},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function lI(e){if(!e._valueTracker){var t=t3(e)?"checked":"value";e._valueTracker=_9(e,t,""+e[t])}}function n3(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),a="";return e&&(a=t3(e)?e.checked?"true":"false":e.value),e=a,e!==n?(t.setValue(e),!0):!1}function t0(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}var S9=/[\n"\\]/g;function ks(e){return e.replace(S9,function(t){return"\\"+t.charCodeAt(0).toString(16)+" "})}function uI(e,t,n,a,r,s,i,o){e.name="",i!=null&&typeof i!="function"&&typeof i!="symbol"&&typeof i!="boolean"?e.type=i:e.removeAttribute("type"),t!=null?i==="number"?(t===0&&e.value===""||e.value!=t)&&(e.value=""+_s(t)):e.value!==""+_s(t)&&(e.value=""+_s(t)):i!=="submit"&&i!=="reset"||e.removeAttribute("value"),t!=null?cI(e,i,_s(t)):n!=null?cI(e,i,_s(n)):a!=null&&e.removeAttribute("value"),r==null&&s!=null&&(e.defaultChecked=!!s),r!=null&&(e.checked=r&&typeof r!="function"&&typeof r!="symbol"),o!=null&&typeof o!="function"&&typeof o!="symbol"&&typeof o!="boolean"?e.name=""+_s(o):e.removeAttribute("name")}function a3(e,t,n,a,r,s,i,o){if(s!=null&&typeof s!="function"&&typeof s!="symbol"&&typeof s!="boolean"&&(e.type=s),t!=null||n!=null){if(!(s!=="submit"&&s!=="reset"||t!=null)){lI(e);return}n=n!=null?""+_s(n):"",t=t!=null?""+_s(t):n,o||t===e.value||(e.value=t),e.defaultValue=t}a=a??r,a=typeof a!="function"&&typeof a!="symbol"&&!!a,e.checked=o?e.checked:!!a,e.defaultChecked=!!a,i!=null&&typeof i!="function"&&typeof i!="symbol"&&typeof i!="boolean"&&(e.name=i),lI(e)}function cI(e,t,n){t==="number"&&t0(e.ownerDocument)===e||e.defaultValue===""+n||(e.defaultValue=""+n)}function bp(e,t,n,a){if(e=e.options,t){t={};for(var r=0;r<n.length;r++)t["$"+n[r]]=!0;for(n=0;n<e.length;n++)r=t.hasOwnProperty("$"+e[n].value),e[n].selected!==r&&(e[n].selected=r),r&&a&&(e[n].defaultSelected=!0)}else{for(n=""+_s(n),t=null,r=0;r<e.length;r++){if(e[r].value===n){e[r].selected=!0,a&&(e[r].defaultSelected=!0);return}t!==null||e[r].disabled||(t=e[r])}t!==null&&(t.selected=!0)}}function r3(e,t,n){if(t!=null&&(t=""+_s(t),t!==e.value&&(e.value=t),n==null)){e.defaultValue!==t&&(e.defaultValue=t);return}e.defaultValue=n!=null?""+_s(n):""}function s3(e,t,n,a){if(t==null){if(a!=null){if(n!=null)throw Error(pe(92));if(vg(a)){if(1<a.length)throw Error(pe(93));a=a[0]}n=a}n==null&&(n=""),t=n}n=_s(t),e.defaultValue=n,a=e.textContent,a===n&&a!==""&&a!==null&&(e.value=a),lI(e)}function Mp(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var I9=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function rD(e,t,n){var a=t.indexOf("--")===0;n==null||typeof n=="boolean"||n===""?a?e.setProperty(t,""):t==="float"?e.cssFloat="":e[t]="":a?e.setProperty(t,n):typeof n!="number"||n===0||I9.has(t)?t==="float"?e.cssFloat=n:e[t]=(""+n).trim():e[t]=n+"px"}function i3(e,t,n){if(t!=null&&typeof t!="object")throw Error(pe(62));if(e=e.style,n!=null){for(var a in n)!n.hasOwnProperty(a)||t!=null&&t.hasOwnProperty(a)||(a.indexOf("--")===0?e.setProperty(a,""):a==="float"?e.cssFloat="":e[a]="");for(var r in t)a=t[r],t.hasOwnProperty(r)&&n[r]!==a&&rD(e,r,a)}else for(var s in t)t.hasOwnProperty(s)&&rD(e,s,t[s])}function OT(e){if(e.indexOf("-")===-1)return!1;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var k9=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),T9=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function _x(e){return T9.test(""+e)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":e}function po(){}var hI=null;function FT(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var op=null,vp=null;function sD(e){var t=gf(e);if(t&&(e=t.stateNode)){var n=e[Fr]||null;e:switch(e=t.stateNode,t.type){case"input":if(uI(e,n.value,n.defaultValue,n.defaultValue,n.checked,n.defaultChecked,n.type,n.name),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll('input[name="'+ks(""+t)+'"][type="radio"]'),t=0;t<n.length;t++){var a=n[t];if(a!==e&&a.form===e.form){var r=a[Fr]||null;if(!r)throw Error(pe(90));uI(a,r.value,r.defaultValue,r.defaultValue,r.checked,r.defaultChecked,r.type,r.name)}}for(t=0;t<n.length;t++)a=n[t],a.form===e.form&&n3(a)}break e;case"textarea":r3(e,n.value,n.defaultValue);break e;case"select":t=n.value,t!=null&&bp(e,!!n.multiple,t,!1)}}}var G_=!1;function o3(e,t,n){if(G_)return e(t,n);G_=!0;try{var a=e(t);return a}finally{if(G_=!1,(op!==null||vp!==null)&&(Mw(),op&&(t=op,e=vp,vp=op=null,sD(t),e)))for(t=0;t<e.length;t++)sD(e[t])}}function ly(e,t){var n=e.stateNode;if(n===null)return null;var a=n[Fr]||null;if(a===null)return null;n=a[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(e=e.type,a=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!a;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(pe(231,t,typeof n));return n}var _o=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),dI=!1;if(_o)try{var og={};Object.defineProperty(og,"passive",{get:function(){dI=!0}}),window.addEventListener("test",og,og),window.removeEventListener("test",og,og)}catch{dI=!1}var hl=null,LT=null,Sx=null;function l3(){if(Sx)return Sx;var e,t=LT,n=t.length,a,r="value"in hl?hl.value:hl.textContent,s=r.length;for(e=0;e<n&&t[e]===r[e];e++);var i=n-e;for(a=1;a<=i&&t[n-a]===r[s-a];a++);return Sx=r.slice(e,1<a?1-a:void 0)}function Ix(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function Bv(){return!0}function iD(){return!1}function Br(e){function t(n,a,r,s,i){this._reactName=n,this._targetInst=r,this.type=a,this.nativeEvent=s,this.target=i,this.currentTarget=null;for(var o in e)e.hasOwnProperty(o)&&(n=e[o],this[o]=n?n(s):s[o]);return this.isDefaultPrevented=(s.defaultPrevented!=null?s.defaultPrevented:s.returnValue===!1)?Bv:iD,this.isPropagationStopped=iD,this}return bn(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=Bv)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=Bv)},persist:function(){},isPersistent:Bv}),t}var qc={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Sw=Br(qc),eb=bn({},qc,{view:0,detail:0}),E9=Br(eb),H_,q_,lg,Iw=bn({},eb,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zT,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==lg&&(lg&&e.type==="mousemove"?(H_=e.screenX-lg.screenX,q_=e.screenY-lg.screenY):q_=H_=0,lg=e),H_)},movementY:function(e){return"movementY"in e?e.movementY:q_}}),oD=Br(Iw),N9=bn({},Iw,{dataTransfer:0}),C9=Br(N9),A9=bn({},eb,{relatedTarget:0}),K_=Br(A9),R9=bn({},qc,{animationName:0,elapsedTime:0,pseudoElement:0}),D9=Br(R9),$9=bn({},qc,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),M9=Br($9),O9=bn({},qc,{data:0}),lD=Br(O9),F9={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},L9={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},z9={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function P9(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=z9[e])?!!t[e]:!1}function zT(){return P9}var V9=bn({},eb,{key:function(e){if(e.key){var t=F9[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=Ix(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?L9[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zT,charCode:function(e){return e.type==="keypress"?Ix(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?Ix(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),B9=Br(V9),U9=bn({},Iw,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),uD=Br(U9),W9=bn({},eb,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zT}),j9=Br(W9),G9=bn({},qc,{propertyName:0,elapsedTime:0,pseudoElement:0}),H9=Br(G9),q9=bn({},Iw,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),K9=Br(q9),X9=bn({},qc,{newState:0,oldState:0}),Q9=Br(X9),Y9=[9,13,27,32],PT=_o&&"CompositionEvent"in window,zg=null;_o&&"documentMode"in document&&(zg=document.documentMode);var Z9=_o&&"TextEvent"in window&&!zg,u3=_o&&(!PT||zg&&8<zg&&11>=zg),cD=" ",hD=!1;function c3(e,t){switch(e){case"keyup":return Y9.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function h3(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var lp=!1;function J9(e,t){switch(e){case"compositionend":return h3(t);case"keypress":return t.which!==32?null:(hD=!0,cD);case"textInput":return e=t.data,e===cD&&hD?null:e;default:return null}}function eq(e,t){if(lp)return e==="compositionend"||!PT&&c3(e,t)?(e=l3(),Sx=LT=hl=null,lp=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return u3&&t.locale!=="ko"?null:t.data;default:return null}}var tq={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function dD(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!tq[e.type]:t==="textarea"}function d3(e,t,n,a){op?vp?vp.push(a):vp=[a]:op=a,t=v0(t,"onChange"),0<t.length&&(n=new Sw("onChange","change",null,n,a),e.push({event:n,listeners:t}))}var Pg=null,uy=null;function nq(e){oz(e,0)}function kw(e){var t=xg(e);if(n3(t))return e}function pD(e,t){if(e==="change")return t}var p3=!1;if(_o){var X_;if(_o){var Q_="oninput"in document;if(!Q_){var fD=document.createElement("div");fD.setAttribute("oninput","return;"),Q_=typeof fD.oninput=="function"}X_=Q_}else X_=!1;p3=X_&&(!document.documentMode||9<document.documentMode)}function mD(){Pg&&(Pg.detachEvent("onpropertychange",f3),uy=Pg=null)}function f3(e){if(e.propertyName==="value"&&kw(uy)){var t=[];d3(t,uy,e,FT(e)),o3(nq,t)}}function aq(e,t,n){e==="focusin"?(mD(),Pg=t,uy=n,Pg.attachEvent("onpropertychange",f3)):e==="focusout"&&mD()}function rq(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return kw(uy)}function sq(e,t){if(e==="click")return kw(t)}function iq(e,t){if(e==="input"||e==="change")return kw(t)}function oq(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var os=typeof Object.is=="function"?Object.is:oq;function cy(e,t){if(os(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),a=Object.keys(t);if(n.length!==a.length)return!1;for(a=0;a<n.length;a++){var r=n[a];if(!iI.call(t,r)||!os(e[r],t[r]))return!1}return!0}function gD(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function yD(e,t){var n=gD(e);e=0;for(var a;n;){if(n.nodeType===3){if(a=e+n.textContent.length,e<=t&&a>=t)return{node:n,offset:t-e};e=a}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=gD(n)}}function m3(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?m3(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function g3(e){e=e!=null&&e.ownerDocument!=null&&e.ownerDocument.defaultView!=null?e.ownerDocument.defaultView:window;for(var t=t0(e.document);t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=t0(e.document)}return t}function VT(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}var lq=_o&&"documentMode"in document&&11>=document.documentMode,up=null,pI=null,Vg=null,fI=!1;function bD(e,t,n){var a=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;fI||up==null||up!==t0(a)||(a=up,"selectionStart"in a&&VT(a)?a={start:a.selectionStart,end:a.selectionEnd}:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection(),a={anchorNode:a.anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset}),Vg&&cy(Vg,a)||(Vg=a,a=v0(pI,"onSelect"),0<a.length&&(t=new Sw("onSelect","select",null,t,n),e.push({event:t,listeners:a}),t.target=up)))}function Wu(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var cp={animationend:Wu("Animation","AnimationEnd"),animationiteration:Wu("Animation","AnimationIteration"),animationstart:Wu("Animation","AnimationStart"),transitionrun:Wu("Transition","TransitionRun"),transitionstart:Wu("Transition","TransitionStart"),transitioncancel:Wu("Transition","TransitionCancel"),transitionend:Wu("Transition","TransitionEnd")},Y_={},y3={};_o&&(y3=document.createElement("div").style,"AnimationEvent"in window||(delete cp.animationend.animation,delete cp.animationiteration.animation,delete cp.animationstart.animation),"TransitionEvent"in window||delete cp.transitionend.transition);function Kc(e){if(Y_[e])return Y_[e];if(!cp[e])return e;var t=cp[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in y3)return Y_[e]=t[n];return e}var b3=Kc("animationend"),v3=Kc("animationiteration"),x3=Kc("animationstart"),uq=Kc("transitionrun"),cq=Kc("transitionstart"),hq=Kc("transitioncancel"),w3=Kc("transitionend"),_3=new Map,mI="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");mI.push("scrollEnd");function ai(e,t){_3.set(e,t),Hc(t,[e])}var n0=typeof reportError=="function"?reportError:function(e){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof e=="object"&&e!==null&&typeof e.message=="string"?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",e);return}console.error(e)},vs=[],hp=0,BT=0;function Tw(){for(var e=hp,t=BT=hp=0;t<e;){var n=vs[t];vs[t++]=null;var a=vs[t];vs[t++]=null;var r=vs[t];vs[t++]=null;var s=vs[t];if(vs[t++]=null,a!==null&&r!==null){var i=a.pending;i===null?r.next=r:(r.next=i.next,i.next=r),a.pending=r}s!==0&&S3(n,r,s)}}function Ew(e,t,n,a){vs[hp++]=e,vs[hp++]=t,vs[hp++]=n,vs[hp++]=a,BT|=a,e.lanes|=a,e=e.alternate,e!==null&&(e.lanes|=a)}function UT(e,t,n,a){return Ew(e,t,n,a),a0(e)}function Xc(e,t){return Ew(e,null,null,t),a0(e)}function S3(e,t,n){e.lanes|=n;var a=e.alternate;a!==null&&(a.lanes|=n);for(var r=!1,s=e.return;s!==null;)s.childLanes|=n,a=s.alternate,a!==null&&(a.childLanes|=n),s.tag===22&&(e=s.stateNode,e===null||e._visibility&1||(r=!0)),e=s,s=s.return;return e.tag===3?(s=e.stateNode,r&&t!==null&&(r=31-rs(n),e=s.hiddenUpdates,a=e[r],a===null?e[r]=[t]:a.push(t),t.lane=n|536870912),s):null}function a0(e){if(50<Xg)throw Xg=0,FI=null,Error(pe(185));for(var t=e.return;t!==null;)e=t,t=e.return;return e.tag===3?e.stateNode:null}var dp={};function dq(e,t,n,a){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Xr(e,t,n,a){return new dq(e,t,n,a)}function WT(e){return e=e.prototype,!(!e||!e.isReactComponent)}function mo(e,t){var n=e.alternate;return n===null?(n=Xr(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&65011712,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n.refCleanup=e.refCleanup,n}function I3(e,t){e.flags&=65011714;var n=e.alternate;return n===null?(e.childLanes=0,e.lanes=t,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=n.childLanes,e.lanes=n.lanes,e.child=n.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=n.memoizedProps,e.memoizedState=n.memoizedState,e.updateQueue=n.updateQueue,e.type=n.type,t=n.dependencies,e.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext}),e}function kx(e,t,n,a,r,s){var i=0;if(a=e,typeof e=="function")WT(e)&&(i=1);else if(typeof e=="string")i=y7(e,n,Ni.current)?26:e==="html"||e==="head"||e==="body"?27:5;else e:switch(e){case nI:return e=Xr(31,n,t,r),e.elementType=nI,e.lanes=s,e;case rp:return cc(n.children,r,s,t);case WF:i=8,r|=24;break;case JS:return e=Xr(12,n,t,r|2),e.elementType=JS,e.lanes=s,e;case eI:return e=Xr(13,n,t,r),e.elementType=eI,e.lanes=s,e;case tI:return e=Xr(19,n,t,r),e.elementType=tI,e.lanes=s,e;default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case ho:i=10;break e;case jF:i=9;break e;case CT:i=11;break e;case AT:i=14;break e;case tl:i=16,a=null;break e}i=29,n=Error(pe(130,e===null?"null":typeof e,"")),a=null}return t=Xr(i,n,t,r),t.elementType=e,t.type=a,t.lanes=s,t}function cc(e,t,n,a){return e=Xr(7,e,a,t),e.lanes=n,e}function Z_(e,t,n){return e=Xr(6,e,null,t),e.lanes=n,e}function k3(e){var t=Xr(18,null,null,0);return t.stateNode=e,t}function J_(e,t,n){return t=Xr(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}var vD=new WeakMap;function Ts(e,t){if(typeof e=="object"&&e!==null){var n=vD.get(e);return n!==void 0?n:(t={value:e,source:t,stack:JR(t)},vD.set(e,t),t)}return{value:e,source:t,stack:JR(t)}}var pp=[],fp=0,r0=null,hy=0,Ss=[],Is=0,Fl=null,Si=1,Ii="";function so(e,t){pp[fp++]=hy,pp[fp++]=r0,r0=e,hy=t}function T3(e,t,n){Ss[Is++]=Si,Ss[Is++]=Ii,Ss[Is++]=Fl,Fl=e;var a=Si;e=Ii;var r=32-rs(a)-1;a&=~(1<<r),n+=1;var s=32-rs(t)+r;if(30<s){var i=r-r%5;s=(a&(1<<i)-1).toString(32),a>>=i,r-=i,Si=1<<32-rs(t)+r|n<<r|a,Ii=s+e}else Si=1<<s|n<<r|a,Ii=e}function jT(e){e.return!==null&&(so(e,1),T3(e,1,0))}function GT(e){for(;e===r0;)r0=pp[--fp],pp[fp]=null,hy=pp[--fp],pp[fp]=null;for(;e===Fl;)Fl=Ss[--Is],Ss[Is]=null,Ii=Ss[--Is],Ss[Is]=null,Si=Ss[--Is],Ss[Is]=null}function E3(e,t){Ss[Is++]=Si,Ss[Is++]=Ii,Ss[Is++]=Fl,Si=t.id,Ii=t.overflow,Fl=e}var Fa=null,pn=null,Nt=!1,wl=null,Es=!1,gI=Error(pe(519));function Ll(e){var t=Error(pe(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw dy(Ts(t,e)),gI}function xD(e){var t=e.stateNode,n=e.type,a=e.memoizedProps;switch(t[Oa]=e,t[Fr]=a,n){case"dialog":xt("cancel",t),xt("close",t);break;case"iframe":case"object":case"embed":xt("load",t);break;case"video":case"audio":for(n=0;n<gy.length;n++)xt(gy[n],t);break;case"source":xt("error",t);break;case"img":case"image":case"link":xt("error",t),xt("load",t);break;case"details":xt("toggle",t);break;case"input":xt("invalid",t),a3(t,a.value,a.defaultValue,a.checked,a.defaultChecked,a.type,a.name,!0);break;case"select":xt("invalid",t);break;case"textarea":xt("invalid",t),s3(t,a.value,a.defaultValue,a.children)}n=a.children,typeof n!="string"&&typeof n!="number"&&typeof n!="bigint"||t.textContent===""+n||a.suppressHydrationWarning===!0||uz(t.textContent,n)?(a.popover!=null&&(xt("beforetoggle",t),xt("toggle",t)),a.onScroll!=null&&xt("scroll",t),a.onScrollEnd!=null&&xt("scrollend",t),a.onClick!=null&&(t.onclick=po),t=!0):t=!1,t||Ll(e,!0)}function wD(e){for(Fa=e.return;Fa;)switch(Fa.tag){case 5:case 31:case 13:Es=!1;return;case 27:case 3:Es=!0;return;default:Fa=Fa.return}}function Ud(e){if(e!==Fa)return!1;if(!Nt)return wD(e),Nt=!0,!1;var t=e.tag,n;if((n=t!==3&&t!==27)&&((n=t===5)&&(n=e.type,n=!(n!=="form"&&n!=="button")||BI(e.type,e.memoizedProps)),n=!n),n&&pn&&Ll(e),wD(e),t===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(pe(317));pn=o$(e)}else if(t===31){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(pe(317));pn=o$(e)}else t===27?(t=pn,uu(e.type)?(e=GI,GI=null,pn=e):pn=t):pn=Fa?As(e.stateNode.nextSibling):null;return!0}function vc(){pn=Fa=null,Nt=!1}function eS(){var e=wl;return e!==null&&(Er===null?Er=e:Er.push.apply(Er,e),wl=null),e}function dy(e){wl===null?wl=[e]:wl.push(e)}var yI=Ui(null),Qc=null,fo=null;function sl(e,t,n){cn(yI,t._currentValue),t._currentValue=n}function go(e){e._currentValue=yI.current,Aa(yI)}function bI(e,t,n){for(;e!==null;){var a=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,a!==null&&(a.childLanes|=t)):a!==null&&(a.childLanes&t)!==t&&(a.childLanes|=t),e===n)break;e=e.return}}function vI(e,t,n,a){var r=e.child;for(r!==null&&(r.return=e);r!==null;){var s=r.dependencies;if(s!==null){var i=r.child;s=s.firstContext;e:for(;s!==null;){var o=s;s=r;for(var l=0;l<t.length;l++)if(o.context===t[l]){s.lanes|=n,o=s.alternate,o!==null&&(o.lanes|=n),bI(s.return,n,e),a||(i=null);break e}s=o.next}}else if(r.tag===18){if(i=r.return,i===null)throw Error(pe(341));i.lanes|=n,s=i.alternate,s!==null&&(s.lanes|=n),bI(i,n,e),i=null}else i=r.child;if(i!==null)i.return=r;else for(i=r;i!==null;){if(i===e){i=null;break}if(r=i.sibling,r!==null){r.return=i.return,i=r;break}i=i.return}r=i}}function yf(e,t,n,a){e=null;for(var r=t,s=!1;r!==null;){if(!s){if(r.flags&524288)s=!0;else if(r.flags&262144)break}if(r.tag===10){var i=r.alternate;if(i===null)throw Error(pe(387));if(i=i.memoizedProps,i!==null){var o=r.type;os(r.pendingProps.value,i.value)||(e!==null?e.push(o):e=[o])}}else if(r===Yx.current){if(i=r.alternate,i===null)throw Error(pe(387));i.memoizedState.memoizedState!==r.memoizedState.memoizedState&&(e!==null?e.push(by):e=[by])}r=r.return}e!==null&&vI(t,e,n,a),t.flags|=262144}function s0(e){for(e=e.firstContext;e!==null;){if(!os(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function xc(e){Qc=e,fo=null,e=e.dependencies,e!==null&&(e.firstContext=null)}function za(e){return N3(Qc,e)}function Uv(e,t){return Qc===null&&xc(e),N3(e,t)}function N3(e,t){var n=t._currentValue;if(t={context:t,memoizedValue:n,next:null},fo===null){if(e===null)throw Error(pe(308));fo=t,e.dependencies={lanes:0,firstContext:t},e.flags|=524288}else fo=fo.next=t;return n}var pq=typeof AbortController<"u"?AbortController:function(){var e=[],t=this.signal={aborted:!1,addEventListener:function(n,a){e.push(a)}};this.abort=function(){t.aborted=!0,e.forEach(function(n){return n()})}},fq=ba.unstable_scheduleCallback,mq=ba.unstable_NormalPriority,Qn={$$typeof:ho,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function HT(){return{controller:new pq,data:new Map,refCount:0}}function tb(e){e.refCount--,e.refCount===0&&fq(mq,function(){e.controller.abort()})}var Bg=null,xI=0,Op=0,xp=null;function gq(e,t){if(Bg===null){var n=Bg=[];xI=0,Op=y2(),xp={status:"pending",value:void 0,then:function(a){n.push(a)}}}return xI++,t.then(_D,_D),t}function _D(){if(--xI===0&&Bg!==null){xp!==null&&(xp.status="fulfilled");var e=Bg;Bg=null,Op=0,xp=null;for(var t=0;t<e.length;t++)(0,e[t])()}}function yq(e,t){var n=[],a={status:"pending",value:null,reason:null,then:function(r){n.push(r)}};return e.then(function(){a.status="fulfilled",a.value=t;for(var r=0;r<n.length;r++)(0,n[r])(t)},function(r){for(a.status="rejected",a.reason=r,r=0;r<n.length;r++)(0,n[r])(void 0)}),a}var SD=Qe.S;Qe.S=function(e,t){UL=ns(),typeof t=="object"&&t!==null&&typeof t.then=="function"&&gq(e,t),SD!==null&&SD(e,t)};var hc=Ui(null);function qT(){var e=hc.current;return e!==null?e:sn.pooledCache}function Tx(e,t){t===null?cn(hc,hc.current):cn(hc,t.pool)}function C3(){var e=qT();return e===null?null:{parent:Qn._currentValue,pool:e}}var bf=Error(pe(460)),KT=Error(pe(474)),Nw=Error(pe(542)),i0={then:function(){}};function ID(e){return e=e.status,e==="fulfilled"||e==="rejected"}function A3(e,t,n){switch(n=e[n],n===void 0?e.push(t):n!==t&&(t.then(po,po),t=n),t.status){case"fulfilled":return t.value;case"rejected":throw e=t.reason,TD(e),e;default:if(typeof t.status=="string")t.then(po,po);else{if(e=sn,e!==null&&100<e.shellSuspendCounter)throw Error(pe(482));e=t,e.status="pending",e.then(function(a){if(t.status==="pending"){var r=t;r.status="fulfilled",r.value=a}},function(a){if(t.status==="pending"){var r=t;r.status="rejected",r.reason=a}})}switch(t.status){case"fulfilled":return t.value;case"rejected":throw e=t.reason,TD(e),e}throw dc=t,bf}}function Xu(e){try{var t=e._init;return t(e._payload)}catch(n){throw n!==null&&typeof n=="object"&&typeof n.then=="function"?(dc=n,bf):n}}var dc=null;function kD(){if(dc===null)throw Error(pe(459));var e=dc;return dc=null,e}function TD(e){if(e===bf||e===Nw)throw Error(pe(483))}var wp=null,py=0;function Wv(e){var t=py;return py+=1,wp===null&&(wp=[]),A3(wp,e,t)}function ug(e,t){t=t.props.ref,e.ref=t!==void 0?t:null}function jv(e,t){throw t.$$typeof===a9?Error(pe(525)):(e=Object.prototype.toString.call(t),Error(pe(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e)))}function R3(e){function t(y,v){if(e){var x=y.deletions;x===null?(y.deletions=[v],y.flags|=16):x.push(v)}}function n(y,v){if(!e)return null;for(;v!==null;)t(y,v),v=v.sibling;return null}function a(y){for(var v=new Map;y!==null;)y.key!==null?v.set(y.key,y):v.set(y.index,y),y=y.sibling;return v}function r(y,v){return y=mo(y,v),y.index=0,y.sibling=null,y}function s(y,v,x){return y.index=x,e?(x=y.alternate,x!==null?(x=x.index,x<v?(y.flags|=67108866,v):x):(y.flags|=67108866,v)):(y.flags|=1048576,v)}function i(y){return e&&y.alternate===null&&(y.flags|=67108866),y}function o(y,v,x,w){return v===null||v.tag!==6?(v=Z_(x,y.mode,w),v.return=y,v):(v=r(v,x),v.return=y,v)}function l(y,v,x,w){var k=x.type;return k===rp?u(y,v,x.props.children,w,x.key):v!==null&&(v.elementType===k||typeof k=="object"&&k!==null&&k.$$typeof===tl&&Xu(k)===v.type)?(v=r(v,x.props),ug(v,x),v.return=y,v):(v=kx(x.type,x.key,x.props,null,y.mode,w),ug(v,x),v.return=y,v)}function c(y,v,x,w){return v===null||v.tag!==4||v.stateNode.containerInfo!==x.containerInfo||v.stateNode.implementation!==x.implementation?(v=J_(x,y.mode,w),v.return=y,v):(v=r(v,x.children||[]),v.return=y,v)}function u(y,v,x,w,k){return v===null||v.tag!==7?(v=cc(x,y.mode,w,k),v.return=y,v):(v=r(v,x),v.return=y,v)}function h(y,v,x){if(typeof v=="string"&&v!==""||typeof v=="number"||typeof v=="bigint")return v=Z_(""+v,y.mode,x),v.return=y,v;if(typeof v=="object"&&v!==null){switch(v.$$typeof){case Fv:return x=kx(v.type,v.key,v.props,null,y.mode,x),ug(x,v),x.return=y,x;case bg:return v=J_(v,y.mode,x),v.return=y,v;case tl:return v=Xu(v),h(y,v,x)}if(vg(v)||ig(v))return v=cc(v,y.mode,x,null),v.return=y,v;if(typeof v.then=="function")return h(y,Wv(v),x);if(v.$$typeof===ho)return h(y,Uv(y,v),x);jv(y,v)}return null}function d(y,v,x,w){var k=v!==null?v.key:null;if(typeof x=="string"&&x!==""||typeof x=="number"||typeof x=="bigint")return k!==null?null:o(y,v,""+x,w);if(typeof x=="object"&&x!==null){switch(x.$$typeof){case Fv:return x.key===k?l(y,v,x,w):null;case bg:return x.key===k?c(y,v,x,w):null;case tl:return x=Xu(x),d(y,v,x,w)}if(vg(x)||ig(x))return k!==null?null:u(y,v,x,w,null);if(typeof x.then=="function")return d(y,v,Wv(x),w);if(x.$$typeof===ho)return d(y,v,Uv(y,x),w);jv(y,x)}return null}function p(y,v,x,w,k){if(typeof w=="string"&&w!==""||typeof w=="number"||typeof w=="bigint")return y=y.get(x)||null,o(v,y,""+w,k);if(typeof w=="object"&&w!==null){switch(w.$$typeof){case Fv:return y=y.get(w.key===null?x:w.key)||null,l(v,y,w,k);case bg:return y=y.get(w.key===null?x:w.key)||null,c(v,y,w,k);case tl:return w=Xu(w),p(y,v,x,w,k)}if(vg(w)||ig(w))return y=y.get(x)||null,u(v,y,w,k,null);if(typeof w.then=="function")return p(y,v,x,Wv(w),k);if(w.$$typeof===ho)return p(y,v,x,Uv(v,w),k);jv(v,w)}return null}function f(y,v,x,w){for(var k=null,M=null,S=v,I=v=0,E=null;S!==null&&I<x.length;I++){S.index>I?(E=S,S=null):E=S.sibling;var R=d(y,S,x[I],w);if(R===null){S===null&&(S=E);break}e&&S&&R.alternate===null&&t(y,S),v=s(R,v,I),M===null?k=R:M.sibling=R,M=R,S=E}if(I===x.length)return n(y,S),Nt&&so(y,I),k;if(S===null){for(;I<x.length;I++)S=h(y,x[I],w),S!==null&&(v=s(S,v,I),M===null?k=S:M.sibling=S,M=S);return Nt&&so(y,I),k}for(S=a(S);I<x.length;I++)E=p(S,y,I,x[I],w),E!==null&&(e&&E.alternate!==null&&S.delete(E.key===null?I:E.key),v=s(E,v,I),M===null?k=E:M.sibling=E,M=E);return e&&S.forEach(function(A){return t(y,A)}),Nt&&so(y,I),k}function m(y,v,x,w){if(x==null)throw Error(pe(151));for(var k=null,M=null,S=v,I=v=0,E=null,R=x.next();S!==null&&!R.done;I++,R=x.next()){S.index>I?(E=S,S=null):E=S.sibling;var A=d(y,S,R.value,w);if(A===null){S===null&&(S=E);break}e&&S&&A.alternate===null&&t(y,S),v=s(A,v,I),M===null?k=A:M.sibling=A,M=A,S=E}if(R.done)return n(y,S),Nt&&so(y,I),k;if(S===null){for(;!R.done;I++,R=x.next())R=h(y,R.value,w),R!==null&&(v=s(R,v,I),M===null?k=R:M.sibling=R,M=R);return Nt&&so(y,I),k}for(S=a(S);!R.done;I++,R=x.next())R=p(S,y,I,R.value,w),R!==null&&(e&&R.alternate!==null&&S.delete(R.key===null?I:R.key),v=s(R,v,I),M===null?k=R:M.sibling=R,M=R);return e&&S.forEach(function(_){return t(y,_)}),Nt&&so(y,I),k}function g(y,v,x,w){if(typeof x=="object"&&x!==null&&x.type===rp&&x.key===null&&(x=x.props.children),typeof x=="object"&&x!==null){switch(x.$$typeof){case Fv:e:{for(var k=x.key;v!==null;){if(v.key===k){if(k=x.type,k===rp){if(v.tag===7){n(y,v.sibling),w=r(v,x.props.children),w.return=y,y=w;break e}}else if(v.elementType===k||typeof k=="object"&&k!==null&&k.$$typeof===tl&&Xu(k)===v.type){n(y,v.sibling),w=r(v,x.props),ug(w,x),w.return=y,y=w;break e}n(y,v);break}else t(y,v);v=v.sibling}x.type===rp?(w=cc(x.props.children,y.mode,w,x.key),w.return=y,y=w):(w=kx(x.type,x.key,x.props,null,y.mode,w),ug(w,x),w.return=y,y=w)}return i(y);case bg:e:{for(k=x.key;v!==null;){if(v.key===k)if(v.tag===4&&v.stateNode.containerInfo===x.containerInfo&&v.stateNode.implementation===x.implementation){n(y,v.sibling),w=r(v,x.children||[]),w.return=y,y=w;break e}else{n(y,v);break}else t(y,v);v=v.sibling}w=J_(x,y.mode,w),w.return=y,y=w}return i(y);case tl:return x=Xu(x),g(y,v,x,w)}if(vg(x))return f(y,v,x,w);if(ig(x)){if(k=ig(x),typeof k!="function")throw Error(pe(150));return x=k.call(x),m(y,v,x,w)}if(typeof x.then=="function")return g(y,v,Wv(x),w);if(x.$$typeof===ho)return g(y,v,Uv(y,x),w);jv(y,x)}return typeof x=="string"&&x!==""||typeof x=="number"||typeof x=="bigint"?(x=""+x,v!==null&&v.tag===6?(n(y,v.sibling),w=r(v,x),w.return=y,y=w):(n(y,v),w=Z_(x,y.mode,w),w.return=y,y=w),i(y)):n(y,v)}return function(y,v,x,w){try{py=0;var k=g(y,v,x,w);return wp=null,k}catch(S){if(S===bf||S===Nw)throw S;var M=Xr(29,S,null,y.mode);return M.lanes=w,M.return=y,M}finally{}}}var wc=R3(!0),D3=R3(!1),nl=!1;function XT(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function wI(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function _l(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function Sl(e,t,n){var a=e.updateQueue;if(a===null)return null;if(a=a.shared,Lt&2){var r=a.pending;return r===null?t.next=t:(t.next=r.next,r.next=t),a.pending=t,t=a0(e),S3(e,null,n),t}return Ew(e,a,t,n),a0(e)}function Ug(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194048)!==0)){var a=t.lanes;a&=e.pendingLanes,n|=a,t.lanes=n,QF(e,n)}}function tS(e,t){var n=e.updateQueue,a=e.alternate;if(a!==null&&(a=a.updateQueue,n===a)){var r=null,s=null;if(n=n.firstBaseUpdate,n!==null){do{var i={lane:n.lane,tag:n.tag,payload:n.payload,callback:null,next:null};s===null?r=s=i:s=s.next=i,n=n.next}while(n!==null);s===null?r=s=t:s=s.next=t}else r=s=t;n={baseState:a.baseState,firstBaseUpdate:r,lastBaseUpdate:s,shared:a.shared,callbacks:a.callbacks},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}var _I=!1;function Wg(){if(_I){var e=xp;if(e!==null)throw e}}function jg(e,t,n,a){_I=!1;var r=e.updateQueue;nl=!1;var s=r.firstBaseUpdate,i=r.lastBaseUpdate,o=r.shared.pending;if(o!==null){r.shared.pending=null;var l=o,c=l.next;l.next=null,i===null?s=c:i.next=c,i=l;var u=e.alternate;u!==null&&(u=u.updateQueue,o=u.lastBaseUpdate,o!==i&&(o===null?u.firstBaseUpdate=c:o.next=c,u.lastBaseUpdate=l))}if(s!==null){var h=r.baseState;i=0,u=c=l=null,o=s;do{var d=o.lane&-536870913,p=d!==o.lane;if(p?(kt&d)===d:(a&d)===d){d!==0&&d===Op&&(_I=!0),u!==null&&(u=u.next={lane:0,tag:o.tag,payload:o.payload,callback:null,next:null});e:{var f=e,m=o;d=t;var g=n;switch(m.tag){case 1:if(f=m.payload,typeof f=="function"){h=f.call(g,h,d);break e}h=f;break e;case 3:f.flags=f.flags&-65537|128;case 0:if(f=m.payload,d=typeof f=="function"?f.call(g,h,d):f,d==null)break e;h=bn({},h,d);break e;case 2:nl=!0}}d=o.callback,d!==null&&(e.flags|=64,p&&(e.flags|=8192),p=r.callbacks,p===null?r.callbacks=[d]:p.push(d))}else p={lane:d,tag:o.tag,payload:o.payload,callback:o.callback,next:null},u===null?(c=u=p,l=h):u=u.next=p,i|=d;if(o=o.next,o===null){if(o=r.shared.pending,o===null)break;p=o,o=p.next,p.next=null,r.lastBaseUpdate=p,r.shared.pending=null}}while(!0);u===null&&(l=h),r.baseState=l,r.firstBaseUpdate=c,r.lastBaseUpdate=u,s===null&&(r.shared.lanes=0),Pl|=i,e.lanes=i,e.memoizedState=h}}function $3(e,t){if(typeof e!="function")throw Error(pe(191,e));e.call(t)}function M3(e,t){var n=e.callbacks;if(n!==null)for(e.callbacks=null,e=0;e<n.length;e++)$3(n[e],t)}var Fp=Ui(null),o0=Ui(0);function ED(e,t){e=To,cn(o0,e),cn(Fp,t),To=e|t.baseLanes}function SI(){cn(o0,To),cn(Fp,Fp.current)}function QT(){To=o0.current,Aa(Fp),Aa(o0)}var ls=Ui(null),Cs=null;function il(e){var t=e.alternate;cn(Ln,Ln.current&1),cn(ls,e),Cs===null&&(t===null||Fp.current!==null||t.memoizedState!==null)&&(Cs=e)}function II(e){cn(Ln,Ln.current),cn(ls,e),Cs===null&&(Cs=e)}function O3(e){e.tag===22?(cn(Ln,Ln.current),cn(ls,e),Cs===null&&(Cs=e)):ol()}function ol(){cn(Ln,Ln.current),cn(ls,ls.current)}function Kr(e){Aa(ls),Cs===e&&(Cs=null),Aa(Ln)}var Ln=Ui(0);function l0(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||WI(n)||jI(n)))return t}else if(t.tag===19&&(t.memoizedProps.revealOrder==="forwards"||t.memoizedProps.revealOrder==="backwards"||t.memoizedProps.revealOrder==="unstable_legacy-backwards"||t.memoizedProps.revealOrder==="together")){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var So=0,dt=null,tn=null,Kn=null,u0=!1,_p=!1,_c=!1,c0=0,fy=0,Sp=null,bq=0;function Rn(){throw Error(pe(321))}function YT(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!os(e[n],t[n]))return!1;return!0}function ZT(e,t,n,a,r,s){return So=s,dt=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,Qe.H=e===null||e.memoizedState===null?dL:u2,_c=!1,s=n(a,r),_c=!1,_p&&(s=L3(t,n,a,r)),F3(e),s}function F3(e){Qe.H=my;var t=tn!==null&&tn.next!==null;if(So=0,Kn=tn=dt=null,u0=!1,fy=0,Sp=null,t)throw Error(pe(300));e===null||Zn||(e=e.dependencies,e!==null&&s0(e)&&(Zn=!0))}function L3(e,t,n,a){dt=e;var r=0;do{if(_p&&(Sp=null),fy=0,_p=!1,25<=r)throw Error(pe(301));if(r+=1,Kn=tn=null,e.updateQueue!=null){var s=e.updateQueue;s.lastEffect=null,s.events=null,s.stores=null,s.memoCache!=null&&(s.memoCache.index=0)}Qe.H=pL,s=t(n,a)}while(_p);return s}function vq(){var e=Qe.H,t=e.useState()[0];return t=typeof t.then=="function"?nb(t):t,e=e.useState()[0],(tn!==null?tn.memoizedState:null)!==e&&(dt.flags|=1024),t}function JT(){var e=c0!==0;return c0=0,e}function e2(e,t,n){t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~n}function t2(e){if(u0){for(e=e.memoizedState;e!==null;){var t=e.queue;t!==null&&(t.pending=null),e=e.next}u0=!1}So=0,Kn=tn=dt=null,_p=!1,fy=c0=0,Sp=null}function cr(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Kn===null?dt.memoizedState=Kn=e:Kn=Kn.next=e,Kn}function Pn(){if(tn===null){var e=dt.alternate;e=e!==null?e.memoizedState:null}else e=tn.next;var t=Kn===null?dt.memoizedState:Kn.next;if(t!==null)Kn=t,tn=e;else{if(e===null)throw dt.alternate===null?Error(pe(467)):Error(pe(310));tn=e,e={memoizedState:tn.memoizedState,baseState:tn.baseState,baseQueue:tn.baseQueue,queue:tn.queue,next:null},Kn===null?dt.memoizedState=Kn=e:Kn=Kn.next=e}return Kn}function Cw(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function nb(e){var t=fy;return fy+=1,Sp===null&&(Sp=[]),e=A3(Sp,e,t),t=dt,(Kn===null?t.memoizedState:Kn.next)===null&&(t=t.alternate,Qe.H=t===null||t.memoizedState===null?dL:u2),e}function Aw(e){if(e!==null&&typeof e=="object"){if(typeof e.then=="function")return nb(e);if(e.$$typeof===ho)return za(e)}throw Error(pe(438,String(e)))}function n2(e){var t=null,n=dt.updateQueue;if(n!==null&&(t=n.memoCache),t==null){var a=dt.alternate;a!==null&&(a=a.updateQueue,a!==null&&(a=a.memoCache,a!=null&&(t={data:a.data.map(function(r){return r.slice()}),index:0})))}if(t==null&&(t={data:[],index:0}),n===null&&(n=Cw(),dt.updateQueue=n),n.memoCache=t,n=t.data[t.index],n===void 0)for(n=t.data[t.index]=Array(e),a=0;a<e;a++)n[a]=r9;return t.index++,n}function Io(e,t){return typeof t=="function"?t(e):t}function Ex(e){var t=Pn();return a2(t,tn,e)}function a2(e,t,n){var a=e.queue;if(a===null)throw Error(pe(311));a.lastRenderedReducer=n;var r=e.baseQueue,s=a.pending;if(s!==null){if(r!==null){var i=r.next;r.next=s.next,s.next=i}t.baseQueue=r=s,a.pending=null}if(s=e.baseState,r===null)e.memoizedState=s;else{t=r.next;var o=i=null,l=null,c=t,u=!1;do{var h=c.lane&-536870913;if(h!==c.lane?(kt&h)===h:(So&h)===h){var d=c.revertLane;if(d===0)l!==null&&(l=l.next={lane:0,revertLane:0,gesture:null,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),h===Op&&(u=!0);else if((So&d)===d){c=c.next,d===Op&&(u=!0);continue}else h={lane:0,revertLane:c.revertLane,gesture:null,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null},l===null?(o=l=h,i=s):l=l.next=h,dt.lanes|=d,Pl|=d;h=c.action,_c&&n(s,h),s=c.hasEagerState?c.eagerState:n(s,h)}else d={lane:h,revertLane:c.revertLane,gesture:c.gesture,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null},l===null?(o=l=d,i=s):l=l.next=d,dt.lanes|=h,Pl|=h;c=c.next}while(c!==null&&c!==t);if(l===null?i=s:l.next=o,!os(s,e.memoizedState)&&(Zn=!0,u&&(n=xp,n!==null)))throw n;e.memoizedState=s,e.baseState=i,e.baseQueue=l,a.lastRenderedState=s}return r===null&&(a.lanes=0),[e.memoizedState,a.dispatch]}function nS(e){var t=Pn(),n=t.queue;if(n===null)throw Error(pe(311));n.lastRenderedReducer=e;var a=n.dispatch,r=n.pending,s=t.memoizedState;if(r!==null){n.pending=null;var i=r=r.next;do s=e(s,i.action),i=i.next;while(i!==r);os(s,t.memoizedState)||(Zn=!0),t.memoizedState=s,t.baseQueue===null&&(t.baseState=s),n.lastRenderedState=s}return[s,a]}function z3(e,t,n){var a=dt,r=Pn(),s=Nt;if(s){if(n===void 0)throw Error(pe(407));n=n()}else n=t();var i=!os((tn||r).memoizedState,n);if(i&&(r.memoizedState=n,Zn=!0),r=r.queue,r2(B3.bind(null,a,r,e),[e]),r.getSnapshot!==t||i||Kn!==null&&Kn.memoizedState.tag&1){if(a.flags|=2048,Lp(9,{destroy:void 0},V3.bind(null,a,r,n,t),null),sn===null)throw Error(pe(349));s||So&127||P3(a,t,n)}return n}function P3(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=dt.updateQueue,t===null?(t=Cw(),dt.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function V3(e,t,n,a){t.value=n,t.getSnapshot=a,U3(t)&&W3(e)}function B3(e,t,n){return n(function(){U3(t)&&W3(e)})}function U3(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!os(e,n)}catch{return!0}}function W3(e){var t=Xc(e,2);t!==null&&$r(t,e,2)}function kI(e){var t=cr();if(typeof e=="function"){var n=e;if(e=n(),_c){cl(!0);try{n()}finally{cl(!1)}}}return t.memoizedState=t.baseState=e,t.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Io,lastRenderedState:e},t}function j3(e,t,n,a){return e.baseState=n,a2(e,tn,typeof a=="function"?a:Io)}function xq(e,t,n,a,r){if(Dw(e))throw Error(pe(485));if(e=t.action,e!==null){var s={payload:r,action:e,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(i){s.listeners.push(i)}};Qe.T!==null?n(!0):s.isTransition=!1,a(s),n=t.pending,n===null?(s.next=t.pending=s,G3(t,s)):(s.next=n.next,t.pending=n.next=s)}}function G3(e,t){var n=t.action,a=t.payload,r=e.state;if(t.isTransition){var s=Qe.T,i={};Qe.T=i;try{var o=n(r,a),l=Qe.S;l!==null&&l(i,o),ND(e,t,o)}catch(c){TI(e,t,c)}finally{s!==null&&i.types!==null&&(s.types=i.types),Qe.T=s}}else try{s=n(r,a),ND(e,t,s)}catch(c){TI(e,t,c)}}function ND(e,t,n){n!==null&&typeof n=="object"&&typeof n.then=="function"?n.then(function(a){CD(e,t,a)},function(a){return TI(e,t,a)}):CD(e,t,n)}function CD(e,t,n){t.status="fulfilled",t.value=n,H3(t),e.state=n,t=e.pending,t!==null&&(n=t.next,n===t?e.pending=null:(n=n.next,t.next=n,G3(e,n)))}function TI(e,t,n){var a=e.pending;if(e.pending=null,a!==null){a=a.next;do t.status="rejected",t.reason=n,H3(t),t=t.next;while(t!==a)}e.action=null}function H3(e){e=e.listeners;for(var t=0;t<e.length;t++)(0,e[t])()}function q3(e,t){return t}function AD(e,t){if(Nt){var n=sn.formState;if(n!==null){e:{var a=dt;if(Nt){if(pn){t:{for(var r=pn,s=Es;r.nodeType!==8;){if(!s){r=null;break t}if(r=As(r.nextSibling),r===null){r=null;break t}}s=r.data,r=s==="F!"||s==="F"?r:null}if(r){pn=As(r.nextSibling),a=r.data==="F!";break e}}Ll(a)}a=!1}a&&(t=n[0])}}return n=cr(),n.memoizedState=n.baseState=t,a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:q3,lastRenderedState:t},n.queue=a,n=uL.bind(null,dt,a),a.dispatch=n,a=kI(!1),s=l2.bind(null,dt,!1,a.queue),a=cr(),r={state:t,dispatch:null,action:e,pending:null},a.queue=r,n=xq.bind(null,dt,r,s,n),r.dispatch=n,a.memoizedState=e,[t,n,!1]}function RD(e){var t=Pn();return K3(t,tn,e)}function K3(e,t,n){if(t=a2(e,t,q3)[0],e=Ex(Io)[0],typeof t=="object"&&t!==null&&typeof t.then=="function")try{var a=nb(t)}catch(i){throw i===bf?Nw:i}else a=t;t=Pn();var r=t.queue,s=r.dispatch;return n!==t.memoizedState&&(dt.flags|=2048,Lp(9,{destroy:void 0},wq.bind(null,r,n),null)),[a,s,e]}function wq(e,t){e.action=t}function DD(e){var t=Pn(),n=tn;if(n!==null)return K3(t,n,e);Pn(),t=t.memoizedState,n=Pn();var a=n.queue.dispatch;return n.memoizedState=e,[t,a,!1]}function Lp(e,t,n,a){return e={tag:e,create:n,deps:a,inst:t,next:null},t=dt.updateQueue,t===null&&(t=Cw(),dt.updateQueue=t),n=t.lastEffect,n===null?t.lastEffect=e.next=e:(a=n.next,n.next=e,e.next=a,t.lastEffect=e),e}function X3(){return Pn().memoizedState}function Nx(e,t,n,a){var r=cr();dt.flags|=e,r.memoizedState=Lp(1|t,{destroy:void 0},n,a===void 0?null:a)}function Rw(e,t,n,a){var r=Pn();a=a===void 0?null:a;var s=r.memoizedState.inst;tn!==null&&a!==null&&YT(a,tn.memoizedState.deps)?r.memoizedState=Lp(t,s,n,a):(dt.flags|=e,r.memoizedState=Lp(1|t,s,n,a))}function $D(e,t){Nx(8390656,8,e,t)}function r2(e,t){Rw(2048,8,e,t)}function _q(e){dt.flags|=4;var t=dt.updateQueue;if(t===null)t=Cw(),dt.updateQueue=t,t.events=[e];else{var n=t.events;n===null?t.events=[e]:n.push(e)}}function Q3(e){var t=Pn().memoizedState;return _q({ref:t,nextImpl:e}),function(){if(Lt&2)throw Error(pe(440));return t.impl.apply(void 0,arguments)}}function Y3(e,t){return Rw(4,2,e,t)}function Z3(e,t){return Rw(4,4,e,t)}function J3(e,t){if(typeof t=="function"){e=e();var n=t(e);return function(){typeof n=="function"?n():t(null)}}if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function eL(e,t,n){n=n!=null?n.concat([e]):null,Rw(4,4,J3.bind(null,t,e),n)}function s2(){}function tL(e,t){var n=Pn();t=t===void 0?null:t;var a=n.memoizedState;return t!==null&&YT(t,a[1])?a[0]:(n.memoizedState=[e,t],e)}function nL(e,t){var n=Pn();t=t===void 0?null:t;var a=n.memoizedState;if(t!==null&&YT(t,a[1]))return a[0];if(a=e(),_c){cl(!0);try{e()}finally{cl(!1)}}return n.memoizedState=[a,t],a}function i2(e,t,n){return n===void 0||So&1073741824&&!(kt&261930)?e.memoizedState=t:(e.memoizedState=n,e=jL(),dt.lanes|=e,Pl|=e,n)}function aL(e,t,n,a){return os(n,t)?n:Fp.current!==null?(e=i2(e,n,a),os(e,t)||(Zn=!0),e):!(So&42)||So&1073741824&&!(kt&261930)?(Zn=!0,e.memoizedState=n):(e=jL(),dt.lanes|=e,Pl|=e,t)}function rL(e,t,n,a,r){var s=zt.p;zt.p=s!==0&&8>s?s:8;var i=Qe.T,o={};Qe.T=o,l2(e,!1,t,n);try{var l=r(),c=Qe.S;if(c!==null&&c(o,l),l!==null&&typeof l=="object"&&typeof l.then=="function"){var u=yq(l,a);Gg(e,t,u,ss(e))}else Gg(e,t,a,ss(e))}catch(h){Gg(e,t,{then:function(){},status:"rejected",reason:h},ss())}finally{zt.p=s,i!==null&&o.types!==null&&(i.types=o.types),Qe.T=i}}function Sq(){}function EI(e,t,n,a){if(e.tag!==5)throw Error(pe(476));var r=sL(e).queue;rL(e,r,t,uc,n===null?Sq:function(){return iL(e),n(a)})}function sL(e){var t=e.memoizedState;if(t!==null)return t;t={memoizedState:uc,baseState:uc,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Io,lastRenderedState:uc},next:null};var n={};return t.next={memoizedState:n,baseState:n,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Io,lastRenderedState:n},next:null},e.memoizedState=t,e=e.alternate,e!==null&&(e.memoizedState=t),t}function iL(e){var t=sL(e);t.next===null&&(t=e.alternate.memoizedState),Gg(e,t.next.queue,{},ss())}function o2(){return za(by)}function oL(){return Pn().memoizedState}function lL(){return Pn().memoizedState}function Iq(e){for(var t=e.return;t!==null;){switch(t.tag){case 24:case 3:var n=ss();e=_l(n);var a=Sl(t,e,n);a!==null&&($r(a,t,n),Ug(a,t,n)),t={cache:HT()},e.payload=t;return}t=t.return}}function kq(e,t,n){var a=ss();n={lane:a,revertLane:0,gesture:null,action:n,hasEagerState:!1,eagerState:null,next:null},Dw(e)?cL(t,n):(n=UT(e,t,n,a),n!==null&&($r(n,e,a),hL(n,t,a)))}function uL(e,t,n){var a=ss();Gg(e,t,n,a)}function Gg(e,t,n,a){var r={lane:a,revertLane:0,gesture:null,action:n,hasEagerState:!1,eagerState:null,next:null};if(Dw(e))cL(t,r);else{var s=e.alternate;if(e.lanes===0&&(s===null||s.lanes===0)&&(s=t.lastRenderedReducer,s!==null))try{var i=t.lastRenderedState,o=s(i,n);if(r.hasEagerState=!0,r.eagerState=o,os(o,i))return Ew(e,t,r,0),sn===null&&Tw(),!1}catch{}finally{}if(n=UT(e,t,r,a),n!==null)return $r(n,e,a),hL(n,t,a),!0}return!1}function l2(e,t,n,a){if(a={lane:2,revertLane:y2(),gesture:null,action:a,hasEagerState:!1,eagerState:null,next:null},Dw(e)){if(t)throw Error(pe(479))}else t=UT(e,n,a,2),t!==null&&$r(t,e,2)}function Dw(e){var t=e.alternate;return e===dt||t!==null&&t===dt}function cL(e,t){_p=u0=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function hL(e,t,n){if(n&4194048){var a=t.lanes;a&=e.pendingLanes,n|=a,t.lanes=n,QF(e,n)}}var my={readContext:za,use:Aw,useCallback:Rn,useContext:Rn,useEffect:Rn,useImperativeHandle:Rn,useLayoutEffect:Rn,useInsertionEffect:Rn,useMemo:Rn,useReducer:Rn,useRef:Rn,useState:Rn,useDebugValue:Rn,useDeferredValue:Rn,useTransition:Rn,useSyncExternalStore:Rn,useId:Rn,useHostTransitionStatus:Rn,useFormState:Rn,useActionState:Rn,useOptimistic:Rn,useMemoCache:Rn,useCacheRefresh:Rn};my.useEffectEvent=Rn;var dL={readContext:za,use:Aw,useCallback:function(e,t){return cr().memoizedState=[e,t===void 0?null:t],e},useContext:za,useEffect:$D,useImperativeHandle:function(e,t,n){n=n!=null?n.concat([e]):null,Nx(4194308,4,J3.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Nx(4194308,4,e,t)},useInsertionEffect:function(e,t){Nx(4,2,e,t)},useMemo:function(e,t){var n=cr();t=t===void 0?null:t;var a=e();if(_c){cl(!0);try{e()}finally{cl(!1)}}return n.memoizedState=[a,t],a},useReducer:function(e,t,n){var a=cr();if(n!==void 0){var r=n(t);if(_c){cl(!0);try{n(t)}finally{cl(!1)}}}else r=t;return a.memoizedState=a.baseState=r,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:r},a.queue=e,e=e.dispatch=kq.bind(null,dt,e),[a.memoizedState,e]},useRef:function(e){var t=cr();return e={current:e},t.memoizedState=e},useState:function(e){e=kI(e);var t=e.queue,n=uL.bind(null,dt,t);return t.dispatch=n,[e.memoizedState,n]},useDebugValue:s2,useDeferredValue:function(e,t){var n=cr();return i2(n,e,t)},useTransition:function(){var e=kI(!1);return e=rL.bind(null,dt,e.queue,!0,!1),cr().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,t,n){var a=dt,r=cr();if(Nt){if(n===void 0)throw Error(pe(407));n=n()}else{if(n=t(),sn===null)throw Error(pe(349));kt&127||P3(a,t,n)}r.memoizedState=n;var s={value:n,getSnapshot:t};return r.queue=s,$D(B3.bind(null,a,s,e),[e]),a.flags|=2048,Lp(9,{destroy:void 0},V3.bind(null,a,s,n,t),null),n},useId:function(){var e=cr(),t=sn.identifierPrefix;if(Nt){var n=Ii,a=Si;n=(a&~(1<<32-rs(a)-1)).toString(32)+n,t="_"+t+"R_"+n,n=c0++,0<n&&(t+="H"+n.toString(32)),t+="_"}else n=bq++,t="_"+t+"r_"+n.toString(32)+"_";return e.memoizedState=t},useHostTransitionStatus:o2,useFormState:AD,useActionState:AD,useOptimistic:function(e){var t=cr();t.memoizedState=t.baseState=e;var n={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return t.queue=n,t=l2.bind(null,dt,!0,n),n.dispatch=t,[e,t]},useMemoCache:n2,useCacheRefresh:function(){return cr().memoizedState=Iq.bind(null,dt)},useEffectEvent:function(e){var t=cr(),n={impl:e};return t.memoizedState=n,function(){if(Lt&2)throw Error(pe(440));return n.impl.apply(void 0,arguments)}}},u2={readContext:za,use:Aw,useCallback:tL,useContext:za,useEffect:r2,useImperativeHandle:eL,useInsertionEffect:Y3,useLayoutEffect:Z3,useMemo:nL,useReducer:Ex,useRef:X3,useState:function(){return Ex(Io)},useDebugValue:s2,useDeferredValue:function(e,t){var n=Pn();return aL(n,tn.memoizedState,e,t)},useTransition:function(){var e=Ex(Io)[0],t=Pn().memoizedState;return[typeof e=="boolean"?e:nb(e),t]},useSyncExternalStore:z3,useId:oL,useHostTransitionStatus:o2,useFormState:RD,useActionState:RD,useOptimistic:function(e,t){var n=Pn();return j3(n,tn,e,t)},useMemoCache:n2,useCacheRefresh:lL};u2.useEffectEvent=Q3;var pL={readContext:za,use:Aw,useCallback:tL,useContext:za,useEffect:r2,useImperativeHandle:eL,useInsertionEffect:Y3,useLayoutEffect:Z3,useMemo:nL,useReducer:nS,useRef:X3,useState:function(){return nS(Io)},useDebugValue:s2,useDeferredValue:function(e,t){var n=Pn();return tn===null?i2(n,e,t):aL(n,tn.memoizedState,e,t)},useTransition:function(){var e=nS(Io)[0],t=Pn().memoizedState;return[typeof e=="boolean"?e:nb(e),t]},useSyncExternalStore:z3,useId:oL,useHostTransitionStatus:o2,useFormState:DD,useActionState:DD,useOptimistic:function(e,t){var n=Pn();return tn!==null?j3(n,tn,e,t):(n.baseState=e,[e,n.queue.dispatch])},useMemoCache:n2,useCacheRefresh:lL};pL.useEffectEvent=Q3;function aS(e,t,n,a){t=e.memoizedState,n=n(a,t),n=n==null?t:bn({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var NI={enqueueSetState:function(e,t,n){e=e._reactInternals;var a=ss(),r=_l(a);r.payload=t,n!=null&&(r.callback=n),t=Sl(e,r,a),t!==null&&($r(t,e,a),Ug(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var a=ss(),r=_l(a);r.tag=1,r.payload=t,n!=null&&(r.callback=n),t=Sl(e,r,a),t!==null&&($r(t,e,a),Ug(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=ss(),a=_l(n);a.tag=2,t!=null&&(a.callback=t),t=Sl(e,a,n),t!==null&&($r(t,e,n),Ug(t,e,n))}};function MD(e,t,n,a,r,s,i){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(a,s,i):t.prototype&&t.prototype.isPureReactComponent?!cy(n,a)||!cy(r,s):!0}function OD(e,t,n,a){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,a),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,a),t.state!==e&&NI.enqueueReplaceState(t,t.state,null)}function Sc(e,t){var n=t;if("ref"in t){n={};for(var a in t)a!=="ref"&&(n[a]=t[a])}if(e=e.defaultProps){n===t&&(n=bn({},n));for(var r in e)n[r]===void 0&&(n[r]=e[r])}return n}function fL(e){n0(e)}function mL(e){console.error(e)}function gL(e){n0(e)}function h0(e,t){try{var n=e.onUncaughtError;n(t.value,{componentStack:t.stack})}catch(a){setTimeout(function(){throw a})}}function FD(e,t,n){try{var a=e.onCaughtError;a(n.value,{componentStack:n.stack,errorBoundary:t.tag===1?t.stateNode:null})}catch(r){setTimeout(function(){throw r})}}function CI(e,t,n){return n=_l(n),n.tag=3,n.payload={element:null},n.callback=function(){h0(e,t)},n}function yL(e){return e=_l(e),e.tag=3,e}function bL(e,t,n,a){var r=n.type.getDerivedStateFromError;if(typeof r=="function"){var s=a.value;e.payload=function(){return r(s)},e.callback=function(){FD(t,n,a)}}var i=n.stateNode;i!==null&&typeof i.componentDidCatch=="function"&&(e.callback=function(){FD(t,n,a),typeof r!="function"&&(Il===null?Il=new Set([this]):Il.add(this));var o=a.stack;this.componentDidCatch(a.value,{componentStack:o!==null?o:""})})}function Tq(e,t,n,a,r){if(n.flags|=32768,a!==null&&typeof a=="object"&&typeof a.then=="function"){if(t=n.alternate,t!==null&&yf(t,n,r,!0),n=ls.current,n!==null){switch(n.tag){case 31:case 13:return Cs===null?g0():n.alternate===null&&Dn===0&&(Dn=3),n.flags&=-257,n.flags|=65536,n.lanes=r,a===i0?n.flags|=16384:(t=n.updateQueue,t===null?n.updateQueue=new Set([a]):t.add(a),fS(e,a,r)),!1;case 22:return n.flags|=65536,a===i0?n.flags|=16384:(t=n.updateQueue,t===null?(t={transitions:null,markerInstances:null,retryQueue:new Set([a])},n.updateQueue=t):(n=t.retryQueue,n===null?t.retryQueue=new Set([a]):n.add(a)),fS(e,a,r)),!1}throw Error(pe(435,n.tag))}return fS(e,a,r),g0(),!1}if(Nt)return t=ls.current,t!==null?(!(t.flags&65536)&&(t.flags|=256),t.flags|=65536,t.lanes=r,a!==gI&&(e=Error(pe(422),{cause:a}),dy(Ts(e,n)))):(a!==gI&&(t=Error(pe(423),{cause:a}),dy(Ts(t,n))),e=e.current.alternate,e.flags|=65536,r&=-r,e.lanes|=r,a=Ts(a,n),r=CI(e.stateNode,a,r),tS(e,r),Dn!==4&&(Dn=2)),!1;var s=Error(pe(520),{cause:a});if(s=Ts(s,n),Kg===null?Kg=[s]:Kg.push(s),Dn!==4&&(Dn=2),t===null)return!0;a=Ts(a,n),n=t;do{switch(n.tag){case 3:return n.flags|=65536,e=r&-r,n.lanes|=e,e=CI(n.stateNode,a,e),tS(n,e),!1;case 1:if(t=n.type,s=n.stateNode,(n.flags&128)===0&&(typeof t.getDerivedStateFromError=="function"||s!==null&&typeof s.componentDidCatch=="function"&&(Il===null||!Il.has(s))))return n.flags|=65536,r&=-r,n.lanes|=r,r=yL(r),bL(r,e,n,a),tS(n,r),!1}n=n.return}while(n!==null);return!1}var c2=Error(pe(461)),Zn=!1;function $a(e,t,n,a){t.child=e===null?D3(t,null,n,a):wc(t,e.child,n,a)}function LD(e,t,n,a,r){n=n.render;var s=t.ref;if("ref"in a){var i={};for(var o in a)o!=="ref"&&(i[o]=a[o])}else i=a;return xc(t),a=ZT(e,t,n,i,s,r),o=JT(),e!==null&&!Zn?(e2(e,t,r),ko(e,t,r)):(Nt&&o&&jT(t),t.flags|=1,$a(e,t,a,r),t.child)}function zD(e,t,n,a,r){if(e===null){var s=n.type;return typeof s=="function"&&!WT(s)&&s.defaultProps===void 0&&n.compare===null?(t.tag=15,t.type=s,vL(e,t,s,a,r)):(e=kx(n.type,null,a,t,t.mode,r),e.ref=t.ref,e.return=t,t.child=e)}if(s=e.child,!h2(e,r)){var i=s.memoizedProps;if(n=n.compare,n=n!==null?n:cy,n(i,a)&&e.ref===t.ref)return ko(e,t,r)}return t.flags|=1,e=mo(s,a),e.ref=t.ref,e.return=t,t.child=e}function vL(e,t,n,a,r){if(e!==null){var s=e.memoizedProps;if(cy(s,a)&&e.ref===t.ref)if(Zn=!1,t.pendingProps=a=s,h2(e,r))e.flags&131072&&(Zn=!0);else return t.lanes=e.lanes,ko(e,t,r)}return AI(e,t,n,a,r)}function xL(e,t,n,a){var r=a.children,s=e!==null?e.memoizedState:null;if(e===null&&t.stateNode===null&&(t.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),a.mode==="hidden"){if(t.flags&128){if(s=s!==null?s.baseLanes|n:n,e!==null){for(a=t.child=e.child,r=0;a!==null;)r=r|a.lanes|a.childLanes,a=a.sibling;a=r&~s}else a=0,t.child=null;return PD(e,t,s,n,a)}if(n&536870912)t.memoizedState={baseLanes:0,cachePool:null},e!==null&&Tx(t,s!==null?s.cachePool:null),s!==null?ED(t,s):SI(),O3(t);else return a=t.lanes=536870912,PD(e,t,s!==null?s.baseLanes|n:n,n,a)}else s!==null?(Tx(t,s.cachePool),ED(t,s),ol(),t.memoizedState=null):(e!==null&&Tx(t,null),SI(),ol());return $a(e,t,r,n),t.child}function wg(e,t){return e!==null&&e.tag===22||t.stateNode!==null||(t.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),t.sibling}function PD(e,t,n,a,r){var s=qT();return s=s===null?null:{parent:Qn._currentValue,pool:s},t.memoizedState={baseLanes:n,cachePool:s},e!==null&&Tx(t,null),SI(),O3(t),e!==null&&yf(e,t,a,!0),t.childLanes=r,null}function Cx(e,t){return t=d0({mode:t.mode,children:t.children},e.mode),t.ref=e.ref,e.child=t,t.return=e,t}function VD(e,t,n){return wc(t,e.child,null,n),e=Cx(t,t.pendingProps),e.flags|=2,Kr(t),t.memoizedState=null,e}function Eq(e,t,n){var a=t.pendingProps,r=(t.flags&128)!==0;if(t.flags&=-129,e===null){if(Nt){if(a.mode==="hidden")return e=Cx(t,a),t.lanes=536870912,wg(null,e);if(II(t),(e=pn)?(e=dz(e,Es),e=e!==null&&e.data==="&"?e:null,e!==null&&(t.memoizedState={dehydrated:e,treeContext:Fl!==null?{id:Si,overflow:Ii}:null,retryLane:536870912,hydrationErrors:null},n=k3(e),n.return=t,t.child=n,Fa=t,pn=null)):e=null,e===null)throw Ll(t);return t.lanes=536870912,null}return Cx(t,a)}var s=e.memoizedState;if(s!==null){var i=s.dehydrated;if(II(t),r)if(t.flags&256)t.flags&=-257,t=VD(e,t,n);else if(t.memoizedState!==null)t.child=e.child,t.flags|=128,t=null;else throw Error(pe(558));else if(Zn||yf(e,t,n,!1),r=(n&e.childLanes)!==0,Zn||r){if(a=sn,a!==null&&(i=YF(a,n),i!==0&&i!==s.retryLane))throw s.retryLane=i,Xc(e,i),$r(a,e,i),c2;g0(),t=VD(e,t,n)}else e=s.treeContext,pn=As(i.nextSibling),Fa=t,Nt=!0,wl=null,Es=!1,e!==null&&E3(t,e),t=Cx(t,a),t.flags|=4096;return t}return e=mo(e.child,{mode:a.mode,children:a.children}),e.ref=t.ref,t.child=e,e.return=t,e}function Ax(e,t){var n=t.ref;if(n===null)e!==null&&e.ref!==null&&(t.flags|=4194816);else{if(typeof n!="function"&&typeof n!="object")throw Error(pe(284));(e===null||e.ref!==n)&&(t.flags|=4194816)}}function AI(e,t,n,a,r){return xc(t),n=ZT(e,t,n,a,void 0,r),a=JT(),e!==null&&!Zn?(e2(e,t,r),ko(e,t,r)):(Nt&&a&&jT(t),t.flags|=1,$a(e,t,n,r),t.child)}function BD(e,t,n,a,r,s){return xc(t),t.updateQueue=null,n=L3(t,a,n,r),F3(e),a=JT(),e!==null&&!Zn?(e2(e,t,s),ko(e,t,s)):(Nt&&a&&jT(t),t.flags|=1,$a(e,t,n,s),t.child)}function UD(e,t,n,a,r){if(xc(t),t.stateNode===null){var s=dp,i=n.contextType;typeof i=="object"&&i!==null&&(s=za(i)),s=new n(a,s),t.memoizedState=s.state!==null&&s.state!==void 0?s.state:null,s.updater=NI,t.stateNode=s,s._reactInternals=t,s=t.stateNode,s.props=a,s.state=t.memoizedState,s.refs={},XT(t),i=n.contextType,s.context=typeof i=="object"&&i!==null?za(i):dp,s.state=t.memoizedState,i=n.getDerivedStateFromProps,typeof i=="function"&&(aS(t,n,i,a),s.state=t.memoizedState),typeof n.getDerivedStateFromProps=="function"||typeof s.getSnapshotBeforeUpdate=="function"||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(i=s.state,typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount(),i!==s.state&&NI.enqueueReplaceState(s,s.state,null),jg(t,a,s,r),Wg(),s.state=t.memoizedState),typeof s.componentDidMount=="function"&&(t.flags|=4194308),a=!0}else if(e===null){s=t.stateNode;var o=t.memoizedProps,l=Sc(n,o);s.props=l;var c=s.context,u=n.contextType;i=dp,typeof u=="object"&&u!==null&&(i=za(u));var h=n.getDerivedStateFromProps;u=typeof h=="function"||typeof s.getSnapshotBeforeUpdate=="function",o=t.pendingProps!==o,u||typeof s.UNSAFE_componentWillReceiveProps!="function"&&typeof s.componentWillReceiveProps!="function"||(o||c!==i)&&OD(t,s,a,i),nl=!1;var d=t.memoizedState;s.state=d,jg(t,a,s,r),Wg(),c=t.memoizedState,o||d!==c||nl?(typeof h=="function"&&(aS(t,n,h,a),c=t.memoizedState),(l=nl||MD(t,n,l,a,d,c,i))?(u||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount()),typeof s.componentDidMount=="function"&&(t.flags|=4194308)):(typeof s.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=a,t.memoizedState=c),s.props=a,s.state=c,s.context=i,a=l):(typeof s.componentDidMount=="function"&&(t.flags|=4194308),a=!1)}else{s=t.stateNode,wI(e,t),i=t.memoizedProps,u=Sc(n,i),s.props=u,h=t.pendingProps,d=s.context,c=n.contextType,l=dp,typeof c=="object"&&c!==null&&(l=za(c)),o=n.getDerivedStateFromProps,(c=typeof o=="function"||typeof s.getSnapshotBeforeUpdate=="function")||typeof s.UNSAFE_componentWillReceiveProps!="function"&&typeof s.componentWillReceiveProps!="function"||(i!==h||d!==l)&&OD(t,s,a,l),nl=!1,d=t.memoizedState,s.state=d,jg(t,a,s,r),Wg();var p=t.memoizedState;i!==h||d!==p||nl||e!==null&&e.dependencies!==null&&s0(e.dependencies)?(typeof o=="function"&&(aS(t,n,o,a),p=t.memoizedState),(u=nl||MD(t,n,u,a,d,p,l)||e!==null&&e.dependencies!==null&&s0(e.dependencies))?(c||typeof s.UNSAFE_componentWillUpdate!="function"&&typeof s.componentWillUpdate!="function"||(typeof s.componentWillUpdate=="function"&&s.componentWillUpdate(a,p,l),typeof s.UNSAFE_componentWillUpdate=="function"&&s.UNSAFE_componentWillUpdate(a,p,l)),typeof s.componentDidUpdate=="function"&&(t.flags|=4),typeof s.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof s.componentDidUpdate!="function"||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),typeof s.getSnapshotBeforeUpdate!="function"||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=a,t.memoizedState=p),s.props=a,s.state=p,s.context=l,a=u):(typeof s.componentDidUpdate!="function"||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),typeof s.getSnapshotBeforeUpdate!="function"||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),a=!1)}return s=a,Ax(e,t),a=(t.flags&128)!==0,s||a?(s=t.stateNode,n=a&&typeof n.getDerivedStateFromError!="function"?null:s.render(),t.flags|=1,e!==null&&a?(t.child=wc(t,e.child,null,r),t.child=wc(t,null,n,r)):$a(e,t,n,r),t.memoizedState=s.state,e=t.child):e=ko(e,t,r),e}function WD(e,t,n,a){return vc(),t.flags|=256,$a(e,t,n,a),t.child}var rS={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function sS(e){return{baseLanes:e,cachePool:C3()}}function iS(e,t,n){return e=e!==null?e.childLanes&~n:0,t&&(e|=Qr),e}function wL(e,t,n){var a=t.pendingProps,r=!1,s=(t.flags&128)!==0,i;if((i=s)||(i=e!==null&&e.memoizedState===null?!1:(Ln.current&2)!==0),i&&(r=!0,t.flags&=-129),i=(t.flags&32)!==0,t.flags&=-33,e===null){if(Nt){if(r?il(t):ol(),(e=pn)?(e=dz(e,Es),e=e!==null&&e.data!=="&"?e:null,e!==null&&(t.memoizedState={dehydrated:e,treeContext:Fl!==null?{id:Si,overflow:Ii}:null,retryLane:536870912,hydrationErrors:null},n=k3(e),n.return=t,t.child=n,Fa=t,pn=null)):e=null,e===null)throw Ll(t);return jI(e)?t.lanes=32:t.lanes=536870912,null}var o=a.children;return a=a.fallback,r?(ol(),r=t.mode,o=d0({mode:"hidden",children:o},r),a=cc(a,r,n,null),o.return=t,a.return=t,o.sibling=a,t.child=o,a=t.child,a.memoizedState=sS(n),a.childLanes=iS(e,i,n),t.memoizedState=rS,wg(null,a)):(il(t),RI(t,o))}var l=e.memoizedState;if(l!==null&&(o=l.dehydrated,o!==null)){if(s)t.flags&256?(il(t),t.flags&=-257,t=oS(e,t,n)):t.memoizedState!==null?(ol(),t.child=e.child,t.flags|=128,t=null):(ol(),o=a.fallback,r=t.mode,a=d0({mode:"visible",children:a.children},r),o=cc(o,r,n,null),o.flags|=2,a.return=t,o.return=t,a.sibling=o,t.child=a,wc(t,e.child,null,n),a=t.child,a.memoizedState=sS(n),a.childLanes=iS(e,i,n),t.memoizedState=rS,t=wg(null,a));else if(il(t),jI(o)){if(i=o.nextSibling&&o.nextSibling.dataset,i)var c=i.dgst;i=c,a=Error(pe(419)),a.stack="",a.digest=i,dy({value:a,source:null,stack:null}),t=oS(e,t,n)}else if(Zn||yf(e,t,n,!1),i=(n&e.childLanes)!==0,Zn||i){if(i=sn,i!==null&&(a=YF(i,n),a!==0&&a!==l.retryLane))throw l.retryLane=a,Xc(e,a),$r(i,e,a),c2;WI(o)||g0(),t=oS(e,t,n)}else WI(o)?(t.flags|=192,t.child=e.child,t=null):(e=l.treeContext,pn=As(o.nextSibling),Fa=t,Nt=!0,wl=null,Es=!1,e!==null&&E3(t,e),t=RI(t,a.children),t.flags|=4096);return t}return r?(ol(),o=a.fallback,r=t.mode,l=e.child,c=l.sibling,a=mo(l,{mode:"hidden",children:a.children}),a.subtreeFlags=l.subtreeFlags&65011712,c!==null?o=mo(c,o):(o=cc(o,r,n,null),o.flags|=2),o.return=t,a.return=t,a.sibling=o,t.child=a,wg(null,a),a=t.child,o=e.child.memoizedState,o===null?o=sS(n):(r=o.cachePool,r!==null?(l=Qn._currentValue,r=r.parent!==l?{parent:l,pool:l}:r):r=C3(),o={baseLanes:o.baseLanes|n,cachePool:r}),a.memoizedState=o,a.childLanes=iS(e,i,n),t.memoizedState=rS,wg(e.child,a)):(il(t),n=e.child,e=n.sibling,n=mo(n,{mode:"visible",children:a.children}),n.return=t,n.sibling=null,e!==null&&(i=t.deletions,i===null?(t.deletions=[e],t.flags|=16):i.push(e)),t.child=n,t.memoizedState=null,n)}function RI(e,t){return t=d0({mode:"visible",children:t},e.mode),t.return=e,e.child=t}function d0(e,t){return e=Xr(22,e,null,t),e.lanes=0,e}function oS(e,t,n){return wc(t,e.child,null,n),e=RI(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function jD(e,t,n){e.lanes|=t;var a=e.alternate;a!==null&&(a.lanes|=t),bI(e.return,t,n)}function lS(e,t,n,a,r,s){var i=e.memoizedState;i===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:a,tail:n,tailMode:r,treeForkCount:s}:(i.isBackwards=t,i.rendering=null,i.renderingStartTime=0,i.last=a,i.tail=n,i.tailMode=r,i.treeForkCount=s)}function _L(e,t,n){var a=t.pendingProps,r=a.revealOrder,s=a.tail;a=a.children;var i=Ln.current,o=(i&2)!==0;if(o?(i=i&1|2,t.flags|=128):i&=1,cn(Ln,i),$a(e,t,a,n),a=Nt?hy:0,!o&&e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&jD(e,n,t);else if(e.tag===19)jD(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}switch(r){case"forwards":for(n=t.child,r=null;n!==null;)e=n.alternate,e!==null&&l0(e)===null&&(r=n),n=n.sibling;n=r,n===null?(r=t.child,t.child=null):(r=n.sibling,n.sibling=null),lS(t,!1,r,n,s,a);break;case"backwards":case"unstable_legacy-backwards":for(n=null,r=t.child,t.child=null;r!==null;){if(e=r.alternate,e!==null&&l0(e)===null){t.child=r;break}e=r.sibling,r.sibling=n,n=r,r=e}lS(t,!0,n,null,s,a);break;case"together":lS(t,!1,null,null,void 0,a);break;default:t.memoizedState=null}return t.child}function ko(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),Pl|=t.lanes,!(n&t.childLanes))if(e!==null){if(yf(e,t,n,!1),(n&t.childLanes)===0)return null}else return null;if(e!==null&&t.child!==e.child)throw Error(pe(153));if(t.child!==null){for(e=t.child,n=mo(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=mo(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function h2(e,t){return e.lanes&t?!0:(e=e.dependencies,!!(e!==null&&s0(e)))}function Nq(e,t,n){switch(t.tag){case 3:Zx(t,t.stateNode.containerInfo),sl(t,Qn,e.memoizedState.cache),vc();break;case 27:case 5:sI(t);break;case 4:Zx(t,t.stateNode.containerInfo);break;case 10:sl(t,t.type,t.memoizedProps.value);break;case 31:if(t.memoizedState!==null)return t.flags|=128,II(t),null;break;case 13:var a=t.memoizedState;if(a!==null)return a.dehydrated!==null?(il(t),t.flags|=128,null):n&t.child.childLanes?wL(e,t,n):(il(t),e=ko(e,t,n),e!==null?e.sibling:null);il(t);break;case 19:var r=(e.flags&128)!==0;if(a=(n&t.childLanes)!==0,a||(yf(e,t,n,!1),a=(n&t.childLanes)!==0),r){if(a)return _L(e,t,n);t.flags|=128}if(r=t.memoizedState,r!==null&&(r.rendering=null,r.tail=null,r.lastEffect=null),cn(Ln,Ln.current),a)break;return null;case 22:return t.lanes=0,xL(e,t,n,t.pendingProps);case 24:sl(t,Qn,e.memoizedState.cache)}return ko(e,t,n)}function SL(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps)Zn=!0;else{if(!h2(e,n)&&!(t.flags&128))return Zn=!1,Nq(e,t,n);Zn=!!(e.flags&131072)}else Zn=!1,Nt&&t.flags&1048576&&T3(t,hy,t.index);switch(t.lanes=0,t.tag){case 16:e:{var a=t.pendingProps;if(e=Xu(t.elementType),t.type=e,typeof e=="function")WT(e)?(a=Sc(e,a),t.tag=1,t=UD(null,t,e,a,n)):(t.tag=0,t=AI(null,t,e,a,n));else{if(e!=null){var r=e.$$typeof;if(r===CT){t.tag=11,t=LD(null,t,e,a,n);break e}else if(r===AT){t.tag=14,t=zD(null,t,e,a,n);break e}}throw t=aI(e)||e,Error(pe(306,t,""))}}return t;case 0:return AI(e,t,t.type,t.pendingProps,n);case 1:return a=t.type,r=Sc(a,t.pendingProps),UD(e,t,a,r,n);case 3:e:{if(Zx(t,t.stateNode.containerInfo),e===null)throw Error(pe(387));a=t.pendingProps;var s=t.memoizedState;r=s.element,wI(e,t),jg(t,a,null,n);var i=t.memoizedState;if(a=i.cache,sl(t,Qn,a),a!==s.cache&&vI(t,[Qn],n,!0),Wg(),a=i.element,s.isDehydrated)if(s={element:a,isDehydrated:!1,cache:i.cache},t.updateQueue.baseState=s,t.memoizedState=s,t.flags&256){t=WD(e,t,a,n);break e}else if(a!==r){r=Ts(Error(pe(424)),t),dy(r),t=WD(e,t,a,n);break e}else{switch(e=t.stateNode.containerInfo,e.nodeType){case 9:e=e.body;break;default:e=e.nodeName==="HTML"?e.ownerDocument.body:e}for(pn=As(e.firstChild),Fa=t,Nt=!0,wl=null,Es=!0,n=D3(t,null,a,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling}else{if(vc(),a===r){t=ko(e,t,n);break e}$a(e,t,a,n)}t=t.child}return t;case 26:return Ax(e,t),e===null?(n=c$(t.type,null,t.pendingProps,null))?t.memoizedState=n:Nt||(n=t.type,e=t.pendingProps,a=x0(xl.current).createElement(n),a[Oa]=t,a[Fr]=e,Pa(a,n,e),Ta(a),t.stateNode=a):t.memoizedState=c$(t.type,e.memoizedProps,t.pendingProps,e.memoizedState),null;case 27:return sI(t),e===null&&Nt&&(a=t.stateNode=pz(t.type,t.pendingProps,xl.current),Fa=t,Es=!0,r=pn,uu(t.type)?(GI=r,pn=As(a.firstChild)):pn=r),$a(e,t,t.pendingProps.children,n),Ax(e,t),e===null&&(t.flags|=4194304),t.child;case 5:return e===null&&Nt&&((r=a=pn)&&(a=r7(a,t.type,t.pendingProps,Es),a!==null?(t.stateNode=a,Fa=t,pn=As(a.firstChild),Es=!1,r=!0):r=!1),r||Ll(t)),sI(t),r=t.type,s=t.pendingProps,i=e!==null?e.memoizedProps:null,a=s.children,BI(r,s)?a=null:i!==null&&BI(r,i)&&(t.flags|=32),t.memoizedState!==null&&(r=ZT(e,t,vq,null,null,n),by._currentValue=r),Ax(e,t),$a(e,t,a,n),t.child;case 6:return e===null&&Nt&&((e=n=pn)&&(n=s7(n,t.pendingProps,Es),n!==null?(t.stateNode=n,Fa=t,pn=null,e=!0):e=!1),e||Ll(t)),null;case 13:return wL(e,t,n);case 4:return Zx(t,t.stateNode.containerInfo),a=t.pendingProps,e===null?t.child=wc(t,null,a,n):$a(e,t,a,n),t.child;case 11:return LD(e,t,t.type,t.pendingProps,n);case 7:return $a(e,t,t.pendingProps,n),t.child;case 8:return $a(e,t,t.pendingProps.children,n),t.child;case 12:return $a(e,t,t.pendingProps.children,n),t.child;case 10:return a=t.pendingProps,sl(t,t.type,a.value),$a(e,t,a.children,n),t.child;case 9:return r=t.type._context,a=t.pendingProps.children,xc(t),r=za(r),a=a(r),t.flags|=1,$a(e,t,a,n),t.child;case 14:return zD(e,t,t.type,t.pendingProps,n);case 15:return vL(e,t,t.type,t.pendingProps,n);case 19:return _L(e,t,n);case 31:return Eq(e,t,n);case 22:return xL(e,t,n,t.pendingProps);case 24:return xc(t),a=za(Qn),e===null?(r=qT(),r===null&&(r=sn,s=HT(),r.pooledCache=s,s.refCount++,s!==null&&(r.pooledCacheLanes|=n),r=s),t.memoizedState={parent:a,cache:r},XT(t),sl(t,Qn,r)):(e.lanes&n&&(wI(e,t),jg(t,null,null,n),Wg()),r=e.memoizedState,s=t.memoizedState,r.parent!==a?(r={parent:a,cache:a},t.memoizedState=r,t.lanes===0&&(t.memoizedState=t.updateQueue.baseState=r),sl(t,Qn,a)):(a=s.cache,sl(t,Qn,a),a!==r.cache&&vI(t,[Qn],n,!0))),$a(e,t,t.pendingProps.children,n),t.child;case 29:throw t.pendingProps}throw Error(pe(156,t.tag))}function Ji(e){e.flags|=4}function uS(e,t,n,a,r){if((t=(e.mode&32)!==0)&&(t=!1),t){if(e.flags|=16777216,(r&335544128)===r)if(e.stateNode.complete)e.flags|=8192;else if(qL())e.flags|=8192;else throw dc=i0,KT}else e.flags&=-16777217}function GD(e,t){if(t.type!=="stylesheet"||t.state.loading&4)e.flags&=-16777217;else if(e.flags|=16777216,!gz(t))if(qL())e.flags|=8192;else throw dc=i0,KT}function Gv(e,t){t!==null&&(e.flags|=4),e.flags&16384&&(t=e.tag!==22?KF():536870912,e.lanes|=t,zp|=t)}function cg(e,t){if(!Nt)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var a=null;n!==null;)n.alternate!==null&&(a=n),n=n.sibling;a===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:a.sibling=null}}function dn(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,a=0;if(t)for(var r=e.child;r!==null;)n|=r.lanes|r.childLanes,a|=r.subtreeFlags&65011712,a|=r.flags&65011712,r.return=e,r=r.sibling;else for(r=e.child;r!==null;)n|=r.lanes|r.childLanes,a|=r.subtreeFlags,a|=r.flags,r.return=e,r=r.sibling;return e.subtreeFlags|=a,e.childLanes=n,t}function Cq(e,t,n){var a=t.pendingProps;switch(GT(t),t.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return dn(t),null;case 1:return dn(t),null;case 3:return n=t.stateNode,a=null,e!==null&&(a=e.memoizedState.cache),t.memoizedState.cache!==a&&(t.flags|=2048),go(Qn),Dp(),n.pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),(e===null||e.child===null)&&(Ud(t)?Ji(t):e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,eS())),dn(t),null;case 26:var r=t.type,s=t.memoizedState;return e===null?(Ji(t),s!==null?(dn(t),GD(t,s)):(dn(t),uS(t,r,null,a,n))):s?s!==e.memoizedState?(Ji(t),dn(t),GD(t,s)):(dn(t),t.flags&=-16777217):(e=e.memoizedProps,e!==a&&Ji(t),dn(t),uS(t,r,e,a,n)),null;case 27:if(Jx(t),n=xl.current,r=t.type,e!==null&&t.stateNode!=null)e.memoizedProps!==a&&Ji(t);else{if(!a){if(t.stateNode===null)throw Error(pe(166));return dn(t),null}e=Ni.current,Ud(t)?xD(t):(e=pz(r,a,n),t.stateNode=e,Ji(t))}return dn(t),null;case 5:if(Jx(t),r=t.type,e!==null&&t.stateNode!=null)e.memoizedProps!==a&&Ji(t);else{if(!a){if(t.stateNode===null)throw Error(pe(166));return dn(t),null}if(s=Ni.current,Ud(t))xD(t);else{var i=x0(xl.current);switch(s){case 1:s=i.createElementNS("http://www.w3.org/2000/svg",r);break;case 2:s=i.createElementNS("http://www.w3.org/1998/Math/MathML",r);break;default:switch(r){case"svg":s=i.createElementNS("http://www.w3.org/2000/svg",r);break;case"math":s=i.createElementNS("http://www.w3.org/1998/Math/MathML",r);break;case"script":s=i.createElement("div"),s.innerHTML="<script><\/script>",s=s.removeChild(s.firstChild);break;case"select":s=typeof a.is=="string"?i.createElement("select",{is:a.is}):i.createElement("select"),a.multiple?s.multiple=!0:a.size&&(s.size=a.size);break;default:s=typeof a.is=="string"?i.createElement(r,{is:a.is}):i.createElement(r)}}s[Oa]=t,s[Fr]=a;e:for(i=t.child;i!==null;){if(i.tag===5||i.tag===6)s.appendChild(i.stateNode);else if(i.tag!==4&&i.tag!==27&&i.child!==null){i.child.return=i,i=i.child;continue}if(i===t)break e;for(;i.sibling===null;){if(i.return===null||i.return===t)break e;i=i.return}i.sibling.return=i.return,i=i.sibling}t.stateNode=s;e:switch(Pa(s,r,a),r){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break e;case"img":a=!0;break e;default:a=!1}a&&Ji(t)}}return dn(t),uS(t,t.type,e===null?null:e.memoizedProps,t.pendingProps,n),null;case 6:if(e&&t.stateNode!=null)e.memoizedProps!==a&&Ji(t);else{if(typeof a!="string"&&t.stateNode===null)throw Error(pe(166));if(e=xl.current,Ud(t)){if(e=t.stateNode,n=t.memoizedProps,a=null,r=Fa,r!==null)switch(r.tag){case 27:case 5:a=r.memoizedProps}e[Oa]=t,e=!!(e.nodeValue===n||a!==null&&a.suppressHydrationWarning===!0||uz(e.nodeValue,n)),e||Ll(t,!0)}else e=x0(e).createTextNode(a),e[Oa]=t,t.stateNode=e}return dn(t),null;case 31:if(n=t.memoizedState,e===null||e.memoizedState!==null){if(a=Ud(t),n!==null){if(e===null){if(!a)throw Error(pe(318));if(e=t.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(pe(557));e[Oa]=t}else vc(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;dn(t),e=!1}else n=eS(),e!==null&&e.memoizedState!==null&&(e.memoizedState.hydrationErrors=n),e=!0;if(!e)return t.flags&256?(Kr(t),t):(Kr(t),null);if(t.flags&128)throw Error(pe(558))}return dn(t),null;case 13:if(a=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(r=Ud(t),a!==null&&a.dehydrated!==null){if(e===null){if(!r)throw Error(pe(318));if(r=t.memoizedState,r=r!==null?r.dehydrated:null,!r)throw Error(pe(317));r[Oa]=t}else vc(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;dn(t),r=!1}else r=eS(),e!==null&&e.memoizedState!==null&&(e.memoizedState.hydrationErrors=r),r=!0;if(!r)return t.flags&256?(Kr(t),t):(Kr(t),null)}return Kr(t),t.flags&128?(t.lanes=n,t):(n=a!==null,e=e!==null&&e.memoizedState!==null,n&&(a=t.child,r=null,a.alternate!==null&&a.alternate.memoizedState!==null&&a.alternate.memoizedState.cachePool!==null&&(r=a.alternate.memoizedState.cachePool.pool),s=null,a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(s=a.memoizedState.cachePool.pool),s!==r&&(a.flags|=2048)),n!==e&&n&&(t.child.flags|=8192),Gv(t,t.updateQueue),dn(t),null);case 4:return Dp(),e===null&&b2(t.stateNode.containerInfo),dn(t),null;case 10:return go(t.type),dn(t),null;case 19:if(Aa(Ln),a=t.memoizedState,a===null)return dn(t),null;if(r=(t.flags&128)!==0,s=a.rendering,s===null)if(r)cg(a,!1);else{if(Dn!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(s=l0(e),s!==null){for(t.flags|=128,cg(a,!1),e=s.updateQueue,t.updateQueue=e,Gv(t,e),t.subtreeFlags=0,e=n,n=t.child;n!==null;)I3(n,e),n=n.sibling;return cn(Ln,Ln.current&1|2),Nt&&so(t,a.treeForkCount),t.child}e=e.sibling}a.tail!==null&&ns()>f0&&(t.flags|=128,r=!0,cg(a,!1),t.lanes=4194304)}else{if(!r)if(e=l0(s),e!==null){if(t.flags|=128,r=!0,e=e.updateQueue,t.updateQueue=e,Gv(t,e),cg(a,!0),a.tail===null&&a.tailMode==="hidden"&&!s.alternate&&!Nt)return dn(t),null}else 2*ns()-a.renderingStartTime>f0&&n!==536870912&&(t.flags|=128,r=!0,cg(a,!1),t.lanes=4194304);a.isBackwards?(s.sibling=t.child,t.child=s):(e=a.last,e!==null?e.sibling=s:t.child=s,a.last=s)}return a.tail!==null?(e=a.tail,a.rendering=e,a.tail=e.sibling,a.renderingStartTime=ns(),e.sibling=null,n=Ln.current,cn(Ln,r?n&1|2:n&1),Nt&&so(t,a.treeForkCount),e):(dn(t),null);case 22:case 23:return Kr(t),QT(),a=t.memoizedState!==null,e!==null?e.memoizedState!==null!==a&&(t.flags|=8192):a&&(t.flags|=8192),a?n&536870912&&!(t.flags&128)&&(dn(t),t.subtreeFlags&6&&(t.flags|=8192)):dn(t),n=t.updateQueue,n!==null&&Gv(t,n.retryQueue),n=null,e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(n=e.memoizedState.cachePool.pool),a=null,t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(a=t.memoizedState.cachePool.pool),a!==n&&(t.flags|=2048),e!==null&&Aa(hc),null;case 24:return n=null,e!==null&&(n=e.memoizedState.cache),t.memoizedState.cache!==n&&(t.flags|=2048),go(Qn),dn(t),null;case 25:return null;case 30:return null}throw Error(pe(156,t.tag))}function Aq(e,t){switch(GT(t),t.tag){case 1:return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return go(Qn),Dp(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 26:case 27:case 5:return Jx(t),null;case 31:if(t.memoizedState!==null){if(Kr(t),t.alternate===null)throw Error(pe(340));vc()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 13:if(Kr(t),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(pe(340));vc()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return Aa(Ln),null;case 4:return Dp(),null;case 10:return go(t.type),null;case 22:case 23:return Kr(t),QT(),e!==null&&Aa(hc),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 24:return go(Qn),null;case 25:return null;default:return null}}function IL(e,t){switch(GT(t),t.tag){case 3:go(Qn),Dp();break;case 26:case 27:case 5:Jx(t);break;case 4:Dp();break;case 31:t.memoizedState!==null&&Kr(t);break;case 13:Kr(t);break;case 19:Aa(Ln);break;case 10:go(t.type);break;case 22:case 23:Kr(t),QT(),e!==null&&Aa(hc);break;case 24:go(Qn)}}function ab(e,t){try{var n=t.updateQueue,a=n!==null?n.lastEffect:null;if(a!==null){var r=a.next;n=r;do{if((n.tag&e)===e){a=void 0;var s=n.create,i=n.inst;a=s(),i.destroy=a}n=n.next}while(n!==r)}}catch(o){qt(t,t.return,o)}}function zl(e,t,n){try{var a=t.updateQueue,r=a!==null?a.lastEffect:null;if(r!==null){var s=r.next;a=s;do{if((a.tag&e)===e){var i=a.inst,o=i.destroy;if(o!==void 0){i.destroy=void 0,r=t;var l=n,c=o;try{c()}catch(u){qt(r,l,u)}}}a=a.next}while(a!==s)}}catch(u){qt(t,t.return,u)}}function kL(e){var t=e.updateQueue;if(t!==null){var n=e.stateNode;try{M3(t,n)}catch(a){qt(e,e.return,a)}}}function TL(e,t,n){n.props=Sc(e.type,e.memoizedProps),n.state=e.memoizedState;try{n.componentWillUnmount()}catch(a){qt(e,t,a)}}function Hg(e,t){try{var n=e.ref;if(n!==null){switch(e.tag){case 26:case 27:case 5:var a=e.stateNode;break;case 30:a=e.stateNode;break;default:a=e.stateNode}typeof n=="function"?e.refCleanup=n(a):n.current=a}}catch(r){qt(e,t,r)}}function ki(e,t){var n=e.ref,a=e.refCleanup;if(n!==null)if(typeof a=="function")try{a()}catch(r){qt(e,t,r)}finally{e.refCleanup=null,e=e.alternate,e!=null&&(e.refCleanup=null)}else if(typeof n=="function")try{n(null)}catch(r){qt(e,t,r)}else n.current=null}function EL(e){var t=e.type,n=e.memoizedProps,a=e.stateNode;try{e:switch(t){case"button":case"input":case"select":case"textarea":n.autoFocus&&a.focus();break e;case"img":n.src?a.src=n.src:n.srcSet&&(a.srcset=n.srcSet)}}catch(r){qt(e,e.return,r)}}function cS(e,t,n){try{var a=e.stateNode;Zq(a,e.type,n,t),a[Fr]=t}catch(r){qt(e,e.return,r)}}function NL(e){return e.tag===5||e.tag===3||e.tag===26||e.tag===27&&uu(e.type)||e.tag===4}function hS(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||NL(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.tag===27&&uu(e.type)||e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function DI(e,t,n){var a=e.tag;if(a===5||a===6)e=e.stateNode,t?(n.nodeType===9?n.body:n.nodeName==="HTML"?n.ownerDocument.body:n).insertBefore(e,t):(t=n.nodeType===9?n.body:n.nodeName==="HTML"?n.ownerDocument.body:n,t.appendChild(e),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=po));else if(a!==4&&(a===27&&uu(e.type)&&(n=e.stateNode,t=null),e=e.child,e!==null))for(DI(e,t,n),e=e.sibling;e!==null;)DI(e,t,n),e=e.sibling}function p0(e,t,n){var a=e.tag;if(a===5||a===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(a!==4&&(a===27&&uu(e.type)&&(n=e.stateNode),e=e.child,e!==null))for(p0(e,t,n),e=e.sibling;e!==null;)p0(e,t,n),e=e.sibling}function CL(e){var t=e.stateNode,n=e.memoizedProps;try{for(var a=e.type,r=t.attributes;r.length;)t.removeAttributeNode(r[0]);Pa(t,a,n),t[Oa]=e,t[Fr]=n}catch(s){qt(e,e.return,s)}}var uo=!1,Xn=!1,dS=!1,HD=typeof WeakSet=="function"?WeakSet:Set,ka=null;function Rq(e,t){if(e=e.containerInfo,PI=I0,e=g3(e),VT(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var a=n.getSelection&&n.getSelection();if(a&&a.rangeCount!==0){n=a.anchorNode;var r=a.anchorOffset,s=a.focusNode;a=a.focusOffset;try{n.nodeType,s.nodeType}catch{n=null;break e}var i=0,o=-1,l=-1,c=0,u=0,h=e,d=null;t:for(;;){for(var p;h!==n||r!==0&&h.nodeType!==3||(o=i+r),h!==s||a!==0&&h.nodeType!==3||(l=i+a),h.nodeType===3&&(i+=h.nodeValue.length),(p=h.firstChild)!==null;)d=h,h=p;for(;;){if(h===e)break t;if(d===n&&++c===r&&(o=i),d===s&&++u===a&&(l=i),(p=h.nextSibling)!==null)break;h=d,d=h.parentNode}h=p}n=o===-1||l===-1?null:{start:o,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(VI={focusedElem:e,selectionRange:n},I0=!1,ka=t;ka!==null;)if(t=ka,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,ka=e;else for(;ka!==null;){switch(t=ka,s=t.alternate,e=t.flags,t.tag){case 0:if(e&4&&(e=t.updateQueue,e=e!==null?e.events:null,e!==null))for(n=0;n<e.length;n++)r=e[n],r.ref.impl=r.nextImpl;break;case 11:case 15:break;case 1:if(e&1024&&s!==null){e=void 0,n=t,r=s.memoizedProps,s=s.memoizedState,a=n.stateNode;try{var f=Sc(n.type,r);e=a.getSnapshotBeforeUpdate(f,s),a.__reactInternalSnapshotBeforeUpdate=e}catch(m){qt(n,n.return,m)}}break;case 3:if(e&1024){if(e=t.stateNode.containerInfo,n=e.nodeType,n===9)UI(e);else if(n===1)switch(e.nodeName){case"HEAD":case"HTML":case"BODY":UI(e);break;default:e.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if(e&1024)throw Error(pe(163))}if(e=t.sibling,e!==null){e.return=t.return,ka=e;break}ka=t.return}}function AL(e,t,n){var a=n.flags;switch(n.tag){case 0:case 11:case 15:to(e,n),a&4&&ab(5,n);break;case 1:if(to(e,n),a&4)if(e=n.stateNode,t===null)try{e.componentDidMount()}catch(i){qt(n,n.return,i)}else{var r=Sc(n.type,t.memoizedProps);t=t.memoizedState;try{e.componentDidUpdate(r,t,e.__reactInternalSnapshotBeforeUpdate)}catch(i){qt(n,n.return,i)}}a&64&&kL(n),a&512&&Hg(n,n.return);break;case 3:if(to(e,n),a&64&&(e=n.updateQueue,e!==null)){if(t=null,n.child!==null)switch(n.child.tag){case 27:case 5:t=n.child.stateNode;break;case 1:t=n.child.stateNode}try{M3(e,t)}catch(i){qt(n,n.return,i)}}break;case 27:t===null&&a&4&&CL(n);case 26:case 5:to(e,n),t===null&&a&4&&EL(n),a&512&&Hg(n,n.return);break;case 12:to(e,n);break;case 31:to(e,n),a&4&&$L(e,n);break;case 13:to(e,n),a&4&&ML(e,n),a&64&&(e=n.memoizedState,e!==null&&(e=e.dehydrated,e!==null&&(n=Vq.bind(null,n),i7(e,n))));break;case 22:if(a=n.memoizedState!==null||uo,!a){t=t!==null&&t.memoizedState!==null||Xn,r=uo;var s=Xn;uo=a,(Xn=t)&&!s?no(e,n,(n.subtreeFlags&8772)!==0):to(e,n),uo=r,Xn=s}break;case 30:break;default:to(e,n)}}function RL(e){var t=e.alternate;t!==null&&(e.alternate=null,RL(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&MT(t)),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var xn=null,kr=!1;function eo(e,t,n){for(n=n.child;n!==null;)DL(e,t,n),n=n.sibling}function DL(e,t,n){if(as&&typeof as.onCommitFiberUnmount=="function")try{as.onCommitFiberUnmount(Qy,n)}catch{}switch(n.tag){case 26:Xn||ki(n,t),eo(e,t,n),n.memoizedState?n.memoizedState.count--:n.stateNode&&(n=n.stateNode,n.parentNode.removeChild(n));break;case 27:Xn||ki(n,t);var a=xn,r=kr;uu(n.type)&&(xn=n.stateNode,kr=!1),eo(e,t,n),Qg(n.stateNode),xn=a,kr=r;break;case 5:Xn||ki(n,t);case 6:if(a=xn,r=kr,xn=null,eo(e,t,n),xn=a,kr=r,xn!==null)if(kr)try{(xn.nodeType===9?xn.body:xn.nodeName==="HTML"?xn.ownerDocument.body:xn).removeChild(n.stateNode)}catch(s){qt(n,t,s)}else try{xn.removeChild(n.stateNode)}catch(s){qt(n,t,s)}break;case 18:xn!==null&&(kr?(e=xn,s$(e.nodeType===9?e.body:e.nodeName==="HTML"?e.ownerDocument.body:e,n.stateNode),Up(e)):s$(xn,n.stateNode));break;case 4:a=xn,r=kr,xn=n.stateNode.containerInfo,kr=!0,eo(e,t,n),xn=a,kr=r;break;case 0:case 11:case 14:case 15:zl(2,n,t),Xn||zl(4,n,t),eo(e,t,n);break;case 1:Xn||(ki(n,t),a=n.stateNode,typeof a.componentWillUnmount=="function"&&TL(n,t,a)),eo(e,t,n);break;case 21:eo(e,t,n);break;case 22:Xn=(a=Xn)||n.memoizedState!==null,eo(e,t,n),Xn=a;break;default:eo(e,t,n)}}function $L(e,t){if(t.memoizedState===null&&(e=t.alternate,e!==null&&(e=e.memoizedState,e!==null))){e=e.dehydrated;try{Up(e)}catch(n){qt(t,t.return,n)}}}function ML(e,t){if(t.memoizedState===null&&(e=t.alternate,e!==null&&(e=e.memoizedState,e!==null&&(e=e.dehydrated,e!==null))))try{Up(e)}catch(n){qt(t,t.return,n)}}function Dq(e){switch(e.tag){case 31:case 13:case 19:var t=e.stateNode;return t===null&&(t=e.stateNode=new HD),t;case 22:return e=e.stateNode,t=e._retryCache,t===null&&(t=e._retryCache=new HD),t;default:throw Error(pe(435,e.tag))}}function Hv(e,t){var n=Dq(e);t.forEach(function(a){if(!n.has(a)){n.add(a);var r=Bq.bind(null,e,a);a.then(r,r)}})}function xr(e,t){var n=t.deletions;if(n!==null)for(var a=0;a<n.length;a++){var r=n[a],s=e,i=t,o=i;e:for(;o!==null;){switch(o.tag){case 27:if(uu(o.type)){xn=o.stateNode,kr=!1;break e}break;case 5:xn=o.stateNode,kr=!1;break e;case 3:case 4:xn=o.stateNode.containerInfo,kr=!0;break e}o=o.return}if(xn===null)throw Error(pe(160));DL(s,i,r),xn=null,kr=!1,s=r.alternate,s!==null&&(s.return=null),r.return=null}if(t.subtreeFlags&13886)for(t=t.child;t!==null;)OL(t,e),t=t.sibling}var Hs=null;function OL(e,t){var n=e.alternate,a=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:xr(t,e),wr(e),a&4&&(zl(3,e,e.return),ab(3,e),zl(5,e,e.return));break;case 1:xr(t,e),wr(e),a&512&&(Xn||n===null||ki(n,n.return)),a&64&&uo&&(e=e.updateQueue,e!==null&&(a=e.callbacks,a!==null&&(n=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=n===null?a:n.concat(a))));break;case 26:var r=Hs;if(xr(t,e),wr(e),a&512&&(Xn||n===null||ki(n,n.return)),a&4){var s=n!==null?n.memoizedState:null;if(a=e.memoizedState,n===null)if(a===null)if(e.stateNode===null){e:{a=e.type,n=e.memoizedProps,r=r.ownerDocument||r;t:switch(a){case"title":s=r.getElementsByTagName("title")[0],(!s||s[Jy]||s[Oa]||s.namespaceURI==="http://www.w3.org/2000/svg"||s.hasAttribute("itemprop"))&&(s=r.createElement(a),r.head.insertBefore(s,r.querySelector("head > title"))),Pa(s,a,n),s[Oa]=e,Ta(s),a=s;break e;case"link":var i=d$("link","href",r).get(a+(n.href||""));if(i){for(var o=0;o<i.length;o++)if(s=i[o],s.getAttribute("href")===(n.href==null||n.href===""?null:n.href)&&s.getAttribute("rel")===(n.rel==null?null:n.rel)&&s.getAttribute("title")===(n.title==null?null:n.title)&&s.getAttribute("crossorigin")===(n.crossOrigin==null?null:n.crossOrigin)){i.splice(o,1);break t}}s=r.createElement(a),Pa(s,a,n),r.head.appendChild(s);break;case"meta":if(i=d$("meta","content",r).get(a+(n.content||""))){for(o=0;o<i.length;o++)if(s=i[o],s.getAttribute("content")===(n.content==null?null:""+n.content)&&s.getAttribute("name")===(n.name==null?null:n.name)&&s.getAttribute("property")===(n.property==null?null:n.property)&&s.getAttribute("http-equiv")===(n.httpEquiv==null?null:n.httpEquiv)&&s.getAttribute("charset")===(n.charSet==null?null:n.charSet)){i.splice(o,1);break t}}s=r.createElement(a),Pa(s,a,n),r.head.appendChild(s);break;default:throw Error(pe(468,a))}s[Oa]=e,Ta(s),a=s}e.stateNode=a}else p$(r,e.type,e.stateNode);else e.stateNode=h$(r,a,e.memoizedProps);else s!==a?(s===null?n.stateNode!==null&&(n=n.stateNode,n.parentNode.removeChild(n)):s.count--,a===null?p$(r,e.type,e.stateNode):h$(r,a,e.memoizedProps)):a===null&&e.stateNode!==null&&cS(e,e.memoizedProps,n.memoizedProps)}break;case 27:xr(t,e),wr(e),a&512&&(Xn||n===null||ki(n,n.return)),n!==null&&a&4&&cS(e,e.memoizedProps,n.memoizedProps);break;case 5:if(xr(t,e),wr(e),a&512&&(Xn||n===null||ki(n,n.return)),e.flags&32){r=e.stateNode;try{Mp(r,"")}catch(f){qt(e,e.return,f)}}a&4&&e.stateNode!=null&&(r=e.memoizedProps,cS(e,r,n!==null?n.memoizedProps:r)),a&1024&&(dS=!0);break;case 6:if(xr(t,e),wr(e),a&4){if(e.stateNode===null)throw Error(pe(162));a=e.memoizedProps,n=e.stateNode;try{n.nodeValue=a}catch(f){qt(e,e.return,f)}}break;case 3:if($x=null,r=Hs,Hs=w0(t.containerInfo),xr(t,e),Hs=r,wr(e),a&4&&n!==null&&n.memoizedState.isDehydrated)try{Up(t.containerInfo)}catch(f){qt(e,e.return,f)}dS&&(dS=!1,FL(e));break;case 4:a=Hs,Hs=w0(e.stateNode.containerInfo),xr(t,e),wr(e),Hs=a;break;case 12:xr(t,e),wr(e);break;case 31:xr(t,e),wr(e),a&4&&(a=e.updateQueue,a!==null&&(e.updateQueue=null,Hv(e,a)));break;case 13:xr(t,e),wr(e),e.child.flags&8192&&e.memoizedState!==null!=(n!==null&&n.memoizedState!==null)&&($w=ns()),a&4&&(a=e.updateQueue,a!==null&&(e.updateQueue=null,Hv(e,a)));break;case 22:r=e.memoizedState!==null;var l=n!==null&&n.memoizedState!==null,c=uo,u=Xn;if(uo=c||r,Xn=u||l,xr(t,e),Xn=u,uo=c,wr(e),a&8192)e:for(t=e.stateNode,t._visibility=r?t._visibility&-2:t._visibility|1,r&&(n===null||l||uo||Xn||Qu(e)),n=null,t=e;;){if(t.tag===5||t.tag===26){if(n===null){l=n=t;try{if(s=l.stateNode,r)i=s.style,typeof i.setProperty=="function"?i.setProperty("display","none","important"):i.display="none";else{o=l.stateNode;var h=l.memoizedProps.style,d=h!=null&&h.hasOwnProperty("display")?h.display:null;o.style.display=d==null||typeof d=="boolean"?"":(""+d).trim()}}catch(f){qt(l,l.return,f)}}}else if(t.tag===6){if(n===null){l=t;try{l.stateNode.nodeValue=r?"":l.memoizedProps}catch(f){qt(l,l.return,f)}}}else if(t.tag===18){if(n===null){l=t;try{var p=l.stateNode;r?i$(p,!0):i$(l.stateNode,!1)}catch(f){qt(l,l.return,f)}}}else if((t.tag!==22&&t.tag!==23||t.memoizedState===null||t===e)&&t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;t.sibling===null;){if(t.return===null||t.return===e)break e;n===t&&(n=null),t=t.return}n===t&&(n=null),t.sibling.return=t.return,t=t.sibling}a&4&&(a=e.updateQueue,a!==null&&(n=a.retryQueue,n!==null&&(a.retryQueue=null,Hv(e,n))));break;case 19:xr(t,e),wr(e),a&4&&(a=e.updateQueue,a!==null&&(e.updateQueue=null,Hv(e,a)));break;case 30:break;case 21:break;default:xr(t,e),wr(e)}}function wr(e){var t=e.flags;if(t&2){try{for(var n,a=e.return;a!==null;){if(NL(a)){n=a;break}a=a.return}if(n==null)throw Error(pe(160));switch(n.tag){case 27:var r=n.stateNode,s=hS(e);p0(e,s,r);break;case 5:var i=n.stateNode;n.flags&32&&(Mp(i,""),n.flags&=-33);var o=hS(e);p0(e,o,i);break;case 3:case 4:var l=n.stateNode.containerInfo,c=hS(e);DI(e,c,l);break;default:throw Error(pe(161))}}catch(u){qt(e,e.return,u)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function FL(e){if(e.subtreeFlags&1024)for(e=e.child;e!==null;){var t=e;FL(t),t.tag===5&&t.flags&1024&&t.stateNode.reset(),e=e.sibling}}function to(e,t){if(t.subtreeFlags&8772)for(t=t.child;t!==null;)AL(e,t.alternate,t),t=t.sibling}function Qu(e){for(e=e.child;e!==null;){var t=e;switch(t.tag){case 0:case 11:case 14:case 15:zl(4,t,t.return),Qu(t);break;case 1:ki(t,t.return);var n=t.stateNode;typeof n.componentWillUnmount=="function"&&TL(t,t.return,n),Qu(t);break;case 27:Qg(t.stateNode);case 26:case 5:ki(t,t.return),Qu(t);break;case 22:t.memoizedState===null&&Qu(t);break;case 30:Qu(t);break;default:Qu(t)}e=e.sibling}}function no(e,t,n){for(n=n&&(t.subtreeFlags&8772)!==0,t=t.child;t!==null;){var a=t.alternate,r=e,s=t,i=s.flags;switch(s.tag){case 0:case 11:case 15:no(r,s,n),ab(4,s);break;case 1:if(no(r,s,n),a=s,r=a.stateNode,typeof r.componentDidMount=="function")try{r.componentDidMount()}catch(c){qt(a,a.return,c)}if(a=s,r=a.updateQueue,r!==null){var o=a.stateNode;try{var l=r.shared.hiddenCallbacks;if(l!==null)for(r.shared.hiddenCallbacks=null,r=0;r<l.length;r++)$3(l[r],o)}catch(c){qt(a,a.return,c)}}n&&i&64&&kL(s),Hg(s,s.return);break;case 27:CL(s);case 26:case 5:no(r,s,n),n&&a===null&&i&4&&EL(s),Hg(s,s.return);break;case 12:no(r,s,n);break;case 31:no(r,s,n),n&&i&4&&$L(r,s);break;case 13:no(r,s,n),n&&i&4&&ML(r,s);break;case 22:s.memoizedState===null&&no(r,s,n),Hg(s,s.return);break;case 30:break;default:no(r,s,n)}t=t.sibling}}function d2(e,t){var n=null;e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(n=e.memoizedState.cachePool.pool),e=null,t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(e=t.memoizedState.cachePool.pool),e!==n&&(e!=null&&e.refCount++,n!=null&&tb(n))}function p2(e,t){e=null,t.alternate!==null&&(e=t.alternate.memoizedState.cache),t=t.memoizedState.cache,t!==e&&(t.refCount++,e!=null&&tb(e))}function Us(e,t,n,a){if(t.subtreeFlags&10256)for(t=t.child;t!==null;)LL(e,t,n,a),t=t.sibling}function LL(e,t,n,a){var r=t.flags;switch(t.tag){case 0:case 11:case 15:Us(e,t,n,a),r&2048&&ab(9,t);break;case 1:Us(e,t,n,a);break;case 3:Us(e,t,n,a),r&2048&&(e=null,t.alternate!==null&&(e=t.alternate.memoizedState.cache),t=t.memoizedState.cache,t!==e&&(t.refCount++,e!=null&&tb(e)));break;case 12:if(r&2048){Us(e,t,n,a),e=t.stateNode;try{var s=t.memoizedProps,i=s.id,o=s.onPostCommit;typeof o=="function"&&o(i,t.alternate===null?"mount":"update",e.passiveEffectDuration,-0)}catch(l){qt(t,t.return,l)}}else Us(e,t,n,a);break;case 31:Us(e,t,n,a);break;case 13:Us(e,t,n,a);break;case 23:break;case 22:s=t.stateNode,i=t.alternate,t.memoizedState!==null?s._visibility&2?Us(e,t,n,a):qg(e,t):s._visibility&2?Us(e,t,n,a):(s._visibility|=2,Xd(e,t,n,a,(t.subtreeFlags&10256)!==0||!1)),r&2048&&d2(i,t);break;case 24:Us(e,t,n,a),r&2048&&p2(t.alternate,t);break;default:Us(e,t,n,a)}}function Xd(e,t,n,a,r){for(r=r&&((t.subtreeFlags&10256)!==0||!1),t=t.child;t!==null;){var s=e,i=t,o=n,l=a,c=i.flags;switch(i.tag){case 0:case 11:case 15:Xd(s,i,o,l,r),ab(8,i);break;case 23:break;case 22:var u=i.stateNode;i.memoizedState!==null?u._visibility&2?Xd(s,i,o,l,r):qg(s,i):(u._visibility|=2,Xd(s,i,o,l,r)),r&&c&2048&&d2(i.alternate,i);break;case 24:Xd(s,i,o,l,r),r&&c&2048&&p2(i.alternate,i);break;default:Xd(s,i,o,l,r)}t=t.sibling}}function qg(e,t){if(t.subtreeFlags&10256)for(t=t.child;t!==null;){var n=e,a=t,r=a.flags;switch(a.tag){case 22:qg(n,a),r&2048&&d2(a.alternate,a);break;case 24:qg(n,a),r&2048&&p2(a.alternate,a);break;default:qg(n,a)}t=t.sibling}}var _g=8192;function Wd(e,t,n){if(e.subtreeFlags&_g)for(e=e.child;e!==null;)zL(e,t,n),e=e.sibling}function zL(e,t,n){switch(e.tag){case 26:Wd(e,t,n),e.flags&_g&&e.memoizedState!==null&&b7(n,Hs,e.memoizedState,e.memoizedProps);break;case 5:Wd(e,t,n);break;case 3:case 4:var a=Hs;Hs=w0(e.stateNode.containerInfo),Wd(e,t,n),Hs=a;break;case 22:e.memoizedState===null&&(a=e.alternate,a!==null&&a.memoizedState!==null?(a=_g,_g=16777216,Wd(e,t,n),_g=a):Wd(e,t,n));break;default:Wd(e,t,n)}}function PL(e){var t=e.alternate;if(t!==null&&(e=t.child,e!==null)){t.child=null;do t=e.sibling,e.sibling=null,e=t;while(e!==null)}}function hg(e){var t=e.deletions;if(e.flags&16){if(t!==null)for(var n=0;n<t.length;n++){var a=t[n];ka=a,BL(a,e)}PL(e)}if(e.subtreeFlags&10256)for(e=e.child;e!==null;)VL(e),e=e.sibling}function VL(e){switch(e.tag){case 0:case 11:case 15:hg(e),e.flags&2048&&zl(9,e,e.return);break;case 3:hg(e);break;case 12:hg(e);break;case 22:var t=e.stateNode;e.memoizedState!==null&&t._visibility&2&&(e.return===null||e.return.tag!==13)?(t._visibility&=-3,Rx(e)):hg(e);break;default:hg(e)}}function Rx(e){var t=e.deletions;if(e.flags&16){if(t!==null)for(var n=0;n<t.length;n++){var a=t[n];ka=a,BL(a,e)}PL(e)}for(e=e.child;e!==null;){switch(t=e,t.tag){case 0:case 11:case 15:zl(8,t,t.return),Rx(t);break;case 22:n=t.stateNode,n._visibility&2&&(n._visibility&=-3,Rx(t));break;default:Rx(t)}e=e.sibling}}function BL(e,t){for(;ka!==null;){var n=ka;switch(n.tag){case 0:case 11:case 15:zl(8,n,t);break;case 23:case 22:if(n.memoizedState!==null&&n.memoizedState.cachePool!==null){var a=n.memoizedState.cachePool.pool;a!=null&&a.refCount++}break;case 24:tb(n.memoizedState.cache)}if(a=n.child,a!==null)a.return=n,ka=a;else e:for(n=e;ka!==null;){a=ka;var r=a.sibling,s=a.return;if(RL(a),a===n){ka=null;break e}if(r!==null){r.return=s,ka=r;break e}ka=s}}}var $q={getCacheForType:function(e){var t=za(Qn),n=t.data.get(e);return n===void 0&&(n=e(),t.data.set(e,n)),n},cacheSignal:function(){return za(Qn).controller.signal}},Mq=typeof WeakMap=="function"?WeakMap:Map,Lt=0,sn=null,wt=null,kt=0,Ht=0,qr=null,dl=!1,vf=!1,f2=!1,To=0,Dn=0,Pl=0,pc=0,m2=0,Qr=0,zp=0,Kg=null,Er=null,$I=!1,$w=0,UL=0,f0=1/0,m0=null,Il=null,fa=0,kl=null,Pp=null,yo=0,MI=0,OI=null,WL=null,Xg=0,FI=null;function ss(){return Lt&2&&kt!==0?kt&-kt:Qe.T!==null?y2():ZF()}function jL(){if(Qr===0)if(!(kt&536870912)||Nt){var e=zv;zv<<=1,!(zv&3932160)&&(zv=262144),Qr=e}else Qr=536870912;return e=ls.current,e!==null&&(e.flags|=32),Qr}function $r(e,t,n){(e===sn&&(Ht===2||Ht===9)||e.cancelPendingCommit!==null)&&(Vp(e,0),pl(e,kt,Qr,!1)),Zy(e,n),(!(Lt&2)||e!==sn)&&(e===sn&&(!(Lt&2)&&(pc|=n),Dn===4&&pl(e,kt,Qr,!1)),Wi(e))}function GL(e,t,n){if(Lt&6)throw Error(pe(327));var a=!n&&(t&127)===0&&(t&e.expiredLanes)===0||Yy(e,t),r=a?Lq(e,t):pS(e,t,!0),s=a;do{if(r===0){vf&&!a&&pl(e,t,0,!1);break}else{if(n=e.current.alternate,s&&!Oq(n)){r=pS(e,t,!1),s=!1;continue}if(r===2){if(s=t,e.errorRecoveryDisabledLanes&s)var i=0;else i=e.pendingLanes&-536870913,i=i!==0?i:i&536870912?536870912:0;if(i!==0){t=i;e:{var o=e;r=Kg;var l=o.current.memoizedState.isDehydrated;if(l&&(Vp(o,i).flags|=256),i=pS(o,i,!1),i!==2){if(f2&&!l){o.errorRecoveryDisabledLanes|=s,pc|=s,r=4;break e}s=Er,Er=r,s!==null&&(Er===null?Er=s:Er.push.apply(Er,s))}r=i}if(s=!1,r!==2)continue}}if(r===1){Vp(e,0),pl(e,t,0,!0);break}e:{switch(a=e,s=r,s){case 0:case 1:throw Error(pe(345));case 4:if((t&4194048)!==t)break;case 6:pl(a,t,Qr,!dl);break e;case 2:Er=null;break;case 3:case 5:break;default:throw Error(pe(329))}if((t&62914560)===t&&(r=$w+300-ns(),10<r)){if(pl(a,t,Qr,!dl),_w(a,0,!0)!==0)break e;yo=t,a.timeoutHandle=hz(qD.bind(null,a,n,Er,m0,$I,t,Qr,pc,zp,dl,s,"Throttled",-0,0),r);break e}qD(a,n,Er,m0,$I,t,Qr,pc,zp,dl,s,null,-0,0)}}break}while(!0);Wi(e)}function qD(e,t,n,a,r,s,i,o,l,c,u,h,d,p){if(e.timeoutHandle=-1,h=t.subtreeFlags,h&8192||(h&16785408)===16785408){h={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:po},zL(t,s,h);var f=(s&62914560)===s?$w-ns():(s&4194048)===s?UL-ns():0;if(f=v7(h,f),f!==null){yo=s,e.cancelPendingCommit=f(XD.bind(null,e,t,s,n,a,r,i,o,l,u,h,null,d,p)),pl(e,s,i,!c);return}}XD(e,t,s,n,a,r,i,o,l)}function Oq(e){for(var t=e;;){var n=t.tag;if((n===0||n===11||n===15)&&t.flags&16384&&(n=t.updateQueue,n!==null&&(n=n.stores,n!==null)))for(var a=0;a<n.length;a++){var r=n[a],s=r.getSnapshot;r=r.value;try{if(!os(s(),r))return!1}catch{return!1}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function pl(e,t,n,a){t&=~m2,t&=~pc,e.suspendedLanes|=t,e.pingedLanes&=~t,a&&(e.warmLanes|=t),a=e.expirationTimes;for(var r=t;0<r;){var s=31-rs(r),i=1<<s;a[s]=-1,r&=~i}n!==0&&XF(e,n,t)}function Mw(){return Lt&6?!0:(rb(0),!1)}function g2(){if(wt!==null){if(Ht===0)var e=wt.return;else e=wt,fo=Qc=null,t2(e),wp=null,py=0,e=wt;for(;e!==null;)IL(e.alternate,e),e=e.return;wt=null}}function Vp(e,t){var n=e.timeoutHandle;n!==-1&&(e.timeoutHandle=-1,t7(n)),n=e.cancelPendingCommit,n!==null&&(e.cancelPendingCommit=null,n()),yo=0,g2(),sn=e,wt=n=mo(e.current,null),kt=t,Ht=0,qr=null,dl=!1,vf=Yy(e,t),f2=!1,zp=Qr=m2=pc=Pl=Dn=0,Er=Kg=null,$I=!1,t&8&&(t|=t&32);var a=e.entangledLanes;if(a!==0)for(e=e.entanglements,a&=t;0<a;){var r=31-rs(a),s=1<<r;t|=e[r],a&=~s}return To=t,Tw(),n}function HL(e,t){dt=null,Qe.H=my,t===bf||t===Nw?(t=kD(),Ht=3):t===KT?(t=kD(),Ht=4):Ht=t===c2?8:t!==null&&typeof t=="object"&&typeof t.then=="function"?6:1,qr=t,wt===null&&(Dn=1,h0(e,Ts(t,e.current)))}function qL(){var e=ls.current;return e===null?!0:(kt&4194048)===kt?Cs===null:(kt&62914560)===kt||kt&536870912?e===Cs:!1}function KL(){var e=Qe.H;return Qe.H=my,e===null?my:e}function XL(){var e=Qe.A;return Qe.A=$q,e}function g0(){Dn=4,dl||(kt&4194048)!==kt&&ls.current!==null||(vf=!0),!(Pl&134217727)&&!(pc&134217727)||sn===null||pl(sn,kt,Qr,!1)}function pS(e,t,n){var a=Lt;Lt|=2;var r=KL(),s=XL();(sn!==e||kt!==t)&&(m0=null,Vp(e,t)),t=!1;var i=Dn;e:do try{if(Ht!==0&&wt!==null){var o=wt,l=qr;switch(Ht){case 8:g2(),i=6;break e;case 3:case 2:case 9:case 6:ls.current===null&&(t=!0);var c=Ht;if(Ht=0,qr=null,mp(e,o,l,c),n&&vf){i=0;break e}break;default:c=Ht,Ht=0,qr=null,mp(e,o,l,c)}}Fq(),i=Dn;break}catch(u){HL(e,u)}while(!0);return t&&e.shellSuspendCounter++,fo=Qc=null,Lt=a,Qe.H=r,Qe.A=s,wt===null&&(sn=null,kt=0,Tw()),i}function Fq(){for(;wt!==null;)QL(wt)}function Lq(e,t){var n=Lt;Lt|=2;var a=KL(),r=XL();sn!==e||kt!==t?(m0=null,f0=ns()+500,Vp(e,t)):vf=Yy(e,t);e:do try{if(Ht!==0&&wt!==null){t=wt;var s=qr;t:switch(Ht){case 1:Ht=0,qr=null,mp(e,t,s,1);break;case 2:case 9:if(ID(s)){Ht=0,qr=null,KD(t);break}t=function(){Ht!==2&&Ht!==9||sn!==e||(Ht=7),Wi(e)},s.then(t,t);break e;case 3:Ht=7;break e;case 4:Ht=5;break e;case 7:ID(s)?(Ht=0,qr=null,KD(t)):(Ht=0,qr=null,mp(e,t,s,7));break;case 5:var i=null;switch(wt.tag){case 26:i=wt.memoizedState;case 5:case 27:var o=wt;if(i?gz(i):o.stateNode.complete){Ht=0,qr=null;var l=o.sibling;if(l!==null)wt=l;else{var c=o.return;c!==null?(wt=c,Ow(c)):wt=null}break t}}Ht=0,qr=null,mp(e,t,s,5);break;case 6:Ht=0,qr=null,mp(e,t,s,6);break;case 8:g2(),Dn=6;break e;default:throw Error(pe(462))}}zq();break}catch(u){HL(e,u)}while(!0);return fo=Qc=null,Qe.H=a,Qe.A=r,Lt=n,wt!==null?0:(sn=null,kt=0,Tw(),Dn)}function zq(){for(;wt!==null&&!o9();)QL(wt)}function QL(e){var t=SL(e.alternate,e,To);e.memoizedProps=e.pendingProps,t===null?Ow(e):wt=t}function KD(e){var t=e,n=t.alternate;switch(t.tag){case 15:case 0:t=BD(n,t,t.pendingProps,t.type,void 0,kt);break;case 11:t=BD(n,t,t.pendingProps,t.type.render,t.ref,kt);break;case 5:t2(t);default:IL(n,t),t=wt=I3(t,To),t=SL(n,t,To)}e.memoizedProps=e.pendingProps,t===null?Ow(e):wt=t}function mp(e,t,n,a){fo=Qc=null,t2(t),wp=null,py=0;var r=t.return;try{if(Tq(e,r,t,n,kt)){Dn=1,h0(e,Ts(n,e.current)),wt=null;return}}catch(s){if(r!==null)throw wt=r,s;Dn=1,h0(e,Ts(n,e.current)),wt=null;return}t.flags&32768?(Nt||a===1?e=!0:vf||kt&536870912?e=!1:(dl=e=!0,(a===2||a===9||a===3||a===6)&&(a=ls.current,a!==null&&a.tag===13&&(a.flags|=16384))),YL(t,e)):Ow(t)}function Ow(e){var t=e;do{if(t.flags&32768){YL(t,dl);return}e=t.return;var n=Cq(t.alternate,t,To);if(n!==null){wt=n;return}if(t=t.sibling,t!==null){wt=t;return}wt=t=e}while(t!==null);Dn===0&&(Dn=5)}function YL(e,t){do{var n=Aq(e.alternate,e);if(n!==null){n.flags&=32767,wt=n;return}if(n=e.return,n!==null&&(n.flags|=32768,n.subtreeFlags=0,n.deletions=null),!t&&(e=e.sibling,e!==null)){wt=e;return}wt=e=n}while(e!==null);Dn=6,wt=null}function XD(e,t,n,a,r,s,i,o,l){e.cancelPendingCommit=null;do Fw();while(fa!==0);if(Lt&6)throw Error(pe(327));if(t!==null){if(t===e.current)throw Error(pe(177));if(s=t.lanes|t.childLanes,s|=BT,y9(e,n,s,i,o,l),e===sn&&(wt=sn=null,kt=0),Pp=t,kl=e,yo=n,MI=s,OI=r,WL=a,t.subtreeFlags&10256||t.flags&10256?(e.callbackNode=null,e.callbackPriority=0,Uq(e0,function(){return nz(),null})):(e.callbackNode=null,e.callbackPriority=0),a=(t.flags&13878)!==0,t.subtreeFlags&13878||a){a=Qe.T,Qe.T=null,r=zt.p,zt.p=2,i=Lt,Lt|=4;try{Rq(e,t,n)}finally{Lt=i,zt.p=r,Qe.T=a}}fa=1,ZL(),JL(),ez()}}function ZL(){if(fa===1){fa=0;var e=kl,t=Pp,n=(t.flags&13878)!==0;if(t.subtreeFlags&13878||n){n=Qe.T,Qe.T=null;var a=zt.p;zt.p=2;var r=Lt;Lt|=4;try{OL(t,e);var s=VI,i=g3(e.containerInfo),o=s.focusedElem,l=s.selectionRange;if(i!==o&&o&&o.ownerDocument&&m3(o.ownerDocument.documentElement,o)){if(l!==null&&VT(o)){var c=l.start,u=l.end;if(u===void 0&&(u=c),"selectionStart"in o)o.selectionStart=c,o.selectionEnd=Math.min(u,o.value.length);else{var h=o.ownerDocument||document,d=h&&h.defaultView||window;if(d.getSelection){var p=d.getSelection(),f=o.textContent.length,m=Math.min(l.start,f),g=l.end===void 0?m:Math.min(l.end,f);!p.extend&&m>g&&(i=g,g=m,m=i);var y=yD(o,m),v=yD(o,g);if(y&&v&&(p.rangeCount!==1||p.anchorNode!==y.node||p.anchorOffset!==y.offset||p.focusNode!==v.node||p.focusOffset!==v.offset)){var x=h.createRange();x.setStart(y.node,y.offset),p.removeAllRanges(),m>g?(p.addRange(x),p.extend(v.node,v.offset)):(x.setEnd(v.node,v.offset),p.addRange(x))}}}}for(h=[],p=o;p=p.parentNode;)p.nodeType===1&&h.push({element:p,left:p.scrollLeft,top:p.scrollTop});for(typeof o.focus=="function"&&o.focus(),o=0;o<h.length;o++){var w=h[o];w.element.scrollLeft=w.left,w.element.scrollTop=w.top}}I0=!!PI,VI=PI=null}finally{Lt=r,zt.p=a,Qe.T=n}}e.current=t,fa=2}}function JL(){if(fa===2){fa=0;var e=kl,t=Pp,n=(t.flags&8772)!==0;if(t.subtreeFlags&8772||n){n=Qe.T,Qe.T=null;var a=zt.p;zt.p=2;var r=Lt;Lt|=4;try{AL(e,t.alternate,t)}finally{Lt=r,zt.p=a,Qe.T=n}}fa=3}}function ez(){if(fa===4||fa===3){fa=0,l9();var e=kl,t=Pp,n=yo,a=WL;t.subtreeFlags&10256||t.flags&10256?fa=5:(fa=0,Pp=kl=null,tz(e,e.pendingLanes));var r=e.pendingLanes;if(r===0&&(Il=null),$T(n),t=t.stateNode,as&&typeof as.onCommitFiberRoot=="function")try{as.onCommitFiberRoot(Qy,t,void 0,(t.current.flags&128)===128)}catch{}if(a!==null){t=Qe.T,r=zt.p,zt.p=2,Qe.T=null;try{for(var s=e.onRecoverableError,i=0;i<a.length;i++){var o=a[i];s(o.value,{componentStack:o.stack})}}finally{Qe.T=t,zt.p=r}}yo&3&&Fw(),Wi(e),r=e.pendingLanes,n&261930&&r&42?e===FI?Xg++:(Xg=0,FI=e):Xg=0,rb(0)}}function tz(e,t){(e.pooledCacheLanes&=t)===0&&(t=e.pooledCache,t!=null&&(e.pooledCache=null,tb(t)))}function Fw(){return ZL(),JL(),ez(),nz()}function nz(){if(fa!==5)return!1;var e=kl,t=MI;MI=0;var n=$T(yo),a=Qe.T,r=zt.p;try{zt.p=32>n?32:n,Qe.T=null,n=OI,OI=null;var s=kl,i=yo;if(fa=0,Pp=kl=null,yo=0,Lt&6)throw Error(pe(331));var o=Lt;if(Lt|=4,VL(s.current),LL(s,s.current,i,n),Lt=o,rb(0,!1),as&&typeof as.onPostCommitFiberRoot=="function")try{as.onPostCommitFiberRoot(Qy,s)}catch{}return!0}finally{zt.p=r,Qe.T=a,tz(e,t)}}function QD(e,t,n){t=Ts(n,t),t=CI(e.stateNode,t,2),e=Sl(e,t,2),e!==null&&(Zy(e,2),Wi(e))}function qt(e,t,n){if(e.tag===3)QD(e,e,n);else for(;t!==null;){if(t.tag===3){QD(t,e,n);break}else if(t.tag===1){var a=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof a.componentDidCatch=="function"&&(Il===null||!Il.has(a))){e=Ts(n,e),n=yL(2),a=Sl(t,n,2),a!==null&&(bL(n,a,t,e),Zy(a,2),Wi(a));break}}t=t.return}}function fS(e,t,n){var a=e.pingCache;if(a===null){a=e.pingCache=new Mq;var r=new Set;a.set(t,r)}else r=a.get(t),r===void 0&&(r=new Set,a.set(t,r));r.has(n)||(f2=!0,r.add(n),e=Pq.bind(null,e,t,n),t.then(e,e))}function Pq(e,t,n){var a=e.pingCache;a!==null&&a.delete(t),e.pingedLanes|=e.suspendedLanes&n,e.warmLanes&=~n,sn===e&&(kt&n)===n&&(Dn===4||Dn===3&&(kt&62914560)===kt&&300>ns()-$w?!(Lt&2)&&Vp(e,0):m2|=n,zp===kt&&(zp=0)),Wi(e)}function az(e,t){t===0&&(t=KF()),e=Xc(e,t),e!==null&&(Zy(e,t),Wi(e))}function Vq(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),az(e,n)}function Bq(e,t){var n=0;switch(e.tag){case 31:case 13:var a=e.stateNode,r=e.memoizedState;r!==null&&(n=r.retryLane);break;case 19:a=e.stateNode;break;case 22:a=e.stateNode._retryCache;break;default:throw Error(pe(314))}a!==null&&a.delete(t),az(e,n)}function Uq(e,t){return RT(e,t)}var y0=null,Qd=null,LI=!1,b0=!1,mS=!1,fl=0;function Wi(e){e!==Qd&&e.next===null&&(Qd===null?y0=Qd=e:Qd=Qd.next=e),b0=!0,LI||(LI=!0,jq())}function rb(e,t){if(!mS&&b0){mS=!0;do for(var n=!1,a=y0;a!==null;){if(e!==0){var r=a.pendingLanes;if(r===0)var s=0;else{var i=a.suspendedLanes,o=a.pingedLanes;s=(1<<31-rs(42|e)+1)-1,s&=r&~(i&~o),s=s&201326741?s&201326741|1:s?s|2:0}s!==0&&(n=!0,YD(a,s))}else s=kt,s=_w(a,a===sn?s:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),!(s&3)||Yy(a,s)||(n=!0,YD(a,s));a=a.next}while(n);mS=!1}}function Wq(){rz()}function rz(){b0=LI=!1;var e=0;fl!==0&&e7()&&(e=fl);for(var t=ns(),n=null,a=y0;a!==null;){var r=a.next,s=sz(a,t);s===0?(a.next=null,n===null?y0=r:n.next=r,r===null&&(Qd=n)):(n=a,(e!==0||s&3)&&(b0=!0)),a=r}fa!==0&&fa!==5||rb(e),fl!==0&&(fl=0)}function sz(e,t){for(var n=e.suspendedLanes,a=e.pingedLanes,r=e.expirationTimes,s=e.pendingLanes&-62914561;0<s;){var i=31-rs(s),o=1<<i,l=r[i];l===-1?(!(o&n)||o&a)&&(r[i]=g9(o,t)):l<=t&&(e.expiredLanes|=o),s&=~o}if(t=sn,n=kt,n=_w(e,e===t?n:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),a=e.callbackNode,n===0||e===t&&(Ht===2||Ht===9)||e.cancelPendingCommit!==null)return a!==null&&a!==null&&W_(a),e.callbackNode=null,e.callbackPriority=0;if(!(n&3)||Yy(e,n)){if(t=n&-n,t===e.callbackPriority)return t;switch(a!==null&&W_(a),$T(n)){case 2:case 8:n=HF;break;case 32:n=e0;break;case 268435456:n=qF;break;default:n=e0}return a=iz.bind(null,e),n=RT(n,a),e.callbackPriority=t,e.callbackNode=n,t}return a!==null&&a!==null&&W_(a),e.callbackPriority=2,e.callbackNode=null,2}function iz(e,t){if(fa!==0&&fa!==5)return e.callbackNode=null,e.callbackPriority=0,null;var n=e.callbackNode;if(Fw()&&e.callbackNode!==n)return null;var a=kt;return a=_w(e,e===sn?a:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),a===0?null:(GL(e,a,t),sz(e,ns()),e.callbackNode!=null&&e.callbackNode===n?iz.bind(null,e):null)}function YD(e,t){if(Fw())return null;GL(e,t,!0)}function jq(){n7(function(){Lt&6?RT(GF,Wq):rz()})}function y2(){if(fl===0){var e=Op;e===0&&(e=Lv,Lv<<=1,!(Lv&261888)&&(Lv=256)),fl=e}return fl}function ZD(e){return e==null||typeof e=="symbol"||typeof e=="boolean"?null:typeof e=="function"?e:_x(""+e)}function JD(e,t){var n=t.ownerDocument.createElement("input");return n.name=t.name,n.value=t.value,e.id&&n.setAttribute("form",e.id),t.parentNode.insertBefore(n,t),e=new FormData(e),n.parentNode.removeChild(n),e}function Gq(e,t,n,a,r){if(t==="submit"&&n&&n.stateNode===r){var s=ZD((r[Fr]||null).action),i=a.submitter;i&&(t=(t=i[Fr]||null)?ZD(t.formAction):i.getAttribute("formAction"),t!==null&&(s=t,i=null));var o=new Sw("action","action",null,a,r);e.push({event:o,listeners:[{instance:null,listener:function(){if(a.defaultPrevented){if(fl!==0){var l=i?JD(r,i):new FormData(r);EI(n,{pending:!0,data:l,method:r.method,action:s},null,l)}}else typeof s=="function"&&(o.preventDefault(),l=i?JD(r,i):new FormData(r),EI(n,{pending:!0,data:l,method:r.method,action:s},s,l))},currentTarget:r}]})}}for(var gS=0;gS<mI.length;gS++){var yS=mI[gS],Hq=yS.toLowerCase(),qq=yS[0].toUpperCase()+yS.slice(1);ai(Hq,"on"+qq)}ai(b3,"onAnimationEnd");ai(v3,"onAnimationIteration");ai(x3,"onAnimationStart");ai("dblclick","onDoubleClick");ai("focusin","onFocus");ai("focusout","onBlur");ai(uq,"onTransitionRun");ai(cq,"onTransitionStart");ai(hq,"onTransitionCancel");ai(w3,"onTransitionEnd");$p("onMouseEnter",["mouseout","mouseover"]);$p("onMouseLeave",["mouseout","mouseover"]);$p("onPointerEnter",["pointerout","pointerover"]);$p("onPointerLeave",["pointerout","pointerover"]);Hc("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Hc("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Hc("onBeforeInput",["compositionend","keypress","textInput","paste"]);Hc("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Hc("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Hc("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var gy="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Kq=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(gy));function oz(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var a=e[n],r=a.event;a=a.listeners;e:{var s=void 0;if(t)for(var i=a.length-1;0<=i;i--){var o=a[i],l=o.instance,c=o.currentTarget;if(o=o.listener,l!==s&&r.isPropagationStopped())break e;s=o,r.currentTarget=c;try{s(r)}catch(u){n0(u)}r.currentTarget=null,s=l}else for(i=0;i<a.length;i++){if(o=a[i],l=o.instance,c=o.currentTarget,o=o.listener,l!==s&&r.isPropagationStopped())break e;s=o,r.currentTarget=c;try{s(r)}catch(u){n0(u)}r.currentTarget=null,s=l}}}}function xt(e,t){var n=t[oI];n===void 0&&(n=t[oI]=new Set);var a=e+"__bubble";n.has(a)||(lz(t,e,2,!1),n.add(a))}function bS(e,t,n){var a=0;t&&(a|=4),lz(n,e,a,t)}var qv="_reactListening"+Math.random().toString(36).slice(2);function b2(e){if(!e[qv]){e[qv]=!0,JF.forEach(function(n){n!=="selectionchange"&&(Kq.has(n)||bS(n,!1,e),bS(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[qv]||(t[qv]=!0,bS("selectionchange",!1,t))}}function lz(e,t,n,a){switch(wz(t)){case 2:var r=_7;break;case 8:r=S7;break;default:r=_2}n=r.bind(null,t,n,e),r=void 0,!dI||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(r=!0),a?r!==void 0?e.addEventListener(t,n,{capture:!0,passive:r}):e.addEventListener(t,n,!0):r!==void 0?e.addEventListener(t,n,{passive:r}):e.addEventListener(t,n,!1)}function vS(e,t,n,a,r){var s=a;if(!(t&1)&&!(t&2)&&a!==null)e:for(;;){if(a===null)return;var i=a.tag;if(i===3||i===4){var o=a.stateNode.containerInfo;if(o===r)break;if(i===4)for(i=a.return;i!==null;){var l=i.tag;if((l===3||l===4)&&i.stateNode.containerInfo===r)return;i=i.return}for(;o!==null;){if(i=ip(o),i===null)return;if(l=i.tag,l===5||l===6||l===26||l===27){a=s=i;continue e}o=o.parentNode}}a=a.return}o3(function(){var c=s,u=FT(n),h=[];e:{var d=_3.get(e);if(d!==void 0){var p=Sw,f=e;switch(e){case"keypress":if(Ix(n)===0)break e;case"keydown":case"keyup":p=B9;break;case"focusin":f="focus",p=K_;break;case"focusout":f="blur",p=K_;break;case"beforeblur":case"afterblur":p=K_;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":p=oD;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":p=C9;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":p=j9;break;case b3:case v3:case x3:p=D9;break;case w3:p=H9;break;case"scroll":case"scrollend":p=E9;break;case"wheel":p=K9;break;case"copy":case"cut":case"paste":p=M9;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":p=uD;break;case"toggle":case"beforetoggle":p=Q9}var m=(t&4)!==0,g=!m&&(e==="scroll"||e==="scrollend"),y=m?d!==null?d+"Capture":null:d;m=[];for(var v=c,x;v!==null;){var w=v;if(x=w.stateNode,w=w.tag,w!==5&&w!==26&&w!==27||x===null||y===null||(w=ly(v,y),w!=null&&m.push(yy(v,w,x))),g)break;v=v.return}0<m.length&&(d=new p(d,f,null,n,u),h.push({event:d,listeners:m}))}}if(!(t&7)){e:{if(d=e==="mouseover"||e==="pointerover",p=e==="mouseout"||e==="pointerout",d&&n!==hI&&(f=n.relatedTarget||n.fromElement)&&(ip(f)||f[mf]))break e;if((p||d)&&(d=u.window===u?u:(d=u.ownerDocument)?d.defaultView||d.parentWindow:window,p?(f=n.relatedTarget||n.toElement,p=c,f=f?ip(f):null,f!==null&&(g=Xy(f),m=f.tag,f!==g||m!==5&&m!==27&&m!==6)&&(f=null)):(p=null,f=c),p!==f)){if(m=oD,w="onMouseLeave",y="onMouseEnter",v="mouse",(e==="pointerout"||e==="pointerover")&&(m=uD,w="onPointerLeave",y="onPointerEnter",v="pointer"),g=p==null?d:xg(p),x=f==null?d:xg(f),d=new m(w,v+"leave",p,n,u),d.target=g,d.relatedTarget=x,w=null,ip(u)===c&&(m=new m(y,v+"enter",f,n,u),m.target=x,m.relatedTarget=g,w=m),g=w,p&&f)t:{for(m=Xq,y=p,v=f,x=0,w=y;w;w=m(w))x++;w=0;for(var k=v;k;k=m(k))w++;for(;0<x-w;)y=m(y),x--;for(;0<w-x;)v=m(v),w--;for(;x--;){if(y===v||v!==null&&y===v.alternate){m=y;break t}y=m(y),v=m(v)}m=null}else m=null;p!==null&&e$(h,d,p,m,!1),f!==null&&g!==null&&e$(h,g,f,m,!0)}}e:{if(d=c?xg(c):window,p=d.nodeName&&d.nodeName.toLowerCase(),p==="select"||p==="input"&&d.type==="file")var M=pD;else if(dD(d))if(p3)M=iq;else{M=rq;var S=aq}else p=d.nodeName,!p||p.toLowerCase()!=="input"||d.type!=="checkbox"&&d.type!=="radio"?c&&OT(c.elementType)&&(M=pD):M=sq;if(M&&(M=M(e,c))){d3(h,M,n,u);break e}S&&S(e,d,c),e==="focusout"&&c&&d.type==="number"&&c.memoizedProps.value!=null&&cI(d,"number",d.value)}switch(S=c?xg(c):window,e){case"focusin":(dD(S)||S.contentEditable==="true")&&(up=S,pI=c,Vg=null);break;case"focusout":Vg=pI=up=null;break;case"mousedown":fI=!0;break;case"contextmenu":case"mouseup":case"dragend":fI=!1,bD(h,n,u);break;case"selectionchange":if(lq)break;case"keydown":case"keyup":bD(h,n,u)}var I;if(PT)e:{switch(e){case"compositionstart":var E="onCompositionStart";break e;case"compositionend":E="onCompositionEnd";break e;case"compositionupdate":E="onCompositionUpdate";break e}E=void 0}else lp?c3(e,n)&&(E="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(E="onCompositionStart");E&&(u3&&n.locale!=="ko"&&(lp||E!=="onCompositionStart"?E==="onCompositionEnd"&&lp&&(I=l3()):(hl=u,LT="value"in hl?hl.value:hl.textContent,lp=!0)),S=v0(c,E),0<S.length&&(E=new lD(E,e,null,n,u),h.push({event:E,listeners:S}),I?E.data=I:(I=h3(n),I!==null&&(E.data=I)))),(I=Z9?J9(e,n):eq(e,n))&&(E=v0(c,"onBeforeInput"),0<E.length&&(S=new lD("onBeforeInput","beforeinput",null,n,u),h.push({event:S,listeners:E}),S.data=I)),Gq(h,e,c,n,u)}oz(h,t)})}function yy(e,t,n){return{instance:e,listener:t,currentTarget:n}}function v0(e,t){for(var n=t+"Capture",a=[];e!==null;){var r=e,s=r.stateNode;if(r=r.tag,r!==5&&r!==26&&r!==27||s===null||(r=ly(e,n),r!=null&&a.unshift(yy(e,r,s)),r=ly(e,t),r!=null&&a.push(yy(e,r,s))),e.tag===3)return a;e=e.return}return[]}function Xq(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5&&e.tag!==27);return e||null}function e$(e,t,n,a,r){for(var s=t._reactName,i=[];n!==null&&n!==a;){var o=n,l=o.alternate,c=o.stateNode;if(o=o.tag,l!==null&&l===a)break;o!==5&&o!==26&&o!==27||c===null||(l=c,r?(c=ly(n,s),c!=null&&i.unshift(yy(n,c,l))):r||(c=ly(n,s),c!=null&&i.push(yy(n,c,l)))),n=n.return}i.length!==0&&e.push({event:t,listeners:i})}var Qq=/\r\n?/g,Yq=/\u0000|\uFFFD/g;function t$(e){return(typeof e=="string"?e:""+e).replace(Qq,`
`).replace(Yq,"")}function uz(e,t){return t=t$(t),t$(e)===t}function en(e,t,n,a,r,s){switch(n){case"children":typeof a=="string"?t==="body"||t==="textarea"&&a===""||Mp(e,a):(typeof a=="number"||typeof a=="bigint")&&t!=="body"&&Mp(e,""+a);break;case"className":Vv(e,"class",a);break;case"tabIndex":Vv(e,"tabindex",a);break;case"dir":case"role":case"viewBox":case"width":case"height":Vv(e,n,a);break;case"style":i3(e,a,s);break;case"data":if(t!=="object"){Vv(e,"data",a);break}case"src":case"href":if(a===""&&(t!=="a"||n!=="href")){e.removeAttribute(n);break}if(a==null||typeof a=="function"||typeof a=="symbol"||typeof a=="boolean"){e.removeAttribute(n);break}a=_x(""+a),e.setAttribute(n,a);break;case"action":case"formAction":if(typeof a=="function"){e.setAttribute(n,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof s=="function"&&(n==="formAction"?(t!=="input"&&en(e,t,"name",r.name,r,null),en(e,t,"formEncType",r.formEncType,r,null),en(e,t,"formMethod",r.formMethod,r,null),en(e,t,"formTarget",r.formTarget,r,null)):(en(e,t,"encType",r.encType,r,null),en(e,t,"method",r.method,r,null),en(e,t,"target",r.target,r,null)));if(a==null||typeof a=="symbol"||typeof a=="boolean"){e.removeAttribute(n);break}a=_x(""+a),e.setAttribute(n,a);break;case"onClick":a!=null&&(e.onclick=po);break;case"onScroll":a!=null&&xt("scroll",e);break;case"onScrollEnd":a!=null&&xt("scrollend",e);break;case"dangerouslySetInnerHTML":if(a!=null){if(typeof a!="object"||!("__html"in a))throw Error(pe(61));if(n=a.__html,n!=null){if(r.children!=null)throw Error(pe(60));e.innerHTML=n}}break;case"multiple":e.multiple=a&&typeof a!="function"&&typeof a!="symbol";break;case"muted":e.muted=a&&typeof a!="function"&&typeof a!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(a==null||typeof a=="function"||typeof a=="boolean"||typeof a=="symbol"){e.removeAttribute("xlink:href");break}n=_x(""+a),e.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",n);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":a!=null&&typeof a!="function"&&typeof a!="symbol"?e.setAttribute(n,""+a):e.removeAttribute(n);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":a&&typeof a!="function"&&typeof a!="symbol"?e.setAttribute(n,""):e.removeAttribute(n);break;case"capture":case"download":a===!0?e.setAttribute(n,""):a!==!1&&a!=null&&typeof a!="function"&&typeof a!="symbol"?e.setAttribute(n,a):e.removeAttribute(n);break;case"cols":case"rows":case"size":case"span":a!=null&&typeof a!="function"&&typeof a!="symbol"&&!isNaN(a)&&1<=a?e.setAttribute(n,a):e.removeAttribute(n);break;case"rowSpan":case"start":a==null||typeof a=="function"||typeof a=="symbol"||isNaN(a)?e.removeAttribute(n):e.setAttribute(n,a);break;case"popover":xt("beforetoggle",e),xt("toggle",e),wx(e,"popover",a);break;case"xlinkActuate":Zi(e,"http://www.w3.org/1999/xlink","xlink:actuate",a);break;case"xlinkArcrole":Zi(e,"http://www.w3.org/1999/xlink","xlink:arcrole",a);break;case"xlinkRole":Zi(e,"http://www.w3.org/1999/xlink","xlink:role",a);break;case"xlinkShow":Zi(e,"http://www.w3.org/1999/xlink","xlink:show",a);break;case"xlinkTitle":Zi(e,"http://www.w3.org/1999/xlink","xlink:title",a);break;case"xlinkType":Zi(e,"http://www.w3.org/1999/xlink","xlink:type",a);break;case"xmlBase":Zi(e,"http://www.w3.org/XML/1998/namespace","xml:base",a);break;case"xmlLang":Zi(e,"http://www.w3.org/XML/1998/namespace","xml:lang",a);break;case"xmlSpace":Zi(e,"http://www.w3.org/XML/1998/namespace","xml:space",a);break;case"is":wx(e,"is",a);break;case"innerText":case"textContent":break;default:(!(2<n.length)||n[0]!=="o"&&n[0]!=="O"||n[1]!=="n"&&n[1]!=="N")&&(n=k9.get(n)||n,wx(e,n,a))}}function zI(e,t,n,a,r,s){switch(n){case"style":i3(e,a,s);break;case"dangerouslySetInnerHTML":if(a!=null){if(typeof a!="object"||!("__html"in a))throw Error(pe(61));if(n=a.__html,n!=null){if(r.children!=null)throw Error(pe(60));e.innerHTML=n}}break;case"children":typeof a=="string"?Mp(e,a):(typeof a=="number"||typeof a=="bigint")&&Mp(e,""+a);break;case"onScroll":a!=null&&xt("scroll",e);break;case"onScrollEnd":a!=null&&xt("scrollend",e);break;case"onClick":a!=null&&(e.onclick=po);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!e3.hasOwnProperty(n))e:{if(n[0]==="o"&&n[1]==="n"&&(r=n.endsWith("Capture"),t=n.slice(2,r?n.length-7:void 0),s=e[Fr]||null,s=s!=null?s[n]:null,typeof s=="function"&&e.removeEventListener(t,s,r),typeof a=="function")){typeof s!="function"&&s!==null&&(n in e?e[n]=null:e.hasAttribute(n)&&e.removeAttribute(n)),e.addEventListener(t,a,r);break e}n in e?e[n]=a:a===!0?e.setAttribute(n,""):wx(e,n,a)}}}function Pa(e,t,n){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":xt("error",e),xt("load",e);var a=!1,r=!1,s;for(s in n)if(n.hasOwnProperty(s)){var i=n[s];if(i!=null)switch(s){case"src":a=!0;break;case"srcSet":r=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(pe(137,t));default:en(e,t,s,i,n,null)}}r&&en(e,t,"srcSet",n.srcSet,n,null),a&&en(e,t,"src",n.src,n,null);return;case"input":xt("invalid",e);var o=s=i=r=null,l=null,c=null;for(a in n)if(n.hasOwnProperty(a)){var u=n[a];if(u!=null)switch(a){case"name":r=u;break;case"type":i=u;break;case"checked":l=u;break;case"defaultChecked":c=u;break;case"value":s=u;break;case"defaultValue":o=u;break;case"children":case"dangerouslySetInnerHTML":if(u!=null)throw Error(pe(137,t));break;default:en(e,t,a,u,n,null)}}a3(e,s,o,l,c,i,r,!1);return;case"select":xt("invalid",e),a=i=s=null;for(r in n)if(n.hasOwnProperty(r)&&(o=n[r],o!=null))switch(r){case"value":s=o;break;case"defaultValue":i=o;break;case"multiple":a=o;default:en(e,t,r,o,n,null)}t=s,n=i,e.multiple=!!a,t!=null?bp(e,!!a,t,!1):n!=null&&bp(e,!!a,n,!0);return;case"textarea":xt("invalid",e),s=r=a=null;for(i in n)if(n.hasOwnProperty(i)&&(o=n[i],o!=null))switch(i){case"value":a=o;break;case"defaultValue":r=o;break;case"children":s=o;break;case"dangerouslySetInnerHTML":if(o!=null)throw Error(pe(91));break;default:en(e,t,i,o,n,null)}s3(e,a,r,s);return;case"option":for(l in n)if(n.hasOwnProperty(l)&&(a=n[l],a!=null))switch(l){case"selected":e.selected=a&&typeof a!="function"&&typeof a!="symbol";break;default:en(e,t,l,a,n,null)}return;case"dialog":xt("beforetoggle",e),xt("toggle",e),xt("cancel",e),xt("close",e);break;case"iframe":case"object":xt("load",e);break;case"video":case"audio":for(a=0;a<gy.length;a++)xt(gy[a],e);break;case"image":xt("error",e),xt("load",e);break;case"details":xt("toggle",e);break;case"embed":case"source":case"link":xt("error",e),xt("load",e);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(c in n)if(n.hasOwnProperty(c)&&(a=n[c],a!=null))switch(c){case"children":case"dangerouslySetInnerHTML":throw Error(pe(137,t));default:en(e,t,c,a,n,null)}return;default:if(OT(t)){for(u in n)n.hasOwnProperty(u)&&(a=n[u],a!==void 0&&zI(e,t,u,a,n,void 0));return}}for(o in n)n.hasOwnProperty(o)&&(a=n[o],a!=null&&en(e,t,o,a,n,null))}function Zq(e,t,n,a){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var r=null,s=null,i=null,o=null,l=null,c=null,u=null;for(p in n){var h=n[p];if(n.hasOwnProperty(p)&&h!=null)switch(p){case"checked":break;case"value":break;case"defaultValue":l=h;default:a.hasOwnProperty(p)||en(e,t,p,null,a,h)}}for(var d in a){var p=a[d];if(h=n[d],a.hasOwnProperty(d)&&(p!=null||h!=null))switch(d){case"type":s=p;break;case"name":r=p;break;case"checked":c=p;break;case"defaultChecked":u=p;break;case"value":i=p;break;case"defaultValue":o=p;break;case"children":case"dangerouslySetInnerHTML":if(p!=null)throw Error(pe(137,t));break;default:p!==h&&en(e,t,d,p,a,h)}}uI(e,i,o,l,c,u,s,r);return;case"select":p=i=o=d=null;for(s in n)if(l=n[s],n.hasOwnProperty(s)&&l!=null)switch(s){case"value":break;case"multiple":p=l;default:a.hasOwnProperty(s)||en(e,t,s,null,a,l)}for(r in a)if(s=a[r],l=n[r],a.hasOwnProperty(r)&&(s!=null||l!=null))switch(r){case"value":d=s;break;case"defaultValue":o=s;break;case"multiple":i=s;default:s!==l&&en(e,t,r,s,a,l)}t=o,n=i,a=p,d!=null?bp(e,!!n,d,!1):!!a!=!!n&&(t!=null?bp(e,!!n,t,!0):bp(e,!!n,n?[]:"",!1));return;case"textarea":p=d=null;for(o in n)if(r=n[o],n.hasOwnProperty(o)&&r!=null&&!a.hasOwnProperty(o))switch(o){case"value":break;case"children":break;default:en(e,t,o,null,a,r)}for(i in a)if(r=a[i],s=n[i],a.hasOwnProperty(i)&&(r!=null||s!=null))switch(i){case"value":d=r;break;case"defaultValue":p=r;break;case"children":break;case"dangerouslySetInnerHTML":if(r!=null)throw Error(pe(91));break;default:r!==s&&en(e,t,i,r,a,s)}r3(e,d,p);return;case"option":for(var f in n)if(d=n[f],n.hasOwnProperty(f)&&d!=null&&!a.hasOwnProperty(f))switch(f){case"selected":e.selected=!1;break;default:en(e,t,f,null,a,d)}for(l in a)if(d=a[l],p=n[l],a.hasOwnProperty(l)&&d!==p&&(d!=null||p!=null))switch(l){case"selected":e.selected=d&&typeof d!="function"&&typeof d!="symbol";break;default:en(e,t,l,d,a,p)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var m in n)d=n[m],n.hasOwnProperty(m)&&d!=null&&!a.hasOwnProperty(m)&&en(e,t,m,null,a,d);for(c in a)if(d=a[c],p=n[c],a.hasOwnProperty(c)&&d!==p&&(d!=null||p!=null))switch(c){case"children":case"dangerouslySetInnerHTML":if(d!=null)throw Error(pe(137,t));break;default:en(e,t,c,d,a,p)}return;default:if(OT(t)){for(var g in n)d=n[g],n.hasOwnProperty(g)&&d!==void 0&&!a.hasOwnProperty(g)&&zI(e,t,g,void 0,a,d);for(u in a)d=a[u],p=n[u],!a.hasOwnProperty(u)||d===p||d===void 0&&p===void 0||zI(e,t,u,d,a,p);return}}for(var y in n)d=n[y],n.hasOwnProperty(y)&&d!=null&&!a.hasOwnProperty(y)&&en(e,t,y,null,a,d);for(h in a)d=a[h],p=n[h],!a.hasOwnProperty(h)||d===p||d==null&&p==null||en(e,t,h,d,a,p)}function n$(e){switch(e){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function Jq(){if(typeof performance.getEntriesByType=="function"){for(var e=0,t=0,n=performance.getEntriesByType("resource"),a=0;a<n.length;a++){var r=n[a],s=r.transferSize,i=r.initiatorType,o=r.duration;if(s&&o&&n$(i)){for(i=0,o=r.responseEnd,a+=1;a<n.length;a++){var l=n[a],c=l.startTime;if(c>o)break;var u=l.transferSize,h=l.initiatorType;u&&n$(h)&&(l=l.responseEnd,i+=u*(l<o?1:(o-c)/(l-c)))}if(--a,t+=8*(s+i)/(r.duration/1e3),e++,10<e)break}}if(0<e)return t/e/1e6}return navigator.connection&&(e=navigator.connection.downlink,typeof e=="number")?e:5}var PI=null,VI=null;function x0(e){return e.nodeType===9?e:e.ownerDocument}function a$(e){switch(e){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function cz(e,t){if(e===0)switch(t){case"svg":return 1;case"math":return 2;default:return 0}return e===1&&t==="foreignObject"?0:e}function BI(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.children=="bigint"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var xS=null;function e7(){var e=window.event;return e&&e.type==="popstate"?e===xS?!1:(xS=e,!0):(xS=null,!1)}var hz=typeof setTimeout=="function"?setTimeout:void 0,t7=typeof clearTimeout=="function"?clearTimeout:void 0,r$=typeof Promise=="function"?Promise:void 0,n7=typeof queueMicrotask=="function"?queueMicrotask:typeof r$<"u"?function(e){return r$.resolve(null).then(e).catch(a7)}:hz;function a7(e){setTimeout(function(){throw e})}function uu(e){return e==="head"}function s$(e,t){var n=t,a=0;do{var r=n.nextSibling;if(e.removeChild(n),r&&r.nodeType===8)if(n=r.data,n==="/$"||n==="/&"){if(a===0){e.removeChild(r),Up(t);return}a--}else if(n==="$"||n==="$?"||n==="$~"||n==="$!"||n==="&")a++;else if(n==="html")Qg(e.ownerDocument.documentElement);else if(n==="head"){n=e.ownerDocument.head,Qg(n);for(var s=n.firstChild;s;){var i=s.nextSibling,o=s.nodeName;s[Jy]||o==="SCRIPT"||o==="STYLE"||o==="LINK"&&s.rel.toLowerCase()==="stylesheet"||n.removeChild(s),s=i}}else n==="body"&&Qg(e.ownerDocument.body);n=r}while(n);Up(t)}function i$(e,t){var n=e;e=0;do{var a=n.nextSibling;if(n.nodeType===1?t?(n._stashedDisplay=n.style.display,n.style.display="none"):(n.style.display=n._stashedDisplay||"",n.getAttribute("style")===""&&n.removeAttribute("style")):n.nodeType===3&&(t?(n._stashedText=n.nodeValue,n.nodeValue=""):n.nodeValue=n._stashedText||""),a&&a.nodeType===8)if(n=a.data,n==="/$"){if(e===0)break;e--}else n!=="$"&&n!=="$?"&&n!=="$~"&&n!=="$!"||e++;n=a}while(n)}function UI(e){var t=e.firstChild;for(t&&t.nodeType===10&&(t=t.nextSibling);t;){var n=t;switch(t=t.nextSibling,n.nodeName){case"HTML":case"HEAD":case"BODY":UI(n),MT(n);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(n.rel.toLowerCase()==="stylesheet")continue}e.removeChild(n)}}function r7(e,t,n,a){for(;e.nodeType===1;){var r=n;if(e.nodeName.toLowerCase()!==t.toLowerCase()){if(!a&&(e.nodeName!=="INPUT"||e.type!=="hidden"))break}else if(a){if(!e[Jy])switch(t){case"meta":if(!e.hasAttribute("itemprop"))break;return e;case"link":if(s=e.getAttribute("rel"),s==="stylesheet"&&e.hasAttribute("data-precedence"))break;if(s!==r.rel||e.getAttribute("href")!==(r.href==null||r.href===""?null:r.href)||e.getAttribute("crossorigin")!==(r.crossOrigin==null?null:r.crossOrigin)||e.getAttribute("title")!==(r.title==null?null:r.title))break;return e;case"style":if(e.hasAttribute("data-precedence"))break;return e;case"script":if(s=e.getAttribute("src"),(s!==(r.src==null?null:r.src)||e.getAttribute("type")!==(r.type==null?null:r.type)||e.getAttribute("crossorigin")!==(r.crossOrigin==null?null:r.crossOrigin))&&s&&e.hasAttribute("async")&&!e.hasAttribute("itemprop"))break;return e;default:return e}}else if(t==="input"&&e.type==="hidden"){var s=r.name==null?null:""+r.name;if(r.type==="hidden"&&e.getAttribute("name")===s)return e}else return e;if(e=As(e.nextSibling),e===null)break}return null}function s7(e,t,n){if(t==="")return null;for(;e.nodeType!==3;)if((e.nodeType!==1||e.nodeName!=="INPUT"||e.type!=="hidden")&&!n||(e=As(e.nextSibling),e===null))return null;return e}function dz(e,t){for(;e.nodeType!==8;)if((e.nodeType!==1||e.nodeName!=="INPUT"||e.type!=="hidden")&&!t||(e=As(e.nextSibling),e===null))return null;return e}function WI(e){return e.data==="$?"||e.data==="$~"}function jI(e){return e.data==="$!"||e.data==="$?"&&e.ownerDocument.readyState!=="loading"}function i7(e,t){var n=e.ownerDocument;if(e.data==="$~")e._reactRetry=t;else if(e.data!=="$?"||n.readyState!=="loading")t();else{var a=function(){t(),n.removeEventListener("DOMContentLoaded",a)};n.addEventListener("DOMContentLoaded",a),e._reactRetry=a}}function As(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?"||t==="$~"||t==="&"||t==="F!"||t==="F")break;if(t==="/$"||t==="/&")return null}}return e}var GI=null;function o$(e){e=e.nextSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"||n==="/&"){if(t===0)return As(e.nextSibling);t--}else n!=="$"&&n!=="$!"&&n!=="$?"&&n!=="$~"&&n!=="&"||t++}e=e.nextSibling}return null}function l$(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"||n==="$~"||n==="&"){if(t===0)return e;t--}else n!=="/$"&&n!=="/&"||t++}e=e.previousSibling}return null}function pz(e,t,n){switch(t=x0(n),e){case"html":if(e=t.documentElement,!e)throw Error(pe(452));return e;case"head":if(e=t.head,!e)throw Error(pe(453));return e;case"body":if(e=t.body,!e)throw Error(pe(454));return e;default:throw Error(pe(451))}}function Qg(e){for(var t=e.attributes;t.length;)e.removeAttributeNode(t[0]);MT(e)}var $s=new Map,u$=new Set;function w0(e){return typeof e.getRootNode=="function"?e.getRootNode():e.nodeType===9?e:e.ownerDocument}var Do=zt.d;zt.d={f:o7,r:l7,D:u7,C:c7,L:h7,m:d7,X:f7,S:p7,M:m7};function o7(){var e=Do.f(),t=Mw();return e||t}function l7(e){var t=gf(e);t!==null&&t.tag===5&&t.type==="form"?iL(t):Do.r(e)}var xf=typeof document>"u"?null:document;function fz(e,t,n){var a=xf;if(a&&typeof t=="string"&&t){var r=ks(t);r='link[rel="'+e+'"][href="'+r+'"]',typeof n=="string"&&(r+='[crossorigin="'+n+'"]'),u$.has(r)||(u$.add(r),e={rel:e,crossOrigin:n,href:t},a.querySelector(r)===null&&(t=a.createElement("link"),Pa(t,"link",e),Ta(t),a.head.appendChild(t)))}}function u7(e){Do.D(e),fz("dns-prefetch",e,null)}function c7(e,t){Do.C(e,t),fz("preconnect",e,t)}function h7(e,t,n){Do.L(e,t,n);var a=xf;if(a&&e&&t){var r='link[rel="preload"][as="'+ks(t)+'"]';t==="image"&&n&&n.imageSrcSet?(r+='[imagesrcset="'+ks(n.imageSrcSet)+'"]',typeof n.imageSizes=="string"&&(r+='[imagesizes="'+ks(n.imageSizes)+'"]')):r+='[href="'+ks(e)+'"]';var s=r;switch(t){case"style":s=Bp(e);break;case"script":s=wf(e)}$s.has(s)||(e=bn({rel:"preload",href:t==="image"&&n&&n.imageSrcSet?void 0:e,as:t},n),$s.set(s,e),a.querySelector(r)!==null||t==="style"&&a.querySelector(sb(s))||t==="script"&&a.querySelector(ib(s))||(t=a.createElement("link"),Pa(t,"link",e),Ta(t),a.head.appendChild(t)))}}function d7(e,t){Do.m(e,t);var n=xf;if(n&&e){var a=t&&typeof t.as=="string"?t.as:"script",r='link[rel="modulepreload"][as="'+ks(a)+'"][href="'+ks(e)+'"]',s=r;switch(a){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":s=wf(e)}if(!$s.has(s)&&(e=bn({rel:"modulepreload",href:e},t),$s.set(s,e),n.querySelector(r)===null)){switch(a){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(n.querySelector(ib(s)))return}a=n.createElement("link"),Pa(a,"link",e),Ta(a),n.head.appendChild(a)}}}function p7(e,t,n){Do.S(e,t,n);var a=xf;if(a&&e){var r=yp(a).hoistableStyles,s=Bp(e);t=t||"default";var i=r.get(s);if(!i){var o={loading:0,preload:null};if(i=a.querySelector(sb(s)))o.loading=5;else{e=bn({rel:"stylesheet",href:e,"data-precedence":t},n),(n=$s.get(s))&&v2(e,n);var l=i=a.createElement("link");Ta(l),Pa(l,"link",e),l._p=new Promise(function(c,u){l.onload=c,l.onerror=u}),l.addEventListener("load",function(){o.loading|=1}),l.addEventListener("error",function(){o.loading|=2}),o.loading|=4,Dx(i,t,a)}i={type:"stylesheet",instance:i,count:1,state:o},r.set(s,i)}}}function f7(e,t){Do.X(e,t);var n=xf;if(n&&e){var a=yp(n).hoistableScripts,r=wf(e),s=a.get(r);s||(s=n.querySelector(ib(r)),s||(e=bn({src:e,async:!0},t),(t=$s.get(r))&&x2(e,t),s=n.createElement("script"),Ta(s),Pa(s,"link",e),n.head.appendChild(s)),s={type:"script",instance:s,count:1,state:null},a.set(r,s))}}function m7(e,t){Do.M(e,t);var n=xf;if(n&&e){var a=yp(n).hoistableScripts,r=wf(e),s=a.get(r);s||(s=n.querySelector(ib(r)),s||(e=bn({src:e,async:!0,type:"module"},t),(t=$s.get(r))&&x2(e,t),s=n.createElement("script"),Ta(s),Pa(s,"link",e),n.head.appendChild(s)),s={type:"script",instance:s,count:1,state:null},a.set(r,s))}}function c$(e,t,n,a){var r=(r=xl.current)?w0(r):null;if(!r)throw Error(pe(446));switch(e){case"meta":case"title":return null;case"style":return typeof n.precedence=="string"&&typeof n.href=="string"?(t=Bp(n.href),n=yp(r).hoistableStyles,a=n.get(t),a||(a={type:"style",instance:null,count:0,state:null},n.set(t,a)),a):{type:"void",instance:null,count:0,state:null};case"link":if(n.rel==="stylesheet"&&typeof n.href=="string"&&typeof n.precedence=="string"){e=Bp(n.href);var s=yp(r).hoistableStyles,i=s.get(e);if(i||(r=r.ownerDocument||r,i={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},s.set(e,i),(s=r.querySelector(sb(e)))&&!s._p&&(i.instance=s,i.state.loading=5),$s.has(e)||(n={rel:"preload",as:"style",href:n.href,crossOrigin:n.crossOrigin,integrity:n.integrity,media:n.media,hrefLang:n.hrefLang,referrerPolicy:n.referrerPolicy},$s.set(e,n),s||g7(r,e,n,i.state))),t&&a===null)throw Error(pe(528,""));return i}if(t&&a!==null)throw Error(pe(529,""));return null;case"script":return t=n.async,n=n.src,typeof n=="string"&&t&&typeof t!="function"&&typeof t!="symbol"?(t=wf(n),n=yp(r).hoistableScripts,a=n.get(t),a||(a={type:"script",instance:null,count:0,state:null},n.set(t,a)),a):{type:"void",instance:null,count:0,state:null};default:throw Error(pe(444,e))}}function Bp(e){return'href="'+ks(e)+'"'}function sb(e){return'link[rel="stylesheet"]['+e+"]"}function mz(e){return bn({},e,{"data-precedence":e.precedence,precedence:null})}function g7(e,t,n,a){e.querySelector('link[rel="preload"][as="style"]['+t+"]")?a.loading=1:(t=e.createElement("link"),a.preload=t,t.addEventListener("load",function(){return a.loading|=1}),t.addEventListener("error",function(){return a.loading|=2}),Pa(t,"link",n),Ta(t),e.head.appendChild(t))}function wf(e){return'[src="'+ks(e)+'"]'}function ib(e){return"script[async]"+e}function h$(e,t,n){if(t.count++,t.instance===null)switch(t.type){case"style":var a=e.querySelector('style[data-href~="'+ks(n.href)+'"]');if(a)return t.instance=a,Ta(a),a;var r=bn({},n,{"data-href":n.href,"data-precedence":n.precedence,href:null,precedence:null});return a=(e.ownerDocument||e).createElement("style"),Ta(a),Pa(a,"style",r),Dx(a,n.precedence,e),t.instance=a;case"stylesheet":r=Bp(n.href);var s=e.querySelector(sb(r));if(s)return t.state.loading|=4,t.instance=s,Ta(s),s;a=mz(n),(r=$s.get(r))&&v2(a,r),s=(e.ownerDocument||e).createElement("link"),Ta(s);var i=s;return i._p=new Promise(function(o,l){i.onload=o,i.onerror=l}),Pa(s,"link",a),t.state.loading|=4,Dx(s,n.precedence,e),t.instance=s;case"script":return s=wf(n.src),(r=e.querySelector(ib(s)))?(t.instance=r,Ta(r),r):(a=n,(r=$s.get(s))&&(a=bn({},n),x2(a,r)),e=e.ownerDocument||e,r=e.createElement("script"),Ta(r),Pa(r,"link",a),e.head.appendChild(r),t.instance=r);case"void":return null;default:throw Error(pe(443,t.type))}else t.type==="stylesheet"&&!(t.state.loading&4)&&(a=t.instance,t.state.loading|=4,Dx(a,n.precedence,e));return t.instance}function Dx(e,t,n){for(var a=n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),r=a.length?a[a.length-1]:null,s=r,i=0;i<a.length;i++){var o=a[i];if(o.dataset.precedence===t)s=o;else if(s!==r)break}s?s.parentNode.insertBefore(e,s.nextSibling):(t=n.nodeType===9?n.head:n,t.insertBefore(e,t.firstChild))}function v2(e,t){e.crossOrigin==null&&(e.crossOrigin=t.crossOrigin),e.referrerPolicy==null&&(e.referrerPolicy=t.referrerPolicy),e.title==null&&(e.title=t.title)}function x2(e,t){e.crossOrigin==null&&(e.crossOrigin=t.crossOrigin),e.referrerPolicy==null&&(e.referrerPolicy=t.referrerPolicy),e.integrity==null&&(e.integrity=t.integrity)}var $x=null;function d$(e,t,n){if($x===null){var a=new Map,r=$x=new Map;r.set(n,a)}else r=$x,a=r.get(n),a||(a=new Map,r.set(n,a));if(a.has(e))return a;for(a.set(e,null),n=n.getElementsByTagName(e),r=0;r<n.length;r++){var s=n[r];if(!(s[Jy]||s[Oa]||e==="link"&&s.getAttribute("rel")==="stylesheet")&&s.namespaceURI!=="http://www.w3.org/2000/svg"){var i=s.getAttribute(t)||"";i=e+i;var o=a.get(i);o?o.push(s):a.set(i,[s])}}return a}function p$(e,t,n){e=e.ownerDocument||e,e.head.insertBefore(n,t==="title"?e.querySelector("head > title"):null)}function y7(e,t,n){if(n===1||t.itemProp!=null)return!1;switch(e){case"meta":case"title":return!0;case"style":if(typeof t.precedence!="string"||typeof t.href!="string"||t.href==="")break;return!0;case"link":if(typeof t.rel!="string"||typeof t.href!="string"||t.href===""||t.onLoad||t.onError)break;switch(t.rel){case"stylesheet":return e=t.disabled,typeof t.precedence=="string"&&e==null;default:return!0}case"script":if(t.async&&typeof t.async!="function"&&typeof t.async!="symbol"&&!t.onLoad&&!t.onError&&t.src&&typeof t.src=="string")return!0}return!1}function gz(e){return!(e.type==="stylesheet"&&!(e.state.loading&3))}function b7(e,t,n,a){if(n.type==="stylesheet"&&(typeof a.media!="string"||matchMedia(a.media).matches!==!1)&&!(n.state.loading&4)){if(n.instance===null){var r=Bp(a.href),s=t.querySelector(sb(r));if(s){t=s._p,t!==null&&typeof t=="object"&&typeof t.then=="function"&&(e.count++,e=_0.bind(e),t.then(e,e)),n.state.loading|=4,n.instance=s,Ta(s);return}s=t.ownerDocument||t,a=mz(a),(r=$s.get(r))&&v2(a,r),s=s.createElement("link"),Ta(s);var i=s;i._p=new Promise(function(o,l){i.onload=o,i.onerror=l}),Pa(s,"link",a),n.instance=s}e.stylesheets===null&&(e.stylesheets=new Map),e.stylesheets.set(n,t),(t=n.state.preload)&&!(n.state.loading&3)&&(e.count++,n=_0.bind(e),t.addEventListener("load",n),t.addEventListener("error",n))}}var wS=0;function v7(e,t){return e.stylesheets&&e.count===0&&Mx(e,e.stylesheets),0<e.count||0<e.imgCount?function(n){var a=setTimeout(function(){if(e.stylesheets&&Mx(e,e.stylesheets),e.unsuspend){var s=e.unsuspend;e.unsuspend=null,s()}},6e4+t);0<e.imgBytes&&wS===0&&(wS=62500*Jq());var r=setTimeout(function(){if(e.waitingForImages=!1,e.count===0&&(e.stylesheets&&Mx(e,e.stylesheets),e.unsuspend)){var s=e.unsuspend;e.unsuspend=null,s()}},(e.imgBytes>wS?50:800)+t);return e.unsuspend=n,function(){e.unsuspend=null,clearTimeout(a),clearTimeout(r)}}:null}function _0(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)Mx(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}}var S0=null;function Mx(e,t){e.stylesheets=null,e.unsuspend!==null&&(e.count++,S0=new Map,t.forEach(x7,e),S0=null,_0.call(e))}function x7(e,t){if(!(t.state.loading&4)){var n=S0.get(e);if(n)var a=n.get(null);else{n=new Map,S0.set(e,n);for(var r=e.querySelectorAll("link[data-precedence],style[data-precedence]"),s=0;s<r.length;s++){var i=r[s];(i.nodeName==="LINK"||i.getAttribute("media")!=="not all")&&(n.set(i.dataset.precedence,i),a=i)}a&&n.set(null,a)}r=t.instance,i=r.getAttribute("data-precedence"),s=n.get(i)||a,s===a&&n.set(null,r),n.set(i,r),this.count++,a=_0.bind(this),r.addEventListener("load",a),r.addEventListener("error",a),s?s.parentNode.insertBefore(r,s.nextSibling):(e=e.nodeType===9?e.head:e,e.insertBefore(r,e.firstChild)),t.state.loading|=4}}var by={$$typeof:ho,Provider:null,Consumer:null,_currentValue:uc,_currentValue2:uc,_threadCount:0};function w7(e,t,n,a,r,s,i,o,l){this.tag=1,this.containerInfo=e,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=j_(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=j_(0),this.hiddenUpdates=j_(null),this.identifierPrefix=a,this.onUncaughtError=r,this.onCaughtError=s,this.onRecoverableError=i,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=l,this.incompleteTransitions=new Map}function yz(e,t,n,a,r,s,i,o,l,c,u,h){return e=new w7(e,t,n,i,l,c,u,h,o),t=1,s===!0&&(t|=24),s=Xr(3,null,null,t),e.current=s,s.stateNode=e,t=HT(),t.refCount++,e.pooledCache=t,t.refCount++,s.memoizedState={element:a,isDehydrated:n,cache:t},XT(s),e}function bz(e){return e?(e=dp,e):dp}function vz(e,t,n,a,r,s){r=bz(r),a.context===null?a.context=r:a.pendingContext=r,a=_l(t),a.payload={element:n},s=s===void 0?null:s,s!==null&&(a.callback=s),n=Sl(e,a,t),n!==null&&($r(n,e,t),Ug(n,e,t))}function f$(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function w2(e,t){f$(e,t),(e=e.alternate)&&f$(e,t)}function xz(e){if(e.tag===13||e.tag===31){var t=Xc(e,67108864);t!==null&&$r(t,e,67108864),w2(e,67108864)}}function m$(e){if(e.tag===13||e.tag===31){var t=ss();t=DT(t);var n=Xc(e,t);n!==null&&$r(n,e,t),w2(e,t)}}var I0=!0;function _7(e,t,n,a){var r=Qe.T;Qe.T=null;var s=zt.p;try{zt.p=2,_2(e,t,n,a)}finally{zt.p=s,Qe.T=r}}function S7(e,t,n,a){var r=Qe.T;Qe.T=null;var s=zt.p;try{zt.p=8,_2(e,t,n,a)}finally{zt.p=s,Qe.T=r}}function _2(e,t,n,a){if(I0){var r=HI(a);if(r===null)vS(e,t,a,k0,n),g$(e,a);else if(k7(r,e,t,n,a))a.stopPropagation();else if(g$(e,a),t&4&&-1<I7.indexOf(e)){for(;r!==null;){var s=gf(r);if(s!==null)switch(s.tag){case 3:if(s=s.stateNode,s.current.memoizedState.isDehydrated){var i=Ku(s.pendingLanes);if(i!==0){var o=s;for(o.pendingLanes|=2,o.entangledLanes|=2;i;){var l=1<<31-rs(i);o.entanglements[1]|=l,i&=~l}Wi(s),!(Lt&6)&&(f0=ns()+500,rb(0))}}break;case 31:case 13:o=Xc(s,2),o!==null&&$r(o,s,2),Mw(),w2(s,2)}if(s=HI(a),s===null&&vS(e,t,a,k0,n),s===r)break;r=s}r!==null&&a.stopPropagation()}else vS(e,t,a,null,n)}}function HI(e){return e=FT(e),S2(e)}var k0=null;function S2(e){if(k0=null,e=ip(e),e!==null){var t=Xy(e);if(t===null)e=null;else{var n=t.tag;if(n===13){if(e=VF(t),e!==null)return e;e=null}else if(n===31){if(e=BF(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null)}}return k0=e,null}function wz(e){switch(e){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(u9()){case GF:return 2;case HF:return 8;case e0:case c9:return 32;case qF:return 268435456;default:return 32}default:return 32}}var qI=!1,Tl=null,El=null,Nl=null,vy=new Map,xy=new Map,ll=[],I7="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function g$(e,t){switch(e){case"focusin":case"focusout":Tl=null;break;case"dragenter":case"dragleave":El=null;break;case"mouseover":case"mouseout":Nl=null;break;case"pointerover":case"pointerout":vy.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":xy.delete(t.pointerId)}}function dg(e,t,n,a,r,s){return e===null||e.nativeEvent!==s?(e={blockedOn:t,domEventName:n,eventSystemFlags:a,nativeEvent:s,targetContainers:[r]},t!==null&&(t=gf(t),t!==null&&xz(t)),e):(e.eventSystemFlags|=a,t=e.targetContainers,r!==null&&t.indexOf(r)===-1&&t.push(r),e)}function k7(e,t,n,a,r){switch(t){case"focusin":return Tl=dg(Tl,e,t,n,a,r),!0;case"dragenter":return El=dg(El,e,t,n,a,r),!0;case"mouseover":return Nl=dg(Nl,e,t,n,a,r),!0;case"pointerover":var s=r.pointerId;return vy.set(s,dg(vy.get(s)||null,e,t,n,a,r)),!0;case"gotpointercapture":return s=r.pointerId,xy.set(s,dg(xy.get(s)||null,e,t,n,a,r)),!0}return!1}function _z(e){var t=ip(e.target);if(t!==null){var n=Xy(t);if(n!==null){if(t=n.tag,t===13){if(t=VF(n),t!==null){e.blockedOn=t,eD(e.priority,function(){m$(n)});return}}else if(t===31){if(t=BF(n),t!==null){e.blockedOn=t,eD(e.priority,function(){m$(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Ox(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=HI(e.nativeEvent);if(n===null){n=e.nativeEvent;var a=new n.constructor(n.type,n);hI=a,n.target.dispatchEvent(a),hI=null}else return t=gf(n),t!==null&&xz(t),e.blockedOn=n,!1;t.shift()}return!0}function y$(e,t,n){Ox(e)&&n.delete(t)}function T7(){qI=!1,Tl!==null&&Ox(Tl)&&(Tl=null),El!==null&&Ox(El)&&(El=null),Nl!==null&&Ox(Nl)&&(Nl=null),vy.forEach(y$),xy.forEach(y$)}function Kv(e,t){e.blockedOn===t&&(e.blockedOn=null,qI||(qI=!0,ba.unstable_scheduleCallback(ba.unstable_NormalPriority,T7)))}var Xv=null;function b$(e){Xv!==e&&(Xv=e,ba.unstable_scheduleCallback(ba.unstable_NormalPriority,function(){Xv===e&&(Xv=null);for(var t=0;t<e.length;t+=3){var n=e[t],a=e[t+1],r=e[t+2];if(typeof a!="function"){if(S2(a||n)===null)continue;break}var s=gf(n);s!==null&&(e.splice(t,3),t-=3,EI(s,{pending:!0,data:r,method:n.method,action:a},a,r))}}))}function Up(e){function t(l){return Kv(l,e)}Tl!==null&&Kv(Tl,e),El!==null&&Kv(El,e),Nl!==null&&Kv(Nl,e),vy.forEach(t),xy.forEach(t);for(var n=0;n<ll.length;n++){var a=ll[n];a.blockedOn===e&&(a.blockedOn=null)}for(;0<ll.length&&(n=ll[0],n.blockedOn===null);)_z(n),n.blockedOn===null&&ll.shift();if(n=(e.ownerDocument||e).$$reactFormReplay,n!=null)for(a=0;a<n.length;a+=3){var r=n[a],s=n[a+1],i=r[Fr]||null;if(typeof s=="function")i||b$(n);else if(i){var o=null;if(s&&s.hasAttribute("formAction")){if(r=s,i=s[Fr]||null)o=i.formAction;else if(S2(r)!==null)continue}else o=i.action;typeof o=="function"?n[a+1]=o:(n.splice(a,3),a-=3),b$(n)}}}function Sz(){function e(s){s.canIntercept&&s.info==="react-transition"&&s.intercept({handler:function(){return new Promise(function(i){return r=i})},focusReset:"manual",scroll:"manual"})}function t(){r!==null&&(r(),r=null),a||setTimeout(n,20)}function n(){if(!a&&!navigation.transition){var s=navigation.currentEntry;s&&s.url!=null&&navigation.navigate(s.url,{state:s.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var a=!1,r=null;return navigation.addEventListener("navigate",e),navigation.addEventListener("navigatesuccess",t),navigation.addEventListener("navigateerror",t),setTimeout(n,100),function(){a=!0,navigation.removeEventListener("navigate",e),navigation.removeEventListener("navigatesuccess",t),navigation.removeEventListener("navigateerror",t),r!==null&&(r(),r=null)}}}function I2(e){this._internalRoot=e}Lw.prototype.render=I2.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(pe(409));var n=t.current,a=ss();vz(n,a,e,t,null,null)};Lw.prototype.unmount=I2.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;vz(e.current,2,null,e,null,null),Mw(),t[mf]=null}};function Lw(e){this._internalRoot=e}Lw.prototype.unstable_scheduleHydration=function(e){if(e){var t=ZF();e={blockedOn:null,target:e,priority:t};for(var n=0;n<ll.length&&t!==0&&t<ll[n].priority;n++);ll.splice(n,0,e),n===0&&_z(e)}};var v$=zF.version;if(v$!=="19.2.3")throw Error(pe(527,v$,"19.2.3"));zt.findDOMNode=function(e){var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(pe(188)):(e=Object.keys(e).join(","),Error(pe(268,e)));return e=n9(t),e=e!==null?UF(e):null,e=e===null?null:e.stateNode,e};var E7={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:Qe,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Qv=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Qv.isDisabled&&Qv.supportsFiber)try{Qy=Qv.inject(E7),as=Qv}catch{}}xw.createRoot=function(e,t){if(!PF(e))throw Error(pe(299));var n=!1,a="",r=fL,s=mL,i=gL;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(a=t.identifierPrefix),t.onUncaughtError!==void 0&&(r=t.onUncaughtError),t.onCaughtError!==void 0&&(s=t.onCaughtError),t.onRecoverableError!==void 0&&(i=t.onRecoverableError)),t=yz(e,1,!1,null,null,n,a,null,r,s,i,Sz),e[mf]=t.current,b2(e),new I2(t)};xw.hydrateRoot=function(e,t,n){if(!PF(e))throw Error(pe(299));var a=!1,r="",s=fL,i=mL,o=gL,l=null;return n!=null&&(n.unstable_strictMode===!0&&(a=!0),n.identifierPrefix!==void 0&&(r=n.identifierPrefix),n.onUncaughtError!==void 0&&(s=n.onUncaughtError),n.onCaughtError!==void 0&&(i=n.onCaughtError),n.onRecoverableError!==void 0&&(o=n.onRecoverableError),n.formState!==void 0&&(l=n.formState)),t=yz(e,1,!0,t,n??null,a,r,l,s,i,o,Sz),t.context=bz(null),n=t.current,a=ss(),a=DT(a),r=_l(a),r.callback=null,Sl(n,r,a),n=a,t.current.lanes=n,Zy(t,n),Wi(t),e[mf]=t.current,b2(e),new Lw(t)};xw.version="19.2.3";function Iz(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Iz)}catch(e){console.error(e)}}Iz(),DF.exports=xw;var N7=DF.exports;const C7=wF(N7);var ao=(e=>(e.USER_PANEL="user",e.ADMIN_PANEL="admin",e.LOGIN="login",e))(ao||{});const kz=({onCapture:e,label:t="Take Photo",autoCapture:n=!1})=>{const a=We.useRef(null),r=We.useRef(null),[s,i]=We.useState(null),[o,l]=We.useState(null),c=async()=>{try{const d=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user",width:640,height:480}});i(d),a.current&&(a.current.srcObject=d)}catch{l("Cannot access camera. Please allow camera permissions.")}},u=We.useCallback(()=>{s&&(s.getTracks().forEach(d=>d.stop()),i(null))},[s]),h=We.useCallback(()=>{if(a.current&&r.current){const d=r.current.getContext("2d");if(d){r.current.width=a.current.videoWidth,r.current.height=a.current.videoHeight,d.drawImage(a.current,0,0);const p=r.current.toDataURL("image/jpeg",.8);e(p)}}},[e]);return We.useEffect(()=>(c(),()=>u()),[]),We.useEffect(()=>{if(n&&s){const d=setInterval(()=>{h()},1500);return()=>clearInterval(d)}},[n,s,h]),P.jsxs("div",{className:"flex flex-col items-center gap-4 w-full",children:[o?P.jsx("div",{className:"bg-red-50 text-red-600 p-4 rounded-lg text-sm font-medium",children:o}):P.jsxs("div",{className:"relative w-full max-w-md bg-black rounded-2xl overflow-hidden shadow-2xl aspect-[4/3] border border-white/10",children:[P.jsx("video",{ref:a,autoPlay:!0,playsInline:!0,className:"w-full h-full object-cover scale-x-[-1]"}),n&&P.jsxs("div",{className:"absolute inset-0 pointer-events-none",children:[P.jsx("div",{className:"absolute inset-0 border-[1px] border-indigo-500/30"}),P.jsx("div",{className:"absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-indigo-500 to-transparent animate-[scan_2s_linear_infinite]"}),P.jsx("div",{className:"absolute inset-0 flex items-center justify-center",children:P.jsxs("div",{className:"w-48 h-64 border-2 border-indigo-500/20 rounded-[40px] relative",children:[P.jsx("div",{className:"absolute -top-1 -left-1 w-4 h-4 border-t-2 border-l-2 border-indigo-500"}),P.jsx("div",{className:"absolute -top-1 -right-1 w-4 h-4 border-t-2 border-r-2 border-indigo-500"}),P.jsx("div",{className:"absolute -bottom-1 -left-1 w-4 h-4 border-b-2 border-l-2 border-indigo-500"}),P.jsx("div",{className:"absolute -bottom-1 -right-1 w-4 h-4 border-b-2 border-r-2 border-indigo-500"})]})})]}),P.jsx("div",{className:"absolute inset-x-0 bottom-6 flex justify-center",children:n?P.jsxs("div",{className:"bg-black/40 backdrop-blur-md px-4 py-1.5 rounded-full border border-white/10 flex items-center gap-2",children:[P.jsx("div",{className:"w-2 h-2 bg-indigo-500 rounded-full animate-pulse"}),P.jsx("span",{className:"text-[10px] font-black uppercase tracking-widest text-white/80",children:"Scanning Face..."})]}):P.jsx("button",{onClick:h,className:"bg-white hover:bg-slate-200 text-slate-900 font-bold p-4 rounded-full shadow-lg transition-all active:scale-95 group",children:P.jsx("div",{className:"w-8 h-8 rounded-full border-4 border-slate-900 group-hover:bg-slate-900/10 transition-colors"})})})]}),P.jsx("canvas",{ref:r,className:"hidden"}),P.jsx("p",{className:"text-slate-500 text-[10px] font-black uppercase tracking-[0.2em]",children:t}),P.jsx("style",{children:`
        @keyframes scan {
          0% { transform: translateY(0); opacity: 0; }
          50% { opacity: 1; }
          100% { transform: translateY(320px); opacity: 0; }
        }
      `})]})};var A7=Object.defineProperty,R7=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),k2=(e,t)=>{for(var n in t)A7(e,n,{get:t[n],enumerable:!0})},D7={};k2(D7,{Abs:()=>Sf,Acos:()=>Zc,Acosh:()=>Jc,AdadeltaOptimizer:()=>GE,AdagradOptimizer:()=>HE,AdamOptimizer:()=>qE,AdamaxOptimizer:()=>KE,Add:()=>hu,AddN:()=>eh,All:()=>If,Any:()=>kf,ArgMax:()=>Tf,ArgMin:()=>Ef,Asin:()=>th,Asinh:()=>nh,Atan:()=>ah,Atan2:()=>sh,Atanh:()=>rh,AvgPool:()=>ih,AvgPool3D:()=>Nf,AvgPool3DGrad:()=>cb,AvgPoolGrad:()=>ub,BackendWasm:()=>Mj,BatchMatMul:()=>oh,BatchToSpaceND:()=>Cf,Bincount:()=>Af,BitwiseAnd:()=>Rf,BroadcastArgs:()=>hb,BroadcastTo:()=>Vz,Callback:()=>$B,CallbackList:()=>TV,Cast:()=>lh,Ceil:()=>uh,ClipByValue:()=>du,Complex:()=>Uw,ComplexAbs:()=>db,Concat:()=>Df,Conv2D:()=>ch,Conv2DBackpropFilter:()=>Ww,Conv2DBackpropInput:()=>hh,Conv3D:()=>dh,Conv3DBackpropFilterV2:()=>$f,Conv3DBackpropInputV2:()=>Mf,Cos:()=>ph,Cosh:()=>fh,CropAndResize:()=>Ff,Cumprod:()=>Of,Cumsum:()=>mh,CustomCallback:()=>NV,DataStorage:()=>Pw,DenseBincount:()=>pb,DepthToSpace:()=>Lf,DepthwiseConv2dNative:()=>gh,DepthwiseConv2dNativeBackpropFilter:()=>jw,DepthwiseConv2dNativeBackpropInput:()=>Gw,Diag:()=>fb,Dilation2D:()=>yh,Dilation2DBackpropFilter:()=>Gp,Dilation2DBackpropInput:()=>jp,Draw:()=>Hw,ENV:()=>A2,EarlyStopping:()=>MB,Einsum:()=>qw,Elu:()=>vh,EluGrad:()=>zf,Environment:()=>zz,Equal:()=>Pf,Erf:()=>xh,Exp:()=>wh,ExpandDims:()=>Vf,Expm1:()=>_h,FFT:()=>Kw,Fill:()=>mb,FlipLeftRight:()=>Bf,Floor:()=>Sh,FloorDiv:()=>Ih,FromPixels:()=>C0,FusedBatchNorm:()=>kh,FusedConv2D:()=>kc,FusedDepthwiseConv2D:()=>Tc,GPGPUContext:()=>Wx,GatherNd:()=>Wf,GatherV2:()=>Uf,GraphModel:()=>MC,Greater:()=>jf,GreaterEqual:()=>Th,History:()=>EV,IFFT:()=>Xw,Identity:()=>Eh,Imag:()=>Qw,InputSpec:()=>zn,IsFinite:()=>Nh,IsInf:()=>Ch,IsNan:()=>Ah,KernelBackend:()=>ob,LRN:()=>Mh,LRNGrad:()=>Yf,LayerVariable:()=>bV,LayersModel:()=>vo,LeakyRelu:()=>Rh,Less:()=>Gf,LessEqual:()=>Hf,LinSpace:()=>qf,Log:()=>Dh,Log1p:()=>$h,LogSoftmax:()=>Uz,LogicalAnd:()=>Kf,LogicalNot:()=>Xf,LogicalOr:()=>Qf,LogicalXor:()=>Bz,LowerBound:()=>SK,MathBackendCPU:()=>LC,MathBackendWebGL:()=>hA,MatrixBandPart:()=>IK,Max:()=>Oh,MaxPool:()=>Lh,MaxPool3D:()=>Zf,MaxPool3DGrad:()=>yb,MaxPoolGrad:()=>gb,MaxPoolWithArgmax:()=>bb,Maximum:()=>Fh,Mean:()=>zh,Min:()=>Ph,Minimum:()=>Vh,MirrorPad:()=>Bh,Mod:()=>Uh,MomentumOptimizer:()=>XE,Multinomial:()=>Jf,Multiply:()=>Wh,Neg:()=>em,NonMaxSuppressionV3:()=>nm,NonMaxSuppressionV4:()=>am,NonMaxSuppressionV5:()=>rm,NotEqual:()=>tm,OP_SCOPE_SUFFIX:()=>O2,OneHot:()=>jh,OnesLike:()=>sm,Optimizer:()=>zo,OptimizerConstructors:()=>YP,Pack:()=>im,PadV2:()=>Gh,Pool:()=>kK,Pow:()=>Hh,Prelu:()=>qh,Prod:()=>Kh,RMSPropOptimizer:()=>QE,RNN:()=>Po,RaggedGather:()=>Yw,RaggedRange:()=>Zw,RaggedTensorToTensor:()=>Jw,Range:()=>vb,Rank:()=>QI,Real:()=>e1,RealDiv:()=>bh,Reciprocal:()=>Xh,Reduction:()=>Qa,Relu:()=>Qh,Relu6:()=>Jh,Reshape:()=>om,ResizeBilinear:()=>Zh,ResizeBilinearGrad:()=>um,ResizeNearestNeighbor:()=>Yh,ResizeNearestNeighborGrad:()=>lm,Reverse:()=>ed,RotateWithOffset:()=>Im,Round:()=>td,Rsqrt:()=>nd,SGDOptimizer:()=>F1,ScatterNd:()=>cm,SearchSorted:()=>dm,Select:()=>pm,Selu:()=>ad,Sequential:()=>X1,Sigmoid:()=>od,Sign:()=>id,Sin:()=>rd,Sinh:()=>sd,Slice:()=>fm,Softmax:()=>hd,Softplus:()=>ld,SpaceToBatchND:()=>mm,SparseFillEmptyRows:()=>xb,SparseReshape:()=>ym,SparseSegmentMean:()=>wb,SparseSegmentSum:()=>_b,SparseToDense:()=>bm,SplitV:()=>gm,Sqrt:()=>ud,Square:()=>Sb,SquaredDifference:()=>dd,StaticRegexReplace:()=>Ib,Step:()=>fu,StridedSlice:()=>vm,StringNGrams:()=>kb,StringSplit:()=>Tb,StringToHashBucketFast:()=>Eb,Sub:()=>pd,Sum:()=>cd,SymbolicTensor:()=>Js,Tan:()=>fd,Tanh:()=>md,Tensor:()=>at,TensorBuffer:()=>Vn,TensorScatterUpdate:()=>hm,Tile:()=>pu,TopK:()=>xm,Transform:()=>wm,Transpose:()=>bo,Unique:()=>Nb,Unpack:()=>_m,UnsortedSegmentSum:()=>Cb,UpperBound:()=>TK,Variable:()=>Ec,ZerosLike:()=>Sm,_FusedMatMul:()=>Ic,abs:()=>On,acos:()=>V2,acosh:()=>B2,add:()=>re,addN:()=>g4,all:()=>s1,any:()=>Ty,argMax:()=>Rc,argMin:()=>U2,asin:()=>W2,asinh:()=>j2,atan:()=>G2,atan2:()=>H2,atanh:()=>q2,avgPool:()=>Oo,avgPool3d:()=>X2,backend:()=>F2,backend_util:()=>O,basicLSTMCell:()=>x4,batchNorm:()=>gd,batchNorm2d:()=>Q2,batchNorm3d:()=>Y2,batchNorm4d:()=>Z2,batchToSpaceND:()=>Fb,bincount:()=>J2,bitwiseAnd:()=>w4,booleanMaskAsync:()=>cP,broadcastArgs:()=>_4,broadcastTo:()=>fc,broadcast_util:()=>km,browser:()=>Xb,buffer:()=>ut,callbacks:()=>wue,cast:()=>ye,ceil:()=>eE,clipByValue:()=>Va,clone:()=>Ci,complex:()=>Eo,concat:()=>Qt,concat1d:()=>tE,concat2d:()=>nE,concat3d:()=>aE,concat4d:()=>rE,constraints:()=>_V,conv1d:()=>i1,conv2d:()=>Ja,conv2dTranspose:()=>o1,conv3d:()=>iE,conv3dTranspose:()=>oE,copyRegisteredKernels:()=>AK,cos:()=>Lb,cosh:()=>l1,cosineWindow:()=>R1,cumprod:()=>Cy,cumsum:()=>u1,customGrad:()=>zi,data:()=>rU,denseBincount:()=>D0,deprecationWarn:()=>n4,depthToSpace:()=>lE,depthwiseConv2d:()=>yd,deregisterOp:()=>Iue,device_util:()=>$b,diag:()=>I4,dilation2d:()=>uE,disableDeprecationWarnings:()=>iX,dispose:()=>et,disposeVariables:()=>oX,div:()=>Ce,divNoNan:()=>cE,dot:()=>hE,dropout:()=>VE,einsum:()=>nc,elu:()=>Tm,enableDebugMode:()=>sX,enableProdMode:()=>rX,enclosingPowerOfTwo:()=>BE,engine:()=>xs,ensureShape:()=>T4,env:()=>Z,equal:()=>Lr,erf:()=>c1,euclideanNorm:()=>fE,exp:()=>Ba,expandDims:()=>pa,expm1:()=>mE,eye:()=>h1,fft:()=>qb,fill:()=>Mr,findBackend:()=>pX,findBackendFactory:()=>fX,floor:()=>Nm,floorDiv:()=>r1,forceHalfFloat:()=>N5,fused:()=>Jp,gather:()=>Cm,gatherND:()=>fP,gather_util:()=>JE,getBackend:()=>a4,getGradient:()=>KI,getKernel:()=>Sy,getKernelsForBackend:()=>A0,getThreadsCount:()=>NDe,gpgpu_util:()=>s5,grad:()=>HY,grads:()=>qY,greater:()=>sr,greaterEqual:()=>Fo,ifft:()=>Zp,imag:()=>zb,image:()=>Yr,inTopKAsync:()=>mP,initializers:()=>SV,input:()=>UV,io:()=>Ca,irfft:()=>I1,isFinite:()=>gE,isInf:()=>yE,isNaN:()=>bE,keep:()=>Jn,kernel_impls:()=>Hi,layers:()=>IV,leakyRelu:()=>Pb,less:()=>Kp,lessEqual:()=>gu,linalg:()=>jE,linspace:()=>R4,loadGraphModel:()=>Ace,loadGraphModelSync:()=>Rce,loadLayersModel:()=>goe,localResponseNormalization:()=>vE,log:()=>zr,log1p:()=>Vb,logSigmoid:()=>xE,logSoftmax:()=>p1,logSumExp:()=>Bb,logicalAnd:()=>Ms,logicalNot:()=>Ub,logicalOr:()=>f1,logicalXor:()=>wE,losses:()=>EP,lowerBound:()=>$4,matMul:()=>ot,math:()=>zP,max:()=>is,maxPool:()=>ca,maxPool3d:()=>_E,maxPoolWithArgmax:()=>M4,maximum:()=>Gi,mean:()=>wn,memory:()=>ak,meshgrid:()=>O4,metrics:()=>AB,min:()=>qp,minimum:()=>Hl,mirrorPad:()=>SE,mod:()=>IE,model:()=>voe,models:()=>RB,moments:()=>Wb,movingAverage:()=>hP,mul:()=>G,multiRNNCell:()=>F4,multinomial:()=>L4,neg:()=>on,nextFrame:()=>eN,norm:()=>Em,notEqual:()=>Mc,oneHot:()=>Xp,ones:()=>pr,onesLike:()=>Pr,op:()=>W,outerProduct:()=>z4,pad:()=>ri,pad1d:()=>P4,pad2d:()=>V4,pad3d:()=>B4,pad4d:()=>U4,pool:()=>kE,pow:()=>Li,prelu:()=>Gb,print:()=>P2,prod:()=>TE,profile:()=>lX,raggedGather:()=>W4,raggedRange:()=>j4,raggedTensorToTensor:()=>G4,rand:()=>H4,randomGamma:()=>Q4,randomNormal:()=>g1,randomStandardNormal:()=>Y4,randomUniform:()=>yu,randomUniformInt:()=>Z4,range:()=>Oc,ready:()=>hX,real:()=>Qp,reciprocal:()=>RE,registerBackend:()=>a1,registerCallbackConstructor:()=>woe,registerGradient:()=>Wz,registerKernel:()=>Ab,registerOp:()=>Sue,regularizers:()=>DB,relu:()=>Bt,relu6:()=>y1,removeBackend:()=>dX,reshape:()=>K,reverse:()=>hs,reverse1d:()=>J4,reverse2d:()=>eP,reverse3d:()=>tP,reverse4d:()=>nP,rfft:()=>Kb,round:()=>b1,rsqrt:()=>v1,scalar:()=>ze,scatterND:()=>dP,scatter_util:()=>E1,searchSorted:()=>m1,selu:()=>x1,separableConv2d:()=>Am,sequential:()=>xoe,serialization:()=>de,setBackend:()=>cX,setPlatform:()=>mX,setThreadsCount:()=>EDe,setWasmPath:()=>kDe,setWasmPaths:()=>TDe,setWebGLContext:()=>C6,setdiff1dAsync:()=>aP,shared:()=>zC,sigmoid:()=>Rs,sign:()=>DE,signal:()=>TP,sin:()=>w1,sinh:()=>_1,slice:()=>vt,slice1d:()=>Hb,slice2d:()=>S1,slice3d:()=>Rm,slice4d:()=>Yp,slice_util:()=>aa,softmax:()=>bu,softplus:()=>bd,spaceToBatchND:()=>jb,sparse:()=>NP,sparseToDense:()=>pP,spectral:()=>kP,split:()=>fr,sqrt:()=>va,square:()=>Xt,squaredDifference:()=>k1,squeeze:()=>vu,stack:()=>Bn,step:()=>vd,stridedSlice:()=>$E,string:()=>CP,sub:()=>Ie,sum:()=>De,sumOutType:()=>n1,tan:()=>ME,tanh:()=>Gl,tensor:()=>Za,tensor1d:()=>Ft,tensor2d:()=>Ai,tensor3d:()=>T1,tensor4d:()=>ql,tensor5d:()=>rP,tensor6d:()=>sP,tensorScatterUpdate:()=>oP,tensor_util:()=>Ks,test_util:()=>q4,tidy:()=>X,tile:()=>Dr,time:()=>uX,topk:()=>FE,train:()=>Zu,transpose:()=>lt,truncatedNormal:()=>C1,unique:()=>LE,unregisterGradient:()=>CK,unregisterKernel:()=>NK,unsortedSegmentSum:()=>A1,unstack:()=>Tn,upcastType:()=>us,upperBound:()=>lP,util:()=>N,valueAndGrad:()=>KY,valueAndGrads:()=>XY,variable:()=>zE,variableGrads:()=>D4,version:()=>ODe,version_converter:()=>$ce,version_core:()=>vne,version_cpu:()=>Mde,version_layers:()=>SN,version_wasm:()=>CDe,version_webgl:()=>Sxe,webgl:()=>Ixe,webgl_util:()=>N6,where:()=>ga,whereAsync:()=>PE,zeros:()=>_n,zerosLike:()=>_t});var $7=Object.create,T2=Object.defineProperty,M7=Object.getOwnPropertyDescriptor,O7=Object.getOwnPropertyNames,F7=Object.getPrototypeOf,L7=Object.prototype.hasOwnProperty,Wn=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),tt=(e,t)=>{for(var n in t)T2(e,n,{get:t[n],enumerable:!0})},z7=(e,t,n,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of O7(t))!L7.call(e,r)&&r!==n&&T2(e,r,{get:()=>t[r],enumerable:!(a=M7(t,r))||a.enumerable});return e},cu=(e,t,n)=>(n=e!=null?$7(F7(e)):{},z7(!e||!e.__esModule?T2(n,"default",{value:e,enumerable:!0}):n,e)),P7=Wn((e,t)=>{t.exports=a;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function a(_,D,j){this.low=_|0,this.high=D|0,this.unsigned=!!j}a.prototype.__isLong__,Object.defineProperty(a.prototype,"__isLong__",{value:!0});function r(_){return(_&&_.__isLong__)===!0}a.isLong=r;var s={},i={};function o(_,D){var j,q,B;return D?(_>>>=0,(B=0<=_&&_<256)&&(q=i[_],q)?q:(j=c(_,(_|0)<0?-1:0,!0),B&&(i[_]=j),j)):(_|=0,(B=-128<=_&&_<128)&&(q=s[_],q)?q:(j=c(_,_<0?-1:0,!1),B&&(s[_]=j),j))}a.fromInt=o;function l(_,D){if(isNaN(_))return D?w:x;if(D){if(_<0)return w;if(_>=g)return E}else{if(_<=-y)return R;if(_+1>=y)return I}return _<0?l(-_,D).neg():c(_%m|0,_/m|0,D)}a.fromNumber=l;function c(_,D,j){return new a(_,D,j)}a.fromBits=c;var u=Math.pow;function h(_,D,j){if(_.length===0)throw Error("empty string");if(_==="NaN"||_==="Infinity"||_==="+Infinity"||_==="-Infinity")return x;if(typeof D=="number"?(j=D,D=!1):D=!!D,j=j||10,j<2||36<j)throw RangeError("radix");var q;if((q=_.indexOf("-"))>0)throw Error("interior hyphen");if(q===0)return h(_.substring(1),D,j).neg();for(var B=l(u(j,8)),Q=x,H=0;H<_.length;H+=8){var J=Math.min(8,_.length-H),ae=parseInt(_.substring(H,H+J),j);if(J<8){var ne=l(u(j,J));Q=Q.mul(ne).add(l(ae))}else Q=Q.mul(B),Q=Q.add(l(ae))}return Q.unsigned=D,Q}a.fromString=h;function d(_,D){return typeof _=="number"?l(_,D):typeof _=="string"?h(_,D):c(_.low,_.high,typeof D=="boolean"?D:_.unsigned)}a.fromValue=d;var p=65536,f=1<<24,m=p*p,g=m*m,y=g/2,v=o(f),x=o(0);a.ZERO=x;var w=o(0,!0);a.UZERO=w;var k=o(1);a.ONE=k;var M=o(1,!0);a.UONE=M;var S=o(-1);a.NEG_ONE=S;var I=c(-1,2147483647,!1);a.MAX_VALUE=I;var E=c(-1,-1,!0);a.MAX_UNSIGNED_VALUE=E;var R=c(0,-2147483648,!1);a.MIN_VALUE=R;var A=a.prototype;A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},A.toString=function(_){if(_=_||10,_<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(R)){var D=l(_),j=this.div(D),q=j.mul(D).sub(this);return j.toString(_)+q.toInt().toString(_)}else return"-"+this.neg().toString(_);for(var B=l(u(_,6),this.unsigned),Q=this,H="";;){var J=Q.div(B),ae=Q.sub(J.mul(B)).toInt()>>>0,ne=ae.toString(_);if(Q=J,Q.isZero())return ne+H;for(;ne.length<6;)ne="0"+ne;H=""+ne+H}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var _=this.high!=0?this.high:this.low,D=31;D>0&&!(_&1<<D);D--);return this.high!=0?D+33:D+1},A.isZero=function(){return this.high===0&&this.low===0},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return(this.low&1)===1},A.isEven=function(){return(this.low&1)===0},A.equals=function(_){return r(_)||(_=d(_)),this.unsigned!==_.unsigned&&this.high>>>31===1&&_.high>>>31===1?!1:this.high===_.high&&this.low===_.low},A.eq=A.equals,A.notEquals=function(_){return!this.eq(_)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(_){return this.comp(_)<0},A.lt=A.lessThan,A.lessThanOrEqual=function(_){return this.comp(_)<=0},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(_){return this.comp(_)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(_){return this.comp(_)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(_){if(r(_)||(_=d(_)),this.eq(_))return 0;var D=this.isNegative(),j=_.isNegative();return D&&!j?-1:!D&&j?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add(k)},A.neg=A.negate,A.add=function(_){r(_)||(_=d(_));var D=this.high>>>16,j=this.high&65535,q=this.low>>>16,B=this.low&65535,Q=_.high>>>16,H=_.high&65535,J=_.low>>>16,ae=_.low&65535,ne=0,ue=0,le=0,he=0;return he+=B+ae,le+=he>>>16,he&=65535,le+=q+J,ue+=le>>>16,le&=65535,ue+=j+H,ne+=ue>>>16,ue&=65535,ne+=D+Q,ne&=65535,c(le<<16|he,ne<<16|ue,this.unsigned)},A.subtract=function(_){return r(_)||(_=d(_)),this.add(_.neg())},A.sub=A.subtract,A.multiply=function(_){if(this.isZero())return x;if(r(_)||(_=d(_)),n){var D=n.mul(this.low,this.high,_.low,_.high);return c(D,n.get_high(),this.unsigned)}if(_.isZero())return x;if(this.eq(R))return _.isOdd()?R:x;if(_.eq(R))return this.isOdd()?R:x;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(v)&&_.lt(v))return l(this.toNumber()*_.toNumber(),this.unsigned);var j=this.high>>>16,q=this.high&65535,B=this.low>>>16,Q=this.low&65535,H=_.high>>>16,J=_.high&65535,ae=_.low>>>16,ne=_.low&65535,ue=0,le=0,he=0,me=0;return me+=Q*ne,he+=me>>>16,me&=65535,he+=B*ne,le+=he>>>16,he&=65535,he+=Q*ae,le+=he>>>16,he&=65535,le+=q*ne,ue+=le>>>16,le&=65535,le+=B*ae,ue+=le>>>16,le&=65535,le+=Q*J,ue+=le>>>16,le&=65535,ue+=j*ne+q*ae+B*J+Q*H,ue&=65535,c(he<<16|me,ue<<16|le,this.unsigned)},A.mul=A.multiply,A.divide=function(_){if(r(_)||(_=d(_)),_.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&_.low===-1&&_.high===-1)return this;var D=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,_.low,_.high);return c(D,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?w:x;var j,q,B;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return w;if(_.gt(this.shru(1)))return M;B=w}else{if(this.eq(R)){if(_.eq(k)||_.eq(S))return R;if(_.eq(R))return k;var Q=this.shr(1);return j=Q.div(_).shl(1),j.eq(x)?_.isNegative()?k:S:(q=this.sub(_.mul(j)),B=j.add(q.div(_)),B)}else if(_.eq(R))return this.unsigned?w:x;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();B=x}for(q=this;q.gte(_);){j=Math.max(1,Math.floor(q.toNumber()/_.toNumber()));for(var H=Math.ceil(Math.log(j)/Math.LN2),J=H<=48?1:u(2,H-48),ae=l(j),ne=ae.mul(_);ne.isNegative()||ne.gt(q);)j-=J,ae=l(j,this.unsigned),ne=ae.mul(_);ae.isZero()&&(ae=k),B=B.add(ae),q=q.sub(ne)}return B},A.div=A.divide,A.modulo=function(_){if(r(_)||(_=d(_)),n){var D=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,_.low,_.high);return c(D,n.get_high(),this.unsigned)}return this.sub(this.div(_).mul(_))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return c(~this.low,~this.high,this.unsigned)},A.and=function(_){return r(_)||(_=d(_)),c(this.low&_.low,this.high&_.high,this.unsigned)},A.or=function(_){return r(_)||(_=d(_)),c(this.low|_.low,this.high|_.high,this.unsigned)},A.xor=function(_){return r(_)||(_=d(_)),c(this.low^_.low,this.high^_.high,this.unsigned)},A.shiftLeft=function(_){return r(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?c(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):c(0,this.low<<_-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(_){return r(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?c(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):c(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(_){if(r(_)&&(_=_.toInt()),_&=63,_===0)return this;var D=this.high;if(_<32){var j=this.low;return c(j>>>_|D<<32-_,D>>>_,this.unsigned)}else return _===32?c(D,0,this.unsigned):c(D>>>_-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},A.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var _=this.high,D=this.low;return[D&255,D>>>8&255,D>>>16&255,D>>>24,_&255,_>>>8&255,_>>>16&255,_>>>24]},A.toBytesBE=function(){var _=this.high,D=this.low;return[_>>>24,_>>>16&255,_>>>8&255,_&255,D>>>24,D>>>16&255,D>>>8&255,D&255]},a.fromBytes=function(_,D,j){return j?a.fromBytesLE(_,D):a.fromBytesBE(_,D)},a.fromBytesLE=function(_,D){return new a(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,D)},a.fromBytesBE=function(_,D){return new a(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],D)}}),V7=Wn(()=>{}),B7=Wn(()=>{}),U7=Wn((e,t)=>{(function(n,a,r){function s(c){var u=this,h=l();u.next=function(){var d=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=d-(u.c=d|0)},u.c=1,u.s0=h(" "),u.s1=h(" "),u.s2=h(" "),u.s0-=h(c),u.s0<0&&(u.s0+=1),u.s1-=h(c),u.s1<0&&(u.s1+=1),u.s2-=h(c),u.s2<0&&(u.s2+=1),h=null}function i(c,u){return u.c=c.c,u.s0=c.s0,u.s1=c.s1,u.s2=c.s2,u}function o(c,u){var h=new s(c),d=u&&u.state,p=h.next;return p.int32=function(){return h.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}function l(){var c=4022871197,u=function(h){h=String(h);for(var d=0;d<h.length;d++){c+=h.charCodeAt(d);var p=.02519603282416938*c;c=p>>>0,p-=c,p*=c,c=p>>>0,p-=c,c+=p*4294967296}return(c>>>0)*23283064365386963e-26};return u}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),W7=Wn((e,t)=>{(function(n,a,r){function s(l){var c=this,u="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var d=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^d^d>>>8},l===(l|0)?c.x=l:u+=l;for(var h=0;h<u.length+64;h++)c.x^=u.charCodeAt(h)|0,c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c}function o(l,c){var u=new s(l),h=c&&c.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),j7=Wn((e,t)=>{(function(n,a,r){function s(l){var c=this,u="";c.next=function(){var d=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(d^d<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,l===(l|0)?c.x=l:u+=l;for(var h=0;h<u.length+64;h++)c.x^=u.charCodeAt(h)|0,h==u.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c.v=l.v,c.d=l.d,c}function o(l,c){var u=new s(l),h=c&&c.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),G7=Wn((e,t)=>{(function(n,a,r){function s(l){var c=this;c.next=function(){var h=c.x,d=c.i,p,f;return p=h[d],p^=p>>>7,f=p^p<<24,p=h[d+1&7],f^=p^p>>>10,p=h[d+3&7],f^=p^p>>>3,p=h[d+4&7],f^=p^p<<7,p=h[d+7&7],p=p^p<<13,f^=p^p<<9,h[d]=f,c.i=d+1&7,f};function u(h,d){var p,f=[];if(d===(d|0))f[0]=d;else for(d=""+d,p=0;p<d.length;++p)f[p&7]=f[p&7]<<15^d.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?f[7]=-1:f[p],h.x=f,h.i=0,p=256;p>0;--p)h.next()}u(c,l)}function i(l,c){return c.x=l.x.slice(),c.i=l.i,c}function o(l,c){l==null&&(l=+new Date);var u=new s(l),h=c&&c.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(h.x&&i(h,u),d.state=function(){return i(u,{})}),d}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),H7=Wn((e,t)=>{(function(n,a,r){function s(l){var c=this;c.next=function(){var h=c.w,d=c.X,p=c.i,f,m;return c.w=h=h+1640531527|0,m=d[p+34&127],f=d[p=p+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=d[p]=m^f,c.i=p,m+(h^h>>>16)|0};function u(h,d){var p,f,m,g,y,v=[],x=128;for(d===(d|0)?(f=d,d=null):(d=d+"\0",f=0,x=Math.max(x,d.length)),m=0,g=-32;g<x;++g)d&&(f^=d.charCodeAt((g+32)%d.length)),g===0&&(y=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,g>=0&&(y=y+1640531527|0,p=v[g&127]^=f+y,m=p==0?m+1:0);for(m>=128&&(v[(d&&d.length||0)&127]=-1),m=127,g=4*128;g>0;--g)f=v[m+34&127],p=v[m=m+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,v[m]=f^p;h.w=y,h.X=v,h.i=m}u(c,l)}function i(l,c){return c.i=l.i,c.w=l.w,c.X=l.X.slice(),c}function o(l,c){l==null&&(l=+new Date);var u=new s(l),h=c&&c.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(h.X&&i(h,u),d.state=function(){return i(u,{})}),d}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),q7=Wn((e,t)=>{(function(n,a,r){function s(l){var c=this,u="";c.next=function(){var d=c.b,p=c.c,f=c.d,m=c.a;return d=d<<25^d>>>7^p,p=p-f|0,f=f<<24^f>>>8^m,m=m-d|0,c.b=d=d<<20^d>>>12^p,c.c=p=p-f|0,c.d=f<<16^p>>>16^m,c.a=m-d|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,l===Math.floor(l)?(c.a=l/4294967296|0,c.b=l|0):u+=l;for(var h=0;h<u.length+20;h++)c.b^=u.charCodeAt(h)|0,c.next()}function i(l,c){return c.a=l.a,c.b=l.b,c.c=l.c,c.d=l.d,c}function o(l,c){var u=new s(l),h=c&&c.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),K7=Wn(()=>{}),X7=Wn((e,t)=>{(function(n,a,r){var s=256,i=6,o=52,l="random",c=r.pow(s,i),u=r.pow(2,o),h=u*2,d=s-1,p;function f(k,M,S){var I=[];M=M==!0?{entropy:!0}:M||{};var E=v(y(M.entropy?[k,w(a)]:k??x(),3),I),R=new m(I),A=function(){for(var _=R.g(i),D=c,j=0;_<u;)_=(_+j)*s,D*=s,j=R.g(1);for(;_>=h;)_/=2,D/=2,j>>>=1;return(_+j)/D};return A.int32=function(){return R.g(4)|0},A.quick=function(){return R.g(4)/4294967296},A.double=A,v(w(R.S),a),(M.pass||S||function(_,D,j,q){return q&&(q.S&&g(q,R),_.state=function(){return g(R,{})}),j?(r[l]=_,D):_})(A,E,"global"in M?M.global:this==r,M.state)}function m(k){var M,S=k.length,I=this,E=0,R=I.i=I.j=0,A=I.S=[];for(S||(k=[S++]);E<s;)A[E]=E++;for(E=0;E<s;E++)A[E]=A[R=d&R+k[E%S]+(M=A[E])],A[R]=M;(I.g=function(_){for(var D,j=0,q=I.i,B=I.j,Q=I.S;_--;)D=Q[q=d&q+1],j=j*s+Q[d&(Q[q]=Q[B=d&B+D])+(Q[B]=D)];return I.i=q,I.j=B,j})(s)}function g(k,M){return M.i=k.i,M.j=k.j,M.S=k.S.slice(),M}function y(k,M){var S=[],I=typeof k,E;if(M&&I=="object")for(E in k)try{S.push(y(k[E],M-1))}catch{}return S.length?S:I=="string"?k:k+"\0"}function v(k,M){for(var S=k+"",I,E=0;E<S.length;)M[d&E]=d&(I^=M[d&E]*19)+S.charCodeAt(E++);return w(M)}function x(){try{var k;return p&&(k=p.randomBytes)?k=k(s):(k=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(k)),w(k)}catch{var M=n.navigator,S=M&&M.plugins;return[+new Date,n,S,n.screen,w(a)]}}function w(k){return String.fromCharCode.apply(0,k)}if(v(r.random(),a),typeof t=="object"&&t.exports){t.exports=f;try{p=K7()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):r["seed"+l]=f})(typeof self<"u"?self:e,[],Math)}),zw=Wn((e,t)=>{var n=U7(),a=W7(),r=j7(),s=G7(),i=H7(),o=q7(),l=X7();l.alea=n,l.xor128=a,l.xorwow=r,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l}),Tz=Wn(()=>{}),E2=Wn(()=>{}),Ez=Wn(()=>{}),Q7=Wn(()=>{}),Y7=Wn(()=>{}),Z7=Wn(()=>{}),J7=Wn((e,t)=>{var n=(()=>{var a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(a=a||__filename),function(r){r=r||{};function s(){return H.buffer!=xe&&st(H.buffer),Le}function i(){return H.buffer!=xe&&st(H.buffer),Pe}function o(){return H.buffer!=xe&&st(H.buffer),Xe}function l(){return H.buffer!=xe&&st(H.buffer),Ue}function c(){return H.buffer!=xe&&st(H.buffer),Et}var u=typeof r<"u"?r:{},h,d;u.ready=new Promise(function(V,ee){h=V,d=ee});var p;typeof process<"u"&&process.listeners&&(p={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},u),m=(V,ee)=>{throw ee},g=typeof window=="object",y=typeof importScripts=="function",v=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=u.ENVIRONMENT_IS_PTHREAD||!1,w="";function k(V){return u.locateFile?u.locateFile(V,w):w+V}var M,S,I;function E(V){V instanceof or||q("exiting due to exception: "+V)}if(v){var R=E2(),A=Ez();y?w=A.dirname(w)+"/":w=__dirname+"/",M=(ee,be)=>(ee=fs(ee)?new URL(ee):A.normalize(ee),R.readFileSync(ee,be?void 0:"utf8")),I=ee=>{var be=M(ee,!0);return be.buffer||(be=new Uint8Array(be)),be},S=(ee,be,Be)=>{ee=fs(ee)?new URL(ee):A.normalize(ee),R.readFile(ee,function(Ge,qe){Ge?Be(Ge):be(qe.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(ee){if(!(ee instanceof or))throw ee}),process.on("unhandledRejection",function(ee){throw ee}),m=(ee,be)=>{if(pt())throw process.exitCode=ee,be;E(be),process.exit(ee)},u.inspect=function(){return"[Emscripten Module object]"};let V;try{V=Q7()}catch(ee){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),ee}global.Worker=V.Worker}else(g||y)&&(y?w=self.location.href:typeof document<"u"&&document.currentScript&&(w=document.currentScript.src),typeof a<"u"&&a&&(w=a),w.indexOf("blob:")!==0?w=w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):w="",v||(M=V=>{var ee=new XMLHttpRequest;return ee.open("GET",V,!1),ee.send(null),ee.responseText},y&&(I=V=>{var ee=new XMLHttpRequest;return ee.open("GET",V,!1),ee.responseType="arraybuffer",ee.send(null),new Uint8Array(ee.response)}),S=(V,ee,be)=>{var Be=new XMLHttpRequest;Be.open("GET",V,!0),Be.responseType="arraybuffer",Be.onload=()=>{if(Be.status==200||Be.status==0&&Be.response){ee(Be.response);return}be()},Be.onerror=be,Be.send(null)}));v&&typeof performance>"u"&&(global.performance=Y7().performance);var _=console.log.bind(console),D=console.warn.bind(console);v&&(_=V=>R.writeSync(1,V+`
`),D=V=>R.writeSync(2,V+`
`));var j=u.print||_,q=u.printErr||D;Object.assign(u,f),f=null,u.arguments&&u.arguments,u.thisProgram&&u.thisProgram,u.quit&&(m=u.quit);var B;u.wasmBinary&&(B=u.wasmBinary);var Q=u.noExitRuntime||!0;typeof WebAssembly!="object"&&ps("no native wasm support detected");var H,J,ae=!1,ne;function ue(V,ee){V||ps(ee)}var le=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function he(V,ee,be){ee>>>=0;for(var Be=ee+be,Ge=ee;V[Ge]&&!(Ge>=Be);)++Ge;if(Ge-ee>16&&V.buffer&&le)return le.decode(V.buffer instanceof SharedArrayBuffer?V.slice(ee,Ge):V.subarray(ee,Ge));for(var qe="";ee<Ge;){var Ee=V[ee++];if(!(Ee&128)){qe+=String.fromCharCode(Ee);continue}var Fe=V[ee++]&63;if((Ee&224)==192){qe+=String.fromCharCode((Ee&31)<<6|Fe);continue}var Ye=V[ee++]&63;if((Ee&240)==224?Ee=(Ee&15)<<12|Fe<<6|Ye:Ee=(Ee&7)<<18|Fe<<12|Ye<<6|V[ee++]&63,Ee<65536)qe+=String.fromCharCode(Ee);else{var lr=Ee-65536;qe+=String.fromCharCode(55296|lr>>10,56320|lr&1023)}}return qe}function me(V,ee){return V>>>=0,V?he(i(),V,ee):""}function Re(V,ee,be,Be){if(be>>>=0,!(Be>0))return 0;for(var Ge=be,qe=be+Be-1,Ee=0;Ee<V.length;++Ee){var Fe=V.charCodeAt(Ee);if(Fe>=55296&&Fe<=57343){var Ye=V.charCodeAt(++Ee);Fe=65536+((Fe&1023)<<10)|Ye&1023}if(Fe<=127){if(be>=qe)break;ee[be++>>>0]=Fe}else if(Fe<=2047){if(be+1>=qe)break;ee[be++>>>0]=192|Fe>>6,ee[be++>>>0]=128|Fe&63}else if(Fe<=65535){if(be+2>=qe)break;ee[be++>>>0]=224|Fe>>12,ee[be++>>>0]=128|Fe>>6&63,ee[be++>>>0]=128|Fe&63}else{if(be+3>=qe)break;ee[be++>>>0]=240|Fe>>18,ee[be++>>>0]=128|Fe>>12&63,ee[be++>>>0]=128|Fe>>6&63,ee[be++>>>0]=128|Fe&63}}return ee[be>>>0]=0,be-Ge}function Ne(V,ee,be){return Re(V,i(),ee,be)}var xe,Le,Pe,Xe,Ue,Et;x&&(xe=u.buffer);function st(V){xe=V,u.HEAP8=Le=new Int8Array(V),u.HEAP16=new Int16Array(V),u.HEAP32=Xe=new Int32Array(V),u.HEAPU8=Pe=new Uint8Array(V),u.HEAPU16=new Uint16Array(V),u.HEAPU32=Ue=new Uint32Array(V),u.HEAPF32=new Float32Array(V),u.HEAPF64=Et=new Float64Array(V)}var bt=u.INITIAL_MEMORY||16777216;if(x)H=u.wasmMemory,xe=u.buffer;else if(u.wasmMemory)H=u.wasmMemory;else if(H=new WebAssembly.Memory({initial:bt/65536,maximum:65536,shared:!0}),!(H.buffer instanceof SharedArrayBuffer))throw q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&q("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");H&&(xe=H.buffer),bt=xe.byteLength,st(xe);var je,gt=[],Ot=[],At=[];function pt(){return Q}function Nn(){if(u.preRun)for(typeof u.preRun=="function"&&(u.preRun=[u.preRun]);u.preRun.length;)Ze(u.preRun.shift());Gt(gt)}function Cn(){!x&&Gt(Ot)}function ge(){if(!x){if(u.postRun)for(typeof u.postRun=="function"&&(u.postRun=[u.postRun]);u.postRun.length;)kn(u.postRun.shift());Gt(At)}}function Ze(V){gt.unshift(V)}function ht(V){Ot.unshift(V)}function kn(V){At.unshift(V)}var vn=0,Da=null;function ii(V){vn++,u.monitorRunDependencies&&u.monitorRunDependencies(vn)}function Cu(V){if(vn--,u.monitorRunDependencies&&u.monitorRunDependencies(vn),vn==0&&Da){var ee=Da;Da=null,ee()}}function ps(V){u.onAbort&&u.onAbort(V),V="Aborted("+V+")",q(V),ae=!0,ne=1,V+=". Build with -sASSERTIONS for more info.";var ee=new WebAssembly.RuntimeError(V);throw d(ee),ee}var Bo="data:application/octet-stream;base64,";function Ga(V){return V.startsWith(Bo)}function fs(V){return V.startsWith("file://")}var An;An="tfjs-backend-wasm-threaded-simd.wasm",Ga(An)||(An=k(An));function ms(V){try{if(V==An&&B)return new Uint8Array(B);if(I)return I(V);throw"both async and sync fetching of the wasm failed"}catch(ee){ps(ee)}}function Au(){if(!B&&(g||y)){if(typeof fetch=="function"&&!fs(An))return fetch(An,{credentials:"same-origin"}).then(function(V){if(!V.ok)throw"failed to load wasm binary file at '"+An+"'";return V.arrayBuffer()}).catch(function(){return ms(An)});if(S)return new Promise(function(V,ee){S(An,function(be){V(new Uint8Array(be))},ee)})}return Promise.resolve().then(function(){return ms(An)})}function Ki(){var V={env:kv,wasi_snapshot_preview1:kv};function ee(Ee,Fe){var Ye=Ee.exports;if(u.asm=Ye,zs(u.asm._emscripten_tls_init),je=u.asm.__indirect_function_table,ht(u.asm.__wasm_call_ctors),J=Fe,!x){var lr=ke.unusedWorkers.length;ke.unusedWorkers.forEach(function(Bs){ke.loadWasmModuleToWorker(Bs,function(){--lr||Cu()})})}}x||ii();function be(Ee){ee(Ee.instance,Ee.module)}function Be(Ee){return Au().then(function(Fe){return WebAssembly.instantiate(Fe,V)}).then(function(Fe){return Fe}).then(Ee,function(Fe){q("failed to asynchronously prepare wasm: "+Fe),ps(Fe)})}function Ge(){return!B&&typeof WebAssembly.instantiateStreaming=="function"&&!Ga(An)&&!fs(An)&&!v&&typeof fetch=="function"?fetch(An,{credentials:"same-origin"}).then(function(Ee){var Fe=WebAssembly.instantiateStreaming(Ee,V);return Fe.then(be,function(Ye){return q("wasm streaming compile failed: "+Ye),q("falling back to ArrayBuffer instantiation"),Be(be)})}):Be(be)}if(u.instantiateWasm)try{var qe=u.instantiateWasm(V,ee);return qe}catch(Ee){q("Module.instantiateWasm callback failed with error: "+Ee),d(Ee)}return Ge().catch(d),{}}var Ru={};function or(V){this.name="ExitStatus",this.message="Program terminated with exit("+V+")",this.status=V}function Xi(V){var ee=ke.pthreads[V];delete ke.pthreads[V],ee.terminate(),Ps(V),ke.runningWorkers.splice(ke.runningWorkers.indexOf(ee),1),ee.pthread_ptr=0}function Gn(V){var ee=ke.pthreads[V];ee.postMessage({cmd:"cancel"})}function oi(V){var ee=ke.pthreads[V];ue(ee),ke.returnWorkerToPool(ee)}function Wr(V){var ee=ke.getNewWorker();if(!ee)return 6;ke.runningWorkers.push(ee),ke.pthreads[V.pthread_ptr]=ee,ee.pthread_ptr=V.pthread_ptr;var be={cmd:"run",start_routine:V.startRoutine,arg:V.arg,pthread_ptr:V.pthread_ptr};return ee.runPthread=()=>{v&&ee.ref(),ee.postMessage(be,V.transferList),delete ee.runPthread},ee.loaded&&ee.runPthread(),0}function li(V){if(x)return ui(1,1,V);ne=V,pt()||(ke.terminateAllThreads(),u.onExit&&u.onExit(V),ae=!0),m(V,new or(V))}function oe(V,ee){if(ne=V,!ee&&x)throw it(V),"unwind";li(V)}var ve=oe;function Oe(V){if(V instanceof or||V=="unwind")return ne;m(1,V)}var ke={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?ke.initWorker():ke.initMainThread()},initMainThread:function(){for(var V=8;V--;)ke.allocateUnusedWorker()},initWorker:function(){Q=!1},setExitStatus:function(V){ne=V},terminateAllThreads:function(){for(var V of Object.values(ke.pthreads))ke.returnWorkerToPool(V);for(var V of ke.unusedWorkers)V.terminate();ke.unusedWorkers=[]},returnWorkerToPool:function(V){var ee=V.pthread_ptr;delete ke.pthreads[ee],ke.unusedWorkers.push(V),ke.runningWorkers.splice(ke.runningWorkers.indexOf(V),1),V.pthread_ptr=0,v&&V.unref(),Ps(ee)},receiveObjectTransfer:function(V){},threadInitTLS:function(){ke.tlsInitFunctions.forEach(V=>V())},loadWasmModuleToWorker:function(V,ee){V.onmessage=qe=>{var Ee=qe.data,Fe=Ee.cmd;if(V.pthread_ptr&&(ke.currentProxiedOperationCallerThread=V.pthread_ptr),Ee.targetThread&&Ee.targetThread!=Fd()){var Ye=ke.pthreads[Ee.targetThread];Ye?Ye.postMessage(Ee,Ee.transferList):q('Internal error! Worker sent a message "'+Fe+'" to target pthread '+Ee.targetThread+", but that thread no longer exists!"),ke.currentProxiedOperationCallerThread=void 0;return}Fe==="processProxyingQueue"?Rd(Ee.queue):Fe==="spawnThread"?Wr(Ee):Fe==="cleanupThread"?oi(Ee.thread):Fe==="killThread"?Xi(Ee.thread):Fe==="cancelThread"?Gn(Ee.thread):Fe==="loaded"?(V.loaded=!0,v&&V.unref(),ee&&ee(V),V.runPthread&&V.runPthread()):Fe==="print"?j("Thread "+Ee.threadId+": "+Ee.text):Fe==="printErr"?q("Thread "+Ee.threadId+": "+Ee.text):Fe==="alert"?alert("Thread "+Ee.threadId+": "+Ee.text):Ee.target==="setimmediate"?V.postMessage(Ee):Fe==="callHandler"?u[Ee.handler](...Ee.args):Fe&&q("worker sent an unknown command "+Fe),ke.currentProxiedOperationCallerThread=void 0},V.onerror=qe=>{var Ee="worker sent an error!";throw q(Ee+" "+qe.filename+":"+qe.lineno+": "+qe.message),qe},v&&(V.on("message",function(qe){V.onmessage({data:qe})}),V.on("error",function(qe){V.onerror(qe)}),V.on("detachedExit",function(){}));var be=[],Be=["onExit","onAbort","print","printErr"];for(var Ge of Be)u.hasOwnProperty(Ge)&&be.push(Ge);V.postMessage({cmd:"load",handlers:be,urlOrBlob:u.mainScriptUrlOrBlob||a,wasmMemory:H,wasmModule:J})},allocateUnusedWorker:function(){var V,ee=k("tfjs-backend-wasm-threaded-simd.worker.js");V=new Worker(ee),ke.unusedWorkers.push(V)},getNewWorker:function(){return ke.unusedWorkers.length==0&&(ke.allocateUnusedWorker(),ke.loadWasmModuleToWorker(ke.unusedWorkers[0])),ke.unusedWorkers.pop()}};u.PThread=ke;function Gt(V){for(;V.length>0;)V.shift()(u)}function Pt(){var V=Fd(),ee=o()[V+52>>>2],be=o()[V+56>>>2],Be=ee-be;tg(ee,Be),Pu(ee)}u.establishStackSpace=Pt;function it(V){if(x)return ui(2,0,V);try{ve(V)}catch(ee){Oe(ee)}}var Je=[];function hn(V){var ee=Je[V];return ee||(V>=Je.length&&(Je.length=V+1),Je[V]=ee=je.get(V)),ee}function oa(V,ee){var be=hn(V)(ee);pt()?ke.setExitStatus(be):eg(be)}u.invokeEntryPoint=oa;function zs(V){ke.tlsInitFunctions.push(V)}function jr(V){Tv(V,!y,1,!g),ke.threadInitTLS()}function Uo(V){x?postMessage({cmd:"cleanupThread",thread:V}):oi(V)}function Du(V,ee,be,Be){return x?ui(3,1,V,ee,be,Be):Hn(V,ee,be,Be)}function Hn(V,ee,be,Be){if(typeof SharedArrayBuffer>"u")return q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Ge=[],qe=0;if(x&&(Ge.length===0||qe))return Du(V,ee,be,Be);var Ee={startRoutine:be,pthread_ptr:V,arg:Be,transferList:Ge};return x?(Ee.cmd="spawnThread",postMessage(Ee,Ge),0):Wr(Ee)}function gs(){return 65536}var $u=!0;function A_(){return $u}function Rd(V){Atomics.store(o(),V>>2,1),Fd()&&jo(V),Atomics.compareExchange(o(),V>>2,1,0)}u.executeNotifiedProxyingQueue=Rd;function R_(V,ee,be,Be){if(V==ee)setTimeout(()=>Rd(Be));else if(x)postMessage({targetThread:V,cmd:"processProxyingQueue",queue:Be});else{var Ge=ke.pthreads[V];if(!Ge)return;Ge.postMessage({cmd:"processProxyingQueue",queue:Be})}return 1}function Dd(V,ee,be){return-1}function vv(){ps("")}function Qi(V){Qi.shown||(Qi.shown={}),Qi.shown[V]||(Qi.shown[V]=1,v&&(V="warning: "+V),q(V))}function Mu(){v||y||Qi("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function Yi(){return Date.now()}function $d(){return 4294901760}function D_(){return $d()}var Md;v?Md=()=>{var V=process.hrtime();return V[0]*1e3+V[1]/1e6}:Md=()=>performance.timeOrigin+performance.now();function xv(V,ee,be){i().copyWithin(V>>>0,ee>>>0,ee+be>>>0)}function wv(){return v?Z7().cpus().length:navigator.hardwareConcurrency}function Zm(V){var ee=Ld(),be=V();return Pu(ee),be}function ui(V,ee){var be=arguments.length-2,Be=arguments;return Zm(()=>{for(var Ge=be,qe=Vu(Ge*8),Ee=qe>>3,Fe=0;Fe<be;Fe++){var Ye=Be[2+Fe];c()[Ee+Fe>>>0]=Ye}return Ev(V,Ge,qe,ee)})}var Od=[];function _v(V,ee,be){Od.length=ee;for(var Be=be>>3,Ge=0;Ge<ee;Ge++)Od[Ge]=c()[Be+Ge>>>0];var qe=V<0,Ee=qe?Ru[-V-1]:Iv[V];return Ee.apply(null,Od)}function Sv(V){try{return H.grow(V-xe.byteLength+65535>>>16),st(H.buffer),1}catch{}}function $_(V){var ee=i().length;if(V=V>>>0,V<=ee)return!1;var be=$d();if(V>be)return!1;let Be=(Ye,lr)=>Ye+(lr-Ye%lr)%lr;for(var Ge=1;Ge<=4;Ge*=2){var qe=ee*(1+.2/Ge);qe=Math.min(qe,V+100663296);var Ee=Math.min(be,Be(Math.max(V,qe),65536)),Fe=Sv(Ee);if(Fe)return!0}return!1}function ci(){throw"unwind"}function Gr(V){return x?ui(4,1,V):52}function Wo(V,ee,be,Be,Ge){return x?ui(5,1,V,ee,be,Be,Ge):70}var Ou=[null,[],[]];function Jm(V,ee){var be=Ou[V];ee===0||ee===10?((V===1?j:q)(he(be,0)),be.length=0):be.push(ee)}function Jt(V,ee,be,Be){if(x)return ui(6,1,V,ee,be,Be);for(var Ge=0,qe=0;qe<be;qe++){var Ee=l()[ee>>>2],Fe=l()[ee+4>>>2];ee+=8;for(var Ye=0;Ye<Fe;Ye++)Jm(V,i()[Ee+Ye>>>0]);Ge+=Fe}return l()[Be>>>2]=Ge,0}function Fu(V){var ee=u["_"+V];return ee}function Lu(V,ee){s().set(V,ee>>>0)}function zu(V,ee,be,Be,Ge){var qe={string:_a=>{var ur=0;if(_a!=null&&_a!==0){var ag=(_a.length<<2)+1;ur=Vu(ag),Ne(_a,ur,ag)}return ur},array:_a=>{var ur=Vu(_a.length);return Lu(_a,ur),ur}};function Ee(_a){return ee==="string"?me(_a):ee==="boolean"?!!_a:_a}var Fe=Fu(V),Ye=[],lr=0;if(Be)for(var Bs=0;Bs<Be.length;Bs++){var ng=qe[be[Bs]];ng?(lr===0&&(lr=Ld()),Ye[Bs]=ng(Be[Bs])):Ye[Bs]=Be[Bs]}var Vd=Fe.apply(null,Ye);function Cv(_a){return lr!==0&&Pu(lr),Ee(_a)}return Vd=Cv(Vd),Vd}function M_(V,ee,be,Be){be=be||[];var Ge=be.every(Ee=>Ee==="number"||Ee==="boolean"),qe=ee!=="string";return qe&&Ge&&!Be?Fu(V):function(){return zu(V,ee,be,arguments)}}ke.init();var Iv=[null,li,it,Du,Gr,Wo,Jt],kv={__emscripten_init_main_thread_js:jr,__emscripten_thread_cleanup:Uo,__pthread_create_js:Hn,_emscripten_default_pthread_stack_size:gs,_emscripten_get_now_is_monotonic:A_,_emscripten_notify_task_queue:R_,_emscripten_set_offscreencanvas_size:Dd,abort:vv,emscripten_check_blocking_allowed:Mu,emscripten_date_now:Yi,emscripten_get_heap_max:D_,emscripten_get_now:Md,emscripten_memcpy_big:xv,emscripten_num_logical_cores:wv,emscripten_receive_on_main_thread_js:_v,emscripten_resize_heap:$_,emscripten_unwind_to_js_event_loop:ci,exit:ve,fd_close:Gr,fd_seek:Wo,fd_write:Jt,memory:H||u.wasmMemory};Ki(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.__wasm_call_ctors).apply(null,arguments)},u._init=function(){return(u._init=u.asm.init).apply(null,arguments)},u._init_with_threads_count=function(){return(u._init_with_threads_count=u.asm.init_with_threads_count).apply(null,arguments)},u._get_threads_count=function(){return(u._get_threads_count=u.asm.get_threads_count).apply(null,arguments)},u._register_tensor=function(){return(u._register_tensor=u.asm.register_tensor).apply(null,arguments)},u._dispose_data=function(){return(u._dispose_data=u.asm.dispose_data).apply(null,arguments)},u._dispose=function(){return(u._dispose=u.asm.dispose).apply(null,arguments)},u._Abs=function(){return(u._Abs=u.asm.Abs).apply(null,arguments)},u._Acos=function(){return(u._Acos=u.asm.Acos).apply(null,arguments)},u._Acosh=function(){return(u._Acosh=u.asm.Acosh).apply(null,arguments)},u._Add=function(){return(u._Add=u.asm.Add).apply(null,arguments)},u._AddN=function(){return(u._AddN=u.asm.AddN).apply(null,arguments)},u._All=function(){return(u._All=u.asm.All).apply(null,arguments)},u._Any=function(){return(u._Any=u.asm.Any).apply(null,arguments)},u._ArgMax=function(){return(u._ArgMax=u.asm.ArgMax).apply(null,arguments)},u._ArgMin=function(){return(u._ArgMin=u.asm.ArgMin).apply(null,arguments)},u._Asin=function(){return(u._Asin=u.asm.Asin).apply(null,arguments)},u._Asinh=function(){return(u._Asinh=u.asm.Asinh).apply(null,arguments)},u._Atan=function(){return(u._Atan=u.asm.Atan).apply(null,arguments)},u._Atan2=function(){return(u._Atan2=u.asm.Atan2).apply(null,arguments)},u._Atanh=function(){return(u._Atanh=u.asm.Atanh).apply(null,arguments)},u._AvgPool=function(){return(u._AvgPool=u.asm.AvgPool).apply(null,arguments)},u._AvgPool3D=function(){return(u._AvgPool3D=u.asm.AvgPool3D).apply(null,arguments)},u._AvgPool3DGrad=function(){return(u._AvgPool3DGrad=u.asm.AvgPool3DGrad).apply(null,arguments)},u._AvgPoolGrad=function(){return(u._AvgPoolGrad=u.asm.AvgPoolGrad).apply(null,arguments)},u._BatchMatMul=function(){return(u._BatchMatMul=u.asm.BatchMatMul).apply(null,arguments)},u._Bincount=function(){return(u._Bincount=u.asm.Bincount).apply(null,arguments)},u._BitwiseAnd=function(){return(u._BitwiseAnd=u.asm.BitwiseAnd).apply(null,arguments)},u._Ceil=function(){return(u._Ceil=u.asm.Ceil).apply(null,arguments)},u._ClipByValue=function(){return(u._ClipByValue=u.asm.ClipByValue).apply(null,arguments)},u._Conv2D=function(){return(u._Conv2D=u.asm.Conv2D).apply(null,arguments)},u._Conv2DBackpropInput=function(){return(u._Conv2DBackpropInput=u.asm.Conv2DBackpropInput).apply(null,arguments)},u._Conv3D=function(){return(u._Conv3D=u.asm.Conv3D).apply(null,arguments)},u._Conv3DBackpropFilterV2=function(){return(u._Conv3DBackpropFilterV2=u.asm.Conv3DBackpropFilterV2).apply(null,arguments)},u._Conv3DBackpropInputV2=function(){return(u._Conv3DBackpropInputV2=u.asm.Conv3DBackpropInputV2).apply(null,arguments)},u._Cos=function(){return(u._Cos=u.asm.Cos).apply(null,arguments)},u._Cosh=function(){return(u._Cosh=u.asm.Cosh).apply(null,arguments)},u._CropAndResize=function(){return(u._CropAndResize=u.asm.CropAndResize).apply(null,arguments)},u._Cumprod=function(){return(u._Cumprod=u.asm.Cumprod).apply(null,arguments)},u._Cumsum=function(){return(u._Cumsum=u.asm.Cumsum).apply(null,arguments)},u._DenseBincount=function(){return(u._DenseBincount=u.asm.DenseBincount).apply(null,arguments)},u._DepthToSpace=function(){return(u._DepthToSpace=u.asm.DepthToSpace).apply(null,arguments)},u._DepthwiseConv2dNative=function(){return(u._DepthwiseConv2dNative=u.asm.DepthwiseConv2dNative).apply(null,arguments)},u._Diag=function(){return(u._Diag=u.asm.Diag).apply(null,arguments)},u._Dilation2D=function(){return(u._Dilation2D=u.asm.Dilation2D).apply(null,arguments)},u._Dilation2DBackpropFilter=function(){return(u._Dilation2DBackpropFilter=u.asm.Dilation2DBackpropFilter).apply(null,arguments)},u._Dilation2DBackpropInput=function(){return(u._Dilation2DBackpropInput=u.asm.Dilation2DBackpropInput).apply(null,arguments)},u._Elu=function(){return(u._Elu=u.asm.Elu).apply(null,arguments)},u._EluGrad=function(){return(u._EluGrad=u.asm.EluGrad).apply(null,arguments)},u._Equal=function(){return(u._Equal=u.asm.Equal).apply(null,arguments)},u._Erf=function(){return(u._Erf=u.asm.Erf).apply(null,arguments)},u._Exp=function(){return(u._Exp=u.asm.Exp).apply(null,arguments)},u._Expm1=function(){return(u._Expm1=u.asm.Expm1).apply(null,arguments)},u._FlipLeftRight=function(){return(u._FlipLeftRight=u.asm.FlipLeftRight).apply(null,arguments)},u._Floor=function(){return(u._Floor=u.asm.Floor).apply(null,arguments)},u._FloorDiv=function(){return(u._FloorDiv=u.asm.FloorDiv).apply(null,arguments)},u._FusedBatchNorm=function(){return(u._FusedBatchNorm=u.asm.FusedBatchNorm).apply(null,arguments)},u._FusedConv2D=function(){return(u._FusedConv2D=u.asm.FusedConv2D).apply(null,arguments)},u._FusedDepthwiseConv2D=function(){return(u._FusedDepthwiseConv2D=u.asm.FusedDepthwiseConv2D).apply(null,arguments)},u._Gather=function(){return(u._Gather=u.asm.Gather).apply(null,arguments)},u._GatherNd=function(){return(u._GatherNd=u.asm.GatherNd).apply(null,arguments)},u._Greater=function(){return(u._Greater=u.asm.Greater).apply(null,arguments)},u._GreaterEqual=function(){return(u._GreaterEqual=u.asm.GreaterEqual).apply(null,arguments)},u._IsFinite=function(){return(u._IsFinite=u.asm.IsFinite).apply(null,arguments)},u._IsInf=function(){return(u._IsInf=u.asm.IsInf).apply(null,arguments)},u._IsNan=function(){return(u._IsNan=u.asm.IsNan).apply(null,arguments)},u._LRN=function(){return(u._LRN=u.asm.LRN).apply(null,arguments)},u._LRNGrad=function(){return(u._LRNGrad=u.asm.LRNGrad).apply(null,arguments)},u._LeakyRelu=function(){return(u._LeakyRelu=u.asm.LeakyRelu).apply(null,arguments)},u._Less=function(){return(u._Less=u.asm.Less).apply(null,arguments)},u._LessEqual=function(){return(u._LessEqual=u.asm.LessEqual).apply(null,arguments)},u._LinSpace=function(){return(u._LinSpace=u.asm.LinSpace).apply(null,arguments)},u._Log=function(){return(u._Log=u.asm.Log).apply(null,arguments)},u._Log1p=function(){return(u._Log1p=u.asm.Log1p).apply(null,arguments)},u._LogicalAnd=function(){return(u._LogicalAnd=u.asm.LogicalAnd).apply(null,arguments)},u._LogicalNot=function(){return(u._LogicalNot=u.asm.LogicalNot).apply(null,arguments)},u._LogicalOr=function(){return(u._LogicalOr=u.asm.LogicalOr).apply(null,arguments)},u._LogicalXor=function(){return(u._LogicalXor=u.asm.LogicalXor).apply(null,arguments)},u._Max=function(){return(u._Max=u.asm.Max).apply(null,arguments)},u._MaxPool=function(){return(u._MaxPool=u.asm.MaxPool).apply(null,arguments)},u._MaxPool3D=function(){return(u._MaxPool3D=u.asm.MaxPool3D).apply(null,arguments)},u._MaxPool3DGrad=function(){return(u._MaxPool3DGrad=u.asm.MaxPool3DGrad).apply(null,arguments)},u._MaxPoolGrad=function(){return(u._MaxPoolGrad=u.asm.MaxPoolGrad).apply(null,arguments)},u._MaxPoolWithArgmax=function(){return(u._MaxPoolWithArgmax=u.asm.MaxPoolWithArgmax).apply(null,arguments)},u._Maximum=function(){return(u._Maximum=u.asm.Maximum).apply(null,arguments)},u._Mean=function(){return(u._Mean=u.asm.Mean).apply(null,arguments)},u._Min=function(){return(u._Min=u.asm.Min).apply(null,arguments)},u._Minimum=function(){return(u._Minimum=u.asm.Minimum).apply(null,arguments)},u._MirrorPad=function(){return(u._MirrorPad=u.asm.MirrorPad).apply(null,arguments)},u._Mod=function(){return(u._Mod=u.asm.Mod).apply(null,arguments)},u._Multinomial=function(){return(u._Multinomial=u.asm.Multinomial).apply(null,arguments)},u._Multiply=function(){return(u._Multiply=u.asm.Multiply).apply(null,arguments)},u._Neg=function(){return(u._Neg=u.asm.Neg).apply(null,arguments)},u._NonMaxSuppressionV3=function(){return(u._NonMaxSuppressionV3=u.asm.NonMaxSuppressionV3).apply(null,arguments)},u._NonMaxSuppressionV4=function(){return(u._NonMaxSuppressionV4=u.asm.NonMaxSuppressionV4).apply(null,arguments)},u._NonMaxSuppressionV5=function(){return(u._NonMaxSuppressionV5=u.asm.NonMaxSuppressionV5).apply(null,arguments)},u._NotEqual=function(){return(u._NotEqual=u.asm.NotEqual).apply(null,arguments)},u._OneHot=function(){return(u._OneHot=u.asm.OneHot).apply(null,arguments)},u._PadV2=function(){return(u._PadV2=u.asm.PadV2).apply(null,arguments)},u._Pow=function(){return(u._Pow=u.asm.Pow).apply(null,arguments)},u._Prelu=function(){return(u._Prelu=u.asm.Prelu).apply(null,arguments)},u._Prod=function(){return(u._Prod=u.asm.Prod).apply(null,arguments)},u._RealDiv=function(){return(u._RealDiv=u.asm.RealDiv).apply(null,arguments)},u._Reciprocal=function(){return(u._Reciprocal=u.asm.Reciprocal).apply(null,arguments)},u._Relu=function(){return(u._Relu=u.asm.Relu).apply(null,arguments)},u._Relu6=function(){return(u._Relu6=u.asm.Relu6).apply(null,arguments)},u._ResizeBilinear=function(){return(u._ResizeBilinear=u.asm.ResizeBilinear).apply(null,arguments)},u._ResizeBilinearGrad=function(){return(u._ResizeBilinearGrad=u.asm.ResizeBilinearGrad).apply(null,arguments)},u._ResizeNearestNeighbor=function(){return(u._ResizeNearestNeighbor=u.asm.ResizeNearestNeighbor).apply(null,arguments)},u._ResizeNearestNeighborGrad=function(){return(u._ResizeNearestNeighborGrad=u.asm.ResizeNearestNeighborGrad).apply(null,arguments)},u._Reverse=function(){return(u._Reverse=u.asm.Reverse).apply(null,arguments)},u._RotateWithOffset=function(){return(u._RotateWithOffset=u.asm.RotateWithOffset).apply(null,arguments)},u._Round=function(){return(u._Round=u.asm.Round).apply(null,arguments)},u._Rsqrt=function(){return(u._Rsqrt=u.asm.Rsqrt).apply(null,arguments)},u._ScatterNd=function(){return(u._ScatterNd=u.asm.ScatterNd).apply(null,arguments)},u._SearchSorted=function(){return(u._SearchSorted=u.asm.SearchSorted).apply(null,arguments)},u._SelectV2=function(){return(u._SelectV2=u.asm.SelectV2).apply(null,arguments)},u._Selu=function(){return(u._Selu=u.asm.Selu).apply(null,arguments)},u._Sigmoid=function(){return(u._Sigmoid=u.asm.Sigmoid).apply(null,arguments)},u._Sign=function(){return(u._Sign=u.asm.Sign).apply(null,arguments)},u._Sin=function(){return(u._Sin=u.asm.Sin).apply(null,arguments)},u._Sinh=function(){return(u._Sinh=u.asm.Sinh).apply(null,arguments)},u._Softmax=function(){return(u._Softmax=u.asm.Softmax).apply(null,arguments)},u._Softplus=function(){return(u._Softplus=u.asm.Softplus).apply(null,arguments)},u._SparseFillEmptyRows=function(){return(u._SparseFillEmptyRows=u.asm.SparseFillEmptyRows).apply(null,arguments)},u._SparseReshape=function(){return(u._SparseReshape=u.asm.SparseReshape).apply(null,arguments)},u._SparseSegmentReduction=function(){return(u._SparseSegmentReduction=u.asm.SparseSegmentReduction).apply(null,arguments)},u._SparseToDense=function(){return(u._SparseToDense=u.asm.SparseToDense).apply(null,arguments)},u._Sqrt=function(){return(u._Sqrt=u.asm.Sqrt).apply(null,arguments)},u._Square=function(){return(u._Square=u.asm.Square).apply(null,arguments)},u._SquaredDifference=function(){return(u._SquaredDifference=u.asm.SquaredDifference).apply(null,arguments)},u._Step=function(){return(u._Step=u.asm.Step).apply(null,arguments)},u._StridedSlice=function(){return(u._StridedSlice=u.asm.StridedSlice).apply(null,arguments)},u._Sub=function(){return(u._Sub=u.asm.Sub).apply(null,arguments)},u._Sum=function(){return(u._Sum=u.asm.Sum).apply(null,arguments)},u._Tan=function(){return(u._Tan=u.asm.Tan).apply(null,arguments)},u._Tanh=function(){return(u._Tanh=u.asm.Tanh).apply(null,arguments)},u._TensorScatterUpdate=function(){return(u._TensorScatterUpdate=u.asm.TensorScatterUpdate).apply(null,arguments)},u._Tile=function(){return(u._Tile=u.asm.Tile).apply(null,arguments)},u._TopK=function(){return(u._TopK=u.asm.TopK).apply(null,arguments)},u._Transform=function(){return(u._Transform=u.asm.Transform).apply(null,arguments)},u._Transpose=function(){return(u._Transpose=u.asm.Transpose).apply(null,arguments)},u.__FusedMatMul=function(){return(u.__FusedMatMul=u.asm._FusedMatMul).apply(null,arguments)},u._malloc=function(){return(u._malloc=u.asm.malloc).apply(null,arguments)},u._free=function(){return(u._free=u.asm.free).apply(null,arguments)},u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm._emscripten_tls_init).apply(null,arguments)};var Fd=u._pthread_self=function(){return(Fd=u._pthread_self=u.asm.pthread_self).apply(null,arguments)};u.___errno_location=function(){return(u.___errno_location=u.asm.__errno_location).apply(null,arguments)};var Tv=u.__emscripten_thread_init=function(){return(Tv=u.__emscripten_thread_init=u.asm._emscripten_thread_init).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm._emscripten_thread_crashed).apply(null,arguments)},u._emscripten_main_thread_process_queued_calls=function(){return(u._emscripten_main_thread_process_queued_calls=u.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},u._emscripten_main_browser_thread_id=function(){return(u._emscripten_main_browser_thread_id=u.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var Ev=u._emscripten_run_in_main_runtime_thread_js=function(){return(Ev=u._emscripten_run_in_main_runtime_thread_js=u.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};u._emscripten_dispatch_to_thread_=function(){return(u._emscripten_dispatch_to_thread_=u.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var jo=u.__emscripten_proxy_execute_task_queue=function(){return(jo=u.__emscripten_proxy_execute_task_queue=u.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},Ps=u.__emscripten_thread_free_data=function(){return(Ps=u.__emscripten_thread_free_data=u.asm._emscripten_thread_free_data).apply(null,arguments)},eg=u.__emscripten_thread_exit=function(){return(eg=u.__emscripten_thread_exit=u.asm._emscripten_thread_exit).apply(null,arguments)},tg=u._emscripten_stack_set_limits=function(){return(tg=u._emscripten_stack_set_limits=u.asm.emscripten_stack_set_limits).apply(null,arguments)},Ld=u.stackSave=function(){return(Ld=u.stackSave=u.asm.stackSave).apply(null,arguments)},Pu=u.stackRestore=function(){return(Pu=u.stackRestore=u.asm.stackRestore).apply(null,arguments)},Vu=u.stackAlloc=function(){return(Vu=u.stackAlloc=u.asm.stackAlloc).apply(null,arguments)};u.dynCall_iijjiiii=function(){return(u.dynCall_iijjiiii=u.asm.dynCall_iijjiiii).apply(null,arguments)},u.dynCall_jiji=function(){return(u.dynCall_jiji=u.asm.dynCall_jiji).apply(null,arguments)},u.keepRuntimeAlive=pt,u.wasmMemory=H,u.cwrap=M_,u.ExitStatus=or,u.PThread=ke;var Vs;Da=function V(){Vs||Nv(),Vs||(Da=V)};function Nv(V){if(vn>0)return;if(x){h(u),Cn(),startWorker(u);return}if(Nn(),vn>0)return;function ee(){Vs||(Vs=!0,u.calledRun=!0,!ae&&(Cn(),h(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),ge()))}u.setStatus?(u.setStatus("Running..."),setTimeout(function(){setTimeout(function(){u.setStatus("")},1),ee()},1)):ee()}if(u.preInit)for(typeof u.preInit=="function"&&(u.preInit=[u.preInit]);u.preInit.length>0;)u.preInit.pop()();Nv();var zd;p&&(zd={uncaughtException:process.listeners("uncaughtException").filter(function(V){return!p.uncaughtException.indexOf(V)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(V){return!p.unhandledRejection.indexOf(V)>-1})});var Pd;if(typeof WasmBackendModule<"u")Pd=WasmBackendModule;else if(typeof r<"u")Pd=r;else throw new Error("Could not find wasm module in post.js");if(zd){var hi=Pd._dispose;Pd._dispose=function(){hi(),zd.uncaughtException.forEach(function(V){process.removeListener("uncaughtException",V)}),zd.unhandledRejection.forEach(function(V){process.removeListener("unhandledRejection",V)})}}return r.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),eK=Wn((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),tK=Wn((e,t)=>{var n=(()=>{var a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(a=a||__filename),function(r){r=r||{};var s=typeof r<"u"?r:{},i,o;s.ready=new Promise(function(oe,ve){i=oe,o=ve});var l;typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var c=Object.assign({},s),u=typeof window=="object",h=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",p="";function f(oe){return s.locateFile?s.locateFile(oe,p):p+oe}var m,g,y;if(d){var v=E2(),x=Ez();h?p=x.dirname(p)+"/":p=__dirname+"/",m=(oe,ve)=>(oe=bt(oe)?new URL(oe):x.normalize(oe),v.readFileSync(oe,ve?void 0:"utf8")),y=oe=>{var ve=m(oe,!0);return ve.buffer||(ve=new Uint8Array(ve)),ve},g=(oe,ve,Oe)=>{oe=bt(oe)?new URL(oe):x.normalize(oe),v.readFile(oe,function(ke,Gt){ke?Oe(ke):ve(Gt.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(oe){if(!(oe instanceof pt))throw oe}),process.on("unhandledRejection",function(oe){throw oe}),s.inspect=function(){return"[Emscripten Module object]"}}else(u||h)&&(h?p=self.location.href:typeof document<"u"&&document.currentScript&&(p=document.currentScript.src),a&&(p=a),p.indexOf("blob:")!==0?p=p.substr(0,p.replace(/[?#].*/,"").lastIndexOf("/")+1):p="",m=oe=>{var ve=new XMLHttpRequest;return ve.open("GET",oe,!1),ve.send(null),ve.responseText},h&&(y=oe=>{var ve=new XMLHttpRequest;return ve.open("GET",oe,!1),ve.responseType="arraybuffer",ve.send(null),new Uint8Array(ve.response)}),g=(oe,ve,Oe)=>{var ke=new XMLHttpRequest;ke.open("GET",oe,!0),ke.responseType="arraybuffer",ke.onload=()=>{if(ke.status==200||ke.status==0&&ke.response){ve(ke.response);return}Oe()},ke.onerror=Oe,ke.send(null)});var w=s.print||console.log.bind(console),k=s.printErr||console.warn.bind(console);Object.assign(s,c),c=null,s.arguments&&s.arguments,s.thisProgram&&s.thisProgram,s.quit&&s.quit;var M;s.wasmBinary&&(M=s.wasmBinary),s.noExitRuntime,typeof WebAssembly!="object"&&Ue("no native wasm support detected");var S,I=!1,E=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function R(oe,ve,Oe){ve>>>=0;for(var ke=ve+Oe,Gt=ve;oe[Gt]&&!(Gt>=ke);)++Gt;if(Gt-ve>16&&oe.buffer&&E)return E.decode(oe.subarray(ve,Gt));for(var Pt="";ve<Gt;){var it=oe[ve++];if(!(it&128)){Pt+=String.fromCharCode(it);continue}var Je=oe[ve++]&63;if((it&224)==192){Pt+=String.fromCharCode((it&31)<<6|Je);continue}var hn=oe[ve++]&63;if((it&240)==224?it=(it&15)<<12|Je<<6|hn:it=(it&7)<<18|Je<<12|hn<<6|oe[ve++]&63,it<65536)Pt+=String.fromCharCode(it);else{var oa=it-65536;Pt+=String.fromCharCode(55296|oa>>10,56320|oa&1023)}}return Pt}function A(oe,ve){return oe>>>=0,oe?R(B,oe,ve):""}function _(oe,ve,Oe,ke){if(Oe>>>=0,!(ke>0))return 0;for(var Gt=Oe,Pt=Oe+ke-1,it=0;it<oe.length;++it){var Je=oe.charCodeAt(it);if(Je>=55296&&Je<=57343){var hn=oe.charCodeAt(++it);Je=65536+((Je&1023)<<10)|hn&1023}if(Je<=127){if(Oe>=Pt)break;ve[Oe++>>>0]=Je}else if(Je<=2047){if(Oe+1>=Pt)break;ve[Oe++>>>0]=192|Je>>6,ve[Oe++>>>0]=128|Je&63}else if(Je<=65535){if(Oe+2>=Pt)break;ve[Oe++>>>0]=224|Je>>12,ve[Oe++>>>0]=128|Je>>6&63,ve[Oe++>>>0]=128|Je&63}else{if(Oe+3>=Pt)break;ve[Oe++>>>0]=240|Je>>18,ve[Oe++>>>0]=128|Je>>12&63,ve[Oe++>>>0]=128|Je>>6&63,ve[Oe++>>>0]=128|Je&63}}return ve[Oe>>>0]=0,Oe-Gt}function D(oe,ve,Oe){return _(oe,B,ve,Oe)}var j,q,B,Q;function H(oe){j=oe,s.HEAP8=q=new Int8Array(oe),s.HEAP16=new Int16Array(oe),s.HEAP32=new Int32Array(oe),s.HEAPU8=B=new Uint8Array(oe),s.HEAPU16=new Uint16Array(oe),s.HEAPU32=Q=new Uint32Array(oe),s.HEAPF32=new Float32Array(oe),s.HEAPF64=new Float64Array(oe)}s.INITIAL_MEMORY;var J=[],ae=[],ne=[];function ue(){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)me(s.preRun.shift());Nn(J)}function le(){Nn(ae)}function he(){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;)Ne(s.postRun.shift());Nn(ne)}function me(oe){J.unshift(oe)}function Re(oe){ae.unshift(oe)}function Ne(oe){ne.unshift(oe)}var xe=0,Le=null;function Pe(oe){xe++,s.monitorRunDependencies&&s.monitorRunDependencies(xe)}function Xe(oe){if(xe--,s.monitorRunDependencies&&s.monitorRunDependencies(xe),xe==0&&Le){var ve=Le;Le=null,ve()}}function Ue(oe){s.onAbort&&s.onAbort(oe),oe="Aborted("+oe+")",k(oe),I=!0,oe+=". Build with -sASSERTIONS for more info.";var ve=new WebAssembly.RuntimeError(oe);throw o(ve),ve}var Et="data:application/octet-stream;base64,";function st(oe){return oe.startsWith(Et)}function bt(oe){return oe.startsWith("file://")}var je;je="tfjs-backend-wasm.wasm",st(je)||(je=f(je));function gt(oe){try{if(oe==je&&M)return new Uint8Array(M);if(y)return y(oe);throw"both async and sync fetching of the wasm failed"}catch(ve){Ue(ve)}}function Ot(){if(!M&&(u||h)){if(typeof fetch=="function"&&!bt(je))return fetch(je,{credentials:"same-origin"}).then(function(oe){if(!oe.ok)throw"failed to load wasm binary file at '"+je+"'";return oe.arrayBuffer()}).catch(function(){return gt(je)});if(g)return new Promise(function(oe,ve){g(je,function(Oe){oe(new Uint8Array(Oe))},ve)})}return Promise.resolve().then(function(){return gt(je)})}function At(){var oe={env:Au,wasi_snapshot_preview1:Au};function ve(it,Je){var hn=it.exports;s.asm=hn,S=s.asm.memory,H(S.buffer),s.asm.__indirect_function_table,Re(s.asm.__wasm_call_ctors),Xe()}Pe();function Oe(it){ve(it.instance)}function ke(it){return Ot().then(function(Je){return WebAssembly.instantiate(Je,oe)}).then(function(Je){return Je}).then(it,function(Je){k("failed to asynchronously prepare wasm: "+Je),Ue(Je)})}function Gt(){return!M&&typeof WebAssembly.instantiateStreaming=="function"&&!st(je)&&!bt(je)&&!d&&typeof fetch=="function"?fetch(je,{credentials:"same-origin"}).then(function(it){var Je=WebAssembly.instantiateStreaming(it,oe);return Je.then(Oe,function(hn){return k("wasm streaming compile failed: "+hn),k("falling back to ArrayBuffer instantiation"),ke(Oe)})}):ke(Oe)}if(s.instantiateWasm)try{var Pt=s.instantiateWasm(oe,ve);return Pt}catch(it){k("Module.instantiateWasm callback failed with error: "+it),o(it)}return Gt().catch(o),{}}function pt(oe){this.name="ExitStatus",this.message="Program terminated with exit("+oe+")",this.status=oe}function Nn(oe){for(;oe.length>0;)oe.shift()(s)}function Cn(){Ue("")}function ge(){return 4294901760}function Ze(){return ge()}function ht(oe,ve,Oe){B.copyWithin(oe>>>0,ve>>>0,ve+Oe>>>0)}function kn(oe){try{return S.grow(oe-j.byteLength+65535>>>16),H(S.buffer),1}catch{}}function vn(oe){var ve=B.length;oe=oe>>>0;var Oe=ge();if(oe>Oe)return!1;let ke=(hn,oa)=>hn+(oa-hn%oa)%oa;for(var Gt=1;Gt<=4;Gt*=2){var Pt=ve*(1+.2/Gt);Pt=Math.min(Pt,oe+100663296);var it=Math.min(Oe,ke(Math.max(oe,Pt),65536)),Je=kn(it);if(Je)return!0}return!1}function Da(oe){return 52}function ii(oe,ve,Oe,ke,Gt){return 70}var Cu=[null,[],[]];function ps(oe,ve){var Oe=Cu[oe];ve===0||ve===10?((oe===1?w:k)(R(Oe,0)),Oe.length=0):Oe.push(ve)}function Bo(oe,ve,Oe,ke){for(var Gt=0,Pt=0;Pt<Oe;Pt++){var it=Q[ve>>>2],Je=Q[ve+4>>>2];ve+=8;for(var hn=0;hn<Je;hn++)ps(oe,B[it+hn>>>0]);Gt+=Je}return Q[ke>>>2]=Gt,0}function Ga(oe){var ve=s["_"+oe];return ve}function fs(oe,ve){q.set(oe,ve>>>0)}function An(oe,ve,Oe,ke,Gt){var Pt={string:Hn=>{var gs=0;if(Hn!=null&&Hn!==0){var $u=(Hn.length<<2)+1;gs=or($u),D(Hn,gs,$u)}return gs},array:Hn=>{var gs=or(Hn.length);return fs(Hn,gs),gs}};function it(Hn){return ve==="string"?A(Hn):ve==="boolean"?!!Hn:Hn}var Je=Ga(oe),hn=[],oa=0;if(ke)for(var zs=0;zs<ke.length;zs++){var jr=Pt[Oe[zs]];jr?(oa===0&&(oa=Ki()),hn[zs]=jr(ke[zs])):hn[zs]=ke[zs]}var Uo=Je.apply(null,hn);function Du(Hn){return oa!==0&&Ru(oa),it(Hn)}return Uo=Du(Uo),Uo}function ms(oe,ve,Oe,ke){Oe=Oe||[];var Gt=Oe.every(it=>it==="number"||it==="boolean"),Pt=ve!=="string";return Pt&&Gt&&!ke?Ga(oe):function(){return An(oe,ve,Oe,arguments)}}var Au={abort:Cn,emscripten_get_heap_max:Ze,emscripten_memcpy_big:ht,emscripten_resize_heap:vn,fd_close:Da,fd_seek:ii,fd_write:Bo};At(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)};var Ki=s.stackSave=function(){return(Ki=s.stackSave=s.asm.stackSave).apply(null,arguments)},Ru=s.stackRestore=function(){return(Ru=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},or=s.stackAlloc=function(){return(or=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=ms;var Xi;Le=function oe(){Xi||Gn(),Xi||(Le=oe)};function Gn(oe){if(xe>0||(ue(),xe>0))return;function ve(){Xi||(Xi=!0,s.calledRun=!0,!I&&(le(),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),he()))}s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),ve()},1)):ve()}if(s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();Gn();var oi;l&&(oi={uncaughtException:process.listeners("uncaughtException").filter(function(oe){return!l.uncaughtException.indexOf(oe)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(oe){return!l.unhandledRejection.indexOf(oe)>-1})});var Wr;if(typeof r<"u")Wr=r;else if(typeof WasmBackendModuleThreadedSimd<"u")Wr=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(oi){var li=Wr._dispose;Wr._dispose=function(){li(),oi.uncaughtException.forEach(function(oe){process.removeListener("uncaughtException",oe)}),oi.unhandledRejection.forEach(function(oe){process.removeListener("unhandledRejection",oe)})}}return r.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),Pw=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},ob=class{refCount(e){return _r("refCount")}incRef(e){return _r("incRef")}timerAvailable(){return!0}time(e){return _r("time")}read(e){return _r("read")}readSync(e){return _r("readSync")}readToGPU(e,t){return _r("readToGPU")}numDataIds(){return _r("numDataIds")}disposeData(e,t){return _r("disposeData")}write(e,t,n){return _r("write")}move(e,t,n,a,r){return _r("move")}createTensorFromGPUData(e,t,n){return _r("createTensorFromGPUData")}memory(){return _r("memory")}floatPrecision(){return _r("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return _r("dispose")}};function _r(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Nz(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,T0(e,t,n)}function nK(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,a=0;for(;n>0;)a=Math.random()*n|0,n--,T0(e,n,a),T0(t,n,a)}function wy(e,t,n){return Math.max(e,Math.min(t,n))}function aK(e){return e%2===0?e:e+1}function T0(e,t,n){let a=e[t];e[t]=e[n],e[n]=a}function rK(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function sK(e,t){let n=Math.random();return t*n+(1-n)*e}function iK(e,t){let n=0;for(let a=0;a<e.length;a++){let r=Number(e[a])-Number(t[a]);n+=r*r}return n}function z(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function ar(e,t,n=""){z($o(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Yc(e){z(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Ut(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function oK(e){return e.length===0}function Cz(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function $o(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Wp(e){return e%1===0}function lK(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function uK(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function cK(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return Nz(t),t}function Yg(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function hK(e,t=r=>0,n,a){return new Promise((r,s)=>{let i=0,o=()=>{if(e()){r();return}i++;let l=t(i);if(n!=null&&i>=n){s();return}a!=null?a(o,l):setTimeout(o,l)};o()})}function dK(e,t){let n=1,a=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(e[s]===-1){if(a!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${a} and dim ${s}`);a=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(a===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let r=e.slice();return r[a]=t/n,r}function Os(e,t){let n=t.length;return e=e==null?t.map((a,r)=>r):[].concat(e),z(e.every(a=>a>=-n&&a<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),z(e.every(a=>Wp(a)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(a=>a<0?n+a:a)}function Az(e,t){let n=[],a=[],r=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||r?null:Os(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(n.push(e[o]),a.push(o)),s[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),a.push(o))}return{newShape:n,keptDims:a}}function Rz(e,t){return N2(e,t)}function N2(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function Dz(e,t){for(let n=0;n<e.length;n++){let a=e[n];if(isNaN(a)||!isFinite(a))throw Error(`A tensor of type ${t} being uploaded contains ${a}.`)}}function $z(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function pK(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function E0(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function Mz(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function ml(e){return typeof e=="string"||e instanceof String}function Oz(e){return typeof e=="boolean"}function Fz(e){return typeof e=="number"}function lb(e){return Array.isArray(e)?lb(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Fz(e)?"float32":ml(e)?"string":Oz(e)?"bool":"float32"}function Vl(e){return!!(e&&e.constructor&&e.call&&e.apply)}function N0(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function _f(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function Lz(e,t,n,a=!1){let r=new Array;if(t.length===1){let s=t[0]*(a?2:1);for(let i=0;i<s;i++)r[i]=n[e+i]}else{let s=t[0],i=t.slice(1),o=i.reduce((l,c)=>l*c)*(a?2:1);for(let l=0;l<s;l++)r[l]=Lz(e+l*o,i,n,a)}return r}function Ip(e,t,n=!1){if(e.length===0)return t[0];let a=e.reduce((r,s)=>r*s)*(n?2:1);if(a===0)return[];if(a!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Lz(0,e,t,n)}function fK(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function C2(e,t){let n=Vw(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function Vw(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function mK(e,t){let n=e.reduce((a,r)=>a*r,1);if(t==null||t==="float32")return Ip(e,new Float32Array(n));if(t==="int32")return Ip(e,new Int32Array(n));if(t==="bool")return Ip(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Ur(e){e.forEach(t=>{z(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function gK(e,t,n){if(t===0)return 0;if(t===1)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function yK(e,t,n){if(t===0)return[];if(t===1)return[e];let a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function Bw(e){return e&&e.then&&typeof e.then=="function"}var x$="tfjsflags",zz=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=bK,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Z().getBool("IS_TEST")||Z().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let a=this.urlFlags[e];Z().getBool("IS_TEST")||Z().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${a}.`),this.set(e,a)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Bw(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);x$ in e&&e[x$].split(",").forEach(t=>{let[n,a]=t.split(":");this.urlFlags[n]=xK(n,a)})}};function bK(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...a)=>(vK(t,a[0],a[1]),a.join("="))),t}function vK(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function xK(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function Z(){return A2}var A2=null;function wK(e){A2=e}var _S;function Pz(){if(_S==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");_S=e}return _S}function _K(){let e=Pz();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function R2(e,t){let n=_K();if(n.has(e))return n.get(e);{let a=t();return n.set(e,a),n.get(e)}}var Sf="Abs",Zc="Acos",Jc="Acosh",hu="Add",eh="AddN",If="All",kf="Any",Tf="ArgMax",Ef="ArgMin",th="Asin",nh="Asinh",ah="Atan",rh="Atanh",sh="Atan2",ih="AvgPool",ub="AvgPoolGrad",Nf="AvgPool3D",cb="AvgPool3DGrad",oh="BatchMatMul",Cf="BatchToSpaceND",Af="Bincount",Rf="BitwiseAnd",Vz="BroadcastTo",hb="BroadcastArgs",lh="Cast",uh="Ceil",du="ClipByValue",Uw="Complex",db="ComplexAbs",Df="Concat",ch="Conv2D",Ww="Conv2DBackpropFilter",hh="Conv2DBackpropInput",dh="Conv3D",$f="Conv3DBackpropFilterV2",Mf="Conv3DBackpropInputV2",ph="Cos",fh="Cosh",Of="Cumprod",mh="Cumsum",Ff="CropAndResize",pb="DenseBincount",Lf="DepthToSpace",gh="DepthwiseConv2dNative",jw="DepthwiseConv2dNativeBackpropFilter",Gw="DepthwiseConv2dNativeBackpropInput",fb="Diag",yh="Dilation2D",jp="Dilation2DBackpropInput",Gp="Dilation2DBackpropFilter",Hw="Draw",bh="RealDiv",qw="Einsum",vh="Elu",zf="EluGrad",xh="Erf",Pf="Equal",wh="Exp",Vf="ExpandDims",_h="Expm1",Kw="FFT",mb="Fill",Bf="FlipLeftRight",Sh="Floor",Ih="FloorDiv",kh="FusedBatchNorm",Uf="GatherV2",Wf="GatherNd",jf="Greater",Th="GreaterEqual",Eh="Identity",Xw="IFFT",Qw="Imag",Nh="IsFinite",Ch="IsInf",Ah="IsNan",Rh="LeakyRelu",Gf="Less",Hf="LessEqual",qf="LinSpace",Dh="Log",$h="Log1p",Kf="LogicalAnd",Xf="LogicalNot",Qf="LogicalOr",Bz="LogicalXor",Uz="LogSoftmax",SK="LowerBound",Mh="LRN",Yf="LRNGrad",IK="MatrixBandPart",Oh="Max",Fh="Maximum",Lh="MaxPool",gb="MaxPoolGrad",Zf="MaxPool3D",yb="MaxPool3DGrad",bb="MaxPoolWithArgmax",zh="Mean",Ph="Min",Vh="Minimum",Bh="MirrorPad",Uh="Mod",Jf="Multinomial",Wh="Multiply",em="Neg",tm="NotEqual",nm="NonMaxSuppressionV3",am="NonMaxSuppressionV4",rm="NonMaxSuppressionV5",sm="OnesLike",jh="OneHot",im="Pack",Gh="PadV2",kK="Pool",Hh="Pow",qh="Prelu",Kh="Prod",Yw="RaggedGather",Zw="RaggedRange",Jw="RaggedTensorToTensor",vb="Range",e1="Real",Xh="Reciprocal",Qh="Relu",om="Reshape",Yh="ResizeNearestNeighbor",lm="ResizeNearestNeighborGrad",Zh="ResizeBilinear",um="ResizeBilinearGrad",Jh="Relu6",ed="Reverse",td="Round",nd="Rsqrt",cm="ScatterNd",hm="TensorScatterUpdate",dm="SearchSorted",pm="Select",ad="Selu",fm="Slice",rd="Sin",sd="Sinh",id="Sign",od="Sigmoid",ld="Softplus",ud="Sqrt",cd="Sum",mm="SpaceToBatchND",gm="SplitV",hd="Softmax",xb="SparseFillEmptyRows",ym="SparseReshape",wb="SparseSegmentMean",_b="SparseSegmentSum",bm="SparseToDense",dd="SquaredDifference",Sb="Square",Ib="StaticRegexReplace",vm="StridedSlice",kb="StringNGrams",Tb="StringSplit",Eb="StringToHashBucketFast",pd="Sub",fd="Tan",md="Tanh",pu="Tile",xm="TopK",wm="Transform",bo="Transpose",Nb="Unique",_m="Unpack",Cb="UnsortedSegmentSum",TK="UpperBound",Sm="ZerosLike",fu="Step",C0="FromPixels",Im="RotateWithOffset",Ic="_FusedMatMul",kc="FusedConv2D",Tc="FusedDepthwiseConv2D";function ul(...e){Z().getBool("IS_TEST")||Z().getBool("PROD")||console.warn(...e)}function EK(...e){Z().getBool("IS_TEST")||Z().getBool("PROD")||console.log(...e)}var Hp=R2("kernelRegistry",()=>new Map),_y=R2("gradRegistry",()=>new Map);function Sy(e,t){let n=D2(e,t);return Hp.get(n)}function KI(e){return _y.get(e)}function A0(e){let t=Hp.entries(),n=[];for(;;){let{done:a,value:r}=t.next();if(a)break;let[s,i]=r,[o]=s.split("_");o===e&&n.push(i)}return n}function Ab(e){let{kernelName:t,backendName:n}=e,a=D2(t,n);Hp.has(a)&&ul(`The kernel '${t}' for backend '${n}' is already registered`),Hp.set(a,e)}function Wz(e){let{kernelName:t}=e;_y.has(t)&&Z().getBool("DEBUG")&&ul(`Overriding the gradient for '${t}'`),_y.set(t,e)}function NK(e,t){let n=D2(e,t);if(!Hp.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Hp.delete(n)}function CK(e){if(!_y.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);_y.delete(e)}function AK(e,t){A0(e).forEach(n=>{let a=Object.assign({},n,{backendName:t});Ab(a)})}function D2(e,t){return`${t}_${e}`}var N={};tt(N,{arraysEqual:()=>$o,arraysEqualWithNull:()=>Cz,assert:()=>z,assertNonNegativeIntegerDimensions:()=>Ur,assertNonNull:()=>Yc,assertShapesMatch:()=>ar,bytesFromStringArray:()=>Mz,bytesPerElement:()=>E0,checkConversionForErrors:()=>Dz,clamp:()=>wy,computeStrides:()=>_f,convertBackendValuesAndArrayBuffer:()=>fK,createScalarValue:()=>FK,createShuffledIndices:()=>cK,decodeString:()=>R0,distSquared:()=>iK,encodeString:()=>Db,fetch:()=>zK,fingerPrint64:()=>OK,flatten:()=>Bl,getArrayFromDType:()=>N2,getTypedArrayFromDType:()=>Rz,hasEncodingLoss:()=>pK,hexToLong:()=>Rb,indexToLoc:()=>yK,inferDtype:()=>lb,inferFromImplicitShape:()=>dK,isBoolean:()=>Oz,isFunction:()=>Vl,isInt:()=>Wp,isNumber:()=>Fz,isPromise:()=>Bw,isScalarShape:()=>oK,isString:()=>ml,isTypedArray:()=>da,isValidDtype:()=>$z,locToIndex:()=>gK,makeOnesTypedArray:()=>C2,makeZerosNestedTypedArray:()=>mK,makeZerosTypedArray:()=>Vw,nearestDivisor:()=>N0,nearestLargerEven:()=>aK,now:()=>Iy,parseAxisParam:()=>Os,randUniform:()=>sK,repeatedTry:()=>hK,rightPad:()=>Yg,shuffle:()=>Nz,shuffleCombo:()=>nK,sizeFromShape:()=>Ut,sizeToSquarishShape:()=>uK,squeezeShape:()=>Az,sum:()=>rK,swap:()=>T0,tanh:()=>lK,toNestedArray:()=>Ip,toTypedArray:()=>t1});function jz(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var w$=cu(P7()),tc=w$.default||w$;function Rb(e){return tc.fromString(e,!0,16)}var Gz=Rb("c3a5c85c97cb3127"),Yu=Rb("b492b66fbe98f273"),Ka=Rb("9ae16a3b2f90404f");function XI(e){return e.xor(e.shru(47))}function Hz(e,t,n){let a=e.slice(t,t+n);return tc.fromBytes(Array.from(a),!0,!0)}function rn(e,t){return Hz(e,t,8)}function _$(e,t){return Hz(e,t,4)}function ha(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Cl(e,t,n=Rb("9ddfea08eb382d69")){let a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function RK(e,t,n,a,r,s){r=r.add(e),s=ha(s.add(r).add(a),21);let i=r;return r=r.add(t),r=r.add(n),s=s.add(ha(r,44)),[r.add(a),s.add(i)]}function Yv(e,t,n,a){return RK(rn(e,t),rn(e,t+8),rn(e,t+16),rn(e,t+24),n,a)}function DK(e,t=e.length){if(t>=8){let n=Ka.add(t*2),a=rn(e,0).add(Ka),r=rn(e,t-8),s=ha(r,37).mul(n).add(a),i=ha(a,25).add(r).mul(n);return Cl(s,i,n)}if(t>=4){let n=Ka.add(t*2),a=_$(e,0);return Cl(a.shl(3).add(t),_$(e,t-4),n)}if(t>0){let n=e[0],a=e[t>>1],r=e[t-1],s=n+(a<<8),i=t+(r<<2);return XI(Ka.mul(s).xor(Gz.mul(i))).mul(Ka)}return Ka}function $K(e,t=e.length){let n=Ka.add(t*2),a=rn(e,0).mul(Yu),r=rn(e,8),s=rn(e,t-8).mul(n),i=rn(e,t-16).mul(Ka);return Cl(ha(a.add(r),43).add(ha(s,30)).add(i),a.add(ha(r.add(Ka),18)).add(s),n)}function MK(e,t=e.length){let n=Ka.add(t*2),a=rn(e,0).mul(Ka),r=rn(e,8),s=rn(e,t-8).mul(n),i=rn(e,t-16).mul(Ka),o=ha(a.add(r),43).add(ha(s,30)).add(i),l=Cl(o,a.add(ha(r.add(Ka),18)).add(s),n),c=rn(e,16).mul(n),u=rn(e,24),h=o.add(rn(e,t-32)).mul(n),d=l.add(rn(e,t-24)).mul(n);return Cl(ha(c.add(u),43).add(ha(h,30)).add(d),c.add(ha(u.add(a),18)).add(h),n)}function OK(e,t=e.length){let n=tc.fromNumber(81,!0);if(t<=32)return t<=16?DK(e,t):$K(e,t);if(t<=64)return MK(e,t);let a=n,r=n.mul(Yu).add(113),s=XI(r.mul(Ka).add(113)).mul(Ka),i=[tc.UZERO,tc.UZERO],o=[tc.UZERO,tc.UZERO];a=a.mul(Ka).add(rn(e,0));let l=0,c=(t-1>>6)*64,u=c+(t-1&63)-63;do a=ha(a.add(r).add(i[0]).add(rn(e,l+8)),37).mul(Yu),r=ha(r.add(i[1]).add(rn(e,l+48)),42).mul(Yu),a=a.xor(o[1]),r=r.add(i[0]).add(rn(e,l+40)),s=ha(s.add(o[0]),33).mul(Yu),i=Yv(e,l,i[1].mul(Yu),a.add(o[0])),o=Yv(e,l+32,s.add(o[1]),r.add(rn(e,l+16))),[s,a]=[a,s],l+=64;while(l!==c);let h=Yu.add(s.and(255).shl(1));return l=u,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),a=ha(a.add(r).add(i[0]).add(rn(e,l+8)),37).mul(h),r=ha(r.add(i[1]).add(rn(e,l+48)),42).mul(h),a=a.xor(o[1].mul(9)),r=r.add(i[0].mul(9).add(rn(e,l+40))),s=ha(s.add(o[0]),33).mul(h),i=Yv(e,l,i[1].mul(h),a.add(o[0])),o=Yv(e,l+32,s.add(o[1]),r.add(rn(e,l+16))),[s,a]=[a,s],Cl(Cl(i[0],o[0],h).add(XI(r).mul(Gz)).add(s),Cl(i[1],o[1],h).add(a),h)}function FK(e,t){return t==="string"?Db(e):t1([e],t)}function LK(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function t1(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Bl(e)),Z().getBool("DEBUG")&&Dz(e,t),LK(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let a=0;a<n.length;++a)Math.round(e[a])!==0&&(n[a]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Iy(){return Z().platform.now()}function zK(e,t){return Z().platform.fetch(e,t)}function Db(e,t="utf-8"){return t=t||"utf-8",Z().platform.encode(e,t)}function R0(e,t="utf-8"){return t=t||"utf-8",Z().platform.decode(e,t)}function da(e){return Z().platform.isTypedArray!=null?Z().platform.isTypedArray(e):jz(e)}function Bl(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||Bw(e)||e==null||da(e)&&n)t.push(e);else if(Array.isArray(e)||da(e))for(let a=0;a<e.length;++a)Bl(e[a],t,n);else{let a=-1;for(let r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(a=Math.max(a,Number(r)));for(let r=0;r<=a;r++)Bl(e[r],t,n)}return t}var PK=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new BK)}profileKernel(e,t,n){let a,r=()=>{a=n()},s,i=Iy();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(let o of a)o.dataSync();s=Promise.resolve({kernelMs:Iy()-i})}if(Z().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<a.length;o++){let l=a[o];l.data().then(c=>{VK(c,l.dtype,e)})}return{kernelName:e,outputs:a,inputs:t,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach(i=>{Promise.all([i.data(),a,s]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],r,o[2])})})}};function VK(e,t,n){if(t!=="float32")return!1;for(let a=0;a<e.length;a++){let r=e[a];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}var BK=class{logKernelProfile(e,t,n,a,r,s){let i=typeof a=="number"?Yg(`${a}ms`,9):a.error,o=Yg(e,25),l=t.rank,c=t.size,u=Yg(t.shape.toString(),14),h="";for(let d in r){let p=r[d];if(p!=null){let f=p.shape||t.shape,m=f.length;h+=`${d}: ${m}D ${m>0?f:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${u}	%c${c}	%c${h}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function UK(e,t,n){let a={},r={};for(let l=0;l<t.length;l++)a[t[l].id]=!0;for(let l=0;l<e.length;l++){let c=e[l],u=c.inputs;for(let h in u){let d=u[h],p=!1;for(let f=0;f<t.length;f++)if(a[d.id]){c.outputs.forEach(m=>a[m.id]=!0),p=!0,r[c.id]=!0;break}if(p)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let c=e[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(s[c.outputs[h].id]){for(let d in u)s[u[d].id]=!0,i[c.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let c=e[l];if(r[c.id]&&i[c.id]){let u={};for(let d in c.inputs){let p=c.inputs[d];a[p.id]&&(u[d]=p)}let h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,o.push(h)}}return o}function WK(e,t,n,a){for(let r=t.length-1;r>=0;r--){let s=t[r],i=[];if(s.outputs.forEach(l=>{let c=e[l.id];c!=null?i.push(c):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let c=n(()=>o[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);let u=s.inputs[l];if(!$o(c.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(e[u.id]==null)e[u.id]=c;else{let h=e[u.id];e[u.id]=a(h,c),h.dispose()}}}}var S$=20,pg=3,SS=7;function jK(e,t,n,a){let r=_f(t),s=GK(e,t,n,r),i=t.length,o=Fx(e,t,n,r,s),l=["Tensor"];return a&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(c=>"    "+c).join(`
`)),l.join(`
`)}function GK(e,t,n,a){let r=Ut(t),s=a[a.length-1],i=new Array(s).fill(0),o=t.length,l=n==="complex64"?Ig(e):e;if(o>1)for(let c=0;c<r/s;c++){let u=c*s;for(let h=0;h<s;h++)i[h]=Math.max(i[h],Sg(l[u+h],0,n).length)}return i}function Sg(e,t,n){let a;return Array.isArray(e)?a=`${parseFloat(e[0].toFixed(SS))} + ${parseFloat(e[1].toFixed(SS))}j`:ml(e)?a=`'${e}'`:n==="bool"?a=qz(e):a=parseFloat(e.toFixed(SS)).toString(),Yg(a,t)}function qz(e){return e===0?"false":"true"}function Fx(e,t,n,a,r,s=!0){let i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){let m=Ig(e);return[Sg(m[0],0,n)]}return n==="bool"?[qz(e[0])]:[e[0].toString()]}if(l===1){if(o>S$){let m=pg*i,g=Array.from(e.slice(0,m)),y=Array.from(e.slice((o-pg)*i,o*i));return n==="complex64"&&(g=Ig(g),y=Ig(y)),["["+g.map((v,x)=>Sg(v,r[x],n)).join(", ")+", ..., "+y.map((v,x)=>Sg(v,r[o-pg+x],n)).join(", ")+"]"]}return["["+(n==="complex64"?Ig(e):Array.from(e)).map((m,g)=>Sg(m,r[g],n)).join(", ")+"]"]}let c=t.slice(1),u=a.slice(1),h=a[0]*i,d=[];if(o>S$){for(let m=0;m<pg;m++){let g=m*h,y=g+h;d.push(...Fx(e.slice(g,y),c,n,u,r,!1))}d.push("...");for(let m=o-pg;m<o;m++){let g=m*h,y=g+h;d.push(...Fx(e.slice(g,y),c,n,u,r,m===o-1))}}else for(let m=0;m<o;m++){let g=m*h,y=g+h;d.push(...Fx(e.slice(g,y),c,n,u,r,m===o-1))}let p=l===2?",":"";d[0]="["+(o>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function Ig(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Vn=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Ut(e),n!=null){let a=n.length;z(a===this.size,()=>`Length of values '${a}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||N2(t,this.size),this.strides=_f(e)}set(e,...t){t.length===0&&(t=[0]),z(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let a of e){if(a<0||a>=this.shape[t]){let r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let n=e[e.length-1];for(let a=0;a<e.length-1;++a)n+=this.strides[a]*e[a];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return qs().makeTensor(this.values,this.shape,this.dtype)}},qs=null,Yd=null;function HK(e){qs=e}function qK(e){Yd=e}var at=class{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ut(e),this.strides=_f(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Yd.buffer(this.shape,this.dtype,e)}bufferSync(){return Yd.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Ip(this.shape,e,this.dtype==="complex64")}arraySync(){return Ip(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=qs().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>R0(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),qs().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=qs().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>R0(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await qs().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),qs().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Yd.print(this,e)}clone(){return this.throwIfDisposed(),Yd.clone(this)}toString(e=!1){let t=this.dataSync();return jK(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Yd.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),qs().makeVariable(this,e,t,n)}};Object.defineProperty(at,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function ie(){return R2("Tensor",()=>at)}ie();var Ec=class extends at{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!$o(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);qs().disposeTensor(this),this.dataId=e.dataId,qs().incRef(this,null)}dispose(){qs().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Ec,Symbol.hasInstance,{value:e=>e instanceof at&&e.assign!=null&&e.assign instanceof Function});var Ks={};tt(Ks,{assertTypesMatch:()=>Qz,getTensorsInContainer:()=>$2,isTensorInList:()=>XK,makeTypesMatch:()=>In});var QI;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(QI||(QI={}));var YI;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(YI||(YI={}));var ZI;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(ZI||(ZI={}));var JI;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(JI||(JI={}));var ek;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(ek||(ek={}));var KK={float32:JI,int32:YI,bool:ZI,complex64:ek};function us(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return KK[e][t]}function n1(e){return us(e,"int32")}function Kz(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function Xz(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function In(e,t){if(e.dtype===t.dtype)return[e,t];let n=us(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Qz(e,t){z(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function XK(e,t){return t.some(n=>n.id===e.id)}function $2(e){let t=[];return Yz(e,t,new Set),t}function Yz(e,t,n){if(e==null)return;if(e instanceof at){t.push(e);return}if(!QK(e))return;let a=e;for(let r in a){let s=a[r];n.has(s)||(n.add(s),Yz(s,t,n))}}function QK(e){return Array.isArray(e)||typeof e=="object"}function IS(e){return e.kernelName!=null}var I$=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},M2=class tk{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new I$}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n];if(await this.initializeBackend(a).success){await this.setBackend(a);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,a=1){return t in this.registryFactory?(ul(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:a},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:a}=this.initializeBackend(t);if(!(a?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new PK(this.backendInstance),!0}setupRegisteredKernels(){A0(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){A0(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let a=n.factory();if(a&&!(a instanceof ob)&&typeof a.then=="function"){let r=++this.pendingBackendInitId,s=a.then(i=>r<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,ul(`Initialization of backend ${t} failed`),ul(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=a,{success:!0,asyncInit:!1}}catch(a){return ul(`Initialization of backend ${t} failed`),ul(a.stack||a.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n],{success:r,asyncInit:s}=this.initializeBackend(a);if(s||r)return{name:a,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let a=this.state.tensorInfo.get(n),r=a.backend,s=this.readSync(n),i=r.refCount(n);r.disposeData(n,!0),a.backend=t,t.move(n,s,a.shape,a.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let a=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=t}let r;return this.scopedRun(()=>this.startScope(a),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,n,a){t();try{let r=a();return n(),r}catch(r){throw n(),r}}nextTensorId(){return tk.nextTensorId++}nextVariableId(){return tk.nextVariableId++}clone(t){let n=U.runKernel(Eh,{x:t}),a={x:t},r=i=>({x:()=>{let o="float32",l={x:i},c={dtype:o};return U.runKernel(lh,l,c)}}),s=[];return this.addTapeNode(this.state.activeScope.name,a,[n],r,s,{}),n}runKernel(t,n,a){if(this.backendName==null&&this.backend,Sy(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:a})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,a){let r=this.backend.numDataIds(),s=0;a.forEach(l=>{s+=l.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-n-s-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,a=[],r=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l,c=IS(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(IS(t)){let{kernelName:f,inputs:m,attrs:g}=t;this.backendName==null&&this.backend;let y=Sy(f,this.backendName);z(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{let v=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});let x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,v,x);let w=x.map(k=>k.rank!=null?k:this.makeTensorFromTensorInfo(k));if(r){let k=this.getTensorsForGradient(f,m,w);a=this.saveTensorsForBackwardMode(k)}return w}}else{let{forwardFunc:f}=t,m=g=>{r&&(a=g.map(y=>this.keep(this.clone(y))))};o=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));let y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}let{inputs:u,attrs:h}=t,d=IS(t)?null:t.backwardsFunc,p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(p=this.profiler.profileKernel(c,u,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),r&&this.addTapeNode(c,u,n,d,a,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,a){let r=KI(t);if(r!=null){let s=r.inputsToSave||[],i=r.outputsToSave||[],o;r.saveAllInputs?(z(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(c=>n[c])):o=s.map(c=>n[c]);let l=a.filter((c,u)=>i[u]);return o.concat(l)}return[]}makeTensor(t,n,a,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");a=a||"float32",r=r||this.backend;let s=t;a==="string"&&ml(t[0])&&(s=t.map(l=>Db(l)));let i=r.write(s,n,a),o=new at(n,a,i,this.nextTensorId());if(this.trackTensor(o,r),a==="string"){let l=this.state.tensorInfo.get(i),c=Mz(s);this.state.numBytes+=c-l.bytes,l.bytes=c}return o}makeTensorFromDataId(t,n,a,r){a=a||"float32";let s={dataId:t,shape:n,dtype:a};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(t,n){let{dataId:a,shape:r,dtype:s}=t,i=new at(r,s,a,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,a,r){a=a||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));let s=new Ec(t,n,a,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let a=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(a=t.size*E0(t.dtype)),this.state.numBytes+=a,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:a})),t instanceof Ec||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let a=t.size*E0(t.dtype);this.state.numBytes-=a}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,a=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-a;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,a,r,s,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:a,saved:s},l=KI(t);l!=null&&(r=l.gradFunc),r!=null&&(o.gradient=c=>(c=c.map((u,h)=>{if(u==null){let d=a[h],p=Vw(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return u}),r(c.length>1?c:c[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=$2(t),a=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!a.has(i.id)&&i.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(t,n,a,r=!1){if(z(n.length>0,()=>"gradients() received an empty list of xs."),a!=null&&a.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${a.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));z(s instanceof at,()=>"The result y returned by f() must be a tensor.");let i=UK(this.state.activeTape,n,s);if(!r&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[s.id]=a??YK(s.shape),WK(o,i,c=>this.tidy(c),ZK);let l=n.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(let u of c.saved)u.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(t){return z(Vl(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{z(n.every(o=>o instanceof at),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let a,r={};n.forEach((o,l)=>{r[l]=o});let s=(o,l)=>(a=t(...n,l),z(a.value instanceof at,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),z(Vl(a.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),a.value),i=(o,l)=>{let c=a.gradFunc(o,l),u=Array.isArray(c)?c:[c];z(u.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),z(u.every(d=>d instanceof at),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let h={};return u.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=Iy(),a=await this.backend.time(t);return a.wallMs=Iy()-n,a}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new I$;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};M2.nextTensorId=0;M2.nextVariableId=0;function YK(e){let t=C2(Ut(e),"float32");return U.makeTensor(t,e,"float32")}function Zz(){let e=Pz();if(e._tfengine==null){let t=new zz(e);e._tfengine=new M2(t)}return wK(e._tfengine.ENV),HK(()=>e._tfengine),e._tfengine}var U=Zz();function ZK(e,t){let n={a:e,b:t};return U.runKernel(hu,n)}var $b={};tt($b,{isBrowser:()=>Jz,isMobile:()=>tX,mockIsMobile:()=>eX});function JK(){return typeof navigator<"u"&&navigator!=null}var nk;function eX(e){nk=e}function tX(e){if(nk!==void 0)return nk;if(e||JK()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Jz(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var gr=Z();gr.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});gr.registerFlag("IS_BROWSER",()=>Jz());gr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");gr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));gr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));gr.registerFlag("PROD",()=>!1);gr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>gr.getBool("DEBUG"));gr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);gr.registerFlag("IS_TEST",()=>!1);gr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>gr.getBool("DEBUG"));gr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);gr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);gr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Fi(e,t){let n=e;if(da(e))return t==="string"?[]:[e.length];if(Kz(e)){let r=e.channels||"RGBA";return[e.height,e.width*r.length]}else if(Xz(e))return[e.buffer.size/(t==null?4:E0(t))];if(!Array.isArray(e))return[];let a=[];for(;Array.isArray(n)||da(n)&&t!=="string";)a.push(n.length),n=n[0];return Array.isArray(e)&&Z().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&e4(e,a,[]),a}function e4(e,t,n){if(n=n||[],!Array.isArray(e)&&!da(e)){z(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}z(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),z(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let a=t.slice(1);for(let r=0;r<e.length;++r)e4(e[r],a,n.concat(r))}function k$(e,t,n,a){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${a}' must be ${e} tensor, but got ${t} tensor`)}}function F(e,t,n,a="numeric"){if(e instanceof ie())return k$(a,e.dtype,t,n),e;let r=lb(e);if(r!=="string"&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),k$(a,r,t,n),e==null||!da(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let s=Fi(e,r);!da(e)&&!Array.isArray(e)&&(e=[e]);let i=r!=="string"?t1(e,r):Bl(e,[],!0);return U.makeTensor(i,s,r)}function ky(e,t,n,a="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((r,s)=>F(r,`${t}[${s}]`,n,a))}var O2="__op";function W(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+O2;let r=(...s)=>{U.startScope(n);try{let i=a(...s);return Bw(i)&&console.error("Cannot return a Promise inside of tidy."),U.endScope(i),i}catch(i){throw U.endScope(null),i}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}function nX(e,t){let n=F(e,"real","complex"),a=F(t,"imag","complex");ar(n.shape,a.shape,`real and imag shapes, ${n.shape} and ${a.shape}, must match in call to tf.complex().`);let r={real:n,imag:a};return U.runKernel(Uw,r)}var Eo=W({complex_:nX});function mu(e,t,n,a){if(a==null)a=lb(e);else if(a==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Xz(e)||Kz(e)){if(a!=="float32"&&a!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${a}.`);return U.backend.createTensorFromGPUData(e,t||n,a)}if(!da(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Ur(t);let r=Ut(t),s=Ut(n);z(r===s,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${s}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==Ut(t.slice(i)):!0;z(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!da(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=a!=="string"?t1(e,a):Bl(e,[],!0),U.makeTensor(e,t,a)}function Za(e,t,n){let a=Fi(e,n);return mu(e,t,a,n)}var Nc={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Mo=class t4{static join(t){return new t4(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(a=>da(a)?a.buffer:a),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let a=0;a<t.length;a++){let r=t[a];a!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=n+r.byteLength;this.shards.push({buffer:r,start:n,end:s}),n=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let a=this.findShardForByte(t);if(a===-1)throw new Error(`Could not find start shard for byte ${t}`);let r=n-t,s=new ArrayBuffer(r),i=new Uint8Array(s),o=0;for(let l=a;l<this.shards.length;l++){let c=this.shards[l],u=t+o-c.start,h=o,d=Math.min(n,c.end)-c.start,p=new Uint8Array(c.buffer,u,d-u);if(i.set(p,h),o+=p.length,n<c.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(r){return t<r.start?-1:t>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let a=aX(this.shards,n);return a===-1?-1:(this.previousShardIndex=a,this.previousShardIndex)}};function aX(e,t){let n=0,a=e.length;for(;n<=a;){let r=Math.floor((a-n)/2)+n,s=t(e[r]);if(s===0)return r;s<0?a=r:n=r+1}return-1}function rX(){Z().set("PROD",!0)}function sX(){Z().set("DEBUG",!0)}function iX(){Z().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function n4(e){Z().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function oX(){U.disposeVariables()}function xs(){return U}function ak(){return U.memory()}function lX(e){return U.profile(e)}function X(e,t){return U.tidy(e,t)}function et(e){$2(e).forEach(t=>t.dispose())}function Jn(e){return U.keep(e)}function uX(e){return U.time(e)}function cX(e){return U.setBackend(e)}function hX(){return U.ready()}function a4(){return U.backendName}function dX(e){U.removeBackend(e)}function pX(e){return U.findBackend(e)}function fX(e){return U.findBackendFactory(e)}function a1(e,t,n=1){return U.registerBackend(e,t,n)}function F2(){return U.backend}function mX(e,t){Z().setPlatform(e,t)}var Ul=4;async function gX(e,t){let n=[],a=[],r=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<r.length;++i){let o=r[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let c={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let u=new Promise(async h=>{let d=await l.bytes(),p=d.reduce((g,y)=>g+y.length,0)+Ul*d.length,f=new Uint8Array(p),m=0;for(let g=0;g<d.length;g++){let y=d[g],v=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(v,m),m+=Ul,f.set(y,m),m+=y.length}h(f)});a.push(u)}else a.push(l.data());t!=null&&(c.group=t),n.push(c)}let s=await Promise.all(a);return{data:vX(s),specs:n}}function r4(e,t){let n=new Mo(e),a={},r=0;for(let s of t){let i=yX(s,(o,l)=>n.slice(r+o,r+l));a[s.name]=s4(s,n.slice(r,r+i)),r+=i}return a}function yX(e,t){let n=Ut(e.shape),a;if("quantization"in e){let r=e.quantization;a=Nc[r.dtype]}else if(e.dtype==="string"){let r=0;for(let s=0;s<n;s++)r+=Ul+new Uint32Array(t(r,r+Ul))[0];return r}else a=Nc[e.dtype];return n*a}async function bX(e,t){let n=Ut(e.shape),a;if("quantization"in e){let r=e.quantization;a=Nc[r.dtype]}else if(e.dtype==="string"){let r=0;for(let s=0;s<n;s++)r+=Ul+new Uint32Array(await t(r,r+Ul))[0];return r}else a=Nc[e.dtype];return n*a}function s4(e,t){let n=e.name,a=e.dtype,r=e.shape,s=Ut(r),i,o=0;if("quantization"in e){let l=e.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let c=Nc[l.dtype],u=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(a==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(u.length);for(let h=0;h<u.length;h++){let d=u[h];i[h]=d*l.scale+l.min}}else if(l.dtype==="float16")i=TX()(u);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(a==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let h=0;h<u.length;h++){let d=u[h];i[h]=Math.round(d*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*c}else if(a==="string"){let l=Ut(e.shape);i=[];for(let c=0;c<l;c++){let u=new Uint32Array(t.slice(o,o+Ul))[0];o+=Ul;let h=new Uint8Array(t.slice(o,o+u));i.push(h),o+=u}}else{let l=Nc[a];if(a==="float32")i=new Float32Array(t);else if(a==="int32")i=new Int32Array(t);else if(a==="bool")i=new Uint8Array(t);else if(a==="complex64"){i=new Float32Array(t);let c=new Float32Array(i.length/2),u=new Float32Array(i.length/2);for(let f=0;f<c.length;f++)c[f]=i[f*2],u[f]=i[f*2+1];let h=Za(c,r,"float32"),d=Za(u,r,"float32"),p=Eo(h,d);return h.dispose(),d.dispose(),p}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*l}return Za(i,r,a)}async function T$(e,t,n){let a=new Uint8Array(t);for(;a.byteLength<n;){let{done:r,value:s}=await e.read();if(r&&s==null){let o=n-a.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(a.length+s.byteLength);i.set(a,0),i.set(new Uint8Array(s),a.length),a=i}return a.buffer}async function i4(e,t){let n={},a=e.getReader(),r=new ArrayBuffer(0);for(let s of t){let i=await bX(s,async(c,u)=>(r=await T$(a,r,u),r.slice(c,u)));r=await T$(a,r,i);let o=r.slice(0,i);r=r.slice(i);let l=s4(s,o);if(n[s.name]=l,a4()==="webgpu"){let c=F2();"uploadToGPU"in c&&Ut(l.shape)>=Z().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return n}function vX(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(s=>{if(t+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let a=new Uint8Array(t),r=0;return n.forEach(s=>{a.set(new Uint8Array(s.buffer),r),r+=s.byteLength}),a.buffer}var L2=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function E$(e){return L2?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function xX(e){if(L2)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}function wX(e){if(L2){let a=Buffer.from(e,"base64");return a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}function _X(e){return Mo.join(e)}function N$(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function o4(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function l4(e,t,n){let a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(a.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return e.signature!=null&&(a.signature=e.signature),e.userDefinedMetadata!=null&&(a.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(a.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(a.initializerSignature=e.initializerSignature),a}async function z2(e,t){let n,a;return e.weightsManifest!=null&&([n,a]=await t(e.weightsManifest)),l4(e,n,a)}function Mb(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:E$(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:E$(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new Mo(e.weightData).byteLength}}function rk(e){let t=[];for(let n of e)t.push(...n.weights);return t}function SX(){let e=n=>{let a=n<<13,r=0;for(;!(a&8388608);)r-=8388608,a<<=1;return a&=-8388609,r+=947912704,a|r},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function IX(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function kX(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function TX(){let e=SX(),t=IX(),n=kX();return a=>{let r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let i=0;i<a.length;i++){let o=a[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];s[i]=l}return new Float32Array(r)}}var cs=class js{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return js.instance==null&&(js.instance=new js),js.instance}static registerSaveRouter(t){js.getInstance().saveRouters.push(t)}static registerLoadRouter(t){js.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return js.getHandlers(t,"save")}static getLoadHandlers(t,n){return js.getHandlers(t,"load",n)}static getHandlers(t,n,a){let r=[];return(n==="load"?js.getInstance().loadRouters:js.getInstance().saveRouters).forEach(s=>{let i=s(t,a);i!==null&&r.push(i)}),r}},EX=e=>cs.registerSaveRouter(e),NX=e=>cs.registerLoadRouter(e),CX=e=>cs.getSaveHandlers(e),AX=(e,t)=>cs.getLoadHandlers(e,t),sk="tensorflowjs",ik=1,ic="models_store",gl="model_info_store";function u4(){if(!Z().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function ok(e){let t=e.result;t.createObjectStore(ic,{keyPath:"modelPath"}),t.createObjectStore(gl,{keyPath:"modelPath"})}var Cc=class{constructor(e){if(this.indexedDB=u4(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,a)=>{let r=this.indexedDB.open(sk,ik);r.onupgradeneeded=()=>ok(r),r.onsuccess=()=>{let s=r.result;if(t==null){let i=s.transaction(ic,"readonly"),o=i.objectStore(ic).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(s.close(),a(o.error)),i.oncomplete=()=>s.close()}else{t.weightData=Mo.join(t.weightData);let i=Mb(t),o=s.transaction(gl,"readwrite"),l=o.objectStore(gl),c;try{c=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(h){return a(h)}let u;c.onsuccess=()=>{u=s.transaction(ic,"readwrite");let h=u.objectStore(ic),d;try{d=h.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(p){return a(p)}d.onsuccess=()=>n({modelArtifactsInfo:i}),d.onerror=p=>{l=o.objectStore(gl);let f=l.delete(this.modelPath);f.onsuccess=()=>(s.close(),a(d.error)),f.onerror=m=>(s.close(),a(d.error))}},c.onerror=h=>(s.close(),a(c.error)),o.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}}},r.onerror=s=>a(r.error)})}};Cc.URL_SCHEME="indexeddb://";var c4=e=>Z().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Cc.URL_SCHEME)?RX(e.slice(Cc.URL_SCHEME.length)):null;cs.registerSaveRouter(c4);cs.registerLoadRouter(c4);function RX(e){return new Cc(e)}function DX(e){return e.startsWith(Cc.URL_SCHEME)?e.slice(Cc.URL_SCHEME.length):e}var $X=class{constructor(){this.indexedDB=u4()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(sk,ik);n.onupgradeneeded=()=>ok(n),n.onsuccess=()=>{let a=n.result,r=a.transaction(gl,"readonly"),s=r.objectStore(gl).getAll();s.onsuccess=()=>{let i={};for(let o of s.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},s.onerror=i=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=a=>t(n.error)})}async removeModel(e){return e=DX(e),new Promise((t,n)=>{let a=this.indexedDB.open(sk,ik);a.onupgradeneeded=()=>ok(a),a.onsuccess=()=>{let r=a.result,s=r.transaction(gl,"readwrite"),i=s.objectStore(gl),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return r.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let c=i.delete(e),u=()=>{l=r.transaction(ic,"readwrite");let h=l.objectStore(ic).delete(e);h.onsuccess=()=>t(o.result.modelArtifactsInfo),h.onerror=d=>n(o.error)};c.onsuccess=u,c.onerror=h=>(u(),r.close(),n(o.error))}},o.onerror=c=>(r.close(),n(o.error)),s.oncomplete=()=>{l==null?r.close():l.oncomplete=()=>r.close()}},a.onerror=r=>n(a.error)})}},co="/",Zd="tensorflowjs_models",h4="info",MX="model_topology",OX="weight_specs",FX="weight_data",LX="model_metadata";function d4(e){return{info:[Zd,e,h4].join(co),topology:[Zd,e,MX].join(co),weightSpecs:[Zd,e,OX].join(co),weightData:[Zd,e,FX].join(co),modelMetadata:[Zd,e,LX].join(co)}}function p4(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function zX(e){let t=e.split(co);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(co)}function PX(e){return e.startsWith(Ac.URL_SCHEME)?e.slice(Ac.URL_SCHEME.length):e}var Ac=class{constructor(e){if(!Z().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=d4(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),a=Mb(e),r=Mo.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,xX(r));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:a}}catch{throw p4(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(a==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=a;let r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){let i=JSON.parse(r);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=wX(s),t}};Ac.URL_SCHEME="localstorage://";var f4=e=>Z().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ac.URL_SCHEME)?VX(e.slice(Ac.URL_SCHEME.length)):null;cs.registerSaveRouter(f4);cs.registerLoadRouter(f4);function VX(e){return new Ac(e)}var BX=class{constructor(){z(Z().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),z(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=Zd+co,n=co+h4;for(let a=0;a<this.LS.length;++a){let r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){let s=zX(r);e[s]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=PX(e);let t=d4(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return p4(t),n}},kp="://",Wl=class Zo{constructor(){this.managers={}}static getInstance(){return Zo.instance==null&&(Zo.instance=new Zo),Zo.instance}static registerManager(t,n){z(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(kp)&&(t=t.slice(0,t.indexOf(kp))),z(t.length>0,()=>"scheme must not be an empty string.");let a=Zo.getInstance();z(a.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),a.managers[t]=n}static getManager(t){let n=Zo.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Zo.getInstance().managers)}};function Lx(e){if(e.indexOf(kp)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Wl.getSchemes().join(",")}`);return{scheme:e.split(kp)[0],path:e.split(kp)[1]}}async function m4(e,t,n=!1){z(e!==t,()=>`Old path and new path are the same: '${e}'`);let a=cs.getLoadHandlers(e);z(a.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),z(a.length<2,()=>`Copying failed because more than one (${a.length}) load handlers for source URL ${e}.`);let r=a[0],s=cs.getSaveHandlers(t);z(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),z(s.length<2,()=>`Copying failed because more than one (${a.length}) save handlers for destination URL ${t}.`);let i=s[0],o=Lx(e).scheme,l=Lx(e).path,c=o===Lx(e).scheme,u=await r.load();n&&c&&await Wl.getManager(o).removeModel(l);let h=await i.save(u);return n&&!c&&await Wl.getManager(o).removeModel(l),h.modelArtifactsInfo}async function UX(){let e=Wl.getSchemes(),t={};for(let n of e){let a=await Wl.getManager(n).listModels();for(let r in a){let s=n+kp+r;t[s]=a[r]}}return t}async function WX(e){let t=Lx(e);return Wl.getManager(t.scheme).removeModel(t.path)}async function jX(e,t){return m4(e,t,!1)}async function GX(e,t){return m4(e,t,!0)}var HX=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!Z().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let a=this.functionRefs[n.data.index];a(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return jz(e)}};if(Z().get("IS_BROWSER")){Z().setPlatform("browser",new HX);try{Wl.registerManager(Ac.URL_SCHEME,new BX)}catch{}try{Wl.registerManager(Cc.URL_SCHEME,new $X)}catch{}}var qX={importFetch:()=>V7()},kS,KX=class{constructor(){this.util=B7(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Z().global.fetch!=null?Z().global.fetch(e,t):(kS==null&&(kS=qX.importFetch()),kS(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};Z().get("IS_NODE")&&!Z().get("IS_BROWSER")&&Z().setPlatform("node",new KX);function ut(e,t="float32",n){return t=t||"float32",Ur(e),new Vn(e,t,n)}function XX(e,t){let n=F(e,"x","cast");if(!$z(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let a={x:n},r={dtype:t};return U.runKernel(lh,a,r)}var ye=W({cast_:XX});function QX(e){let t={x:F(e,"x","clone","string_or_numeric")};return U.runKernel(Eh,t)}var Ci=W({clone_:QX});function P2(e,t=!1){console.log(e.toString(t))}Zz();var YX={buffer:ut,cast:ye,clone:Ci,print:P2};qK(YX);function ZX(e,t){let n=F(e,"a","add"),a=F(t,"b","add");[n,a]=In(n,a);let r={a:n,b:a};return U.runKernel(hu,r)}var re=W({add_:ZX});function JX(e,t){let n=F(e,"a","floorDiv"),a=F(t,"b","floorDiv");[n,a]=In(n,a);let r={a:n,b:a};return U.runKernel(Ih,r)}var r1=W({floorDiv_:JX});function eQ(e,t){let n=F(e,"a","div"),a=F(t,"b","div");if([n,a]=In(n,a),n.dtype==="int32"&&a.dtype==="int32")return r1(n,a);let r={a:n,b:a},s={};return U.runKernel(bh,r,s)}var Ce=W({div_:eQ});function tQ(e,t){let n=F(e,"a","mul"),a=F(t,"b","mul");[n,a]=In(n,a);let r={a:n,b:a};return U.runKernel(Wh,r)}var G=W({mul_:tQ});function nQ(e){let t=F(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return U.runKernel(db,n)}else{let n={x:t};return U.runKernel(Sf,n)}}var On=W({abs_:nQ});function aQ(e){let t={x:F(e,"x","acos")};return U.runKernel(Zc,t)}var V2=W({acos_:aQ});function rQ(e){let t={x:F(e,"x","acosh")};return U.runKernel(Jc,t)}var B2=W({acosh_:rQ});function sQ(e){z(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),z(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((r,s)=>F(r,`tensors${s}`,"addN")),n=t[0];t.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!$o(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let a=t;return U.runKernel(eh,a)}var g4=W({addN_:sQ});function iQ(e,t=null,n=!1){let a={x:F(e,"x","all","bool")},r={axis:t,keepDims:n};return U.runKernel(If,a,r)}var s1=W({all_:iQ});function oQ(e,t=null,n=!1){let a={x:F(e,"x","any","bool")},r={axis:t,keepDims:n};return U.runKernel(kf,a,r)}var Ty=W({any_:oQ});function lQ(e,t=0){let n={x:F(e,"x","argMax")},a={axis:t};return U.runKernel(Tf,n,a)}var Rc=W({argMax_:lQ});function uQ(e,t=0){let n={x:F(e,"x","argMin")},a={axis:t};return U.runKernel(Ef,n,a)}var U2=W({argMin_:uQ});function cQ(e){let t={x:F(e,"x","asin")};return U.runKernel(th,t)}var W2=W({asin_:cQ});function hQ(e){let t={x:F(e,"x","asinh")};return U.runKernel(nh,t)}var j2=W({asinh_:hQ});function dQ(e){let t={x:F(e,"x","atan")};return U.runKernel(ah,t)}var G2=W({atan_:dQ});function pQ(e,t){let n=F(e,"a","atan2"),a=F(t,"b","atan2");[n,a]=In(n,a);let r={a:n,b:a};return U.runKernel(sh,r)}var H2=W({atan2_:pQ});function fQ(e){let t={x:F(e,"x","atanh")};return U.runKernel(rh,t)}var q2=W({atanh_:fQ});function mQ(e,t,n,a,r="NHWC",s){let i=e[3],o=[...t,i],l=v4(r);return Ob(e,o,n,s,a,null,null,l)}function y4(e,t,n,a,r,s,i="channelsLast"){let[o,l]=Ey(t),c;if(i==="channelsLast")c=[o,l,e[3],e[3]];else if(i==="channelsFirst")c=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Ob(e,c,n,a,r,s,!1,i)}function gQ(e,t,n,a,r,s,i="NDHWC"){let[o,l,c]=lk(t),u,h;if(i==="NDHWC")h="channelsLast",u=[o,l,c,e[4],e[4]];else if(i==="NCDHW")h="channelsFirst",u=[o,l,c,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return b4(e,u,n,a,r,!1,h,s)}function Ob(e,t,n,a,r,s,i=!1,o="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h]=e;else if(o==="channelsFirst")[l,h,c,u]=e;else throw new Error(`Unknown dataFormat ${o}`);let[d,p,,f]=t,[m,g]=Ey(n),[y,v]=Ey(a),x=Tp(d,y),w=Tp(p,v),{padInfo:k,outHeight:M,outWidth:S}=vQ(r,c,u,m,g,x,w,s,o),I=i?f*h:f,E;return o==="channelsFirst"?E=[l,I,M,S]:o==="channelsLast"&&(E=[l,M,S,I]),{batchSize:l,dataFormat:o,inHeight:c,inWidth:u,inChannels:h,outHeight:M,outWidth:S,outChannels:I,padInfo:k,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:v,inShape:e,outShape:E,filterShape:t}}function b4(e,t,n,a,r,s=!1,i="channelsLast",o){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,c,u,h,d]=e;else if(i==="channelsFirst")[l,d,c,u,h]=e;else throw new Error(`Unknown dataFormat ${i}`);let[p,f,m,,g]=t,[y,v,x]=lk(n),[w,k,M]=lk(a),S=Tp(p,w),I=Tp(f,k),E=Tp(m,M),{padInfo:R,outDepth:A,outHeight:_,outWidth:D}=xQ(r,c,u,h,y,v,x,S,I,E,o),j=s?g*d:g,q;return i==="channelsFirst"?q=[l,j,A,_,D]:i==="channelsLast"&&(q=[l,A,_,D,j]),{batchSize:l,dataFormat:i,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:A,outHeight:_,outWidth:D,outChannels:j,padInfo:R,strideDepth:y,strideHeight:v,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:E,dilationDepth:w,dilationHeight:k,dilationWidth:M,inShape:e,outShape:q,filterShape:t}}function yQ(e,t,n,a,r){a==null&&(a=K2(e,t,n));let s=e[0],i=e[1],o=Ny((s-t+2*a)/n+1,r),l=Ny((i-t+2*a)/n+1,r);return[o,l]}function bQ(e,t,n,a,r,s){r==null&&(r=K2(e,t[0],a[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*r>=t[o]&&(i[o]=Ny((e[o]-t[o]+2*r)/a[o]+1,s));return i}function K2(e,t,n,a=1){let r=Tp(t,a);return Math.floor((e[0]*(n-1)-n+r)/2)}function Ey(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function lk(e){return typeof e=="number"?[e,e,e]:e}function Tp(e,t){return t<=1?e:e+(e-1)*(t-1)}function vQ(e,t,n,a,r,s,i,o,l){let c,u,h;if(typeof e=="number"){c={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let d=yQ([t,n],s,a,e,o);u=d[0],h=d[1]}else if(e==="same"){u=Math.ceil(t/a),h=Math.ceil(n/r);let d=Math.max(0,(u-1)*a+s-t),p=Math.max(0,(h-1)*r+i-n),f=Math.floor(d/2),m=d-f,g=Math.floor(p/2),y=p-g;c={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(e==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-s+1)/a),h=Math.ceil((n-i+1)/r);else if(typeof e=="object"){let d=l==="channelsLast"?e[1][0]:e[2][0],p=l==="channelsLast"?e[1][1]:e[2][1],f=l==="channelsLast"?e[2][0]:e[3][0],m=l==="channelsLast"?e[2][1]:e[3][1];c={top:d,bottom:p,left:f,right:m,type:d===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},u=Ny((t-s+d+p)/a+1,o),h=Ny((n-i+f+m)/r+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outHeight:u,outWidth:h}}function xQ(e,t,n,a,r,s,i,o,l,c,u){let h,d,p,f;if(e==="valid"&&(e=0),typeof e=="number"){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let m=bQ([t,n,a,1],[o,l,c],1,[r,s,i],e,u);d=m[0],p=m[1],f=m[2]}else if(e==="same"){d=Math.ceil(t/r),p=Math.ceil(n/s),f=Math.ceil(a/i);let m=(d-1)*r+o-t,g=(p-1)*s+l-n,y=(f-1)*i+c-a,v=Math.floor(m/2),x=m-v,w=Math.floor(g/2),k=g-w,M=Math.floor(y/2),S=y-M;h={top:w,bottom:k,left:M,right:S,front:v,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function Ny(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function jl(e){let[t,n,a]=Ey(e);return t===1&&n===1&&a===1}function ji(e,t){return jl(e)||jl(t)}function Dc(e){return Ey(e).every(t=>t>0)}function v4(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function rr(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")z(Wp(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(a=>{a.forEach(r=>{z(Wp(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function wQ(e,t){let n={x:F(e,"x","reshape","string_or_numeric")},a={shape:t};return U.runKernel(om,n,a)}var K=W({reshape_:wQ});function _Q(e,t,n,a,r){let s=F(e,"x","avgPool","float32"),i=1;z(ji(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=s,l=!1;s.rank===3&&(l=!0,o=K(s,[1,s.shape[0],s.shape[1],s.shape[2]])),z(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),rr("avgPool",a,r);let c={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r},h=U.runKernel(ih,c,u);return h=ye(h,s.dtype),l?K(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Oo=W({avgPool_:_Q});function SQ(e,t,n,a,r,s="NDHWC"){let i=F(e,"x","avgPool3d","float32"),o=i,l=!1;i.rank===4&&(l=!0,o=K(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),z(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),z(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),rr("avgPool3d",a,r);let c={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},h=U.runKernel(Nf,c,u);return h=ye(h,o.dtype),l?K(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var X2=W({avgPool3d_:SQ});function IQ(e,t=0){z(e.length>=1,()=>"Pass at least one tensor to concat");let n=ky(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),n.length===1)return Ci(n[0]);let a=n,r={axis:t};return U.runKernel(Df,a,r)}var Qt=W({concat_:IQ});function kQ(e,t,n=!1,a=!1){let r=F(e,"a","matMul"),s=F(t,"b","matMul");[r,s]=In(r,s);let i={a:r,b:s},o={transposeA:n,transposeB:a};return U.runKernel(oh,i,o)}var ot=W({matMul_:kQ});function TQ(e){let t={x:F(e,"x","sigmoid","float32")};return U.runKernel(od,t)}var Rs=W({sigmoid_:TQ});function EQ(e,t,n){let a=F(e,"x","slice","string_or_numeric");if(a.rank===0)throw new Error("Slicing scalar is not possible");let r={x:a},s={begin:t,size:n};return U.runKernel(fm,r,s)}var vt=W({slice_:EQ});function NQ(e){let t={x:F(e,"x","tanh","float32")};return U.runKernel(md,t)}var Gl=W({tanh_:NQ});function CQ(e,t,n,a,r,s){let i=F(e,"forgetBias","basicLSTMCell"),o=F(t,"lstmKernel","basicLSTMCell"),l=F(n,"lstmBias","basicLSTMCell"),c=F(a,"data","basicLSTMCell"),u=F(r,"c","basicLSTMCell"),h=F(s,"h","basicLSTMCell"),d=Qt([c,h],1),p=ot(d,o),f=re(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],v=vt(f,[0,0],y),x=vt(f,[0,g],y),w=vt(f,[0,g*2],y),k=vt(f,[0,g*3],y),M=re(G(Rs(v),Gl(x)),G(u,Rs(re(i,w)))),S=G(Gl(M),Rs(k));return[M,S]}var x4=W({basicLSTMCell_:CQ});function AQ(e,t,n){let a=F(e,"x","batchToSpaceND"),r=t.reduce((o,l)=>o*l);z(a.rank>=1+t.length,()=>`input rank is ${a.rank} but should be > than blockShape.length ${t.length}`),z(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),z(a.shape[0]%r===0,()=>`input tensor batch is ${a.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);let s={x:a},i={blockShape:t,crops:n};return U.runKernel(Cf,s,i)}var Fb=W({batchToSpaceND_:AQ});function RQ(e){let t;return e.rank===0||e.rank===1?t=K(e,[1,1,1,e.size]):e.rank===2?t=K(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=K(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function DQ(e,t,n,a,r,s){s==null&&(s=.001);let i=F(e,"x","batchNorm"),o=F(t,"mean","batchNorm"),l=F(n,"variance","batchNorm"),c;r!=null&&(c=F(r,"scale","batchNorm"));let u;a!=null&&(u=F(a,"offset","batchNorm")),z(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),z(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),z(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let h={x:RQ(i),scale:c,offset:u,mean:o,variance:l},d={varianceEpsilon:s},p=U.runKernel(kh,h,d);return K(p,i.shape)}var gd=W({batchNorm_:DQ});function $Q(e,t,n,a,r,s){let i=F(e,"x","batchNorm"),o=F(t,"mean","batchNorm"),l=F(n,"variance","batchNorm"),c;r!=null&&(c=F(r,"scale","batchNorm"));let u;return a!=null&&(u=F(a,"offset","batchNorm")),z(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),z(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),z(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&z(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),gd(i,o,l,u,c,s)}var Q2=W({batchNorm2d_:$Q});function MQ(e,t,n,a,r,s){let i=F(e,"x","batchNorm"),o=F(t,"mean","batchNorm"),l=F(n,"variance","batchNorm"),c;r!=null&&(c=F(r,"scale","batchNorm"));let u;return a!=null&&(u=F(a,"offset","batchNorm")),z(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),z(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),z(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&z(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),gd(i,o,l,u,c,s)}var Y2=W({batchNorm3d_:MQ});function OQ(e,t,n,a,r,s){let i=F(e,"x","batchNorm"),o=F(t,"mean","batchNorm"),l=F(n,"variance","batchNorm"),c;r!=null&&(c=F(r,"scale","batchNorm"));let u;return a!=null&&(u=F(a,"offset","batchNorm")),z(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),z(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),z(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&z(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&z(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),gd(i,o,l,u,c,s)}var Z2=W({batchNorm4d_:OQ});function FQ(e,t,n){let a=F(e,"x","bincount"),r=F(t,"weights","bincount");z(a.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${a.dtype}`),z(n>=0,()=>`size must be non-negative, but got ${n}.`),z(r.size===a.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${a.shape}, weights shape: ${r.shape}.`);let s={x:a,weights:r},i={size:n};return U.runKernel(Af,s,i)}var J2=W({bincount_:FQ});function LQ(e,t){let n=F(e,"x","bitwiseAnd"),a=F(t,"y","bitwiseAnd");if(!$o(n.shape,a.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${a.shape}`);if(n.dtype!=="int32"||a.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${a.dtype}`);let r={a:n,b:a};return U.runKernel(Rf,r)}var w4=W({bitwiseAnd_:LQ});function zQ(e,t){let n=F(e,"s0","broadcastArgs","int32"),a=F(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(a.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);let r={s0:n,s1:a};return U.runKernel(hb,r)}var _4=W({broadcastArgs_:zQ});function PQ(e,t){let n=F(e,"broadcastTo","x"),a=n.shape;if(Ur(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=K(n,l)}let r=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(r[l]===t[l])s[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${t}].`);if(s.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return Ci(n);let i={x:n},o={reps:s};return U.runKernel(pu,i,o)}var fc=W({broadcastTo_:PQ});function VQ(e){let t={x:F(e,"x","ceil","float32")};return U.runKernel(uh,t)}var eE=W({ceil_:VQ});function Mr(e,t,n){Ur(e),n=n||lb(t);let a={shape:e,value:t,dtype:n};return U.runKernel(mb,{},a)}function BQ(e,t,n){let a=F(e,"x","clipByValue");if(z(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Mr(a.shape,t,a.dtype);let r={x:a},s={clipValueMin:t,clipValueMax:n};return U.runKernel(du,r,s)}var Va=W({clipByValue_:BQ});function UQ(e){return Qt(e,0)}var tE=W({concat1d_:UQ});function WQ(e,t){return Qt(e,t)}var nE=W({concat2d_:WQ});function jQ(e,t){return Qt(e,t)}var aE=W({concat3d_:jQ});function GQ(e,t){return Qt(e,t)}var rE=W({concat4d_:GQ});function HQ(e,t,n,a,r="NHWC",s=[1,1],i){let o=F(e,"x","conv2d","float32"),l=F(t,"filter","conv2d","float32"),c=o,u=!1;o.rank===3&&(u=!0,c=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),z(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),z(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),rr("conv2d",a,i);let h=r==="NHWC"?c.shape[3]:c.shape[1];z(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),z(ji(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),z(Dc(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),z(Dc(n),()=>"Error in conv2D: Strides should be larger than 0.");let d={x:c,filter:l},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},f=U.runKernel(ch,d,p);return u?K(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Ja=W({conv2d_:HQ});function qQ(e,t,n,a,r="NWC",s=1,i){let o=F(e,"x","conv1d"),l=F(t,"filter","conv1d"),c=o,u=!1;o.rank===2&&(u=!0,c=K(o,[1,o.shape[0],o.shape[1]])),z(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),z(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),rr("conv1d",a,i),z(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),z(ji(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),z(Dc(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),z(Dc(n),()=>"Error in conv1D: Stride should be larger than 0."),z(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);let h=K(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=K(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=Ja(d,h,[1,n],a,"NHWC",[1,s],i);return u?K(p,[p.shape[2],p.shape[3]]):K(p,[p.shape[0],p.shape[2],p.shape[3]])}var i1=W({conv1d_:qQ});function KQ(e,t,n,a,r,s="NHWC",i){z(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,c=!1;t.rank===3&&(c=!0,l=K(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),z(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),z(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),z(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let u=s==="NHWC"?o[3]:o[1],h=s==="NHWC"?l.shape[3]:l.shape[1];z(u===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`),z(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),rr("conv2dDerInput",r,i);let d={dy:l,filter:n},p={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,inputShape:o},f=U.runKernel(hh,d,p);return c?K(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var sE=W({conv2DBackpropInput_:KQ});function XQ(e,t,n,a,r,s){let i=F(e,"x","conv2dTranspose"),o=F(t,"filter","conv2dTranspose");return sE(n,i,o,a,r,"NHWC",s)}var o1=W({conv2dTranspose_:XQ});function QQ(e,t,n,a,r="NDHWC",s=[1,1,1]){let i=F(e,"x","conv3d"),o=F(t,"filter","conv3d"),l=i,c=!1;i.rank===4&&(c=!0,l=K(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),z(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),z(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),z(ji(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),z(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),z(Dc(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),z(Dc(n),()=>"Error in conv3D: Strides should be larger than 0.");let u={x:l,filter:o},h={strides:n,pad:a,dataFormat:r,dilations:s},d=U.runKernel(dh,u,h);return c?K(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var iE=W({conv3d_:QQ});function YQ(e,t,n,a,r){z(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=K(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],c=i.shape[4];z(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),z(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),z(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),z(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),z(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);let u={dy:i,filter:n},h={pad:r,strides:a,inputShape:s},d=U.runKernel(Mf,u,h);return o?K(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var S4=W({conv3DBackpropInput_:YQ});function ZQ(e,t,n,a,r){let s=F(e,"x","conv3dTranspose"),i=F(t,"filter","conv3dTranspose");return S4(n,s,i,a,r)}var oE=W({conv3dTranspose_:ZQ});function JQ(e){let t={x:F(e,"x","cos","float32")};return U.runKernel(ph,t)}var Lb=W({cos_:JQ});function eY(e){let t={x:F(e,"x","cosh","float32")};return U.runKernel(fh,t)}var l1=W({cosh_:eY});function tY(e,t=0,n=!1,a=!1){let r={x:F(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:a};return U.runKernel(Of,r,s)}var Cy=W({cumprod_:tY});function nY(e,t=0,n=!1,a=!1){let r={x:F(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:a};return U.runKernel(mh,r,s)}var u1=W({cumsum_:nY});function aY(e,t,n,a=!1){let r=F(e,"x","denseBincount"),s=F(t,"weights","denseBincount");z(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),z(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),z(n>=0,()=>`size must be non-negative, but got ${n}.`),z(s.size===r.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`);let i={x:r,weights:s},o={size:n,binaryOutput:a};return U.runKernel(pb,i,o)}var D0=W({denseBincount_:aY});function rY(e,t,n="NHWC"){let a=F(e,"x","depthToSpace","float32"),r=n==="NHWC"?a.shape[1]:a.shape[2],s=n==="NHWC"?a.shape[2]:a.shape[3],i=n==="NHWC"?a.shape[3]:a.shape[1];z(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),z(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${a.shape}`),z(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${a.shape}`),z(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${a.shape}`);let o={x:a},l={blockSize:t,dataFormat:n};return U.runKernel(Lf,o,l)}var lE=W({depthToSpace_:rY});function sY(e,t,n,a,r="NHWC",s=[1,1],i){let o=F(e,"x","depthwiseConv2d","float32"),l=F(t,"filter","depthwiseConv2d","float32"),c=o,u=!1;o.rank===3&&(u=!0,c=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),z(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),z(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let h=r==="NHWC"?c.shape[3]:c.shape[1];z(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),rr("depthwiseConv2d",a,i);let d={x:c,filter:l},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},f=U.runKernel(gh,d,p);return u?K(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var yd=W({depthwiseConv2d_:sY});function iY(e){let t={x:F(e,"x","diag")};return U.runKernel(fb,t)}var I4=W({diag_:iY});function oY(e,t,n,a,r=[1,1],s="NHWC"){let i=F(e,"x","dilation2d"),o=F(t,"filter","dilation2d");z(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),z(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),z(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,c=!1;i.rank===3&&(l=K(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0),z(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let u={x:l,filter:o},h={strides:n,pad:a,dilations:r},d=U.runKernel(yh,u,h);return c?K(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var uE=W({dilation2d_:oY}),km={};tt(km,{assertAndGetBroadcastShape:()=>Yt,getBroadcastDims:()=>k4,getReductionAxes:()=>Un});function k4(e,t){let n=e.length,a=[];for(let r=0;r<n;r++){let s=n-1-r,i=e[s]||1;(t[t.length-1-r]||1)>1&&i===1&&a.unshift(s)}return a}function Un(e,t){let n=[];for(let a=0;a<t.length;a++){let r=e[e.length-a-1],s=t.length-a-1,i=t[s];(r==null||r===1&&i>1)&&n.unshift(s)}return n}function Yt(e,t){let n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let s=e[e.length-r-1];s==null&&(s=1);let i=t[t.length-r-1];if(i==null&&(i=1),s===1)a[n-r-1]=i;else if(i===1)a[n-r-1]=s;else if(s!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else a[n-r-1]=s}return a}function lY(e,t){let n=F(e,"a","equal","string_or_numeric"),a=F(t,"b","equal","string_or_numeric");[n,a]=In(n,a),Yt(n.shape,a.shape);let r={a:n,b:a};return U.runKernel(Pf,r)}var Lr=W({equal_:lY});function uY(e,t,n){let a=F(t,"a","where"),r=F(n,"b","where"),s=F(e,"condition","where","bool"),i=Yt(Yt(s.shape,a.shape),r.shape),o=fc(s,i),l=fc(a,i),c=fc(r,i),u={condition:o,t:l,e:c};return U.runKernel(pm,u)}var ga=W({where_:uY});function cY(e){let t={x:F(e,"x","zerosLike")};return U.runKernel(Sm,t)}var _t=W({zerosLike_:cY});function hY(e,t){let n=F(e,"a","div"),a=F(t,"b","div");[n,a]=In(n,a);let r=Ce(n,a),s=_t(r),i=Lr(a,s);return ga(i,s,r)}var cE=W({divNoNan_:hY});function dY(e,t){let n=F(e,"t1","dot"),a=F(t,"t2","dot");z((n.rank===1||n.rank===2)&&(a.rank===1||a.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`);let r=n.rank===1?n.size:n.shape[1],s=a.rank===1?a.size:a.shape[0];if(z(r===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`),n.rank===1&&a.rank===1){let i=K(n,[1,-1]),o=K(a,[-1,1]),l=ot(i,o);return K(l,[])}else if(n.rank===1&&a.rank===2){let i=K(n,[1,-1]),o=K(a,[a.shape[0],a.shape[1]]),l=ot(i,o);return K(l,[l.size])}else if(n.rank===2&&a.rank===1){let i=K(a,[-1,1]),o=ot(n,i);return K(o,[o.size])}else{let i=K(a,[a.shape[0],a.shape[1]]);return ot(n,i)}}var hE=W({dot_:dY});function pY(e,...t){let n=t.map((r,s)=>F(r,`tensors${s}`,"einsum")),a={equation:e};return U.runKernel(qw,n,a)}var nc=W({einsum_:pY});function fY(e){let t={x:F(e,"x","elu","float32")};return U.runKernel(vh,t)}var Tm=W({elu_:fY});function mY(e,t){let n=F(e,"x","ensureShape","string_or_numeric");if(!Cz(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var T4=W({ensureShape_:mY});function gY(e){let t=F(e,"x","erf");z(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=ye(t,"float32"));let n={x:t};return U.runKernel(xh,n)}var c1=W({erf_:gY});function dE(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function E4(e,t,n){let a=e.length+t.length,r=[],s=0,i=0;for(let o=0;o<a;o++)n.indexOf(o)===-1?r.push(e[s++]):r.push(t[i++]);return r}function N4(e,t){let n=[],a=e.length;for(let s=0;s<a;s++)t.indexOf(s)===-1&&n.push(e[s]);let r=t.map(s=>e[s]);return[n,r]}function $c(e,t){let n=t.map(a=>1);return E4(e,n,t)}function yY(e,t,n){z(dE(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function C4(e,t){if(dE(e,t))return null;let n=[];for(let a=0;a<t;++a)e.indexOf(a)===-1&&n.push(a);return e.forEach(a=>n.push(a)),n}function pE(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function bY(e,t){let n=[];for(let a=t-e;a<t;++a)n.push(a);return n}function vY(e,t=null,n=!1){let a={x:F(e,"x","max")},r={reductionIndices:t,keepDims:n};return U.runKernel(Oh,a,r)}var is=W({max_:vY});function xY(e,t=null,n=!1){let a={x:F(e,"x","min")},r={axis:t,keepDims:n};return U.runKernel(Ph,a,r)}var qp=W({min_:xY});function wY(e,t){let n=F(e,"base","pow"),a=F(t,"exp","pow");[n,a]=In(n,a);let r={a:n,b:a};return U.runKernel(Hh,r)}var Li=W({pow_:wY});function ze(e,t){if((da(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&da(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return mu(e,[],[],t)}function _Y(e){let t={x:F(e,"x","sqrt","float32")};return U.runKernel(ud,t)}var va=W({sqrt_:_Y});function SY(e){let t=F(e,"x","square"),n={};return U.runKernel("Square",{x:t},n)}var Xt=W({square_:SY});function IY(e,t=null,n=!1){let a=F(e,"x","sum");a.dtype==="bool"&&(a=ye(a,"int32"));let r={x:a},s={axis:t,keepDims:n};return U.runKernel(cd,r,s)}var De=W({sum_:IY});function kY(e,t="euclidean",n=null,a=!1){e=F(e,"x","norm");let r=A4(e,t,n),s=r.shape;if(a){let i=Os(n,e.shape);s=$c(r.shape,i)}return K(r,s)}function A4(e,t,n=null){if(e.rank===0)return On(e);if(e.rank!==1&&n===null)return A4(K(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return De(On(e),n);if(t===1/0)return is(On(e),n);if(t===-1/0)return qp(On(e),n);if(t==="euclidean"||t===2)return va(De(Li(On(e),ze(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return is(De(On(e),n[0]),n[1]-1);if(t===1/0)return is(De(On(e),n[1]),n[0]);if(t===-1/0)return qp(De(On(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return va(De(Xt(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var Em=W({norm_:kY});function TY(e,t=null,n=!1){return Em(e,"euclidean",t,n)}var fE=W({euclideanNorm_:TY});function EY(e){let t={x:F(e,"x","exp")};return U.runKernel(wh,t)}var Ba=W({exp_:EY});function NY(e,t=0){let n=F(e,"x","expandDims","string_or_numeric");z(t<=n.rank,()=>"Axis must be <= rank of the tensor");let a={input:n},r={dim:t};return U.runKernel(Vf,a,r)}var pa=W({expandDims_:NY});function CY(e){let t={x:F(e,"x","expm1")};return U.runKernel(_h,t)}var mE=W({expm1_:CY});function AY(e,t){let n=F(e,"x","tile","string_or_numeric");z(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let a={x:n},r={reps:t};return U.runKernel(pu,a,r)}var Dr=W({tile_:AY});function RY(e,t,n,a="float32"){t==null&&(t=e);let r=ut([e,t],a),s=e<=t?e:t;for(let o=0;o<s;++o)r.set(1,o,o);let i=K(r.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Dr(pa(i,0),[n[0],1,1]);if(n.length===2)return Dr(pa(pa(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Dr(pa(pa(pa(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var h1=W({eye_:RY});function DY(e){let t={x:F(e,"x","floor","float32")};return U.runKernel(Sh,t)}var Nm=W({floor_:DY});function $Y(e,t,n=0,a=0){let r=F(e,"x","gather"),s=F(t,"indices","gather","int32"),i={x:r,indices:s},o={axis:n,batchDims:a};return U.runKernel(Uf,i,o)}var Cm=W({gather_:$Y});function MY(e,t){let n=F(e,"a","greater","string_or_numeric"),a=F(t,"b","greater","string_or_numeric");[n,a]=In(n,a),Yt(n.shape,a.shape);let r={a:n,b:a};return U.runKernel(jf,r)}var sr=W({greater_:MY});function OY(e,t){let n=F(e,"a","greaterEqual","string_or_numeric"),a=F(t,"b","greaterEqual","string_or_numeric");[n,a]=In(n,a),Yt(n.shape,a.shape);let r={a:n,b:a};return U.runKernel(Th,r)}var Fo=W({greaterEqual_:OY});function FY(e){let t={input:F(e,"input","imag")};return U.runKernel(Qw,t)}var zb=W({imag_:FY});function LY(e){let t={x:F(e,"x","isFinite")};return U.runKernel(Nh,t)}var gE=W({isFinite_:LY});function zY(e){let t={x:F(e,"x","isInf")};return U.runKernel(Ch,t)}var yE=W({isInf_:zY});function PY(e){let t={x:F(e,"x","isNaN")};return U.runKernel(Ah,t)}var bE=W({isNaN_:PY});function VY(e,t=.2){let n={x:F(e,"x","leakyRelu")},a={alpha:t};return U.runKernel(Rh,n,a)}var Pb=W({leakyRelu_:VY});function BY(e,t){let n=F(e,"a","less","string_or_numeric"),a=F(t,"b","less","string_or_numeric");[n,a]=In(n,a),Yt(n.shape,a.shape);let r={a:n,b:a};return U.runKernel(Gf,r)}var Kp=W({less_:BY});function UY(e,t){let n=F(e,"a","lessEqual","string_or_numeric"),a=F(t,"b","lessEqual","string_or_numeric");[n,a]=In(n,a),Yt(n.shape,a.shape);let r={a:n,b:a};return U.runKernel(Hf,r)}var gu=W({lessEqual_:UY});function R4(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let a={start:e,stop:t,num:n};return U.runKernel(qf,{},a)}function WY(e,t=5,n=1,a=1,r=.5){let s=F(e,"x","localResponseNormalization");z(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),z(Wp(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=K(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},c={depthRadius:t,bias:n,alpha:a,beta:r},u=U.runKernel(Mh,l,c);return o?K(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var vE=W({localResponseNormalization_:WY});function jY(e){let t={x:F(e,"x","log","float32")};return U.runKernel(Dh,t)}var zr=W({log_:jY});function GY(e){let t={x:F(e,"x","log1p")};return U.runKernel($h,t)}var Vb=W({log1p_:GY});function HY(e){return z(Vl(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let a=F(t,"x","tf.grad","string_or_numeric"),r=n!=null?F(n,"dy","tf.grad"):null;return U.tidy(()=>{let{value:s,grads:i}=U.gradients(()=>e(a),[a],r);return r!=null&&ar(s.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),d1(i),i[0]})}}function qY(e){return z(Vl(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{z(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let a=ky(t,"args","tf.grads","string_or_numeric"),r=n!=null?F(n,"dy","tf.grads"):null;return U.tidy(()=>{let{value:s,grads:i}=U.gradients(()=>e(...a),a,r);return r!=null&&ar(s.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),d1(i),i})}}function KY(e){return z(Vl(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{z(t instanceof at,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),z(n==null||n instanceof at,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:a,value:r}=U.gradients(()=>e(t),[t],n);return d1(a),{grad:a[0],value:r}}}function XY(e){return z(Vl(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{z(Array.isArray(t)&&t.every(r=>r instanceof at),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),z(n==null||n instanceof at,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let a=U.gradients(()=>e(...t),t,n);return n!=null&&ar(a.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),d1(a.grads),a}}function D4(e,t){z(Vl(e),()=>"The f passed in variableGrads(f) must be a function"),z(t==null||Array.isArray(t)&&t.every(c=>c instanceof Ec),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let c in U.registeredVariables)t.push(U.registeredVariables[c])}let a=n?t.filter(c=>!c.trainable):null,r=t.length;t=t.filter(c=>c.trainable),z(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);let s=!0,{value:i,grads:o}=U.gradients(e,t,null,s);z(o.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),z(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((c,u)=>{o[u]!=null&&(l[c.name]=o[u])}),a!=null&&a.forEach(c=>l[c.name]=null),{value:i,grads:l}}function zi(e){return U.customGrad(e)}function d1(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function QY(e){let t={x:F(e,"x","neg")};return U.runKernel(em,t)}var on=W({neg_:QY});function YY(e){let t={x:F(e,"x","softplus")};return U.runKernel(ld,t)}var bd=W({softplus_:YY});function ZY(e){let t=F(e,"x","logSigmoid");return zi(n=>({value:on(bd(on(n))),gradFunc:a=>G(a,Rs(on(n)))}))(t)}var xE=W({logSigmoid_:ZY});function JY(e,t){let n=F(e,"a","sub"),a=F(t,"b","sub");[n,a]=In(n,a);let r={a:n,b:a};return U.runKernel(pd,r)}var Ie=W({sub_:JY});function eZ(e,t=-1){let n=F(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return zi((a,r)=>{let s=is(a,t,!0),i=Ie(a,s),o=Ie(ye(i,"float32"),zr(De(Ba(i),t,!0)));return r([o]),{value:o,gradFunc:(l,c)=>{let[u]=c,h=!0,d=Ba(u);return Ie(l,G(De(l,t,h),d))}}})(n)}var p1=W({logSoftmax_:eZ});function tZ(e,t=null,n=!1){let a=F(e,"x","logSumExp"),r=Os(t,a.shape),s=is(a,r,!0),i=Ie(a,s),o=Ba(i),l=De(o,r),c=zr(l),u=re(K(s,c.shape),c);if(n){let h=$c(u.shape,r);return K(u,h)}return u}var Bb=W({logSumExp_:tZ});function nZ(e,t){let n=F(e,"a","logicalAnd","bool"),a=F(t,"b","logicalAnd","bool");Yt(n.shape,a.shape);let r={a:n,b:a};return U.runKernel(Kf,r)}var Ms=W({logicalAnd_:nZ});function aZ(e){let t={x:F(e,"x","logicalNot","bool")};return U.runKernel(Xf,t)}var Ub=W({logicalNot_:aZ});function rZ(e,t){let n=F(e,"a","logicalOr","bool"),a=F(t,"b","logicalOr","bool");Yt(n.shape,a.shape);let r={a:n,b:a};return U.runKernel(Qf,r)}var f1=W({logicalOr_:rZ});function sZ(e,t){let n=F(e,"a","logicalXor","bool"),a=F(t,"b","logicalXor","bool");return Yt(n.shape,a.shape),Ms(f1(e,t),Ub(Ms(e,t)))}var wE=W({logicalXor_:sZ}),Zv=2147483648;function iZ(e,t,n="left"){let a=F(e,"sortedSequence","searchSorted"),r=F(t,"values","searchSorted"),s=a.shape[a.shape.length-1],i=r.shape[r.shape.length-1],o=K(a,[-1,s]),l=K(r,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ut(l.shape)>=Zv)throw new Error(`values tensor size must less than ${Zv}`);if(o.shape[1]>=Zv)throw new Error(`trailing dim_size must less than ${Zv} for int32 output type, was ${o.shape[1]}`);let c={sortedSequence:o,values:l},u={side:n};return U.runKernel(dm,c,u)}var m1=W({searchSorted_:iZ});function $4(e,t){return m1(e,t,"left")}function oZ(e,t,n,a,r){let s=F(e,"x","maxPool"),i=1,o=s,l=!1;s.rank===3&&(l=!0,o=K(s,[1,s.shape[0],s.shape[1],s.shape[2]])),z(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),z(ji(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),rr("maxPool",a,r);let c={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r},h=U.runKernel(Lh,c,u);return l?K(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var ca=W({maxPool_:oZ});function lZ(e,t=[1,1,1],n,a,r,s="NDHWC"){let i=F(e,"x","maxPool3d"),o=i,l=!1;i.rank===4&&(l=!0,o=K(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),z(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),z(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),rr("maxPool3d",a,r);let c={x:o},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},h=U.runKernel(Zf,c,u);return l?K(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var _E=W({maxPool3d_:lZ});function uZ(e,t,n,a,r=!1){let s={x:F(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},o=U.runKernel(bb,s,i);return{result:o[0],indexes:o[1]}}var M4=W({maxPoolWithArgmax_:uZ});function cZ(e,t){let n=F(e,"a","maximum"),a=F(t,"b","maximum");[n,a]=In(n,a),n.dtype==="bool"&&(n=ye(n,"int32"),a=ye(a,"int32")),Yt(n.shape,a.shape);let r={a:n,b:a};return U.runKernel(Fh,r)}var Gi=W({maximum_:cZ});function hZ(e,t=null,n=!1){let a={x:F(e,"x","mean")},r={axis:t,keepDims:n};return U.runKernel(zh,a,r)}var wn=W({mean_:hZ});function _n(e,t="float32"){if(Ur(e),t==="complex64"){let a=_n(e,"float32"),r=_n(e,"float32");return Eo(a,r)}let n=Vw(Ut(e),t);return U.makeTensor(n,e,t)}function pr(e,t="float32"){if(Ur(e),t==="complex64"){let a=pr(e,"float32"),r=_n(e,"float32");return Eo(a,r)}let n=C2(Ut(e),t);return U.makeTensor(n,e,t)}function O4(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let a=F(e,"x","meshgrid",e instanceof at?e.dtype:"float32");if(t===void 0)return[a];let r=F(t,"y","meshgrid",t instanceof at?t.dtype:"float32"),s=Ut(a.shape),i=Ut(r.shape);return n==="xy"?(a=K(a,[1,-1]),r=K(r,[-1,1]),[ot(pr([i,1],a.dtype),a),ot(r,pr([1,s],r.dtype))]):(a=K(a,[-1,1]),r=K(r,[1,-1]),[ot(a,pr([1,i],a.dtype)),ot(pr([s,1],r.dtype),r)])}function dZ(e,t){let n=F(e,"a","minimum"),a=F(t,"b","minimum");[n,a]=In(n,a),n.dtype==="bool"&&(n=ye(n,"int32"),a=ye(a,"int32")),Yt(n.shape,a.shape);let r={a:n,b:a};return U.runKernel(Vh,r)}var Hl=W({minimum_:dZ});function pZ(e,t,n){z(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let a=F(e,"x","mirrorPad");if(a.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");z(t.length===a.rank,()=>`Padding doesn't match input. Must be ${a.rank}. Got ${t.length}.`);let r=n==="reflect"?1:0;for(let o=0;o<a.rank;o++)z(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),z(t[o][0]>=0&&t[o][0]<=a.shape[o]-r&&t[o][1]>=0&&t[o][1]<=a.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${a.shape[o]-r} or less than 0 for input of shape ${a.shape}`);let s={paddings:t,mode:n},i={x:a};return U.runKernel(Bh,i,s)}var SE=W({mirrorPad_:pZ});function fZ(e,t){let n=F(e,"a","mod"),a=F(t,"b","mod");[n,a]=In(n,a);let r={a:n,b:a};return U.runKernel(Uh,r)}var IE=W({mod_:fZ});function mZ(e,t=null,n=!1){e=F(e,"x","moments");let a=Os(t,e.shape),r=wn(e,a,n),s=r.shape;n||(s=$c(r.shape,a));let i=Xt(Ie(ye(e,"float32"),K(r,s))),o=wn(i,a,n);return{mean:r,variance:o}}var Wb=W({moments_:mZ});function gZ(e,t,n,a){let r=F(t,"data","multiRNNCell"),s=ky(n,"c","multiRNNCell"),i=ky(a,"h","multiRNNCell"),o=r,l=[];for(let h=0;h<e.length;h++){let d=e[h](o,s[h],i[h]);l.push(d[0]),l.push(d[1]),o=d[1]}let c=[],u=[];for(let h=0;h<l.length;h+=2)c.push(l[h]),u.push(l[h+1]);return[c,u]}var F4=W({multiRNNCell_:gZ});function yZ(e,t,n,a=!1){let r=F(e,"logits","multinomial"),s=r.size,i=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?K(r,[1,-1]):r},l={numSamples:t,seed:n,normalized:a},c=U.runKernel(Jf,o,l);return i===1?K(c,[c.size]):c}var L4=W({multinomial_:yZ});function bZ(e,t){let n=F(e,"a","notEqual","string_or_numeric"),a=F(t,"b","notEqual","string_or_numeric");[n,a]=In(n,a),Yt(n.shape,a.shape);let r={a:n,b:a};return U.runKernel(tm,r)}var Mc=W({notEqual_:bZ});function vZ(e,t,n=1,a=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:F(e,"indices","oneHot","int32")},i={dtype:r,depth:t,onValue:n,offValue:a};return U.runKernel(jh,s,i)}var Xp=W({oneHot_:vZ});function xZ(e){let t={x:F(e,"x","onesLike")};return U.runKernel(sm,t)}var Pr=W({onesLike_:xZ});function wZ(e,t){let n=F(e,"v1","outerProduct"),a=F(t,"v2","outerProduct");z(n.rank===1&&a.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${a.rank}.`);let r=K(n,[-1,1]),s=K(a,[1,-1]);return ot(r,s)}var z4=W({outerProduct_:wZ});function _Z(e,t,n=0){let a=F(e,"x","pad");if(a.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let r={paddings:t,constantValue:n},s={x:a};return U.runKernel(Gh,s,r)}var ri=W({pad_:_Z});function SZ(e,t,n=0){return z(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),ri(e,[t],n)}var P4=W({pad1d_:SZ});function IZ(e,t,n=0){return z(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ri(e,t,n)}var V4=W({pad2d_:IZ});function kZ(e,t,n=0){return z(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ri(e,t,n)}var B4=W({pad3d_:kZ});function TZ(e,t,n=0){return z(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ri(e,t,n)}var U4=W({pad4d_:TZ});function EZ(e,t,n){let a=F(e,"x","spaceToBatchND");z(a.rank>=1+t.length,()=>`input rank ${a.rank} should be > than [blockShape] ${t.length}`),z(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),z(a.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${a.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let r={x:a},s={blockShape:t,paddings:n};return U.runKernel(mm,r,s)}var jb=W({spaceToBatchND_:EZ});function NZ(e,t,n,a,r,s,i){r==null&&(r=[1,1]),s==null&&(s=1),a===0&&(a="valid");let o=F(e,"x","maxPool"),l=o,c=!1;o.rank===3&&(c=!0,l=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),z(ji(s,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`);let u=y4(l.shape,t,s,r,a),h=[u.dilationHeight,u.dilationWidth],d;a==="same"?d=AZ([u.filterHeight,u.filterWidth],h):d=[[0,0],[0,0]];let p=h[0]===1&&h[1]===1,[f,m]=CZ([u.inHeight,u.inWidth],h,d),g=p?a:"valid",y=p?l:jb(l,h,f),v=(n==="avg"?()=>Oo(y,t,s,g,i):()=>ca(y,t,s,g,i))(),x=p?v:Fb(v,h,m);return c?K(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function CZ(e,t,n){let a=n.map(u=>u[0]),r=n.map(u=>u[1]),s=e.concat(a,r),i=t.map((u,h)=>(u-s[h]%u)%u),o=r.map((u,h)=>u+i[h]),l=t.map((u,h)=>[a[h],o[h]]),c=t.map((u,h)=>[0,i[h]]);return[l,c]}function AZ(e,t){let n=e.map((s,i)=>s+(s-1)*(t[i]-1)).map(s=>s-1),a=n.map(s=>Math.floor(s/2)),r=n.map((s,i)=>s-a[i]);return n.map((s,i)=>[a[i],r[i]])}var kE=W({pool_:NZ});function RZ(e,t){let n=F(e,"x","prelu"),a=F(t,"alpha","prelu"),r={x:n,alpha:a};return U.runKernel(qh,r)}var Gb=W({prelu_:RZ});function DZ(e,t=null,n=!1){let a=F(e,"x","prod");a.dtype==="bool"&&(a=ye(a,"int32"));let r={x:a},s={axis:t,keepDims:n};return U.runKernel(Kh,r,s)}var TE=W({prod_:DZ});function $Z(e,t,n,a){let r=e.map((u,h)=>F(u,`tensors${h}`,"raggedGather","int32")),s=F(t,"paramsDenseValues","raggedGather"),i=F(n,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:s,indices:i},l={outputRaggedRank:a},c=U.runKernel(Yw,o,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}var W4=W({raggedGather_:$Z});function MZ(e,t,n){let a=F(e,"starts","raggedRange"),r=F(t,"limits","raggedRange",a.dtype),s=F(n,"deltas","raggedRange",a.dtype),i={starts:a,limits:r,deltas:s},o=U.runKernel(Zw,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var j4=W({raggedRange_:MZ});function OZ(e,t,n,a,r){let s=F(e,"shape","raggedTensorToTensor","int32"),i=F(t,"values","raggedTensorToTensor"),o=F(n,"defaultValue","raggedTensorToTensor",i.dtype),l=a.map((h,d)=>F(h,`tensors${d}`,"raggedTensorToTensor","int32")),c={shape:s,values:i,defaultValue:o,rowPartitionTensors:l},u={rowPartitionTypes:r};return U.runKernel(Jw,c,u)}var G4=W({raggedTensorToTensor_:OZ});function FZ(e,t,n){Ur(e);let a=Ut(e),r=null;if(n==null||n==="float32")r=new Float32Array(a);else if(n==="int32")r=new Int32Array(a);else if(n==="bool")r=new Uint8Array(a);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<a;s++)r[s]=t();return U.makeTensor(r,e,n)}var H4=W({rand_:FZ}),EE=cu(zw()),q4={};tt(q4,{TEST_EPSILON_FLOAT16:()=>K4,createVideoElement:()=>jZ,encodeStrings:()=>X4,expectArrayBuffersEqual:()=>WZ,expectArraysClose:()=>zZ,expectArraysEqual:()=>VZ,expectNumbersClose:()=>BZ,expectPromiseToFail:()=>PZ,expectValuesInRange:()=>UZ,play:()=>GZ,testEpsilon:()=>NE});var LZ=.001,K4=.1;function zZ(e,t,n){return n==null&&(n=NE()),uk(e,t,(a,r)=>CE(a,r,n))}function NE(){return U.backend.floatPrecision()===32?LZ:K4}function uk(e,t,n){let a=!0;if((da(e)||da(t))&&(a=!1),da(e)&&da(t)&&(a=!0),a){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=Fi(e),o=Fi(t);if(!$o(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let r=da(e)?e:Bl(e),s=da(t)?t:Bl(t);if(r.length!==s.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${s.length}.
Actual:   ${r}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let o=r[i],l=s[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${r}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function PZ(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function VZ(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return ml(e)||ml(e[0])||ml(t)||ml(t[0])?uk(e,n,(a,r)=>a==r):uk(e,t,(a,r)=>CE(a,r,0))}function BZ(e,t,n){if(n==null&&(n=NE()),!CE(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function CE(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function UZ(e,t,n){for(let a=0;a<e.length;a++)if(e[a]<t||e[a]>n)throw new Error(`Value out of range:${e[a]} low: ${t}, high: ${n}`)}function WZ(e,t){let n=new Float32Array(e),a=new Float32Array(t);if(n.length!==a.length)throw new Error(`Expected ArrayBuffer to be of length ${a.length}, but it was ${n.length}`);for(let r=0;r<a.length;r++)if(n[r]!==a[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${a[r]} but got ${n[r]} instead`)}function X4(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?X4(n):e[t]=Db(n)}return e}function jZ(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",a=>n(t)),t.load()})}async function GZ(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var AE=class{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=r||Math.random();this.random=EE.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let a=this.nextVal;return this.nextVal=NaN,a}let e,t,n=!1;for(;!n;){let a,r,s;do a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r;while(s>=1||s===0);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*i,t=this.mean+this.stdDev*r*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},HZ=class{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;let r=a||Math.random();this.randu=EE.alea(r.toString()),this.randn=new AE(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,s;for(;;){do a=this.randn.nextValue(),s=1+this.c*a;while(s<=0);if(s*=s*s,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),r=this.randu(),r<t||Math.log(r)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},qZ=class{constructor(e=0,t=1,n,a){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,a==null&&(a=Math.random()),typeof a=="number"&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=EE.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function KZ(e,t,n=1,a="float32",r){if(Ur(e),n==null&&(n=1),a==null&&(a="float32"),a!=="float32"&&a!=="int32")throw new Error(`Unsupported data type ${a}`);let s=new HZ(t,n,a,r),i=ut(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Q4=W({randomGamma_:KZ});function XZ(e,t=0,n=1,a,r){if(Ur(e),a!=null&&a==="bool")throw new Error(`Unsupported data type ${a}`);let s=new AE(t,n,a,!1,r),i=ut(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var g1=W({randomNormal_:XZ});function QZ(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return g1(e,0,1,t,n)}var Y4=W({randomStandardNormal_:QZ});function YZ(e,t=0,n=1,a="float32",r){Ur(e);let s=ut(e,a),i=new qZ(t,n,null,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var yu=W({randomUniform_:YZ});function ZZ(e,t,n,a){return yu(e,t,n,"int32",a)}var Z4=W({randomUniformInt_:ZZ});function Oc(e,t,n=1,a="float32"){if(n===0)throw new Error("Cannot have a step of zero");let r={start:e,stop:t,step:n,dtype:a};return U.runKernel(vb,{},r)}function JZ(e){let t={input:F(e,"input","real")};return U.runKernel(e1,t)}var Qp=W({real_:JZ});function eJ(e){let t={x:F(e,"x","reciprocal")};return U.runKernel(Xh,t)}var RE=W({reciprocal_:eJ});function tJ(e){let t={x:F(e,"x","relu")};return U.runKernel(Qh,t)}var Bt=W({relu_:tJ});function nJ(e){let t={x:F(e,"x","relu6")};return U.runKernel(Jh,t)}var y1=W({relu6_:nJ});function aJ(e,t){let n={x:F(e,"x","reverse")},a={dims:t};return U.runKernel(ed,n,a)}var hs=W({reverse_:aJ});function rJ(e){let t=F(e,"x","reverse");return z(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),hs(t,0)}var J4=W({reverse1d_:rJ});function sJ(e,t){let n=F(e,"x","reverse");return z(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),hs(n,t)}var eP=W({reverse2d_:sJ});function iJ(e,t){let n=F(e,"x","reverse");return z(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),hs(n,t)}var tP=W({reverse3d_:iJ});function oJ(e,t){let n=F(e,"x","reverse");return z(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),hs(n,t)}var nP=W({reverse4d_:oJ});function lJ(e){let t={x:F(e,"x","round")};return U.runKernel(td,t)}var b1=W({round_:lJ});function uJ(e){let t={x:F(e,"x","rsqrt","float32")};return U.runKernel(nd,t)}var v1=W({rsqrt_:uJ});function cJ(e){let t={x:F(e,"x","selu")};return U.runKernel(ad,t)}var x1=W({selu_:cJ});function hJ(e,t,n,a,r,s=[1,1],i="NHWC"){let o=F(e,"x","separableConv2d"),l=F(t,"depthwiseFilter","separableConv2d"),c=F(n,"pointwiseFilter","separableConv2d"),u=o,h=!1;if(o.rank===3&&(h=!0,u=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");z(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),z(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),z(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),z(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),z(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);let d=l.shape[2],p=l.shape[3];z(c.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${c.shape[2]}.`);let f=yd(u,l,a,r,i,s),m=Ja(f,c,1,"valid",i);return h?K(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Am=W({separableConv2d_:hJ});async function dJ(e,t){let n=F(e,"x","setdiff1d"),a=F(t,"y","setdiff1d");z(n.dtype===a.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`),z(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),z(a.rank===1,()=>`y should be 1D tensor, but got y (${a.shape}).`);let r=await n.data(),s=await a.data(),i=new Set(s),o=0;for(let u=0;u<r.length;u++)i.has(r[u])||o++;let l=new Vn([o],n.dtype),c=new Vn([o],"int32");for(let u=0,h=0;u<r.length;u++)i.has(r[u])||(l.values[h]=r[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}var aP=dJ;function pJ(e){let t={x:F(e,"x","sign")};return U.runKernel(id,t)}var DE=W({sign_:pJ});function fJ(e){let t={x:F(e,"x","sin","float32")};return U.runKernel(rd,t)}var w1=W({sin_:fJ});function mJ(e){let t={x:F(e,"x","sinh")};return U.runKernel(sd,t)}var _1=W({sinh_:mJ});function gJ(e,t,n){let a=F(e,"x","slice1d");return z(a.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${a.rank} tensor`),vt(a,[t],[n])}var Hb=W({slice1d_:gJ});function yJ(e,t,n){let a=F(e,"x","slice2d");return z(a.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${a.rank} tensor`),vt(a,t,n)}var S1=W({slice2d_:yJ});function bJ(e,t,n){let a=F(e,"x","slice3d");return z(a.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${a.rank} tensor`),vt(a,t,n)}var Rm=W({slice3d_:bJ});function vJ(e,t,n){let a=F(e,"x","slice4d");return z(a.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${a.rank} tensor`),vt(a,t,n)}var Yp=W({slice4d_:vJ});function xJ(e,t=-1){let n=F(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let a={logits:n},r={dim:t};return U.runKernel(hd,a,r)}var bu=W({softmax_:xJ});function wJ(e){z(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return U.runKernel(Kw,t)}var qb=W({fft_:wJ});function _J(e){z(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return U.runKernel(Xw,t)}var Zp=W({ifft_:_J});function SJ(e){let t=e.shape[e.shape.length-1],n=e.size/t,a;if(t<=2){let r=K(e,[n,t]);a=Zp(r)}else{let r=[n,2*(t-1)],s=K(Qp(e),[n,t]),i=K(zb(e),[n,t]),o=hs(vt(s,[0,1],[n,t-2]),1),l=G(hs(vt(i,[0,1],[n,t-2]),1),ze(-1)),c=Qt([s,o],1),u=Qt([i,l],1),h=K(Eo(c,u),[r[0],r[1]]);a=Zp(h)}if(a=Qp(a),e.rank===3&&e.shape[0]!==0){let r=a,s=e.shape[0];a=K(a,[s,a.shape[0]/s,a.shape[1]]),r.dispose()}return a}var I1=W({irfft_:SJ});function IJ(e,t,n=0){let a={x:F(e,"x","split")},r={numOrSizeSplits:t,axis:n};return U.runKernel(gm,a,r)}var fr=W({split_:IJ});function kJ(e,t){z(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],a=e.size/n,r;if(t!=null&&t<n){let f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,r=vt(e,f,m),n=t}else if(t!=null&&t>n){let f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,r=Qt([e,_n(f)],e.shape.length-1),n=t}else r=e;let s=_t(r),i=K(Eo(r,s),[a,n]),o=qb(i),l=Math.floor(n/2)+1,c=Qp(o),u=zb(o),h=fr(c,[l,n-l],c.shape.length-1),d=fr(u,[l,n-l],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,K(Eo(h[0],d[0]),p)}var Kb=W({rfft_:kJ});function TJ(e,t){let n=F(e,"a","squaredDifference"),a=F(t,"b","squaredDifference");[n,a]=In(n,a),Yt(n.shape,a.shape);let r={a:n,b:a},s={};return U.runKernel(dd,r,s)}var k1=W({squaredDifference_:TJ});function EJ(e,t){let n=F(e,"x","squeeze","string_or_numeric");return K(n,Az(n.shape,t).newShape)}var vu=W({squeeze_:EJ});function NJ(e,t=0){let n=ky(e,"tensors","stack","string_or_numeric");z(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&z(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let a=n,r={axis:t};return U.runKernel(im,a,r)}var Bn=W({stack_:NJ});function CJ(e,t=0){let n={x:F(e,"x","step")},a={alpha:t};return U.runKernel(fu,n,a)}var vd=W({step_:CJ});function AJ(e,t,n,a,r=0,s=0,i=0,o=0,l=0){let c={x:F(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return U.runKernel(vm,c,u)}var $E=W({stridedSlice_:AJ});function RJ(e){let t={x:F(e,"x","tan","float32")};return U.runKernel(fd,t)}var ME=W({tan_:RJ});function Ft(e,t){Yc(e);let n=Fi(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return mu(e,null,n,t)}function Ai(e,t,n){if(Yc(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let a=Fi(e,n);if(a.length!==2&&a.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return mu(e,t,a,n)}function T1(e,t,n){if(Yc(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let a=Fi(e,n);if(a.length!==3&&a.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return mu(e,t,a,n)}function ql(e,t,n){if(Yc(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let a=Fi(e,n);if(a.length!==4&&a.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return mu(e,t,a,n)}function rP(e,t,n){if(Yc(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let a=Fi(e,n);if(a.length!==5&&a.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return mu(e,t,a,n)}function sP(e,t,n){if(Yc(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let a=Fi(e,n);if(a.length!==6&&a.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(a.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||a,mu(e,t,a,n)}var E1={};tt(E1,{calculateShapes:()=>iP,validateInput:()=>N1,validateUpdateShape:()=>OE});function OE(e,t,n){let a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${a}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(s+` update.rank < ${r}. `);if(e.length<a+(n.rank-r))throw new Error(s+` Output shape length < ${a+(n.rank-r)}`);if(n.rank!==r+e.length-a)throw new Error(s+` update.rank != ${r+e.length-a}`);for(let i=0;i<r;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==e[i+a])throw new Error(s+` updates.shape[${i+r}] (${n.shape[i+r]}) != shape[${i+r}] (${e[i+r]})`)}function N1(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}OE(n,t,e)}function iP(e,t,n){let a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length,i=1;for(let h=r;h<s;++h)i*=n[h];let o=r<1?1:r,l=Ut(t.shape)/o,c=[..._f(n.slice(0,r)),1],u=Ut(n);return{sliceRank:r,numUpdates:l,sliceSize:i,strides:c,outputSize:u}}function DJ(e,t,n){let a=F(e,"tensor","tensorScatterupdate"),r=F(t,"indices","tensorScatterupdate","int32"),s=F(n,"updates","tensorScatterupdate");if(N1(s,r,a.shape),a.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${a.dtype} and ${s.dtype}.`);let i={tensor:a,indices:r,updates:s},o={};return U.runKernel(hm,i,o)}var oP=W({tensorScatterUpdate_:DJ});function $J(e,t=1,n=!0){let a=F(e,"x","topk");if(a.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let r=a.shape[a.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);let s={x:a},i={k:t,sorted:n},[o,l]=U.runKernel(xm,s,i);return{values:o,indices:l}}var FE=W({topk_:$J});function MJ(e,t=0,n=1,a,r){if(Ur(e),a!=null&&a==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new AE(t,n,a,!0,r),i=ut(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var C1=W({truncatedNormal_:MJ});function OJ(e,t=0){let n=F(e,"x","unique","string_or_numeric");z(n.rank>0,()=>"The input tensor must be at least 1D");let a={x:n},r={axis:t},[s,i]=U.runKernel(Nb,a,r);return{values:s,indices:i}}var LE=W({unique_:OJ});function FJ(e,t,n){let a=F(e,"x","unsortedSegmentSum"),r=F(t,"segmentIds","unsortedSegmentSum","int32");z(Wp(n),()=>"numSegments must be of dtype int");let s={x:a,segmentIds:r},i={numSegments:n};return U.runKernel(Cb,s,i)}var A1=W({unsortedSegmentSum_:FJ});function LJ(e,t=0){let n=F(e,"x","unstack","string_or_numeric");z(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let a={value:n},r={axis:t};return U.runKernel(_m,a,r)}var Tn=W({unstack_:LJ});function lP(e,t){return m1(e,t,"right")}function zE(e,t=!0,n,a){return U.makeVariable(e,t,n,a)}function uP(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let a=ut(e,"int32"),r=ut([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let i=a.indexToLoc(n[s]),o=s*e.length;r.values.set(i,o)}return r.toTensor()}async function zJ(e){let t=F(e,"condition","whereAsync","bool"),n=await t.data(),a=uP(t.shape,n);return e!==t&&t.dispose(),a}var PE=zJ;async function PJ(e,t,n){let a=F(e,"tensor","boolMask"),r=F(t,"mask","boolMask","bool"),s=n??0,i=r.rank,o=a.shape;z(i>0,()=>"mask cannot be scalar"),ar(o.slice(s,s+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];let c=o.slice(0,s).concat([l],o.slice(s+i)),u=K(a,c),h=K(r,[-1]),d=await PE(h),p=vu(d,[1]),f=Cm(u,p,s);return e!==a&&a.dispose(),t!==r&&r.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f}var cP=PJ;function VJ(e,t,n){let a=F(e,"x","transpose");if(t==null&&(t=a.shape.map((i,o)=>o).reverse()),z(a.rank===t.length,()=>`Error in transpose: rank of input ${a.rank} must match length of perm ${t}.`),t.forEach(i=>{z(i>=0&&i<a.rank,()=>`All entries in 'perm' must be between 0 and ${a.rank-1} but got ${t}`)}),a.rank<=1)return a.clone();let r={x:a},s={perm:t};return a.dtype==="complex64"?X(()=>{let i=Qp(a),o=zb(a);return i=U.runKernel(bo,{x:i},s),o=U.runKernel(bo,{x:o},s),n&&(o=on(o)),Eo(i,o)}):U.runKernel(bo,r,s)}var lt=W({transpose_:VJ});function BJ(e,t,n,a,r=!0){let s=F(e,"v","movingAverage"),i=F(t,"x","movingAverage"),o=F(n,"decay","movingAverage");Qz(s,i),z($o(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=ze(1),c=Ie(l,o),u=G(Ie(i,s),c);if(r){z(a!=null,()=>"When using zeroDebias: true, step is required.");let h=F(a,"step","movingAverage");u=Ce(u,Ie(l,Li(o,h)))}return re(s,u)}var hP=W({movingAverage_:BJ});function UJ(e,t,n){Ur(n);let a=F(e,"indices","scatterND","int32"),r=F(t,"updates","scatterND");N1(r,a,n);let s={indices:a,updates:r},i={shape:n};return U.runKernel(cm,s,i)}var dP=W({scatterND_:UJ});function WJ(e,t,n,a){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function jJ(e,t,n,a=0){Ur(n);let r=F(e,"sparseIndices","sparseToDense","int32"),s=F(t,"sparseValues","sparseToDense","string_or_numeric"),i=F(a,"defaultValue","sparseToDense",s.dtype);WJ(r,s,n,i);let o={sparseIndices:r,sparseValues:s,defaultValue:i},l={outputShape:n};return U.runKernel(bm,o,l)}var pP=W({sparseToDense_:jJ});function GJ(e,t){let n=F(t,"indices","gatherND","int32"),a={params:F(e,"x","gatherND","string_or_numeric"),indices:n};return U.runKernel(Wf,a)}var fP=W({gatherND_:GJ});function HJ(e,t){if(t==null)return e.shape.slice();if($o(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let a=0;a<e.shape.length;a++)t[a]==null&&e.shape[a]!=null?n.push(e.shape[a]):n.push(t[a]);return n}return t}function qJ(e,t,n,a){let r=F(e,"x","dropout");if(z(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),z(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof at?r.clone():r;let s=HJ(r,n),i=1-t,o=Ce(Nm(re(yu(s,0,1,"float32",a),i)),i);return G(r,o)}var VE=W({dropout_:qJ});function BE(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function R1(e,t,n){let a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(i)}return Ft(r,"float32")}async function KJ(e,t,n=1){let a=F(e,"predictions","inTopK"),r=F(t,"targets","inTopK");z(a.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`),z(a.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${r.rank}`),ar(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=a.shape[a.shape.length-1];z(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let i=await a.data(),o=await r.data(),[l,c]=[i.length/s,s],u=Rz("bool",l);for(let h=0;h<l;h++){let d=h*c,p=i.subarray(d,d+c),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),u[h]=0;for(let m=0;m<n;m++)if(f[m].index===o[h]){u[h]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),Za(u,r.shape,"bool")}var mP=KJ,Jp={};tt(Jp,{conv2d:()=>YJ,depthwiseConv2d:()=>tee,matMul:()=>aee});function XJ(e,t,n,a,r,s="NHWC",i){let o=e;e.rank===3&&(o=K(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=K(t,[1,t.shape[0],t.shape[1],t.shape[2]])),z(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),z(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),z(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let c=s==="NHWC"?o.shape[3]:o.shape[1],u=s==="NHWC"?l.shape[3]:l.shape[1];z(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),z(u===n[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`),rr("conv2dDerFilter",r,i);let h={x:o,dy:l},d={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,filterShape:n};return U.runKernel(Ww,h,d)}var UE=W({conv2DBackpropFilter_:XJ});function D1(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return G(e,vd(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function $1(e,t){let n=t,a=Un(e.shape,t.shape);return a.length>0&&(n=De(n,a)),K(n,e.shape)}function M1(e,t,n,a){if(t==="linear")return e;if(t==="relu")return Bt(e);if(t==="elu")return Tm(e);if(t==="relu6")return y1(e);if(t==="prelu")return Gb(e,n);if(t==="leakyrelu")return Pb(e,a);if(t==="sigmoid")return Rs(e);throw new Error(`Unknown fused activation ${t}.`)}var O1=(e,t)=>!(e>0)||t==="linear";function QJ({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",O1(U.state.gradientDepth,l)===!1){z(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let M=Ja(e,t,n,a,r,s,i);return o!=null&&(M=re(M,o)),M1(M,l,c,u)}let h=F(e,"x","conv2d","float32"),d=F(t,"filter","conv2d","float32"),p=h,f=!1;h.rank===3&&(f=!0,p=K(h,[1,h.shape[0],h.shape[1],h.shape[2]])),z(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),z(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),rr("fused conv2d",a,i);let m=r==="NHWC"?p.shape[3]:p.shape[1];z(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),z(ji(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let g=Ob(p.shape,d.shape,n,s,a,i),y;o!=null&&(y=F(o,"bias","fused conv2d"),[y]=In(y,h),r==="NHWC"?Yt(g.outShape,y.shape):(z(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),z(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let v;if(c!=null){let M=c.shape;if(z(M.length<=1||M.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${M.length}.`),M.length===1)z(M[0]===1||M[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${M}) is not compatible with the number of output channels (${g.outChannels}).`);else if(M.length===3)try{Yt(M,g.outShape)}catch{let I=`Error in fused conv2d: PReLU activation weights (${M}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(I)}v=F(c,"prelu weights","fused conv2d")}let x=(M,S)=>{z(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);let[I,E,R,A]=S,_=D1(M,R,l);z(jl(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let D=sE(E.shape,_,I,n,a),j=UE(E,_,I.shape,n,a),q=[D,j];if(A!=null){let B=$1(A,_);q.push(B)}return q},w={x:p,filter:d,bias:y,preluActivationWeights:v},k={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return o==null?zi((M,S,I)=>{let E=U.runKernel(kc,w,k);return I([S,M,E]),f&&(E=K(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:x}})(p,d):zi((M,S,I,E)=>{let R=U.runKernel(kc,w,k);return E([S,M,R,I]),f&&(R=K(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:x}})(p,d,y)}var YJ=W({fusedConv2d_:QJ});function ZJ(e,t,n,a,r,s=[1,1],i){let o=e;e.rank===3&&(o=K(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=K(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={x:o,dy:l},u={strides:a,pad:r,dimRoundingMode:i,dilations:s,filterShape:n};return U.runKernel(jw,c,u)}var gP=W({depthwiseConv2dNativeBackpropFilter_:ZJ});function JJ(e,t,n,a,r,s=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=K(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={dy:o,filter:n},u={strides:a,pad:r,dimRoundingMode:i,dilations:s,inputShape:e},h=U.runKernel(Gw,c,u);return l?K(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var yP=W({depthwiseConv2dNativeBackpropInput_:JJ});function eee({x:e,filter:t,strides:n,pad:a,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(O1(U.state.gradientDepth,l)===!1){let k=yd(e,t,n,a,r,s,i);return o!=null&&(k=re(k,o)),M1(k,l,c,u)}let h=F(e,"x","depthwiseConv2d","float32"),d=F(t,"filter","depthwiseConv2d","float32"),p=h,f=!1;h.rank===3&&(f=!0,p=K(h,[1,h.shape[0],h.shape[1],h.shape[2]])),z(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),z(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),z(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),s==null&&(s=[1,1]),z(ji(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),rr("fused depthwiseConv2d",a,i);let m=Ob(p.shape,d.shape,n,s,a,i,!0),g;o!=null&&(g=F(o,"bias","fused conv2d"),[g]=In(g,h),Yt(m.outShape,g.shape));let y;c!=null&&(y=F(c,"prelu weights","fused depthwiseConv2d"));let v=(k,M)=>{z(jl(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[S,I,E,R]=M,A=D1(k,E,l),_=yP(I.shape,A,S,n,a,s,i),D=gP(I,A,S.shape,n,a,s,i);if(R!=null){let j=$1(g,A);return[_,D,j]}return[_,D]},x={x:p,filter:d,bias:g,preluActivationWeights:y},w={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return o==null?zi((k,M,S)=>{let I=U.runKernel(Tc,x,w);return S([M,k,I]),f&&(I=K(I,[I.shape[1],I.shape[2],I.shape[3]])),{value:I,gradFunc:v}})(p,d):zi((k,M,S,I)=>{let E=U.runKernel(Tc,x,w);return I([M,k,E,S]),f&&(E=K(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:v}})(p,d,g)}var tee=W({fusedDepthwiseConv2d_:eee});function nee({a:e,b:t,transposeA:n=!1,transposeB:a=!1,bias:r,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(O1(U.state.gradientDepth,s)===!1){let R=ot(e,t,n,a);return r!=null&&(R=re(R,r)),M1(R,s,i,o)}let l=F(e,"a","fused matMul"),c=F(t,"b","fused matMul");[l,c]=In(l,c);let u=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=a?c.shape[c.rank-1]:c.shape[c.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=a?c.shape[c.rank-2]:c.shape[c.rank-1],f=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=Ut(f),y=Ut(m);z(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${a} must match.`);let v=Yt(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,p]),x=n?K(l,[g,u,d]):K(l,[g,d,u]),w=a?K(c,[y,p,h]):K(c,[y,h,p]),k;r!=null&&(k=F(r,"bias","fused matMul"),[k]=In(k,l),Yt(v,k.shape));let M;i!=null&&(M=F(i,"prelu weights","fused matMul"));let S=(R,A)=>{let[_,D,j,q]=A,B=D1(K(R,j.shape),j,s),Q,H;if(!n&&!a?(Q=ot(B,D,!1,!0),H=ot(_,B,!0,!1)):!n&&a?(Q=ot(B,D,!1,!1),H=ot(B,_,!0,!1)):n&&!a?(Q=ot(D,B,!1,!0),H=ot(_,B,!1,!1)):(Q=ot(D,B,!0,!0),H=ot(B,_,!0,!0)),r!=null){let J=$1(q,B);return[Q,H,J]}else return[Q,H]},I={a:x,b:w,bias:k,preluActivationWeights:M},E={transposeA:n,transposeB:a,activation:s,leakyreluAlpha:o};return r==null?zi((R,A,_)=>{let D=U.runKernel(Ic,I,E);return _([R,A,D]),{value:K(D,v),gradFunc:S}})(x,w):zi((R,A,_,D)=>{let j=U.runKernel(Ic,I,E);return D([R,A,j,_]),{value:K(j,v),gradFunc:S}})(x,w,k)}var aee=W({fusedMatMul_:nee});function ree(e){return R1(e,.54,.46)}var see=W({hammingWindow_:ree});function iee(e){return R1(e,.5,.5)}var bP=W({hannWindow_:iee});function oee(e,t,n,a=!1,r=0){let s=0,i=[];for(;s+t<=e.size;)i.push(vt(e,s,t)),s+=n;if(a)for(;s<e.size;){let o=s+t-e.size,l=Qt([vt(e,s,t-o),Mr([o],r)]);i.push(l),s+=n}return i.length===0?Ai([],[0,t]):K(Qt(i),[i.length,t])}var vP=W({frame_:oee});function lee(e,t,n,a,r=bP){a==null&&(a=BE(t));let s=vP(e,t,n),i=G(s,r(t));return Kb(i,a)}var uee=W({stft_:lee});function cee(e,t,n,a,r="bilinear",s=0){let i=F(e,"image","cropAndResize"),o=F(t,"boxes","cropAndResize","float32"),l=F(n,"boxInd","cropAndResize","int32"),c=o.shape[0];z(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),z(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`),z(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`),z(a.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${a.length}.`),z(a[0]>=1&&a[1]>=1,()=>`cropSize must be atleast [1,1], but was ${a}`),z(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);let u={image:i,boxes:o,boxInd:l},h={method:r,extrapolationValue:s,cropSize:a};return U.runKernel(Ff,u,h)}var hee=W({cropAndResize_:cee});function dee(e){let t=F(e,"image","flipLeftRight","float32");z(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return U.runKernel(Bf,n,{})}var pee=W({flipLeftRight_:dee});function fee(e){let t=F(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];z(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),z(a===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${a}.`);let r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,Dr(t,r)}var mee=W({grayscaleToRGB_:fee});function gee(e){let t=F(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];z(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),z(a===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${a}.`);let r=t.dtype,s=ye(t,"float32"),i=Ft([.2989,.587,.114]),o;switch(t.rank){case 2:o=nc("ij,j->i",s,i);break;case 3:o=nc("ijk,k->ij",s,i);break;case 4:o=nc("ijkl,l->ijk",s,i);break;case 5:o=nc("ijklm,m->ijkl",s,i);break;case 6:o=nc("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=pa(o,-1),ye(o,r)}var yee=W({rgbToGrayscale_:gee});function bee(e,t,n=0,a=.5){let r=F(e,"image","rotateWithOffset","float32");z(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);let s={image:r},i={radians:t,fillValue:n,center:a};return U.runKernel(Im,s,i)}var vee=W({rotateWithOffset_:bee});function Dm(e,t,n,a,r,s){a==null&&(a=.5),r==null&&(r=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return n=Math.min(n,i),z(0<=a&&a<=1,()=>`iouThreshold must be in [0, 1], but was '${a}'`),z(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),z(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),z(t.rank===1,()=>"scores must be a 1D tensor"),z(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),z(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}function xee(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let s=F(e,"boxes","nonMaxSuppression","float32"),i=F(t,"scores","nonMaxSuppression","float32"),o=Dm(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return U.runKernel(nm,{boxes:s,scores:i},l)}var wee=W({nonMaxSuppression_:xee});function _ee(e,t,n){let a=See(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function See(e,t,n){return kee(e,t,n||Iee)}function Iee(e,t){return e>t?1:e<t?-1:0}function kee(e,t,n){let a=0,r=e.length,s=0,i=!1;for(;a<r;){s=a+(r-a>>>1);let o=n(t,e[s]);o>0?a=s+1:(r=s,i=!o)}return i?a:-a-1}function xP(e,t,n,a,r){return WE(e,t,n,a,r,0)}function wP(e,t,n,a,r,s){return WE(e,t,n,a,r,0,!1,s,!0)}function _P(e,t,n,a,r,s){return WE(e,t,n,a,r,s,!0)}function WE(e,t,n,a,r,s,i=!1,o=!1,l=!1){let c=[];for(let g=0;g<t.length;g++)t[g]>r&&c.push({score:t[g],boxIndex:g,suppressBeginIndex:0});c.sort(C$);let u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){let g=c.pop(),{score:y,boxIndex:v,suppressBeginIndex:x}=g;if(y<r)break;let w=!1;for(let k=h.length-1;k>=x;--k){let M=Tee(e,v,h[k]);if(M>=a){w=!0;break}if(g.score=g.score*Eee(a,u,M),g.score<=r)break}g.suppressBeginIndex=h.length,w||(g.score===y?(h.push(v),d.push(g.score)):g.score>r&&_ee(c,g,C$))}let p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));let m={selectedIndices:h};return i&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function Tee(e,t,n){let a=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),s=Math.min(a[0],a[2]),i=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),l=Math.max(a[1],a[3]),c=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(o-s)*(l-i),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;let m=Math.max(s,c),g=Math.max(i,u),y=Math.min(o,h),v=Math.min(l,d),x=Math.max(y-m,0)*Math.max(v-g,0);return x/(p+f-x)}function Eee(e,t,n){let a=Math.exp(t*n*n);return n<=e?a:0}function C$(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function Nee(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let s=F(e,"boxes","nonMaxSuppressionAsync"),i=F(t,"scores","nonMaxSuppressionAsync"),o=Dm(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),c=l[0],u=l[1],{selectedIndices:h}=xP(c,u,n,a,r);return s!==e&&s.dispose(),i!==t&&i.dispose(),Ft(h,"int32")}var Cee=Nee;function Aee(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=F(e,"boxes","nonMaxSuppression"),o=F(t,"scores","nonMaxSuppression"),l=Dm(i,o,n,a,r,s);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;let c={boxes:i,scores:o},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s},h=U.runKernel(rm,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}var Ree=W({nonMaxSuppressionWithScore_:Aee});async function Dee(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=F(e,"boxes","nonMaxSuppressionAsync"),o=F(t,"scores","nonMaxSuppressionAsync"),l=Dm(i,o,n,a,r,s);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;let c=await Promise.all([i.data(),o.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=_P(u,h,n,a,r,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Ft(d,"int32"),selectedScores:Ft(p)}}var $ee=Dee;function Mee(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=F(e,"boxes","nonMaxSuppression"),o=F(t,"scores","nonMaxSuppression"),l=Dm(i,o,n,a,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,d={boxes:i,scores:o},p={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:s},f=U.runKernel(am,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}var Oee=W({nonMaxSuppressionPadded_:Mee});async function Fee(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=F(e,"boxes","nonMaxSuppressionAsync"),o=F(t,"scores","nonMaxSuppressionAsync"),l=Dm(i,o,n,a,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=wP(d,p,c,u,h,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Ft(f,"int32"),validOutputs:ze(m,"int32")}}var Lee=Fee;function zee(e,t,n=!1,a=!1){let r=F(e,"images","resizeBilinear");z(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),z(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),z(a===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;r.rank===3&&(i=!0,s=K(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},c=U.runKernel(Zh,o,l);return i?K(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var SP=W({resizeBilinear_:zee});function Pee(e,t,n=!1,a=!1){let r=F(e,"images","resizeNearestNeighbor");z(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),z(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),z(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),z(a===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;r.rank===3&&(i=!0,s=K(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},c=U.runKernel(Yh,o,l);return i?K(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var IP=W({resizeNearestNeighbor_:Pee});function Vee(e,t="binary",n=!1,a=.5){let r=F(e,"image","threshold"),s=.2989,i=.587,o=.114,l=r.shape[0]*r.shape[1],c=G(Ft([a]),255),u,h,d,p;if(z(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),z(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),z(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),z(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[u,h,d]=fr(r,[1,1,1],-1);let m=G(u,s),g=G(h,i),y=G(d,o);p=re(re(m,g),y)}else p=e;if(t==="otsu"){let m=J2(ye(b1(p),"int32"),Za([]),256);c=Bee(m,l)}let f=n?gu(p,c):sr(p,c);return ye(G(f,255),"int32")}function Bee(e,t){let n=Ft([-1]),a=Ft([0]),r=Ft([0]),s,i,o,l,c,u;for(let h=0;h<e.size-1;h++){s=vt(e,0,h+1),i=vt(e,h+1),c=Ce(De(s),t),u=Ce(De(i),t);let d=De(G(s,Oc(0,s.size)));o=Ce(d,De(s));let p=Mr(i.shape,s.size),f=re(Oc(0,i.size),p),m=G(i,f);l=Ce(De(m),De(i));let g=Ie(o,l),y=Ie(o,l),v=G(c,u);r=G(G(v,g),y);let x=sr(r,a);a=ga(x,r,a),n=ga(x,Ft([h]),n)}return n}var Uee=W({threshold_:Vee});function Wee(e,t,n="nearest",a="constant",r=0,s){let i=F(e,"image","transform","float32"),o=F(t,"transforms","transform","float32");z(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),z(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),z(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:o},c={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return U.runKernel(wm,l,c)}var jee=W({transform_:Wee});function Gee(e,t,n){let a=F(e,"a","bandPart");z(a.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${a.rank}.`);let r=a.shape,[s,i]=a.shape.slice(-2),o,l;typeof t=="number"?(z(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),z(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=F(t<0?s:t,"numLower","bandPart")):(z(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=ga(Kp(t,0),s,Hl(t,s))),typeof n=="number"?(z(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),z(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=F(n<0?i:n,"numUpper","bandPart")):(z(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=ga(Kp(n,0),i,Hl(n,i)));let c=K(Oc(0,s,1,"int32"),[-1,1]),u=Oc(0,i,1,"int32"),h=Ie(c,u),d=Ms(gu(h,o),Fo(h,on(l))),p=_n([s,i],a.dtype);return K(Bn(Tn(K(a,[-1,s,i])).map(f=>ga(d,f,p))),r)}var Hee=W({bandPart_:Gee});function qee(e){let t;if(Array.isArray(e)){t=!1,z(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let r=e[0].shape[0];for(let s=1;s<e.length;++s)z(e[s].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${r})`)}else t=!0,e=fr(e,e.shape[0],0).map(r=>vu(r,[0]));z(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],a=e;for(let r=0;r<e.length;++r)n.push(U.tidy(()=>{let s=a[r];if(r>0)for(let i=0;i<r;++i){let o=G(De(G(n[i],s)),n[i]);s=Ie(s,o)}return Ce(s,Em(s,"euclidean"))}));return t?Bn(n,0):n}var Kee=W({gramSchmidt_:qee});function Xee(e,t=!1){if(z(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return A$(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,c)=>l*c),a=Tn(K(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];a.forEach(l=>{let[c,u]=A$(l,t);r.push(c),s.push(u)});let i=K(Bn(r,0),e.shape),o=K(Bn(s,0),e.shape);return[i,o]}}function A$(e,t=!1){return U.tidy(()=>{z(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],a=e.shape[1],r=h1(n),s=Ci(e),i=Ai([[1]],[1,1]),o=Ci(i),l=n>=a?a:n;for(let c=0;c<l;++c){let u=s,h=o,d=r;[o,s,r]=U.tidy(()=>{let p=vt(s,[c,c],[n-c,1]),f=Em(p),m=vt(s,[c,c],[1,1]),g=ga(sr(m,0),Ai([[-1]]),Ai([[1]])),y=Ie(m,G(g,f)),v=Ce(p,y);v.shape[0]===1?o=Ci(i):o=Qt([i,vt(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);let x=on(Ce(ot(g,y),f)),w=vt(s,[c,0],[n-c,a]),k=G(x,o),M=lt(o);if(c===0)s=Ie(w,ot(k,ot(M,w)));else{let E=Ie(w,ot(k,ot(M,w)));s=Qt([vt(s,[0,0],[c,a]),E],0)}let S=lt(k),I=vt(r,[0,c],[n,r.shape[1]-c]);if(c===0)r=Ie(I,ot(ot(I,o),S));else{let E=Ie(I,ot(ot(I,o),S));r=Qt([vt(r,[0,0],[n,c]),E],1)}return[o,s,r]}),et([u,h,d])}return!t&&n>a&&(r=vt(r,[0,0],[n,a]),s=vt(s,[0,0],[a,a])),[r,s]})}var Qee=W({qr_:Xee}),Qa;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Qa||(Qa={}));function Yee(e,t,n=Qa.SUM_BY_NONZERO_WEIGHTS){let a=F(e,"losses","computeWeightedLoss"),r=null;t!=null&&(r=F(t,"weights","computeWeightedLoss"));let s=r==null?a:G(a,r);if(n===Qa.NONE)return s;if(n===Qa.SUM)return De(s);if(n===Qa.MEAN){if(r==null)return wn(s);{let i=a.size/r.size,o=Ce(De(s),De(r));return i>1?Ce(o,ze(i)):o}}if(n===Qa.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Ce(De(s),ze(a.size));{let i=G(r,pr(a.shape)),o=ye(De(Mc(i,ze(0))),"float32");return Ce(De(s),o)}}throw Error(`Unknown reduction: ${n}`)}var Lo=W({computeWeightedLoss_:Yee});function Zee(e,t,n,a=Qa.SUM_BY_NONZERO_WEIGHTS){let r=F(e,"labels","absoluteDifference"),s=F(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=F(n,"weights","absoluteDifference")),ar(r.shape,s.shape,"Error in absoluteDifference: ");let o=On(Ie(r,s));return Lo(o,i,a)}var Jee=W({absoluteDifference_:Zee});function ete(e,t,n,a,r=Qa.SUM_BY_NONZERO_WEIGHTS){let s=F(e,"labels","cosineDistance"),i=F(t,"predictions","cosineDistance"),o=null;a!=null&&(o=F(a,"weights","cosineDistance")),ar(s.shape,i.shape,"Error in cosineDistance: ");let l=ze(1),c=Ie(l,De(G(s,i),n,!0));return Lo(c,o,r)}var tte=W({cosineDistance_:ete});function nte(e,t,n,a=Qa.SUM_BY_NONZERO_WEIGHTS){let r=F(e,"labels","hingeLoss"),s=F(t,"predictions","hingeLoss"),i=null;n!=null&&(i=F(n,"weights","hingeLoss")),ar(r.shape,s.shape,"Error in hingeLoss: ");let o=ze(1);r=Ie(G(ze(2),r),o);let l=Bt(Ie(o,G(r,s)));return Lo(l,i,a)}var ate=W({hingeLoss_:nte});function rte(e,t,n,a=1,r=Qa.SUM_BY_NONZERO_WEIGHTS){let s=F(e,"labels","huberLoss"),i=F(t,"predictions","huberLoss"),o=null;n!=null&&(o=F(n,"weights","huberLoss")),ar(s.shape,i.shape,"Error in huberLoss: ");let l=ze(a),c=On(Ie(i,s)),u=Hl(c,l),h=Ie(c,u),d=re(G(ze(.5),Xt(u)),G(l,h));return Lo(d,o,r)}var ste=W({huberLoss_:rte});function ite(e,t,n,a=1e-7,r=Qa.SUM_BY_NONZERO_WEIGHTS){let s=F(e,"labels","logLoss"),i=F(t,"predictions","logLoss"),o=null;n!=null&&(o=F(n,"weights","logLoss")),ar(s.shape,i.shape,"Error in logLoss: ");let l=ze(1),c=ze(a),u=on(G(s,zr(re(i,c)))),h=G(Ie(l,s),zr(re(Ie(l,i),c))),d=Ie(u,h);return Lo(d,o,r)}var ote=W({logLoss_:ite});function lte(e,t,n,a=Qa.SUM_BY_NONZERO_WEIGHTS){let r=F(e,"labels","meanSquaredError"),s=F(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=F(n,"weights","meanSquaredError")),ar(r.shape,s.shape,"Error in meanSquaredError: ");let o=k1(r,s);return Lo(o,i,a)}var ute=W({meanSquaredError_:lte});function cte(e,t){let n=F(e,"labels","sigmoidCrossEntropyWithLogits"),a=F(t,"logits","sigmoidCrossEntropyWithLogits");ar(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");let r=Bt(a),s=G(a,n),i=Vb(Ba(on(On(a))));return re(Ie(r,s),i)}function hte(e,t,n,a=0,r=Qa.SUM_BY_NONZERO_WEIGHTS){let s=F(e,"multiClassLabels","sigmoidCrossEntropy"),i=F(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=F(n,"weights","sigmoidCrossEntropy")),ar(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),a>0){let c=ze(a),u=ze(1),h=ze(.5);s=re(G(s,Ie(u,c)),G(h,c))}let l=cte(s,i);return Lo(l,o,r)}var dte=W({sigmoidCrossEntropy_:hte});function pte(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return zi((a,r,s)=>{let i=Bb(r,[n],!0),o=Ie(ye(r,"float32"),i);s([a,o]);let l=on(G(o,a));return{value:De(l,[n]),gradFunc:(c,u)=>{let[h,d]=u,p=$c(c.shape,[n]);return[G(K(c,p),Ie(ye(h,"float32"),Ba(d))),G(K(c,p),Ie(Ba(d),ye(h,"float32")))]}}})(e,t)}function fte(e,t,n,a=0,r=Qa.SUM_BY_NONZERO_WEIGHTS){let s=F(e,"onehotLabels","softmaxCrossEntropy"),i=F(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=F(n,"weights","softmaxCrossEntropy")),ar(s.shape,i.shape,"Error in softmaxCrossEntropy: "),a>0){let c=ze(a),u=ze(1),h=ze(s.shape[1]);s=re(G(s,Ie(u,c)),Ce(c,h))}let l=pte(s,i);return Lo(l,o,r)}var mte=W({softmaxCrossEntropy_:fte});function gte(e,t,n,a){let r=F(e,"indices","sparseFillEmptyRows","int32"),s=F(t,"values","sparseFillEmptyRows"),i=F(n,"denseShape","sparseFillEmptyRows","int32"),o=F(a,"defaultValue","sparseFillEmptyRows",s.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:r,values:s,denseShape:i,defaultValue:o},c=U.runKernel(xb,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}var yte=W({sparseFillEmptyRows_:gte});function bte(e,t,n){let a=F(e,"inputIndices","sparseReshape","int32"),r=F(t,"inputShape","sparseReshape","int32"),s=F(n,"newShape","sparseReshape","int32");if(a.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${a.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:a,inputShape:r,newShape:s},o=U.runKernel(ym,i);return{outputIndices:o[0],outputShape:o[1]}}var vte=W({sparseReshape_:bte});function xte(e,t,n){let a=F(e,"data","sparseSegmentMean"),r=F(t,"indices","sparseSegmentMean","int32"),s=F(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:a,indices:r,segmentIds:s};return U.runKernel(wb,i)}var wte=W({sparseSegmentMean_:xte});function _te(e,t,n){let a=F(e,"data","sparseSegmentSum"),r=F(t,"indices","sparseSegmentSum","int32"),s=F(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:a,indices:r,segmentIds:s};return U.runKernel(_b,i)}var Ste=W({sparseSegmentSum_:_te});function Ite(e,t,n,a,r,s,i,o){let l=F(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let c=F(t,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let u={separator:n,nGramWidths:a,leftPad:r,rightPad:s,padWidth:i,preserveShortSequences:o},h={data:l,dataSplits:c},d=U.runKernel(kb,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}var kte=W({stringNGrams_:Ite});function Tte(e,t,n=!0){let a=F(e,"input","stringSplit","string"),r=F(t,"delimiter","stringSplit","string");if(a.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${a.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);let s={skipEmpty:n},i={input:a,delimiter:r},o=U.runKernel(Tb,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var Ete=W({stringSplit_:Tte});function Nte(e,t){let n=F(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let r={input:n};return U.runKernel(Eb,r,a)}var Cte=W({stringToHashBucketFast_:Nte});function Ate(e,t,n,a=!0){let r=F(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:a};return U.runKernel(Ib,{x:r},s)}var Rte=W({staticRegexReplace_:Ate}),kP={fft:qb,ifft:Zp,rfft:Kb,irfft:I1},TP={hammingWindow:see,hannWindow:bP,frame:vP,stft:uee},Yr={flipLeftRight:pee,grayscaleToRGB:mee,resizeNearestNeighbor:IP,resizeBilinear:SP,rgbToGrayscale:yee,rotateWithOffset:vee,cropAndResize:hee,nonMaxSuppression:wee,nonMaxSuppressionAsync:Cee,nonMaxSuppressionWithScore:Ree,nonMaxSuppressionWithScoreAsync:$ee,nonMaxSuppressionPadded:Oee,nonMaxSuppressionPaddedAsync:Lee,threshold:Uee,transform:jee},jE={bandPart:Hee,gramSchmidt:Kee,qr:Qee},EP={absoluteDifference:Jee,computeWeightedLoss:Lo,cosineDistance:tte,hingeLoss:ate,huberLoss:ste,logLoss:ote,meanSquaredError:ute,sigmoidCrossEntropy:dte,softmaxCrossEntropy:mte},NP={sparseFillEmptyRows:yte,sparseReshape:vte,sparseSegmentMean:wte,sparseSegmentSum:Ste},CP={stringNGrams:kte,stringSplit:Ete,stringToHashBucketFast:Cte,staticRegexReplace:Rte},de={};tt(de,{Serializable:()=>AP,SerializationMap:()=>RP,getRegisteredName:()=>$te,registerClass:()=>DP});var Dte=new Map,ck=new Map,AP=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},RP=class Jd{constructor(){this.classNameMap={}}static getMap(){return Jd.instance==null&&(Jd.instance=new Jd),Jd.instance}static register(t){Jd.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function DP(e,t,n){z(e.className!=null,()=>"Class being registered does not have the static className property defined."),z(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),z(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let a=n,r=t+">"+a;return RP.register(e),Dte.set(r,e),ck.set(e,r),e}function $te(e){return ck.has(e)?ck.get(e):e.className}var zo=class extends AP{minimize(e,t=!1,n){let{value:a,grads:r}=this.computeGradients(e,n);if(n!=null){let s=n.map(i=>({name:i.name,tensor:r[i.name]}));this.applyGradients(s)}else this.applyGradients(r);return et(r),t?a:(a.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return D4(e,t)}dispose(){this.iterations_!=null&&et(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ze(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(zo,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var GE=class extends zo{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=U.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=U.registeredVariables[t],r=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:X(()=>_t(a).variable(r))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:X(()=>_t(a).variable(r))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;X(()=>{let l=re(G(i,this.rho),G(Xt(s),1-this.rho)),c=G(Ce(va(re(o,this.epsilon)),va(re(i,this.epsilon))),s),u=re(G(o,this.rho),G(Xt(c),1-this.rho));i.assign(l),o.assign(u);let h=re(G(c,-this.learningRate),a);a.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(et(this.accumulatedGrads.map(e=>e.variable)),et(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},HE=class extends zo{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=U.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:X(()=>Mr(a.shape,this.initialAccumulatorValue).variable(!1))});let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let s=this.accumulatedGrads[n].variable;X(()=>{let i=re(s,Xt(r));s.assign(i);let o=re(G(Ce(r,va(re(i,U.backend.epsilon()))),-this.learningRate),a);a.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&et(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},qE=class extends zo{static get className(){return"Adam"}constructor(e,t,n,a=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],X(()=>{this.accBeta1=ze(t).variable(),this.accBeta2=ze(n).variable()}),a==null&&(this.epsilon=U.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);X(()=>{let n=Ie(1,this.accBeta1),a=Ie(1,this.accBeta2);t.forEach((r,s)=>{let i=U.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:X(()=>_t(i).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${r}/v`,variable:X(()=>_t(i).variable(o))});let l=Array.isArray(e)?e[s].tensor:e[r];if(l==null)return;let c=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,h=re(G(c,this.beta1),G(l,1-this.beta1)),d=re(G(u,this.beta2),G(Xt(l),1-this.beta2)),p=Ce(h,n),f=Ce(d,a);c.assign(h),u.assign(d);let m=re(G(Ce(p,re(va(f),this.epsilon)),-this.learningRate),i);i.assign(m)}),this.accBeta1.assign(G(this.accBeta1,this.beta1)),this.accBeta2.assign(G(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&et(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&et(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),X(()=>{this.accBeta1.assign(Li(this.beta1,this.iterations_+1)),this.accBeta2.assign(Li(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},KE=class extends zo{static get className(){return"Adamax"}constructor(e,t,n,a=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],X(()=>{this.iteration=ze(0).variable(),this.accBeta1=ze(t).variable()}),a==null&&(this.epsilon=U.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);X(()=>{let n=Ie(1,this.accBeta1),a=Ce(-this.learningRate,re(G(this.iteration,this.decay),1));t.forEach((r,s)=>{let i=U.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:_t(i).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${r}/v`,variable:_t(i).variable(o)});let l=Array.isArray(e)?e[s].tensor:e[r];if(l==null)return;let c=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,h=re(G(c,this.beta1),G(l,1-this.beta1)),d=G(u,this.beta2),p=On(l),f=Gi(d,p);c.assign(h),u.assign(f);let m=re(G(Ce(a,n),Ce(h,re(f,this.epsilon))),i);i.assign(m)}),this.iteration.assign(re(this.iteration,1)),this.accBeta1.assign(G(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&et(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&et(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},F1=class extends zo{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let r=U.registeredVariables[t];X(()=>{let s=re(G(this.c,a),r);r.assign(s)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Jn(ze(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},XE=class extends F1{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=ze(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=U.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:X(()=>_t(a).variable(!1))});let r=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];s!=null&&X(()=>{let i,o=re(G(this.m,r),s);this.useNesterov?i=re(G(this.c,re(s,G(o,this.m))),a):i=re(G(this.c,o),a),r.assign(o),a.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&et(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},QE=class extends zo{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,a=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,a==null&&(this.epsilon=U.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=U.registeredVariables[t],r=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:X(()=>_t(a).variable(r))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:X(()=>_t(a).variable(r))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:X(()=>_t(a).variable(r))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;X(()=>{let l=re(G(i,this.decay),G(Xt(s),1-this.decay));if(this.centered){let c=this.accumulatedMeanGrads[n].variable,u=re(G(c,this.decay),G(s,1-this.decay)),h=Ce(G(s,this.learningRate),va(Ie(l,re(Xt(u),this.epsilon)))),d=re(G(o,this.momentum),h);i.assign(l),c.assign(u),o.assign(d);let p=Ie(a,d);a.assign(p)}else{let c=re(G(i,this.decay),G(Xt(s),1-this.decay)),u=re(G(o,this.momentum),Ce(G(s,this.learningRate),va(re(c,this.epsilon))));i.assign(c),o.assign(u);let h=Ie(a,u);a.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&et(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&et(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&et(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},Mte=[GE,HE,qE,KE,XE,QE,F1];function Ote(){for(let e of Mte)DP(e)}var Ca={};tt(Ca,{CompositeArrayBuffer:()=>Mo,browserFiles:()=>Ute,browserHTTPRequest:()=>Kte,concatenateArrayBuffers:()=>_X,copyModel:()=>jX,decodeWeights:()=>r4,decodeWeightsStream:()=>i4,encodeWeights:()=>gX,fromMemory:()=>Qte,fromMemorySync:()=>LP,getLoadHandlers:()=>AX,getModelArtifactsForJSON:()=>z2,getModelArtifactsForJSONSync:()=>l4,getModelArtifactsInfoForJSON:()=>Mb,getSaveHandlers:()=>CX,getWeightSpecs:()=>rk,http:()=>ZE,isHTTPScheme:()=>dk,listModels:()=>UX,loadWeights:()=>jte,moveModel:()=>GX,registerLoadRouter:()=>NX,registerSaveRouter:()=>EX,removeModel:()=>WX,weightsLoaderFactory:()=>MP,withSaveHandler:()=>Yte,withSaveHandlerSync:()=>Zte});var Fte="model",Lte=".json",zte=".weights.bin";function R$(e){return new Promise(t=>setTimeout(t)).then(e)}var $0=class hk{constructor(t){if(!Z().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(hk.URL_SCHEME)&&(t=t.slice(hk.URL_SCHEME.length)),(t==null||t.length===0)&&(t=Fte),this.modelJsonFileName=t+Lte,this.weightDataFileName=t+zte}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=Mo.join(t.weightData),a=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=o4(t,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await R$(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=a,await R$(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Mb(t)}}}};$0.URL_SCHEME="downloads://";var Pte=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=a=>{let r=JSON.parse(a.target.result),s=r.modelTopology;if(s==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:s});return}let i=z2(r,o=>this.loadWeights(o));e(i)},n.onerror=a=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let a=this.checkManifestAndWeightFiles(e),r=n.map(s=>this.loadWeightsFile(s,a[s]));return Promise.all(r).then(s=>[t,s])}loadWeightsFile(e,t){return new Promise((n,a)=>{let r=new FileReader;r.onload=s=>{let i=s.target.result;n(i)},r.onerror=s=>a(`Failed to weights data from file of path '${e}'.`),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(r=>N$(r.name)),a={};for(let r of e)r.paths.forEach(s=>{let i=N$(s);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);a[s]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return a}},Vte=e=>Z().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith($0.URL_SCHEME)?Bte(e.slice($0.URL_SCHEME.length)):null;cs.registerSaveRouter(Vte);function Bte(e="model"){return new $0(e)}function Ute(e){return new Pte(e)}function D$(e,t,n,a){i(e),n=n??0,a=a??1,o(n,a);let r=0,s=l=>(l.then(c=>{let u=n+ ++r/e.length*(a-n);return t(u),c}),l);function i(l){z(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,c){z(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),z(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),z(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(e.map(s))}async function $P(e,t){t==null&&(t={});let n=t.fetchFunc==null?Z().platform.fetch:t.fetchFunc,a=e.map(s=>n(s,t.requestInit,{isBinary:!0})),r=(t.onProgress==null?await Promise.all(a):await D$(a,t.onProgress,0,.5)).map(s=>s.arrayBuffer());return t.onProgress==null?await Promise.all(r):await D$(r,t.onProgress,.5,1)}function Wte(e,t){var n;let a=t.fetchFunc==null?Z().platform.fetch:t.fetchFunc,r=0,s;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;r<e.length;){s||(s=(await a(e[r],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:c}=await s.read();if(l){r++,s=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,r/e.length);continue}i.enqueue(c);return}i.close()}})}async function jte(e,t="",n,a){return MP(r=>$P(r,{requestInit:a}))(e,t,n)}function MP(e){return async(t,n="",a)=>{let r=t.map(()=>!1),s={},i=a!=null?a.map(()=>!1):[],o=[];if(t.forEach((p,f)=>{let m=0;p.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,v=Nc[y]*Ut(g.shape),x=()=>{r[f]=!0,s[f]==null&&(s[f]=[]),s[f].push({manifestEntry:g,groupOffset:m,sizeBytes:v})};a!=null?a.forEach((w,k)=>{w===g.name&&(x(),i[k]=!0)}):x(),o.push(g.name),m+=v})}),!i.every(p=>p)){let p=a.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=r.reduce((p,f,m)=>(f&&p.push(m),p),[]),c=[];l.forEach(p=>{t[p].paths.forEach(f=>{let m=n+(n.endsWith("/")?"":"/")+f;c.push(m)})});let u=await e(c),h={},d=0;return l.forEach(p=>{let f=t[p].paths.length,m=new Mo(u.slice(d,d+f));s[p].forEach(g=>{let y=m.slice(g.groupOffset,g.groupOffset+g.sizeBytes),v=r4(y,[g.manifestEntry]);for(let x in v)h[x]=v[x]}),d+=f}),h}}var Gte="application/octet-stream",Hte="application/json",YE=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(z(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Z().platform.fetch,z(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&z(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],a=o4(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(a)],{type:Hte}),"model.json"),e.weightData!=null){let s=Mo.join(e.weightData);t.body.append("model.weights.bin",new Blob([s],{type:Gte}),"model.weights.bin")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Mb(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}let n=t.modelTopology,a=t.weightsManifest;if(n==null&&a==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return z2(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=rk(e.weightsManifest),a=()=>Wte(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:a})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=qte(t),r=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let l of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):s.push(r+l+a);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e),n=rk(e),a=await $P(t,this.loadOptions);return[n,a]}};YE.URL_SCHEME_REGEX=/^https?:\/\//;function qte(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}function dk(e){return e.match(YE.URL_SCHEME_REGEX)!=null}var OP=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(a=>dk(a)):n=dk(e),n)return ZE(e,t)}return null};cs.registerSaveRouter(OP);cs.registerLoadRouter(OP);function ZE(e,t){return new YE(e,t)}function Kte(e,t){return ZE(e,t)}var TS=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},FP=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},Xte=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function Qte(e,t,n,a){let r=arguments;return new Xte(LP(...r))}function LP(e,t,n,a){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new TS(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new TS({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new TS({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a}))}function Yte(e){return new FP(e)}function Zte(e){return new FP(e)}var zP={};tt(zP,{confusionMatrix:()=>ene});function Jte(e,t,n){let a=F(e,"labels","confusionMatrix"),r=F(t,"predictions","confusionMatrix");z(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),z(a.rank===1,()=>`Expected the rank of labels to be 1, but got ${a.rank}`),z(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),z(a.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${a.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),z(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let s=Xp(ye(a,"int32"),n),i=Xp(ye(r,"int32"),n),o=lt(s),l=ot(o,i);return ye(l,"int32")}var ene=W({confusionMatrix_:Jte}),Xb={};tt(Xb,{draw:()=>lne,fromPixels:()=>une,fromPixelsAsync:()=>sne,toPixels:()=>one});var ju,$$=!1;function PP(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)a=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(Sy(C0,U.backendName)!=null){let d={pixels:e},p={numChannels:t};return U.runKernel(C0,d,p)}let[l,c]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height],u;if(i)u=e.getContext("2d").getImageData(0,0,l,c).data;else if(a||n)u=e.data;else if(s||r||o){if(ju==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")ju=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else ju=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ju.canvas.width=l,ju.canvas.height=c,ju.drawImage(e,0,0,l,c),u=ju.getImageData(0,0,l,c).data}let h;if(t===4)h=new Int32Array(u);else{let d=l*c;h=new Int32Array(d*t);for(let p=0;p<d;p++)for(let f=0;f<t;++f)h[p*t+f]=u[p*4+f]}return T1(h,[c,l,t],"int32")}function tne(e){return e!=null&&e.data instanceof Uint8Array}function nne(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function ane(e){return e!=null&&e.width!==0&&e.height!==0}function rne(e){return nne()&&!(e instanceof ImageBitmap)&&ane(e)&&!tne(e)}async function sne(e,t=3){let n=null;if(Z().getBool("WRAP_TO_IMAGEBITMAP")&&rne(e)){let a;try{a=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{a=null}a!=null&&a.width===e.width&&a.height===e.height?n=a:n=e}else n=e;return PP(n,t)}function VP(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function ine(e){let t=(e==null?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function one(e,t){let n=F(e,"img","toPixels");if(!(e instanceof at)){let c=n;n=ye(c,"int32"),c.dispose()}VP(n);let[a,r]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*a*4);for(let c=0;c<a*r;++c){let u=[0,0,0,255];for(let d=0;d<s;d++){let p=i[c*s+d];if(n.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(n.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);s===1?(u[0]=p*o,u[1]=p*o,u[2]=p*o):u[d]=p*o}let h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(t!=null){$$||Sy(Hw,U.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),$$=!0),t.width=r,t.height=a;let c=t.getContext("2d"),u=new ImageData(l,r,a);c.putImageData(u,0,0)}return n!==e&&n.dispose(),l}function lne(e,t,n){let a=F(e,"img","draw");if(!(e instanceof at)){let i=a;a=ye(i,"int32"),i.dispose()}VP(a),ine(n==null?void 0:n.imageOptions);let r={image:a},s={canvas:t,options:n};U.runKernel(Hw,r,s)}var une=W({fromPixels_:PP}),JE={};tt(JE,{prepareAndValidate:()=>BP});function BP(e,t){let n=e.shape.length,a=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(a<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${a}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[a-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[a-1]} vs. ${n}`);if(Ut(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let r=t.shape,s=r[r.length-1],i=1;for(let h=0;h<r.length-1;++h)i*=r[h];let o=e.shape,l=r.slice();l.pop();let c=1;for(let h=s;h<n;++h)c*=o[h],l.push(o[h]);let u=[..._f(e.shape).map(h=>h/c),1].slice(0,s);return[l,i,c,u]}var aa={};tt(aa,{assertParamsValid:()=>hne,computeFlatOffset:()=>gne,computeOutShape:()=>pne,getNormalizedAxes:()=>fne,isSliceContinous:()=>mne,maskToAxes:()=>dne,parseSliceParams:()=>QP,sliceInfo:()=>yne,startForAxis:()=>KP,startIndicesWithElidedDims:()=>GP,stopForAxis:()=>XP,stopIndicesWithElidedDims:()=>HP,stridesForAxis:()=>qP,stridesWithElidedDims:()=>UP});var pk=-2,cne=-1;function hne(e,t,n){let a=e.shape.length;z(a===t.length,()=>`Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`),z(a===n.length,()=>`Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`);for(let r=0;r<a;++r)z(t[r]+n[r]<=e.shape[r],()=>`Error in slice${a}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function dne(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function pne(e,t,n){let a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function UP(e,t,n,a){let r=[...e];for(let s=r.length;s<a.length;s++)r.push(1);for(let s=0;s<n;s++)s===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function WP(e,t,n){return n<=e?n:n-(t-1)}function jP(e,t){let n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function fne(e,t,n,a,r,s,i,o,l){let c=e.length,u=new Array(c),h=new Array(c),d=new Array(c);if(t.length&&n>0){let p=t[0],f=n+1;u=GP(i,p,f,a,e),h=HP(o,p,f,r,e),d=UP(s,p,f,e)}else for(let p=0;p<c;p++)u[p]=KP(i,a,s,e,p,l),h[p]=XP(o,r,s,e,p,l),d[p]=qP(s,p,l);return{begin:u,end:h,strides:d}}function GP(e,t,n,a,r){let s=[...r],i=jP(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let l=WP(t,n,o),c=a[l];e&1<<l&&(c=0),s[o]=c}return s}function HP(e,t,n,a,r){let s=[...r],i=jP(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let l=WP(t,n,o),c=a[l];e&1<<l&&(c=Number.MAX_SAFE_INTEGER),s[o]=c}for(let o=0;o<s.length;o++){let l=r[o];s[o]<0&&(s[o]+=l),s[o]=wy(0,s[o],r[o])}return s}function qP(e,t,n){let a=e[t];return(n&1<<t||a==null)&&(a=1),a}function KP(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=a[r];return i<0&&(i+=l),i=wy(0,i,l-1),i}function XP(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=a[r];return i<0&&(i+=l),o>0?i=wy(0,i,l):i=wy(-1,i,l-1),i}function mne(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function gne(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function QP(e,t,n){let a,r=e.shape.length;typeof t=="number"?a=[t,...new Array(r-1).fill(0)]:t.length<r?a=t.concat(new Array(r-t.length).fill(0)):a=t.slice(),a.forEach(i=>{z(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return n==null?s=new Array(r).fill(-1):typeof n=="number"?s=[n,...new Array(r-1).fill(-1)]:n.length<r?s=n.concat(new Array(r-n.length).fill(-1)):s=n,s=s.map((i,o)=>i>=0?i:(z(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-a[o])),[a,s]}function yne(e,t,n,a,r,s,i,o,l){let c;if(a==null?(c=new Array(t.length),c.fill(1)):c=a,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1,h={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let v=0;v<h.dims;v++)u&&1<<v&o&&h.numAddAxisAfterEllipsis++,1<<v&i&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);let d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};bne(h,d);let p=!0,f=!0,m=!0,g=[],y=[];for(let v=0;v<e.length;++v){if(d.strides[v]===0)throw Error(`strides[${v}] must be non-zero`);let x=!!(d.shrinkAxisMask&1<<v),w=e[v];if(w===-1){g.push(x?1:-1);continue}let k=[d.beginMask&1<<v,d.endMask&1<<v],M=[d.strides[v]>0?0:-1,d.strides[v]>0?w:w-1];if(x&&d.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[v]===1;let S=!!(d.beginMask&1<<v&&d.endMask&1<<v);if(d.beginValid&&d.endValid){if(x){let A=d.begin[v]<0?w+d.begin[v]:d.begin[v];if(d.begin[v]=A,d.end[v]=d.begin[v]+1,A<0||A>=w)throw Error(`slice index ${d.begin[v]} of dimension ${v} out of bounds.`)}else d.begin[v]=M$(d.begin[v],0,d.strides[v],w,k,M),d.end[v]=M$(d.end[v],1,d.strides[v],w,k,M);let R=d.strides[v]===1&&d.begin[v]===0&&d.end[v]===w;p=p&&R,f=f&&(v===0&&d.strides[v]===1||R)}else p=p&&d.strides[v]===1&&S,f=f&&(v===0&&d.strides[v]===1||S);let I,E=!1;if(d.beginValid&&d.endValid?(I=d.end[v]-d.begin[v],E=!0):x?(I=1,E=!0):S&&w>=0&&(d.strides[v]<0?I=-w:I=w,E=!0),E){let R;I===0||I<0!=d.strides[v]<0?R=0:R=Math.trunc(I/d.strides[v])+(I%d.strides[v]!==0?1:0),g.push(R)}else g.push(-1)}for(let v=0;v<d.finalShapeGatherIndices.length;++v){let x=d.finalShapeGatherIndices[v];x>=0?y.push(g[x]):x===pk&&y.push(1)}return{finalShapeSparse:y.filter((v,x)=>d.finalShapeGatherIndices[x]!==pk),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function bne(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){let r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(pk),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[a]),e.end!=null&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(cne),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}function M$(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{let i=e<0?a+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var vne="4.22.0",YP=class{static sgd(e){return new F1(e)}static momentum(e,t,n=!1){return new XE(e,t,n)}static rmsprop(e,t=.9,n=0,a=null,r=!1){return new QE(e,t,n,a,r)}static adam(e=.001,t=.9,n=.999,a=null){return new qE(e,t,n,a)}static adadelta(e=.001,t=.95,n=null){return new GE(e,t,n)}static adamax(e=.002,t=.9,n=.999,a=null,r=0){return new KE(e,t,n,a,r)}static adagrad(e,t=.1){return new HE(e,t)}},Zu=YP,xne=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function eN(){return new Promise(e=>xne(()=>e()))}var O={};tt(O,{ERF_A1:()=>One,ERF_A2:()=>Fne,ERF_A3:()=>Lne,ERF_A4:()=>zne,ERF_A5:()=>Pne,ERF_P:()=>Mne,PARALLELIZE_THRESHOLD:()=>tN,RowPartitionType:()=>xi,SELU_SCALE:()=>JP,SELU_SCALEALPHA:()=>ZP,applyActivation:()=>M1,assertAndGetBroadcastShape:()=>Yt,assertAxesAreInnerMostDims:()=>yY,assertParamsConsistent:()=>wne,assignToTypedArray:()=>Gne,axesAreInnerMostDims:()=>dE,calculateShapes:()=>iP,checkEinsumDimSizes:()=>Yne,checkPadOnDimRoundingMode:()=>rr,combineLocations:()=>E4,combineRaggedTensorToTensorShapes:()=>Sne,complexWithEvenIndex:()=>Une,complexWithOddIndex:()=>Wne,computeConv2DInfo:()=>Ob,computeConv3DInfo:()=>b4,computeDefaultPad:()=>K2,computeDilation2DInfo:()=>mQ,computeOptimalWindowSize:()=>Ene,computeOutAndReduceShapes:()=>N4,computeOutShape:()=>_ne,computePool2DInfo:()=>y4,computePool3DInfo:()=>gQ,convertConv2DDataFormat:()=>v4,decodeEinsumEquation:()=>Xne,eitherStridesOrDilationsAreOne:()=>ji,expandShapeToKeepDim:()=>$c,exponent:()=>qne,exponents:()=>Hne,fromStringArrayToUint8:()=>bae,fromUint8ToStringArray:()=>yae,getAxesPermutation:()=>C4,getBroadcastDims:()=>k4,getComplexWithIndex:()=>jne,getEinsumComputePath:()=>Zne,getEinsumPermutation:()=>Qne,getFusedBiasGradient:()=>$1,getFusedDyActivation:()=>D1,getImageCenter:()=>Nne,getInnerMostAxes:()=>bY,getPermuted:()=>Ane,getRaggedRank:()=>kne,getReductionAxes:()=>Un,getReshaped:()=>Cne,getReshapedPermuted:()=>Rne,getRowPartitionTypesHelper:()=>Ine,getSliceBeginCoords:()=>Dne,getSliceSize:()=>$ne,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>nae,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>aae,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>rae,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>oae,getSparseReshapeInputOutputMismatchErrorMessage:()=>uae,getSparseReshapeInputOutputMultipleErrorMessage:()=>lae,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>sae,getSparseReshapeNegativeOutputDimErrorMessage:()=>iae,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>pae,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>cae,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>hae,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>dae,getUndoAxesPermutation:()=>pE,isIdentityPermutation:()=>Jne,log:()=>EK,mergeRealAndImagArrays:()=>Vne,prepareAndValidate:()=>BP,prepareSplitSize:()=>tae,segment_util:()=>eV,shouldFuse:()=>O1,slice_util:()=>aa,splitRealAndImagArrays:()=>Bne,stridesOrDilationsArePositive:()=>Dc,tupleValuesAreOne:()=>jl,upcastType:()=>us,validateDefaultValueShape:()=>Tne,validateInput:()=>N1,validateUpdateShape:()=>OE,warn:()=>ul});function wne(e,t){let n=e[0].length;e.forEach((r,s)=>{z(r.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),z(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let a=e[0];e.forEach((r,s)=>{for(let i=0;i<n;i++)z(i===t||r[i]===a[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${r}) does not match the shape of the rest (${a}) along the non-concatenated axis ${s}.`)})}function _ne(e,t){let n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var xi;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(xi||(xi={}));function Sne(e,t,n){let a=new Array;if(n==null&&t==null)return a;if(t==null)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(n==null)return a;if(e+n.length!==a.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${a.length}`);for(let r=1;r<n.length;++r){let s=n[r],i=a[a.length-n.length+r],o=a[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${s} but shape[${r+e}] = ${o}`)}else a[i]=s}return a}function Ine(e){let t={FIRST_DIM_SIZE:xi.FIRST_DIM_SIZE,VALUE_ROWIDS:xi.VALUE_ROWIDS,ROW_LENGTHS:xi.ROW_LENGTHS,ROW_SPLITS:xi.ROW_SPLITS,ROW_LIMITS:xi.ROW_LIMITS,ROW_STARTS:xi.ROW_STARTS},n=[];for(let a of e)if(a in t)n.push(t[a]);else break;return n}function kne(e){return e.length===0?0:e[0]===xi.FIRST_DIM_SIZE?e.length-1:e.length}function Tne(e,t){if(e==null||t==null)return;let n=e.length,a=t.length;if(n>=a)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${a})`);for(let r=0;r<Math.min(n,a-1);++r){let s=e[r],i=t[r+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${s} but ragged tensor input.flatValues.shape[${r-e.length}] = ${i}`)}}var tN=30;function Ene(e){return e<=tN?e:N0(e,Math.floor(Math.sqrt(e)))}function Nne(e,t,n){let a=n*(typeof e=="number"?e:e[0]),r=t*(typeof e=="number"?e:e[1]);return[a,r]}function Cne(e,t,n,a=!0){let r=[];if(a)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)r=r.concat([e[i+1]/t[i],t[i]]);r=r.concat(e.slice(s+1))}return r}function Ane(e,t,n=!0){let a=[];if(n){a.push(t);for(let r=t+1;r<e;++r)r<=2*t?(a.push(r),a.push(r-(t+1))):a.push(r)}else{let r=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):r.push(i);a.push(...r),a.push(0),a.push(...s)}return a}function Rne(e,t,n,a=!0){let r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?a?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function Dne(e,t){let n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function $ne(e,t,n){let a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}var ZP=1.7580993408473768,JP=1.0507009873554805,Mne=.3275911,One=.254829592,Fne=-.284496736,Lne=1.421413741,zne=-1.453152027,Pne=1.061405429;function Vne(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function Bne(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function Une(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function Wne(e){let t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function jne(e,t){let n=e[t*2],a=e[t*2+1];return{real:n,imag:a}}function Gne(e,t,n,a){e[a*2]=t,e[a*2+1]=n}function Hne(e,t){let n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){let s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function qne(e,t,n){let a=(n?2:-2)*Math.PI*(e/t),r=Math.cos(a),s=Math.sin(a);return{real:r,imag:s}}var ES="->",Kne=/->/g,O$=",",F$="...";function Xne(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(Kne,"").length)/ES.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${ES}").`);let[a,r]=e.split(ES);z(a.indexOf(F$)===-1,()=>`The ellipsis notation ("${F$}") is not supported yet.`);let s=a.split(O$),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let d=0;d<r.length;++d){let p=r[d];if(!s.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let d=0;d<a.length;++d){let p=a[d];o.indexOf(p)===-1&&p!==O$&&o.push(p)}let l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<s[d].length;++p)l[d].push(o.indexOf(s[d][p]))}let c=o.length,u=r.length,h=[];for(let d=u;d<c;++d)h.push(d);return{allDims:o,summedDims:h,idDims:l}}function Qne(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;let a=[];for(let r=0;r<e;++r)n[r]===-1&&a.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:a}}function Yne(e,t,n){let a=new Array(e);for(let r=0;r<n.length;++r){let s=n[r].shape;for(let i=0;i<t[r].length;++i)a[t[r][i]]===void 0?a[t[r][i]]=s[i]:z(a[t[r][i]]===s[i],()=>`Expected dimension ${a[t[r][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function Zne(e,t){let n=e,a=[],r=0;e.length===0&&n.push(-1),r=e.length+1;for(let i=0;i<r;++i)a.push([]);let s=[];for(let i=0;i<n.length;++i){let o=n[i],l=eae(t,o);for(let c of l)s.indexOf(c)===-1&&(a[i].push(c),s.push(c))}return{path:n,steps:a}}function Jne(e){return e.every((t,n)=>t===n)}function eae(e,t){let n=[];for(let a=0;a<e.length;++a)(e[a].length===0||e[a].indexOf(t)!==-1||t===-1)&&n.push(a);return n}function tae(e,t,n=0){let a=[];if(typeof t=="number")z(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),a=new Array(t).fill(e.shape[n]/t);else{let r=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);z(r<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[s]=e.shape[n]-i}z(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),a=t}return a}function nae(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function aae(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function rae(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function sae(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function iae(e,t){return`size ${e} must be non-negative, not ${t}`}function oae(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function lae(e,t){let n=Ut(e),a=Ut(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${a}. inputShape=${e} outputShape= ${t}`}function uae(e,t){let n=Ut(e),a=Ut(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${a}. inputShape=${e} outputShape=${t}`}function cae(){return"segment ids must be >= 0"}function hae(){return"segment ids are not increasing"}function dae(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function pae(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var eV={};tt(eV,{collectGatherOpShapeInfo:()=>gae,computeOutShape:()=>mae,segOpComputeOptimalWindowSize:()=>fae});function fae(e,t){let n=!1,a;for(e<=tN?(a=e,n=!0):a=N0(e,Math.floor(Math.sqrt(e)));!n;)a>t||a===e?n=!0:a=N0(e,a+1);return a}function mae(e,t,n){let a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function gae(e,t,n,a){let r=t.shape.length,s=e.shape.length;if(a!==0&&(a<-r||a>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${a}`);if(a<0&&(a+=r),a>s)throw new Error(`batchDims (${a}) must be less than rank(x) (
    ${s}).`);if(n<a)throw new Error(`batchDims (${a}) must be less than or equal to axis (${n}).`);for(let h=0;h<a;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);let i=e.shape[n],o=[],l=1,c=1,u=1;for(let h=0;h<a;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=a;h<n;h++)o.push(e.shape[h]),c*=e.shape[h];for(let h=a;h<r;h++)o.push(t.shape[h]);for(let h=n+1;h<s;h++)o.push(e.shape[h]),u*=e.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:i,outputShape:o}}function yae(e){try{return e.map(t=>R0(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function bae(e){return e.map(t=>Db(t))}var Hi={};tt(Hi,{nonMaxSuppressionV3Impl:()=>xP,nonMaxSuppressionV4Impl:()=>wP,nonMaxSuppressionV5Impl:()=>_P,whereImpl:()=>uP});Ote();var tV={kernelName:Sf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(e,vd(ye(n,"float32"),-1))}}},vae={kernelName:Zc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=Xt(ye(n,"float32")),r=va(Ie(ze(1),a));return on(Ce(e,r))}}}},xae={kernelName:Jc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=va(Ie(Xt(ye(n,"float32")),1));return Ce(e,a)}}}},wae={kernelName:hu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Yt(n.shape,a.shape);return{a:()=>{let s=e,i=Un(n.shape,r);return i.length>0&&(s=De(s,i)),K(s,n.shape)},b:()=>{let s=e,i=Un(a.shape,r);return i.length>0&&(s=De(s,i)),K(s,a.shape)}}}},_ae={kernelName:eh,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((a,r)=>{n[r]=()=>e.clone()}),n}},Sae={kernelName:Tf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>_t(n)}}},Iae={kernelName:Ef,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>_t(n)}}},kae={kernelName:th,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ce(e,va(Ie(ze(1),Xt(ye(n,"float32")))))}}},Tae={kernelName:nh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=va(re(ze(1),Xt(ye(n,"float32"))));return Ce(e,a)}}}},Eae={kernelName:sh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Yt(n.shape,a.shape);return{a:()=>{let s=re(Xt(n),Xt(a)),i=G(e,Ce(a,s)),o=Un(n.shape,r);return o.length>0&&(i=De(i,o)),K(i,n.shape)},b:()=>{let s=re(Xt(n),Xt(a)),i=on(G(e,Ce(n,s))),o=Un(a.shape,r);return o.length>0&&(i=De(i,o)),K(i,a.shape)}}}},Nae={kernelName:ah,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ce(e,re(Xt(ye(n,"float32")),1))}}},Cae={kernelName:rh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ce(e,Ie(ze(1),Xt(ye(n,"float32"))))}}};function Aae(e,t,n,a,r,s){let i=F(e,"dy","avgPool3dGrad"),o=F(t,"input","avgPool3dGrad"),l=i,c=o,u=!1;o.rank===4&&(u=!0,l=K(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),c=K(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),z(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),z(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),rr("avgPool3dGrad",r,s);let h={dy:l,input:c},d={filterSize:n,strides:a,pad:r,dimRoundingMode:s},p=U.runKernel(cb,h,d);return u?K(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Rae=W({avgPool3dGrad_:Aae}),Dae={kernelName:Nf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>Rae(e,a,r,s,i,o)}}};function $ae(e,t,n,a,r){let s=F(e,"dy","avgPoolGrad"),i=F(t,"input","avgPoolGrad");z(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,c=!1;i.rank===3&&(c=!0,o=K(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=K(s,[1,s.shape[0],s.shape[1],s.shape[2]])),z(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),z(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let u={dy:l,input:o},h={filterSize:n,strides:a,pad:r},d=U.runKernel(ub,u,h);return c?K(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Mae=W({avgPoolGrad_:$ae}),Oae={kernelName:ih,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i}=n;return{x:()=>Mae(e,a,r,s,i)}}},Fae={kernelName:oh,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[a,r]=t,{transposeA:s,transposeB:i}=n;return!s&&!i?{a:()=>ot(e,r,!1,!0),b:()=>ot(a,e,!0,!1)}:!s&&i?{a:()=>ot(e,r,!1,!1),b:()=>ot(e,a,!0,!1)}:s&&!i?{a:()=>ot(r,e,!1,!0),b:()=>ot(a,e,!1,!1)}:{a:()=>ot(r,e,!0,!0),b:()=>ot(e,a,!0,!0)}}},Lae={kernelName:Cf,gradFunc:(e,t,n)=>{let{blockShape:a,crops:r}=n;return{x:()=>jb(e,a,r)}}},zae={kernelName:Vz,gradFunc:(e,t,n)=>{let a=n,r=a.inputShape,s=a.shape,i=Array.from(s);for(let l=r.length-1;l>=0;l--)if(r[l]===s[l])i[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>De(e,o,!0)}}},Pae={kernelName:lh,gradFunc:e=>({x:()=>e.clone()})},Vae={kernelName:uh,gradFunc:e=>({x:()=>_t(e)})},Bae={kernelName:du,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>ga(Ms(Fo(a,r),gu(a,s)),e,_t(e))}}},Uae={kernelName:db,inputsToSave:["x"],gradFunc:tV.gradFunc},Wae={kernelName:Df,saveAllInputs:!0,gradFunc:(e,t,n)=>{let a=t.map(o=>o.shape),{axis:r}=n,s=Os(r,t[0].shape)[0],i=a.map(o=>o[s]);return fr(e,i,s).map(o=>()=>o)}},jae={kernelName:ch,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return z(jl(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>sE(a.shape,e,r,i,o,l),filter:()=>UE(a,e,r.shape,i,o,l)}}},Gae={kernelName:hh,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Ja(e,r,s,i,o,1,l),filter:()=>UE(e,a,r.shape,s,i,o,l)}}};function Hae(e,t,n,a,r){let s=e;e.rank===4&&(s=K(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=K(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),z(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),z(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),z(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),z(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),z(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:i},l={strides:a,pad:r,filterShape:n};return U.runKernel($f,o,l)}var qae=W({conv3DBackpropFilter_:Hae}),Kae={kernelName:dh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s}=n;z(jl(a),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let[i,o]=t;return{x:()=>S4(i.shape,e,o,r,s),filter:()=>qae(i,e,o.shape,r,s)}}},Xae={kernelName:ph,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(on(w1(ye(n,"float32"))),e)}}},Qae={kernelName:fh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(_1(ye(n,"float32")),e)}}},Yae={kernelName:mh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r,exclusive:s,reverse:i}=n;return{x:()=>{let o=C4([r],a.rank),l=u1(e,r,s,!i);return o!=null&&(l=lt(l,o)),l}}}},Zae={kernelName:gh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s,dimRoundingMode:i}=n,o=a??[1,1];z(jl(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,c]=t;return z(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),z(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),z(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),z(ji(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),rr("depthwiseConv2d",s,i),{x:()=>yP(l.shape,e,c,r,s,o,i),filter:()=>gP(l,e,c.shape,r,s,o,i)}}},Jae={kernelName:yh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[a,r]=t,s={x:a,filter:r,dy:e},i={x:a,filter:r,dy:e};return{x:()=>U.runKernel(jp,s,n),filter:()=>U.runKernel(Gp,i,n)}}},ere={kernelName:vh,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,a={dy:e,y:n};return{x:()=>U.runKernel(zf,a)}}},tre={kernelName:xh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,a=G(Ba(on(Xt(n))),2/Math.sqrt(Math.PI));return{x:()=>G(e,a)}}},nre={kernelName:wh,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(e,n)}}},are={kernelName:Vf,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>K(e,n.shape)}}},rre={kernelName:_h,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(e,Ba(n))}}},sre={kernelName:Sh,gradFunc:e=>({x:()=>_t(e)})},ire={kernelName:Ih,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Yt(n.shape,a.shape);return{a:()=>{let s=Ce(e,ye(a,"float32")),i=Un(n.shape,r);return i.length>0?K(De(s,i),n.shape):s},b:()=>{let s=G(e,ye(n,"float32")),i=Un(a.shape,r);i.length>0&&(s=K(De(s,i),a.shape));let o=Xt(a);return on(Ce(s,ye(o,"float32")))}}}},ore={kernelName:kh,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:a}=n,[r,s,i,o]=t,l=o??ze(1),c=Un(s.shape,r.shape),u=[];if(s.rank===1){for(let m=0;m<r.shape.length-1;++m)u.push(r.shape[m]);u.push(1)}let h=Ie(r,s),d=G(e,l),p=v1(re(i,ze(a))),f=G(G(G(p,p),p),ze(-.5));return{x:()=>s.rank===1?K(G(G(e,Dr(K(p,[1,1,1,s.shape[0]]),u)),l),r.shape):K(G(G(e,p),l),r.shape),mean:()=>{let m=G(G(p,ze(-1)),d);return s.rank===1&&(m=De(m,c)),K(m,s.shape)},variance:()=>{let m=G(G(f,h),d);return s.rank===1&&(m=De(m,c)),K(m,s.shape)},scale:()=>{let m=G(h,p),g=G(e,m);return s.rank===1&&(g=De(g,c)),K(g,s.shape)},offset:()=>{let m=e;return s.rank===1&&(m=De(m,c)),K(m,s.shape)}}}},lre={kernelName:Uf,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[a,r]=t,{axis:s,batchDims:i}=n,o=Os(s,a.shape)[0],l=(c,u,h)=>()=>{let d=c.shape,p=u.size,f=d.slice(0,o),m=f.length,g=d.slice(s,d.length).slice(1),y=g.length,v=L$(0,m),x=L$(m+1,m+1+y),w=z$([f,[p],g]),k=K(h,w),M=K(u,[p]),S=z$([[m],v,x]),I=lt(k,S),E=A1(I,M,c.shape[o]),R=pE(S);return E=lt(E,R),E};if(i===1){let c=a.shape[0],u=a.split(c,0);return{x:()=>Bn(u.map((h,d)=>l(h,r.slice(d,1),e.slice(d,1))())).reshape(a.shape),indices:()=>r}}else return{x:l(a,r,e),indices:()=>r}}};function L$(e,t){let n=[];for(let a=e;a<t;++a)n.push(a);return n}function z$(e){let t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}var ure={kernelName:Th,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>_t(n),b:()=>_t(a)}}},cre={kernelName:Eh,gradFunc:e=>({x:()=>ye(e,"float32")})},hre={kernelName:Nh,gradFunc:e=>({x:()=>_t(e)})},dre={kernelName:Ch,gradFunc:e=>({x:()=>_t(e)})},pre={kernelName:Ah,gradFunc:e=>({x:()=>_t(e)})},fre={kernelName:Rh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{alpha:r}=n,s=sr(a,0);return{x:()=>ga(s,e,G(e,r))}}},mre={kernelName:$h,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ce(e,re(n,1))}}},gre={kernelName:Dh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ce(e,ye(n,"float32"))}}},yre={kernelName:Uz,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n;return{logits:()=>{let s=Ba(a);return Ie(e,G(De(e,r,!0),s))}}}};function bre(e,t,n,a=5,r=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:a,bias:r,alpha:s,beta:i};return U.runKernel(Yf,o,l)}var vre=W({localResponseNormalizationBackprop_:bre}),xre={kernelName:Mh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>vre(a,r,e,s,i,o,l)}}};function nV(e,t,n,a){return t.rank<n.rank&&(t=K(t,$c(t.shape,a))),e.rank<n.rank&&(e=K(e,$c(e.shape,a))),{x:()=>G(e,ye(Lr(n,t),e.dtype))}}var P$={kernelName:Oh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{reductionIndices:r}=a,s=t[0],i=t[1],o=Os(r,s.shape),l=nV(e,i,s,o);return{x:()=>l.x()}}},wre={kernelName:Fh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>G(e,ye(Fo(n,a),"float32")),b:()=>G(e,ye(Kp(n,a),"float32"))}}};function _re(e,t,n,a,r,s,i){let o=F(e,"dy","maxPool3dGrad"),l=F(t,"input","maxPool3dGrad"),c=F(n,"output","maxPool3dGrad"),u=o,h=l,d=c,p=!1;l.rank===4&&(p=!0,u=K(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=K(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=K(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),z(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),z(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),z(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),rr("maxPool3dGrad",s,i);let f={dy:u,input:h,output:d},m={filterSize:a,strides:r,pad:s,dimRoundingMode:i},g=U.runKernel(yb,f,m);return p?K(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var Sre=W({maxPool3dGrad_:_re}),Ire={kernelName:Zf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>Sre(e,a,r,s,i,o,l)}}};function kre(e,t,n,a,r,s,i){let o=F(e,"dy","maxPoolGrad"),l=F(t,"input","maxPoolGrad"),c=F(n,"output","maxPoolGrad");z(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),z(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),z(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),rr("maxPoolGrad",s,i);let u={dy:o,input:l,output:c},h={filterSize:a,strides:r,pad:s,dimRoundingMode:i};return U.runKernel(gb,u,h)}var Tre=W({maxPoolGrad_:kre}),Ere={kernelName:Lh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>Tre(e,a,r,s,i,o)}}},Nre={kernelName:zh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=Os(r,a.shape),i=N4(a.shape,s)[1],o=Ut(i);return{x:()=>{let l=a.shape.slice();s.forEach(u=>{l[u]=1});let c=K(e,l);return Ce(G(c,pr(a.shape,"float32")),o)}}}},Cre={kernelName:Ph,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{axis:r}=a,[s,i]=t,o=Os(r,s.shape),l=nV(e,i,s,o);return{x:()=>l.x()}}},Are={kernelName:Vh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>G(e,ye(gu(n,a),"float32")),b:()=>G(e,ye(sr(n,a),"float32"))}}},Rre={kernelName:Bh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>vt(e,s,a.shape)}}},Dre={kernelName:Uh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Yt(n.shape,a.shape);return{a:()=>{let s=Un(n.shape,r);return s.length>0?K(De(e,s),n.shape):e},b:()=>{let s=G(e,on(Nm(Ce(n,a)))),i=Un(a.shape,r);return i.length>0?K(De(s,i),a.shape):s}}}},$re={kernelName:Wh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Yt(n.shape,a.shape);return{a:()=>{let s=G(e,ye(a,"float32")),i=Un(n.shape,r);return i.length>0?K(De(s,i),n.shape):s},b:()=>{let s=G(e,ye(n,"float32")),i=Un(a.shape,r);return i.length>0?K(De(s,i),a.shape):s}}}},Mre={kernelName:em,gradFunc:e=>({x:()=>on(e)})},Ore={kernelName:jh,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>_n(n.shape,"float32")}}},Fre={kernelName:sm,gradFunc:e=>({x:()=>_t(e)})},Lre={kernelName:im,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:a}=n;return Tn(e,a).map(r=>()=>r)}},V$={kernelName:Gh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>vt(e,s,a.shape)}}},zre={kernelName:Hh,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,a,r]=t,s=n,i=a,o=Yt(s.shape,i.shape);return{a:()=>{let l=ye(i,"float32"),c=G(e,G(l,Li(s,Ie(l,ze(1))))),u=Un(s.shape,o);return u.length>0&&(c=De(c,u)),K(c,s.shape)},b:()=>{let l=sr(s,0),c=ga(l,zr(s),_t(s)),u=G(e,G(r,c)),h=Un(i.shape,o);return h.length>0&&(u=De(u,h)),K(u,i.shape)}}}},Pre={kernelName:qh,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,a]=t,r=sr(n,0);return{x:()=>ga(r,e,G(e,a)),alpha:()=>{let s=ga(r,_t(e),G(e,n)),i=Un(a.shape,e.shape);return i.length>0&&(s=De(s,i)),K(s,a.shape)}}}};function Vre(e,t,n){let a=e.shape.slice();a[n]=1;let r=K(t,a),s=Cy(e,n,!0,!1),i=Cy(e,n,!0,!0),o=G(s,i);return G(r,o)}function Bre(e,t,n){let a=e.shape.length,r=a-n.length,s=O.getAxesPermutation(n,a),i=e;s!=null&&(i=lt(e,s));let o=i.shape.slice(),l=o.splice(a-n.length,n.length).reduce((h,d)=>h*d,1);o.push(l);let c=i.reshape(o),u=Vre(c,t,r);if(u=u.reshape(i.shape),s!=null){let h=O.getUndoAxesPermutation(s);u=lt(u,h)}return u}var Ure={kernelName:Kh,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=[];return r==null?s=a.shape.map((i,o)=>o):typeof r=="number"?s=[r]:s=r,{x:()=>Bre(a,e,s)}}},Wre={kernelName:bh,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Yt(n.shape,a.shape);return{a:()=>{let s=Ce(e,ye(a,"float32")),i=Un(n.shape,r);return i.length>0?K(De(s,i),n.shape):s},b:()=>{let s=G(e,ye(n,"float32")),i=Un(a.shape,r);i.length>0&&(s=K(De(s,i),a.shape));let o=Xt(a);return on(Ce(s,ye(o,"float32")))}}}},jre={kernelName:Xh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ce(e,on(Xt(n)))}}},Gre={kernelName:Jh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,a=G(gu(n,6),vd(n));return{x:()=>G(e,ye(a,"float32"))}}},Hre={kernelName:Qh,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(e,ye(vd(n),"float32"))}}},qre={kernelName:om,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>K(e,n.shape)}}},Kre={kernelName:Zh,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>U.runKernel(um,r,n)}}},Xre={kernelName:Yh,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>U.runKernel(lm,r,n)}}},Qre={kernelName:ed,gradFunc:(e,t,n)=>{let{dims:a}=n,r=Os(a,e.shape);return{x:()=>hs(e,r)}}},Yre={kernelName:td,gradFunc:e=>({x:()=>_t(e)})},Zre={kernelName:nd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>on(Ce(e,G(Li(n,1.5),2)))}}},Jre={kernelName:pm,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>ye(_t(n),"float32"),t:()=>G(e,ye(n,e.dtype)),e:()=>G(e,ye(Ub(n),e.dtype))}}},ese={kernelName:ad,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=sr(n,ze(0)),r=ze(ZP),s=ze(JP),i=G(e,s),o=G(G(e,r),Ba(ye(n,"float32")));return ga(a,i,o)}}}},tse={kernelName:od,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(e,G(n,Ie(ze(1),n)))}}},nse={kernelName:id,gradFunc:e=>({x:()=>_t(e)})},ase={kernelName:rd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(Lb(ye(n,"float32")),e)}}},rse={kernelName:sd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(l1(ye(n,"float32")),e)}}},sse={kernelName:fm,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{begin:r,size:s}=n,i=a.shape,[o,l]=QP(a,r,s),c=[];for(let u=0;u<e.rank;u++)c.push([o[u],i[u]-o[u]-l[u]]);return{x:()=>ri(e,c)}}},ise={kernelName:hd,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{dim:r}=n,s=!0,i=G(e,a);return{logits:()=>Ie(i,G(De(i,[r],s),a))}}},ose={kernelName:ld,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(e,Rs(n))}}},B$={kernelName:mm,gradFunc:(e,t,n)=>{let{blockShape:a,paddings:r}=n;return{x:()=>Fb(e,a,r)}}},U$={kernelName:gm,gradFunc:(e,t,n)=>{let{axis:a}=n;return{x:()=>Qt(e,a)}}},lse={kernelName:ud,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ce(e,G(va(ye(n,"float32")),2))}}},use={kernelName:Sb,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(e,G(ye(n,"float32"),2))}}},cse={kernelName:dd,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=ze(2);return{a:()=>G(e,G(r,Ie(n,a))),b:()=>G(e,G(r,Ie(a,n)))}}},hse={kernelName:fu,gradFunc:e=>({x:()=>_t(e)})},dse={kernelName:pd,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,a]=t,r=Yt(n.shape,a.shape);return{a:()=>{let s=e,i=Un(n.shape,r);return i.length>0&&(s=De(s,i)),K(s,n.shape)},b:()=>{let s=e,i=Un(a.shape,r);return i.length>0&&(s=De(s,i)),K(on(s),a.shape)}}}},pse={kernelName:cd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,r=a.shape.slice(),{axis:s}=n;Os(s,a.shape).forEach(l=>{r[l]=1});let i=K(e,r),o=G(i,pr(a.shape,"float32"));return{x:()=>o}}},fse={kernelName:fd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ce(e,Xt(Lb(n)))}}},mse={kernelName:md,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>G(Ie(ze(1),Xt(n)),e)}}},gse={kernelName:pu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[a]=t,{reps:r}=n;return{x:()=>{let s=_t(a);if(a.rank===1)for(let i=0;i<r[0];++i)s=re(s,vt(e,[i*a.shape[0]],[a.shape[0]]));else if(a.rank===2)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)s=re(s,vt(e,[i*a.shape[0],o*a.shape[1]],[a.shape[0],a.shape[1]]));else if(a.rank===3)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let l=0;l<r[2];++l)s=re(s,vt(e,[i*a.shape[0],o*a.shape[1],l*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else if(a.rank===4)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let l=0;l<r[2];++l)for(let c=0;c<r[3];++c)s=re(s,vt(e,[i*a.shape[0],o*a.shape[1],l*a.shape[2],c*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${a.rank} tensors yet.`);return s}}}},yse={kernelName:bo,gradFunc:(e,t,n)=>{let a=n,{perm:r}=a,s=pE(r);return{x:()=>lt(e,s)}}},bse={kernelName:_m,gradFunc:(e,t,n)=>{let a=n,{axis:r}=a;return{value:()=>Bn(e,r)}}},vse={kernelName:Cb,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>xse(e,n)}}};function xse(e,t){let n=Gi(t,_t(t)),a=Cm(e,n),r=Fo(t,ze(0,"int32")),s=a.rank-r.rank;for(let o=0;o<s;++o)r=pa(r,o+1);r=Ms(r,pr(a.shape,"bool"));let i=_t(a);return ga(r,a,i)}var wse={kernelName:Sm,gradFunc:e=>({x:()=>_t(e)})},_se=[tV,vae,xae,wae,_ae,Sae,Iae,kae,Tae,Eae,Nae,Cae,Dae,Oae,Fae,Lae,zae,Pae,Vae,Bae,Uae,Wae,Gae,jae,Kae,Xae,Qae,Yae,Zae,Jae,Wre,ere,tre,nre,are,rre,ire,sre,ore,lre,ure,cre,hre,dre,pre,fre,mre,gre,yre,xre,P$,P$,wre,Ire,Ere,Nre,Cre,Are,Rre,Dre,$re,Mre,Ore,Fre,Lre,V$,V$,zre,Pre,Ure,jre,Gre,Hre,qre,Kre,Xre,Qre,Yre,Zre,Jre,ese,tse,nse,ase,rse,sse,ise,ose,B$,B$,U$,U$,lse,cse,use,hse,dse,pse,fse,mse,gse,yse,bse,vse,wse];for(let e of _se)Wz(e);ie().prototype.abs=function(){return this.throwIfDisposed(),On(this)};ie().prototype.acos=function(){return this.throwIfDisposed(),V2(this)};ie().prototype.acosh=function(){return this.throwIfDisposed(),B2(this)};ie().prototype.add=function(e){return this.throwIfDisposed(),re(this,e)};ie().prototype.all=function(e,t){return this.throwIfDisposed(),s1(this,e,t)};ie().prototype.any=function(e,t){return this.throwIfDisposed(),Ty(this,e,t)};ie().prototype.argMax=function(e){return this.throwIfDisposed(),Rc(this,e)};ie().prototype.argMin=function(e){return this.throwIfDisposed(),U2(this,e)};ie().prototype.asScalar=function(){return this.throwIfDisposed(),z(this.size===1,()=>"The array must have only 1 element."),K(this,[])};ie().prototype.asType=function(e){return this.throwIfDisposed(),ye(this,e)};ie().prototype.as1D=function(){return this.throwIfDisposed(),K(this,[this.size])};ie().prototype.as2D=function(e,t){return this.throwIfDisposed(),K(this,[e,t])};ie().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),K(this,[e,t,n])};ie().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),K(this,[e,t,n,a])};ie().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),K(this,[e,t,n,a,r])};ie().prototype.asin=function(){return this.throwIfDisposed(),W2(this)};ie().prototype.asinh=function(){return this.throwIfDisposed(),j2(this)};ie().prototype.atan=function(){return this.throwIfDisposed(),G2(this)};ie().prototype.atan2=function(e){return this.throwIfDisposed(),H2(this,e)};ie().prototype.atanh=function(){return this.throwIfDisposed(),q2(this)};ie().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),Oo(this,e,t,n,a)};ie().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Fb(this,e,t)};ie().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),gd(this,e,t,n,a,r)};ie().prototype.broadcastTo=function(e){return this.throwIfDisposed(),fc(this,e)};ie().prototype.cast=function(e){return this.throwIfDisposed(),ye(this,e)};ie().prototype.ceil=function(){return this.throwIfDisposed(),eE(this)};ie().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Va(this,e,t)};ie().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof at&&(e=[e]),Qt([this,...e],t)};ie().prototype.conv1d=function(e,t,n,a,r,s){return this.throwIfDisposed(),i1(this,e,t,n,a,r,s)};ie().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),o1(this,e,t,n,a,r)};ie().prototype.conv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Ja(this,e,t,n,a,r,s)};ie().prototype.cos=function(){return this.throwIfDisposed(),Lb(this)};ie().prototype.cosh=function(){return this.throwIfDisposed(),l1(this)};ie().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Cy(this,e,t,n)};ie().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),u1(this,e,t,n)};ie().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),lE(this,e,t)};ie().prototype.depthwiseConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),yd(this,e,t,n,a,r,s)};ie().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),uE(this,e,t,n,a,r)};ie().prototype.divNoNan=function(e){return this.throwIfDisposed(),cE(this,e)};ie().prototype.div=function(e){return this.throwIfDisposed(),Ce(this,e)};ie().prototype.dot=function(e){return this.throwIfDisposed(),hE(this,e)};ie().prototype.elu=function(){return this.throwIfDisposed(),Tm(this)};ie().prototype.equal=function(e){return this.throwIfDisposed(),Lr(this,e)};ie().prototype.erf=function(){return this.throwIfDisposed(),c1(this)};ie().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),fE(this,e,t)};ie().prototype.exp=function(){return this.throwIfDisposed(),Ba(this)};ie().prototype.expandDims=function(e){return this.throwIfDisposed(),pa(this,e)};ie().prototype.expm1=function(){return this.throwIfDisposed(),mE(this)};ie().prototype.fft=function(){return this.throwIfDisposed(),qb(this)};ie().prototype.flatten=function(){return this.throwIfDisposed(),K(this,[this.size])};ie().prototype.floor=function(){return this.throwIfDisposed(),Nm(this)};ie().prototype.floorDiv=function(e){return this.throwIfDisposed(),r1(this,e)};ie().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Cm(this,e,t,n)};ie().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Fo(this,e)};ie().prototype.greater=function(e){return this.throwIfDisposed(),sr(this,e)};ie().prototype.ifft=function(){return this.throwIfDisposed(),Zp(this)};ie().prototype.irfft=function(){return this.throwIfDisposed(),I1(this)};ie().prototype.isFinite=function(){return this.throwIfDisposed(),gE(this)};ie().prototype.isInf=function(){return this.throwIfDisposed(),yE(this)};ie().prototype.isNaN=function(){return this.throwIfDisposed(),bE(this)};ie().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Pb(this,e)};ie().prototype.lessEqual=function(e){return this.throwIfDisposed(),gu(this,e)};ie().prototype.less=function(e){return this.throwIfDisposed(),Kp(this,e)};ie().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),vE(this,e,t,n,a)};ie().prototype.logSigmoid=function(){return this.throwIfDisposed(),xE(this)};ie().prototype.logSoftmax=function(e){return this.throwIfDisposed(),p1(this,e)};ie().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Bb(this,e,t)};ie().prototype.log=function(){return this.throwIfDisposed(),zr(this)};ie().prototype.log1p=function(){return this.throwIfDisposed(),Vb(this)};ie().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Ms(this,e)};ie().prototype.logicalNot=function(){return this.throwIfDisposed(),Ub(this)};ie().prototype.logicalOr=function(e){return this.throwIfDisposed(),f1(this,e)};ie().prototype.logicalXor=function(e){return this.throwIfDisposed(),wE(this,e)};ie().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),ot(this,e,t,n)};ie().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),ca(this,e,t,n,a)};ie().prototype.max=function(e,t){return this.throwIfDisposed(),is(this,e,t)};ie().prototype.maximum=function(e){return this.throwIfDisposed(),Gi(this,e)};ie().prototype.mean=function(e,t){return this.throwIfDisposed(),wn(this,e,t)};ie().prototype.min=function(e,t){return this.throwIfDisposed(),qp(this,e,t)};ie().prototype.minimum=function(e){return this.throwIfDisposed(),Hl(this,e)};ie().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),SE(this,e,t)};ie().prototype.mod=function(e){return this.throwIfDisposed(),IE(this,e)};ie().prototype.mul=function(e){return this.throwIfDisposed(),G(this,e)};ie().prototype.neg=function(){return this.throwIfDisposed(),on(this)};ie().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Em(this,e,t,n)};ie().prototype.notEqual=function(e){return this.throwIfDisposed(),Mc(this,e)};ie().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Xp(this,e,t,n)};ie().prototype.onesLike=function(){return this.throwIfDisposed(),Pr(this)};ie().prototype.pad=function(e,t){return this.throwIfDisposed(),ri(this,e,t)};ie().prototype.pool=function(e,t,n,a,r,s){return this.throwIfDisposed(),kE(this,e,t,n,a,r,s)};ie().prototype.pow=function(e){return this.throwIfDisposed(),Li(this,e)};ie().prototype.prelu=function(e){return this.throwIfDisposed(),Gb(this,e)};ie().prototype.prod=function(e,t){return this.throwIfDisposed(),TE(this,e,t)};ie().prototype.reciprocal=function(){return this.throwIfDisposed(),RE(this)};ie().prototype.relu=function(){return this.throwIfDisposed(),Bt(this)};ie().prototype.relu6=function(){return this.throwIfDisposed(),y1(this)};ie().prototype.reshapeAs=function(e){return this.throwIfDisposed(),K(this,e.shape)};ie().prototype.reshape=function(e){return this.throwIfDisposed(),K(this,e)};ie().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),SP(this,e,t,n)};ie().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),IP(this,e,t,n)};ie().prototype.reverse=function(e){return this.throwIfDisposed(),hs(this,e)};ie().prototype.rfft=function(){return this.throwIfDisposed(),Kb(this)};ie().prototype.round=function(){return this.throwIfDisposed(),b1(this)};ie().prototype.rsqrt=function(){return this.throwIfDisposed(),v1(this)};ie().prototype.selu=function(){return this.throwIfDisposed(),x1(this)};ie().prototype.separableConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Am(this,e,t,n,a,r,s)};ie().prototype.sigmoid=function(){return this.throwIfDisposed(),Rs(this)};ie().prototype.sign=function(){return this.throwIfDisposed(),DE(this)};ie().prototype.sin=function(){return this.throwIfDisposed(),w1(this)};ie().prototype.sinh=function(){return this.throwIfDisposed(),_1(this)};ie().prototype.slice=function(e,t){return this.throwIfDisposed(),vt(this,e,t)};ie().prototype.softmax=function(e){return this.throwIfDisposed(),bu(this,e)};ie().prototype.softplus=function(){return this.throwIfDisposed(),bd(this)};ie().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),jb(this,e,t)};ie().prototype.split=function(e,t){return this.throwIfDisposed(),fr(this,e,t)};ie().prototype.sqrt=function(){return this.throwIfDisposed(),va(this)};ie().prototype.square=function(){return this.throwIfDisposed(),Xt(this)};ie().prototype.squaredDifference=function(e){return this.throwIfDisposed(),k1(this,e)};ie().prototype.squeeze=function(e){return this.throwIfDisposed(),vu(this,e)};ie().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof at?[this,e]:[this,...e];return Bn(n,t)};ie().prototype.step=function(e){return this.throwIfDisposed(),vd(this,e)};ie().prototype.stridedSlice=function(e,t,n,a,r,s,i,o){return this.throwIfDisposed(),$E(this,e,t,n,a,r,s,i,o)};ie().prototype.sub=function(e){return this.throwIfDisposed(),Ie(this,e)};ie().prototype.sum=function(e,t){return this.throwIfDisposed(),De(this,e,t)};ie().prototype.tan=function(){return this.throwIfDisposed(),ME(this)};ie().prototype.tanh=function(){return this.throwIfDisposed(),Gl(this)};ie().prototype.tile=function(e){return this.throwIfDisposed(),Dr(this,e)};ie().prototype.toBool=function(){return this.throwIfDisposed(),ye(this,"bool")};ie().prototype.toFloat=function(){return this.throwIfDisposed(),ye(this,"float32")};ie().prototype.toInt=function(){return this.throwIfDisposed(),ye(this,"int32")};ie().prototype.topk=function(e,t){return this.throwIfDisposed(),FE(this,e,t)};ie().prototype.transpose=function(e){return this.throwIfDisposed(),lt(this,e)};ie().prototype.unique=function(e){return this.throwIfDisposed(),LE(this,e)};ie().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),A1(this,e,t)};ie().prototype.unstack=function(e){return this.throwIfDisposed(),Tn(this,e)};ie().prototype.where=function(e,t){return this.throwIfDisposed(),ga(e,this,t)};ie().prototype.zerosLike=function(){return this.throwIfDisposed(),_t(this)};var al=class aV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,aV.prototype)}},Ti=class rV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,rV.prototype)}},Y=class sV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,sV.prototype)}},ft=class iV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,iV.prototype)}},Sse=class oV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,oV.prototype)}},lV=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function Fc(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function wi(e,t){if(!e)throw new Sse(t)}function W$(e,t){let n=0;for(let a of e)a===t&&n++;return n}function hr(e){return e.length===1?e[0]:e}function Vt(e){return Array.isArray(e)?e:[e]}function io(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function ac(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var ys={};function nN(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function fk(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>fk(t));else{let t=Object.keys(e);for(let n of t){let a=e[n];a!=null&&typeof a=="object"&&(!Array.isArray(a)&&a.type==="ndarray"&&typeof a.value=="number"?e[n]=a.value:fk(a))}}}function Qb(e,t={},n={},a="object",r=!1){if(typeof e=="string"){let s=e,i;if(s in n)i=n[s];else if(s in ys)i=ys[s];else if(i=t[s],i==null)throw new Y(`Unknown ${a}: ${e}. This may be due to one of the following reasons:
1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new Y(`${a}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,o,l;if(i in n?[o,l]=n[i]:i in ys?[o,l]=ys.className:i in t&&([o,l]=t[i]),o==null)throw new Y(`Unknown ${a}: ${i}. This may be due to one of the following reasons:
1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let c={};for(let p of Object.keys(ys))c[p]=ys[p];for(let p of Object.keys(n))c[p]=n[p];let u=s.config;u.customObjects=c;let h=Object.assign({},ys);for(let p of Object.keys(n))ys[p]=n[p];fk(s.config);let d=l(o,s.config,n,r);return ys=Object.assign({},h),d}else{let c=Object.assign({},ys);for(let h of Object.keys(n))ys[h]=n[h];let u=new o(s.config);return ys=Object.assign({},c),u}}}function Ise(e,t){return e<t?-1:e>t?1:0}function Jv(e,t){return-1*Ise(e,t)}function Al(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function kse(e){if(e==null)throw new Y(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function xd(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new Y(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function aN(e,t,n=0,a=1/0){return wi(n>=0),wi(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every(r=>typeof r===t)}function ma(e,t){Array.isArray(e)?(N.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,a)=>ma(n,`element ${a+1} of ${t}`))):N.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${uV(e)}.`)}function uV(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>uV(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function Tse(e,t,n){let a=n!=null?n():N.now(),r;return(...s)=>{let i=n!=null?n():N.now();return i-a<t||(a=i,r=e(...s)),r}}function cV(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var Ese=0;function hV(){return Ese++}var ex={};function L1(e=""){return e in ex||(ex[e]=0),ex[e]+=1,e+ex[e].toString()}var Nse=["channelsFirst","channelsLast"],Cse=["nearest","bilinear"],Ase=["valid","same","causal"],Rse=["max","avg"],Dse=["sum","mul","concat","ave"],jd=new Map;function $n(e){xd(Nse,"DataFormat",e)}function $se(e){xd(Cse,"InterpolationFormat",e)}function ds(e){xd(Ase,"PaddingMode",e)}function dV(e){xd(Rse,"PoolMode",e)}var Zg=[],j$="/";function mc(e,t){Zg.push(e);try{let n=t();return Zg.pop(),n}catch(n){throw Zg.pop(),n}}function Mse(){return Zg.length===0?"":Zg.join(j$)+j$}function pV(e){if(!mV(e))throw new Error("Not a valid tensor name: '"+e+"'");return Mse()+e}function fV(e){if(!mV(e))throw new Error("Not a valid tensor name: '"+e+"'");jd.has(e)||jd.set(e,0);let t=jd.get(e);if(jd.set(e,jd.get(e)+1),t>0){let n=`${e}_${t}`;return jd.set(n,1),n}else return e}var Ose=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function mV(e){return!!e.match(Ose)}function Fse(e){return e===parseInt(e.toString(),10)}function Rl(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function ef(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a<t&&(t=a)}return t}function Kl(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a>t&&(t=a)}return t}function Ys(e,t){if(t<e)throw new Y(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let a=e;a<t;++a)n.push(a);return n}var NS;function ea(){return NS==null&&(NS=F2().epsilon()),NS}function Zs(){return"channelsLast"}function No(e,t){return ye(e,t)}function Yb(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),K(e,n)}function Lse(e,t){return X(()=>{if(e.shape.length!==2)throw new Y(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=Yb(e,1);return mk(n,[1,t,1])})}function zse(e){let t=[Rl(e.shape)];return K(e,t)}function Pse(e){if(e.rank<=1)throw new Y(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],Rl(e.shape,1)];return K(e,t)}function gc(e,t,n){return X(()=>{switch(e.rank){case 1:return Hb(e,t,n);case 2:return S1(e,[t,0],[n,e.shape[1]]);case 3:return Rm(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Yp(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return vt(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return vt(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Y(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function CS(e,t,n){return X(()=>{switch(e.rank){case 1:return Hb(e,t,n);case 2:return S1(e,[0,t],[e.shape[0],n]);case 3:return Rm(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Yp(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Y(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function tx(e,t,n,a){return X(()=>{switch(e.rank){case 1:return Hb(e,t,n);case 2:switch(a){case 1:return gc(e,t,n);case 2:return CS(e,t,n);default:throw new Y(`The axis is not within the rank of the tensor ${a}`)}case 3:switch(a){case 1:return gc(e,t,n);case 2:return Rm(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return CS(e,t,n);default:throw new Y(`The axis is not within the rank of the tensor ${a}`)}case 4:switch(a){case 1:return gc(e,t,n);case 2:return Yp(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Yp(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return CS(e,t,n);default:throw new Y(`The axis is not within the rank of the tensor ${a}`)}default:throw new Y(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function rN(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),Qt(e,t)}function G$(e,t){switch(e.rank){case 1:return tE([e,t]);case 2:return nE([e,t],0);case 3:return aE([e,t],0);case 4:return rE([e,t],0);default:throw new Y(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function mk(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Y(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Dr(e,t)}function z1(e,t=0,n=1,a,r){return g1(e,t,n,a,r)}function Ri(e,t,n,a){if(e.rank<2||t.rank<2)throw new ft(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let r=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(r!==s)throw new ft(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Jp.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?gk(e.rank,a,Zs()):null,activation:n});{let r=e.shape.slice(),s=r.pop();e=K(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),c=[...i,o],u=Array.from({length:t.rank},(d,p)=>p===0?t.rank-2:p<=t.rank-2?p-1:p);t=K(lt(t,u),[l,-1]);let h=[...r,...c];return K(Jp.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?gk(e.rank,a,Zs()):null,activation:n}),h)}}function gV(e,t,n){return X(()=>(Array.isArray(t)?t=Ft(t,"int32"):t=ye(t,"int32"),Cm(e,t,n)))}function Zb(e){return G(e,e)}function gk(e,t,n){let a=t.shape;if(t.rank!==1&&t.rank!==e)throw new Y(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return a.length===1?K(t,[1,a[0],1,1,1]):K(t,[1,a[3],a[0],a[1],a[2]]);if(n==="channelsLast")return a.length===1?K(t,[1,1,1,1,a[0]]):K(t,[1].concat(a))}else if(e===4){if(n==="channelsFirst")return a.length===1?K(t,[1,a[0],1,1]):K(t,[1,a[2],a[0],a[1]]);if(n==="channelsLast")return a.length===1?K(t,[1,1,1,a[0]]):K(t,[1].concat(a))}else if(e===3){if(n==="channelsFirst")return a.length===1?K(t,[1,a[0],1]):K(t,[1,a[1],a[0]]);if(n==="channelsLast")return a.length===1?K(t,[1,1,a[0]]):K(t,[1].concat(a))}else if(e<3)return t;throw new Y(`Unsupported input rank by biasAdd: ${t.rank}`)}function si(e,t,n){return X(()=>(n==null&&(n=Zs()),$n(n),re(e,gk(e.rank,t,n))))}function Vse(e,t=1){if(t!==1)throw new ft(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Tm(e)}function Bse(e){return X(()=>Ce(e,re(On(e),1)))}function yV(e,t,n,a){return X(()=>VE(e,t,n,a))}function Use(e){return X(()=>{let t=re(.5,G(.2,e));return Va(t,0,1)})}function Jb(e,t,n=!1){return n?e():t()}var Wse=["fanIn","fanOut","fanAvg"],jse=["normal","uniform","truncatedNormal"];function Gse(e){xd(Wse,"FanMode",e)}function Hse(e){xd(jse,"Distribution",e)}var Fs=class extends de.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},sN=class extends Fs{apply(e,t){return _n(e,t)}};sN.className="Zeros";de.registerClass(sN);var P1=class extends Fs{apply(e,t){return pr(e,t)}};P1.className="Ones";de.registerClass(P1);var iN=class extends Fs{constructor(e){if(super(),typeof e!="object")throw new Y(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new Y(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return X(()=>G(ze(this.value),pr(e,t)))}getConfig(){return{value:this.value}}};iN.className="Constant";de.registerClass(iN);var oN=class extends Fs{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return yu(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};oN.className="RandomUniform";de.registerClass(oN);var lN=class extends Fs{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ft(`randomNormal does not support dType ${t}.`);return z1(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};lN.className="RandomNormal";de.registerClass(lN);var uN=class extends Fs{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ft(`truncatedNormal does not support dType ${t}.`);return C1(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};uN.className="TruncatedNormal";de.registerClass(uN);var cN=class extends Fs{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return X(()=>{if(e.length!==2||e[0]!==e[1])throw new Y("Identity matrix initializer can only be used for 2D square matrices.");return G(this.gain,h1(e[0]))})}getConfig(){return{gain:this.gain}}};cN.className="Identity";de.registerClass(cN);function qse(e,t="channelsLast"){let n,a;if($n(t),e.length===2)n=e[0],a=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let r=Rl(e,2);n=e[1]*r,a=e[0]*r}else if(t==="channelsLast"){let r=Rl(e,0,e.length-2);n=e[e.length-2]*r,a=e[e.length-1]*r}}else{let r=Rl(e);n=Math.sqrt(r),a=Math.sqrt(r)}return[n,a]}var yr=class extends Fs{constructor(e){if(super(),e.scale<0)throw new Y(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Gse(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Hse(this.distribution),this.seed=e.seed}apply(e,t){let n=qse(e),a=n[0],r=n[1],s=this.scale;if(this.mode==="fanIn"?s/=Math.max(1,a):this.mode==="fanOut"?s/=Math.max(1,r):s/=Math.max(1,(a+r)/2),this.distribution==="normal"){let i=Math.sqrt(s);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ft(`${this.getClassName()} does not support dType ${t}.`);return C1(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*s);return yu(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};yr.className="VarianceScaling";de.registerClass(yr);var V1=class extends yr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return yr.className}};V1.className="GlorotUniform";de.registerClass(V1);var B1=class extends yr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return yr.className}};B1.className="GlorotNormal";de.registerClass(B1);var U1=class extends yr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return yr.className}};U1.className="HeNormal";de.registerClass(U1);var W1=class extends yr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return yr.className}};W1.className="HeUniform";de.registerClass(W1);var j1=class extends yr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return yr.className}};j1.className="LeCunNormal";de.registerClass(j1);var G1=class extends yr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return yr.className}};G1.className="LeCunUniform";de.registerClass(G1);var hN=class extends Fs{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return X(()=>{if(e.length<2)throw new ft("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=N.sizeFromShape(e.slice(0,-1)),a=e[e.length-1],r=n*a;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);let s=[Math.max(a,n),Math.min(a,n)],i=z1(s,0,1,t,this.seed),o=jE.qr(i,!1),l=o[0],c=o[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return l=G(l,c.sign()),n<a&&(l=l.transpose()),G(ze(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};hN.className="Orthogonal";de.registerClass(hN);var H$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function q$(e,t={}){return Qb(e,de.SerializationMap.getMap().classNameMap,t,"initializer")}function Sn(e){return nN(e)}function gn(e){if(typeof e=="string"){let t=e in H$?H$[e]:e;if(t==="GlorotNormal")return new B1;if(t==="GlorotUniform")return new V1;if(t==="HeNormal")return new U1;if(t==="HeUniform")return new W1;if(t==="LeCunNormal")return new j1;if(t==="LeCunUniform")return new G1;{let n={};return n.className=t,n.config={},q$(n)}}else return e instanceof Fs?e:q$(e)}function yk(e){return Array.isArray(e)&&Array.isArray(e[0])}function M0(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function He(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new Y(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function $t(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new Y(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function O0(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((a,r)=>a*r);return t}var K$="Variable",bV=class{constructor(e,t="float32",n=K$,a=!0,r=null){this.dtype=t??"float32",this.shape=e.shape,this.id=hV(),n=n??K$,this.originalName=pV(n),this.name=fV(this.originalName),this.trainable_=a,this.constraint=r,this.val=zE(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Kse(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function Kse(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function bk(e){return e.map(t=>t.read())}function dN(e){e.forEach(t=>{t[0].write(t[1])})}var zn=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Js=class{constructor(e,t,n,a,r,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=i,this.id=hV(),s!=null&&(this.originalName=pV(s),this.name=fV(this.originalName)),this.rank=t.length}},Xse=0,H1=class{constructor(e,t){this.callArgs=t,this.id=Xse++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},Qse=0,mt=class extends de.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Qse++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=io(n)+"_"+L1(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),n=[r].concat(e.inputShape)}this.batchInputShape=n;let a=e.dtype;a==null&&(a=e.inputDType),a==null&&(a="float32"),this.dtype=a}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Ti(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Y(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return hr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return hr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new al(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new al(`Layer ${this.name} is not connected, no input to return.`);return hr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new al(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new al(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return hr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=Vt(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=Vt(this.inputSpec);if(t.length!==n.length)throw new Y(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let a=0;a<t.length;a++){let r=t[a],s=n[a];if(s==null)continue;let i=r.rank;if(s.ndim!=null&&i!==s.ndim)throw new Y(`Input ${a} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new Y(`Input ${a} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new Y(`Input ${a} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&r.dtype!==s.dtype)throw new Y(`Input ${a} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){let o=r.shape;for(let l in s.axes){let c=Number(l),u=s.axes[l],h=c>=0?o[c]:o[o.length+c];if(u!=null&&[u,null].indexOf(h)===-1)throw new Y(`Input ${a} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${u} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let l=s.shape[o],c=r.shape[o];if(l!=null&&c!=null&&l!==c)throw new Y(`Input ${a} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=Vt(e),a=Jse(e),r=eie(e);if(a===r)throw new Y("Arguments to apply() must be all SymbolicTensors or all Tensors");return mc(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let s=[];for(let i of Vt(e))s.push(i.shape);this.build(hr(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let s=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,s);let i=Vt(s),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(s=hr(o),this.activityRegularizer!=null)throw new ft("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}else{let s=Yse(e),i=this.computeOutputShape(s),o,l=Zse(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?s[0]:s),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((c,u)=>new Js(l,c,this,Vt(e),t,this.name,u)):o=new Js(l,i,this,Vt(e),t,this.name),this.addInboundNode(e,o,null,null,s,i,t),this._refCount++,this.activityRegularizer!=null)throw new ft("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,a)=>{n!=null&&e[a]!=null&&e[a]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new al(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new al(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ti(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return O0(this.weights)}build(e){this.built=!0}getWeights(e=!1){return bk(e?this.trainableWeights:this.weights)}setWeights(e){X(()=>{let t=this.weights;if(t.length!==e.length)throw new Y(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],a=bk(t);for(let r=0;r<a.length;++r){let s=a[r],i=t[r],o=e[r];if(!N.arraysEqual(s.shape,o.shape))throw new Y(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}dN(n)})}addWeight(e,t,n,a,r,s,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new Y(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(a=o!=null?o():gn("zeros"));let l=a.apply(t,n),c=new bV(l,n,e,s,i);return l.dispose(),r!=null&&this.addLoss(()=>r.apply(c.read())),s==null&&(s=!0),s?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Vt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let a=this.computeMask(e,n),r=Vt(t),s=Vt(a);if(r.length!==s.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let i=0;i<r.length;i++)r[i].kerasMask=s[i]}addInboundNode(e,t,n,a,r,s,i=null){let o=Vt(e);t=Vt(t),n=Vt(n),a=Vt(a),r=M0(r),s=M0(s);let l=[],c=[],u=[];for(let h of o)l.push(h.sourceLayer),c.push(h.nodeIndex),u.push(h.tensorIndex);new H1({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:s},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function Yse(e){e=Vt(e);let t=[];for(let n of e)t.push(n.shape);return hr(t)}function Zse(e){return"float32"}function vV(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let a=t.inboundNodes[n];if(a.inboundLayers.length===0)return a.inputTensors;{let r=[];for(let s=0;s<a.inboundLayers.length;s++){let i=a.inputTensors[s],o=a.inboundLayers[s],l=a.nodeIndices[s],c=vV(i,o,l);for(let u of c)r.indexOf(u)===-1&&r.push(u)}return r}}}function Jse(e){let t=!0;for(let n of Vt(e))if(!(n instanceof Js)){t=!1;break}return t}function eie(e){let t=!0;for(let n of Vt(e))if(n instanceof Js){t=!1;break}return t}var $m=class extends mt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:L1("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new Y("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new Y("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new Y("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let a=new Js(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new H1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Y(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};$m.className="InputLayer";de.registerClass($m);function xV(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new Y("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new $m({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function tie(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return ye(t,e.dtype)}catch{throw new Y(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var gp=class wV{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof wV)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,a){if(this.id2Value[t.id]==null)this.id2Value[t.id]=tie(t,n),this.name2Id[t.name]=t.id,a!=null&&(this.id2Mask[t.id]=a);else throw new Y(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Js){if(this.id2Value[t.id]==null)throw new Y(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new Y(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof Js){if(this.id2Value[t.id]==null)throw new Y(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new Y(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&et(this.id2Mask)}},F0=new lV,L0=new lV;function nie(e){F0!=null&&F0.setMaxEntries(e),L0!=null&&L0.setMaxEntries(e)}function kg(e,t,n,a){let r=n==null?!1:n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(f=>f.name),l=[],c=t.names();for(let f of o)c.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);let u=o.join(",")+"|"+t.names().sort().join(","),h=F0.get(u),d;if(h==null){let f=aie(i,t);h=f.sorted,d=f.recipientCounts,F0.put(u,h),L0.put(u,d)}d={},r||Object.assign(d,L0.get(u));let p=new gp(t);for(let f=0;f<h.length;++f){let m=h[f],g=m.sourceLayer;if(g instanceof $m)continue;let y=[],v=[],x=[],w=!1;for(let E of m.inputs){let R=p.getValue(E),A=p.getMask(E);y.push(R),v.push(A),A!=null&&(w=!0),r||(d[E.name]--,d[E.name]===0&&!t.hasKey(E)&&o.indexOf(E.name)===-1&&!R.isDisposed&&E.sourceLayer.stateful!==!0&&x.push(R))}w&&(n=n||{},n.mask=v[0]);let k=Vt(g.apply(y,n)),M=null;g.supportsMasking&&(M=g.computeMask(y,v));let S=sie(m),I=Array.isArray(S)?S:[S];for(let E=0;E<I.length;++E){p.hasKey(I[E])||p.add(I[E],k[E],Array.isArray(M)?M[0]:M);let R=o.indexOf(I[E].name);R!==-1&&(l[R]=k[E])}r||et(x)}return p.disposeMasks(),s?l:l[0]}function aie(e,t){N.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],a={};if(e.length===1){let r=X$(e[0],t);n=r.sorted,a=r.recipientMap}else{let r=new Set;for(let s of e){let{sorted:i,recipientMap:o}=X$(s,t);for(let l of i)r.has(l.name)||(n.push(l),r.add(l.name));for(let l in o)a[l]==null&&(a[l]=new Set),o[l].forEach(c=>a[l].add(c))}}return{sorted:n,recipientCounts:rie(a)}}function rie(e){let t={};for(let n in e)t[n]=e[n].size;return t}function X$(e,t){let n=new Set,a=[],r={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let o=s[s.length-1];if(n.has(o.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(o.inputs.length===0||l)s.pop(),a.push(o),n.add(o.name),l&&i.pop();else{i.push(s.length-1);for(let c of o.inputs)r[c.name]==null&&(r[c.name]=new Set),r[c.name].add(o.name),!n.has(c.name)&&s.push(c)}}return{sorted:a,recipientMap:r}}function sie(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let a=0;a<e.sourceLayer.inboundNodes.length;++a)for(let r of e.sourceLayer.inboundNodes[a].outputTensors)if(r.id===e.id){n=a;break}t=e.sourceLayer.getOutputAt(n)}return t}var iie=Z();iie.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,nie);var _V={};tt(_V,{maxNorm:()=>oie,minMaxNorm:()=>cie,nonNeg:()=>uie,unitNorm:()=>lie});function pN(e,t){return X(()=>va(De(G(e,e),t,!0)))}var ev=class extends de.Serializable{getConfig(){return{}}},fN=class extends ev{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return X(()=>{let t=pN(e,this.axis),n=Va(t,0,this.maxValue);return G(e,Ce(n,re(ea(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};fN.className="MaxNorm";de.registerClass(fN);var mN=class extends ev{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return X(()=>Ce(e,re(ea(),pN(e,this.axis))))}getConfig(){return{axis:this.axis}}};mN.className="UnitNorm";de.registerClass(mN);var gN=class extends ev{apply(e){return Bt(e)}};gN.className="NonNeg";de.registerClass(gN);var yN=class extends ev{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return X(()=>{let t=pN(e,this.axis),n=re(G(this.rate,Va(t,this.minValue,this.maxValue)),G(1-this.rate,t));return G(e,Ce(n,re(ea(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};yN.className="MinMaxNorm";de.registerClass(yN);var Q$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ra(e){return nN(e)}function Y$(e,t={}){return Qb(e,de.SerializationMap.getMap().classNameMap,t,"constraint")}function sa(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in Q$?Q$[e]:e,config:{}};return Y$(t)}else return e instanceof ev?e:Y$(e)}function oie(e){return new fN(e)}function lie(e){return new mN(e)}function uie(){return new gN}function cie(e){return new yN(e)}var SV={};tt(SV,{constant:()=>pie,glorotNormal:()=>xie,glorotUniform:()=>vie,heNormal:()=>wie,heUniform:()=>_ie,identity:()=>yie,leCunNormal:()=>Sie,leCunUniform:()=>Iie,ones:()=>die,orthogonal:()=>kie,randomNormal:()=>mie,randomUniform:()=>fie,truncatedNormal:()=>gie,varianceScaling:()=>bie,zeros:()=>hie});function hie(){return new sN}function die(){return new P1}function pie(e){return new iN(e)}function fie(e){return new oN(e)}function mie(e){return new lN(e)}function gie(e){return new uN(e)}function yie(e){return new cN(e)}function bie(e){return new yr(e)}function vie(e){return new V1(e)}function xie(e){return new B1(e)}function wie(e){return new U1(e)}function _ie(e){return new W1(e)}function Sie(e){return new j1(e)}function Iie(e){return new G1(e)}function kie(e){return new hN(e)}var IV={};tt(IV,{Layer:()=>mt,RNN:()=>Po,RNNCell:()=>nv,activation:()=>nle,add:()=>hle,alphaDropout:()=>Kle,average:()=>dle,averagePooling1d:()=>CC,averagePooling2d:()=>AC,averagePooling3d:()=>RC,avgPool1d:()=>wle,avgPool2d:()=>Sle,avgPool3d:()=>kle,avgPooling1d:()=>_le,avgPooling2d:()=>Ile,avgPooling3d:()=>Tle,batchNormalization:()=>ble,bidirectional:()=>Vle,categoryEncoding:()=>Jle,centerCrop:()=>Yle,concatenate:()=>ple,conv1d:()=>qoe,conv2d:()=>Koe,conv2dTranspose:()=>Xoe,conv3d:()=>Qoe,conv3dTranspose:()=>Yoe,convLstm2d:()=>Fle,convLstm2dCell:()=>Lle,cropping2D:()=>Joe,dense:()=>ale,depthwiseConv2d:()=>tle,dot:()=>yle,dropout:()=>rle,elu:()=>Boe,embedding:()=>cle,flatten:()=>ile,gaussianDropout:()=>qle,gaussianNoise:()=>Hle,globalAveragePooling1d:()=>Ele,globalAveragePooling2d:()=>Nle,globalMaxPool1d:()=>Ule,globalMaxPool2d:()=>Wle,globalMaxPooling1d:()=>TB,globalMaxPooling2d:()=>EB,gru:()=>Ale,gruCell:()=>Rle,input:()=>UV,inputLayer:()=>Voe,layerNormalization:()=>vle,leakyReLU:()=>Woe,lstm:()=>Dle,lstmCell:()=>$le,masking:()=>Xle,maxPool1d:()=>jle,maxPool2d:()=>Gle,maxPooling1d:()=>NB,maxPooling2d:()=>CB,maxPooling3d:()=>Cle,maximum:()=>fle,minimum:()=>mle,multiply:()=>gle,permute:()=>ule,prelu:()=>joe,randomWidth:()=>eue,reLU:()=>Uoe,repeatVector:()=>ole,rescaling:()=>Qle,reshape:()=>lle,resizing:()=>Zle,rnn:()=>zle,separableConv2d:()=>Zoe,simpleRNN:()=>Mle,simpleRNNCell:()=>Ole,softmax:()=>Goe,spatialDropout1d:()=>sle,stackedRNNCells:()=>Ple,thresholdedReLU:()=>Hoe,timeDistributed:()=>Ble,upSampling2d:()=>ele,zeroPadding2d:()=>xle});async function Jo(e){if(e==null)return;let t=[],n=[],a=[];for(let r in e){let s=e[r];if(typeof s!="number"){let i=s;t.push(i.data()),n.push(r),a.push(i)}}if(t.length>0){let r=await Promise.all(t);for(let s=0;s<r.length;++s)e[n[s]]=r[s][0];et(a)}}function kV(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var Z$;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(Z$||(Z$={}));var Tie=125,tf=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},TV=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},Eie=class extends tf{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let a in t){let r=t[a];if(typeof r=="number")this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+r*n;else{let s;a in this.totals?s=this.totals[a]:this.totals[a]=0;let i=X(()=>re(this.totals[a],G(r,n)));this.totals[a]=i,s!=null&&s.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:X(()=>{let a=G(Ce(1,this.seen),this.totals[n]);t[n]=a,this.totals[n].dispose(),Jn(t[n])}))}},EV=class extends tf{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let r in this.history){let s=this.history[r];for(let i=0;i<s.length;++i)if(typeof s[i]!="number"){let o=s[i];e.push(o.data()),t.push(r),n.push(i)}}let a=await Promise.all(e);for(let r=0;r<a.length;++r)this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}},NV=class extends tf{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||eN,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Tie),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");N.isNumber(this.yieldEvery)&&(this.maybeWait=Tse(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let a=[];this.yield!=null&&(await Jo(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Jo(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await Jo(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Jo(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await Jo(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):N.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Jo(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Jo(e),await this.trainEnd(e))}};function CV(e,t){return e==null&&(e={}),e instanceof tf?[e]:Array.isArray(e)&&e[0]instanceof tf?e:Vt(e).map(n=>new NV(n,t))}var bN=class fi{constructor(){}static registerCallbackConstructor(t,n){N.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),fi.checkForDuplicate(n),fi.constructors[t]==null&&(fi.constructors[t]=[]),fi.constructors[t].push(n)}static checkForDuplicate(t){for(let n in fi.constructors)fi.constructors[+n].forEach(a=>{if(a===t)throw new Y("Duplicate callback constructor.")})}static clear(){fi.constructors={}}static createCallbacks(t){let n=[];for(let a in fi.constructors){let r=+a;t>=r&&n.push(...fi.constructors[r])}return n.map(a=>new a)}};bN.constructors={};function AV(e,t,n,a,r,s,i,o,l){let c=new EV,u=[new Eie,...bN.createCallbacks(t)];e!=null&&u.push(...e),u.push(c);let h=new TV(u);return h.setParams({epochs:n,initialEpoch:a,samples:r,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:c}}function Xs(e,t={},n=!1){return Qb(e,de.SerializationMap.getMap().classNameMap,t,"layer",n)}function z0(e,t){return X(()=>{e.dtype!=="float32"&&(e=ye(e,"float32"));let n=De(Zb(e),t,!0),a=Mr(n.shape,ea()),r=va(Gi(n,a));return Ce(e,r)})}function wd(e,t){return X(()=>wn(Zb(Ie(t,e)),-1))}function q1(e,t){return X(()=>wn(On(Ie(t,e)),-1))}function Mm(e,t){return X(()=>{let n=Ie(e,t),a=Va(On(e),ea(),Number.MAX_VALUE),r=On(Ce(n,a));return G(100,wn(r,-1))})}function Nie(e,t){return X(()=>{let n=Va(t,ea(),Number.MAX_VALUE),a=zr(re(1,n)),r=Va(e,ea(),Number.MAX_VALUE),s=zr(re(1,r));return wn(Zb(Ie(a,s)),-1)})}function Cie(e,t){return X(()=>{let n=Gi(0,Ie(1,G(e,t)));return wn(Zb(n),-1)})}function Aie(e,t){return X(()=>{let n=Gi(0,Ie(1,G(e,t)));return wn(n,-1)})}function Rie(e,t){return X(()=>{let n=De(G(e,t),-1),a=is(G(Ie(1,e),t),-1);return Gi(0,re(1,Ie(a,n)))})}function Die(e,t){return X(()=>{let n=Math.log(2),a=Ie(t,e),r=Ie(re(a,bd(G(-2,a))),n);return wn(r,-1)})}function Ay(e,t,n=!1){return X(()=>{if(n)t=bu(t);else{let a=De(t,t.shape.length-1,!0);t=Ce(t,a)}return t=Va(t,ea(),1-ea()),on(De(G(ye(e,"float32"),zr(t)),t.shape.length-1))})}function P0(e,t,n=!1){return X(()=>{let a=ye(Nm(zse(e)),"int32");t=Va(t,ea(),1-ea());let r=t.shape,s=K(Xp(a,r[r.length-1]),r);return Ay(s,t,n)})}function $ie(e,t){if(!N.arraysEqual(e.shape,t.shape))throw new Y(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return X(()=>{let n=Bt(t),a=on(On(t));return re(Ie(n,G(t,e)),Vb(Ba(a)))})}function K1(e,t){return X(()=>{let n;return n=Va(t,ea(),1-ea()),n=zr(Ce(n,Ie(1,n))),wn($ie(e,n),-1)})}function Mie(e,t){return X(()=>{let n=Va(e,ea(),1),a=Va(t,ea(),1);return De(G(e,zr(Ce(n,a))),-1)})}function Oie(e,t){return X(()=>{let n=zr(re(ea(),t));return wn(Ie(t,G(e,n)),-1)})}function vN(e,t){return X(()=>{let n=z0(e,-1),a=z0(t,-1),r=G(n,a);return on(De(r,-1))})}var V0={meanSquaredError:wd,meanAbsoluteError:q1,meanAbsolutePercentageError:Mm,meanSquaredLogarithmicError:Nie,squaredHinge:Cie,hinge:Aie,categoricalHinge:Rie,logcosh:Die,categoricalCrossentropy:Ay,sparseCategoricalCrossentropy:P0,binaryCrossentropy:K1,kullbackLeiblerDivergence:Mie,poisson:Oie,cosineProximity:vN};function AS(e){if(typeof e=="string"){if(e in V0)return V0[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Y(t)}else return e}function xN(e,t){return X(()=>{let n=G(.5,Pr(t)),a=No(sr(t,n),e.dtype);return wn(Lr(e,a),-1)})}function wN(e,t){return X(()=>No(Lr(Rc(e,-1),Rc(t,-1)),"float32"))}function RV(e,t){return X(()=>ye(De(Ms(Lr(e,1),Lr(t,1))),"float32"))}function Fie(e,t){return X(()=>ye(De(Ms(Lr(e,1),Lr(t,0))),"float32"))}function Lie(e,t){return X(()=>ye(De(Ms(Lr(e,0),Lr(t,1))),"float32"))}function DV(e,t){return X(()=>{let n=RV(e,t),a=Lie(e,t),r=re(n,a);return ye(ga(sr(r,0),Ce(n,r),0),"float32")})}function zie(e,t){return X(()=>{let n=RV(e,t),a=Fie(e,t),r=re(n,a);return ye(ga(sr(r,0),Ce(n,r),0),"float32")})}function $V(e,t){return K1(e,t)}function MV(e,t){return e.rank===t.rank&&(e=vu(e,[e.rank-1])),t=Rc(t,-1),t.dtype!==e.dtype&&(t=ye(t,e.dtype)),ye(Lr(e,t),"float32")}function Pie(e,t){return X(()=>{let n=e.sub(t).square().sum(),a=e.sub(e.mean()).square().sum();return ze(1).sub(n.div(a))})}var Vie=wd,Bie=wd,Uie=q1,Wie=q1,jie=Mm,Gie=Mm,_N=Ay,Hie=vN,OV=P0,B0={binaryAccuracy:xN,categoricalAccuracy:wN,precision:DV,categoricalCrossentropy:_N,sparseCategoricalCrossentropy:OV,mse:Vie,MSE:Bie,mae:Uie,MAE:Wie,mape:jie,MAPE:Gie,cosine:Hie};function qie(e){if(typeof e=="string"&&e in B0)return B0[e];if(typeof e!="string"&&e!=null)return e;throw new Y(`Unknown metric ${e}`)}function nx(e){if(wi(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(V0))if(V0[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(B0))if(B0[n]===e){t=n;break}return t!==void 0?t:e.name}}function Kie(e){let t={Adagrad:()=>Zu.adagrad(.01),Adadelta:()=>Zu.adadelta(1,.95,ea()),Adam:()=>Zu.adam(.001,.9,.999,ea()),Adamax:()=>Zu.adamax(.002,.9,.999,ea(),0),RMSProp:()=>Zu.rmsprop(.001,.9,0,ea()),SGD:()=>Zu.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Y(`Unknown Optimizer ${e}`)}function J$(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!vk(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let a=JSON.stringify(e);a.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${a.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function vk(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!vk(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!vk(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function Xie(e,t,n,a=console.log){let r=Yie(e),s=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(u=>Math.floor(t*u)));let i;if(!r){s.push("Receives inputs"),i=[];for(let u in e.nodesByDepth)i.push(...e.nodesByDepth[u])}a("_".repeat(t)),U0(s,n,a),a("=".repeat(t));let o=e.layers;for(let u=0;u<o.length;++u)r?Zie(o[u],n,a):Jie(o[u],n,i,a),a((u===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=Qie(e),c=O0(e.nonTrainableWeights);a(`Total params: ${l+c}`),a(`Trainable params: ${l}`),a(`Non-trainable params: ${c}`),a("_".repeat(t))}function Qie(e){let t;return e.collectedTrainableWeights!=null?t=O0(e.collectedTrainableWeights):t=O0(e.trainableWeights),t}function Yie(e){let t=!0,n=[],a=[];for(let r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(let r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(let r of e.layers){let s=!1;for(let i of r.inboundNodes)if(a.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function U0(e,t,n=console.log){let a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function Zie(e,t,n){let a,r;try{r=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{a=JSON.stringify(e.outputShape)}catch{a="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,r,a,e.countParams().toString()];U0(o,t,n)}function Jie(e,t,n,a){let r,s;try{s=e.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let i=[];for(let h of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){let p=h.inboundLayers[d].name,f=h.nodeIndices[d],m=h.tensorIndices[d];i.push(`${p}[${f}][${m}]`)}let o=e.name,l=e.getClassName(),c=i.length===0?"":i[0],u=[`${o} (${l})`,s,r,e.countParams().toString(),c];U0(u,t,a);for(let h=1;h<i.length;++h)U0(["","","","",i[h]],t,a)}function FV(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function Ry(e,t){if(e===null)return null;if(typeof e=="string")return ac(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let s=e[r];FV(t,r,s)?n.push(s):n.push(Ry(s,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a];if(a==="name"&&typeof r=="string")n[a]=r;else{let s=ac(a);n[s]=Ry(r,s)}}return n}}function xk(e,t){if(e==null)return null;if(typeof e=="string")return io(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let s=e[r];FV(t,r,s)?n.push(s):n.push(xk(s,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a],s=io(a);(a==="name"||a==="className")&&typeof r=="string"?n[s]=r:n[s]=xk(r,a)}return n}}var SN="4.22.0",eoe=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},toe=class mi extends mt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let v=this.getClassName().toLowerCase();this.name=L1(v)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Al(this.inputs).length!==this.inputs.length)throw new Y(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(v=>v.name)}`);Al(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(v=>v.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let v of this.outputs){let x=v.sourceLayer,w=v.nodeIndex,k=v.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(k)}for(let v of this.inputs){let x=v.sourceLayer,w=v.nodeIndex,k=v.tensorIndex;wi(w===0,"input layer has >1 nodes"),wi(k===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(k)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let v=0;v<this.inputLayers.length;v++){let x=this.inputLayers[v];if(!(x instanceof $m))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${v} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(let v of this.outputLayers)this.outputNames.push(v.name);this.internalInputShapes=this.inputs.map(v=>v.shape),this.internalOutputShapes=this.outputs.map(v=>v.shape);let n={},a={},r={},s={},i={},o=[],l=(v,x,w,k,M,S)=>{(k==null||M==null||S==null)&&(k=v.sourceLayer,M=v.nodeIndex,S=v.tensorIndex);let I=k.inboundNodes[M];if(w.indexOf(I)!==-1)throw new Ti(`The tensor ${v.name} at layer "${k.name}" is part of a cycle.`);if(x.indexOf(I)!==-1)return;this.containerNodes.add(mi.nodeKey(k,M)),k.id in i||(i[k.id]=Object.keys(i).length),w.indexOf(I)===-1&&w.push(I);let E=I.inboundLayers.length;for(let R=0;R<E;R++){let A=I.inputTensors[R],_=I.inboundLayers[R],D=I.nodeIndices[R],j=I.tensorIndices[R];l(A,x,w,_,D,j)}for(x.push(I);w.indexOf(I)>=0;)w.splice(w.indexOf(I),1);o.push(I)},c=[],u=[];for(let v of this.outputs)l(v,c,u);let h=o.slice().reverse();for(let v of h){a[v.id]=v,v.id in n||(n[v.id]=0);let x=n[v.id],w=r[v.outboundLayer.id]==null?0:r[v.outboundLayer.id];x=Math.max(x,w),r[v.outboundLayer.id]=x,s[v.outboundLayer.id]=v.outboundLayer,n[v.id]=x;for(let k=0;k<v.inboundLayers.length;k++){let M=v.inboundLayers[k],S=v.nodeIndices[k],I=M.inboundNodes[S],E=n[I.id]==null?0:n[I.id];n[I.id]=Math.max(x+1,E),a[I.id]=I}}let d={};for(let v in n){let x=n[v];x in d||(d[x]=[]),d[x].push(a[v])}let p={};for(let v in r){let x=r[v];x in p||(p[x]=[]),p[x].push(s[v])}let f=Object.keys(p).map(v=>parseInt(v,10)).sort(Jv);this.layers=[];for(let v of f){let x=p[v];x.sort((w,k)=>{let M=i[w.id],S=i[k.id];return M<S?-1:M>S?1:0});for(let w of x)w instanceof mi&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=p,f=Object.keys(d).map(v=>parseInt(v,10)).sort(Jv);let m=this.inputs.slice(),g=[];for(let v of f)for(let x of d[v]){let w=x.outboundLayer;if(w!=null){for(let k of x.inputTensors)if(m.indexOf(k)===-1)throw new Ti(`Graph disconnected: cannot obtain value for tensor ${k} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(let k of x.outputTensors)m.push(k);g.push(w.name)}}this.nodesByDepth=d;let y=this.layers.map(v=>v.name);for(let v of y){let x=y.filter(w=>w===v).length;if(x!==1)throw new Ti(`The name "${v}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new H1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(v=>null),outputMasks:this.outputs.map(v=>null),inputShapes:this.inputs.map(v=>v.shape),outputShapes:this.outputs.map(v=>v.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(a=>a.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new Y("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let a of this.layers)n.push(...a.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let a={},r=0,s=eoe(t);s&&this.parseWeights(t);for(let o of this.layers)for(let[l,c]of o.weights.entries()){let u=s?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(a[u]!=null)throw new Y(`Duplicate weight name: ${u}`);a[u]=c,r++}let i=[];for(let o in t){let l=o;if(a[o]==null){let c=o.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(a[l]!=null)i.push([a[l],t[o]]);else if(n)throw new Y(`Provided weight data has no target variable: ${o}`);delete a[l]}if(n){let o=[];for(let l in a)o.push(l);if(o.length>0)throw new Y(`${o.length} of ${r} weights are not set: ${o}`)}dN(i)}parseWeights(t){for(let n in Object.keys(t)){let a=n.split("/"),r=["vars","layer_checkpoint_dependencies"],s=a.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!r.includes(i)).join("/");s!==n&&(t[s]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${SN}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let a=xk(this.updatedConfig());return n?JSON.stringify(a):a}call(t,n){return X(()=>{t=Vt(t);let a=new gp;for(let r=0;r<this.inputs.length;++r)a.add(this.inputs[r],t[r]);return kg(this.outputs,a,n)})}computeMask(t,n){return X(()=>{t=Vt(t);let a;return n==null?a=Fc(null,t.length):a=Vt(n),this.runInternalGraph(t,a)[1]})}computeOutputShape(t){let n=M0(t);if(n.length!==this.inputLayers.length)throw new Y(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let a={};for(let o=0;o<n.length;o++){let l=this.inputLayers[o],c=n[o],u=l.name+"_0_0";a[u]=c}let r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Jv);if(r.length>1)for(let o of r){let l=this.nodesByDepth[o];for(let c of l){let u=c.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(u.id)!==-1)continue;let h=[];for(let m=0;m<c.inboundLayers.length;m++){let g=c.inboundLayers[m],y=c.nodeIndices[m],v=c.tensorIndices[m],x=`${g.name}_${y}_${v}`,w=a[x];h.push(w)}let d=u.computeOutputShape(hr(h)),p=M0(d),f=u.inboundNodes.indexOf(c);for(let m=0;m<p.length;m++){let g=`${u.name}_${f}_${m}`;a[g]=p[m]}}}let s=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let l=this.outputLayers[o],c=this.outputLayersNodeIndices[o],u=this.outputLayersTensorIndices[o],h=`${l.name}_${c}_${u}`;i.push(h)}for(let o=0;o<i.length;o++){let l=i[o];wi(l in a),s.push(a[l])}return hr(s)}runInternalGraph(t,n){n==null&&(n=Fc(null,t.length));let a={};for(let l=0;l<this.inputs.length;++l){let c=this.inputs[l],u=t[l],h=n[l];a[c.id]=[u,h]}let r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Jv);for(let l of r){let c=this.nodesByDepth[l];for(let u of c){let h=u.outboundLayer,d=u.inputTensors,p=u.outputTensors,f=new Array;for(let m of d)m.id in a&&f.push(a[m.id]);if(f.length===d.length){let m={},g,y,v,x;if(u.callArgs!=null&&(m=u.callArgs),f.length===1){let[w,k]=f[0];m.mask==null&&(m.mask=k),v=Vt(h.call(w,m)),x=Vt(h.computeMask(w,k)),g=[w],y=[k]}else g=f.map(w=>w[0]),y=f.map(w=>w[1]),m.mask==null&&(m.mask=y),v=Vt(h.call(g,m)),x=Vt(h.computeMask(g,y));if(h.activityRegularizer)throw new ft("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<p.length;++w){let k=p[w],M=v[w],S=x[w];a[k.id]=[M,S]}}}}let s=[],i=[],o=[];for(let l of this.outputs){wi(l.id in a,`Could not compute output ${l.name} : ${l.id}`);let[c,u]=a[l.id];o.push(c.shape),s.push(c),i.push(u)}return[s,i,o]}buildNodeConversionMap(t){let n={},a;for(let r of this.layers){a=r instanceof mi?1:0;for(let s=0;s<r.inboundNodes.length;s++){let i=mi.nodeKey(r,s);this.containerNodes.has(i)&&(n[i]=a,a+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new Y("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let a of this.layers)if(a.name===t)return a;throw new Y(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new Y(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return X(()=>{let t=[];for(let n of this.layers)for(let a=0;a<n.inboundNodes.length;++a){let r=mi.nodeKey(n,a);this.containerNodes.has(r)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),a=[];for(let i of this.layers){let o=i.getClassName(),l=i.getConfig(),c=[];for(let h=0;h<i.inboundNodes.length;h++){let d=i.inboundNodes[h],p=mi.nodeKey(i,h),f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){let m=[];for(let g=0;g<d.inboundLayers.length;g++){let y=d.inboundLayers[g],v=d.nodeIndices[g],x=d.tensorIndices[g],w=mi.nodeKey(y,v),k=n[w];k==null&&(k=0),m.push([y.name,k,x,f])}c.push(m)}}}let u={};u.name=i.name,u.className=o,u.config=l,u.inboundNodes=c,a.push(u)}t.layers=a;let r=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],c=mi.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let u=n[c];u==null&&(u=0);let h=this.inputLayersTensorIndices[i];r.push([o.name,u,h])}t.inputLayers=r;let s=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],c=mi.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let u=n[c];u==null&&(u=0);let h=this.outputLayersTensorIndices[i];s.push([o.name,u,h])}return t.outputLayers=s,t}static fromConfig(t,n,a={},r=!1){let s={},i={};function o(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){let v=[],x;for(let w of y){let k=w[0],M=w[1],S=w[2];if(x=w[3]==null?{}:w[3],!(k in s)){o(g,y);return}let I=s[k];if(I.inboundNodes.length<=M){o(g,y);return}let E=I.inboundNodes[M];v.push(E.outputTensors[S])}v.length>0&&g.apply(hr(v),x)}function c(g){let y=g.name,v=Xs(g,n.customObjects!=null?n.customObjects:{});v.setFastWeightInitDuringBuild(r),s[y]=v,g.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new Y(`Corrupted configuration, expected array for nodeData: ${x}`);o(v,x)})}let u=n.name,h=n.layers;for(let g of h)c(g);for(;!kse(i);)for(let g of h){let y=s[g.name];if(y.name in i){let v=i[y.name];delete i[y.name];for(let x of v)l(y,x)}}let d=[],p=[],f=n.inputLayers;for(let g of f){let y=g[0],v=g[1],x=g[2];wi(y in s);let w=s[y].inboundNodes[v].outputTensors;d.push(w[x])}let m=n.outputLayers;for(let g of m){let y=g[0],v=g[1],x=g[2];wi(y in s);let w=s[y].inboundNodes[v].outputTensors;p.push(w[x])}return new t({inputs:d,outputs:p,name:u})}get stateful(){if(this._stateful)throw new Y("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){X(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function noe(e,t,n){let a=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>null);if(a===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${a} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let r=[];return t.forEach(s=>{s in e?r.push(e[s]):r.push(null)}),r}else throw new Error(`The model has multiple (${a}) outputs, so ${n} must be either an array with ${a} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function LV(e,t){return noe(e,t,"classWeight")}async function zV(e,t,n,a){if(n!=null){let r=X(()=>{if(e.shape.length===1)return Ci(e);if(e.shape.length===2){if(e.shape[1]>1)return Rc(e,1);if(e.shape[1]===1)return K(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await r.data());et(r);let i=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),Ft(i,"float32")}else return null}function aoe(e,t){return G(e,t)}var roe=32;function PV(e,t){let n,a,r=t;n=r.xs,a=r.ys,N.assert(n!=null&&a!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=eM("input",e.inputNames,n),i=eM("output",e.outputNames,a),o=s[0].shape[0];N.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),N.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<s.length;l++)N.assert(s[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)N.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function eM(e,t,n){if(n instanceof at)return[n];if(Array.isArray(n))return N.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let a=[];for(let r of t){if(n[r]==null)throw new Y(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);a.push(n[r])}return a}}function soe(e){if(e.length===3)throw new ft("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function ioe(e,t,n){let a=n.batchesPerEpoch!=null;if(N.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),N.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),N.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),N.assert(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),N.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let r=n.validationData!=null,s,i;if(r)if(tM(n.validationData))N.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=soe(n.validationData);s=g.xs,i=g.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),c;r?c=l.slice().concat(l.map(g=>"val_"+g)):c=l.slice();let u=CV(n.callbacks,n.yieldEvery),h=n.verbose==null?1:n.verbose,{callbackList:d,history:p}=AV(u,h,n.epochs,null,null,ooe(t,n),null,r,c);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let g={};await d.onEpochBegin(f);let y=0,v=0;for(a||(m=await t.iterator());!a||y<n.batchesPerEpoch;){let x=await m.next();if(a&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:w,ys:k}=PV(e,x.value),M={};M.batch=v,M.size=w[0].shape[0],await d.onBatchBegin(v,M);let S=[];if(n.classWeight!=null){let R=LV(n.classWeight,e.outputNames);for(let A=0;A<R.length;++A)S.push(await zV(k[A],null,R[A]))}let I=w.concat(k).concat(S),E=o(I);et(I);for(let R=0;R<l.length;++R){let A=l[R],_=E[R];M[A]=_,Jn(_)}await d.onBatchEnd(v,M),kV(M),v++,y++}if(a?y>=n.batchesPerEpoch:x.done){if(r){let w;tM(n.validationData)?w=Vt(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):w=Vt(e.evaluate(s,i,{batchSize:n.validationBatchSize==null?roe:n.validationBatchSize,verbose:0}));for(let k=0;k<e.metricsNames.length;++k)g[`val_${e.metricsNames[k]}`]=w[k]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,g),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function ooe(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function tM(e){return typeof e.iterator=="function"}function loe(e){return typeof e.next=="function"}async function uoe(e,t,n){n=n||{};let a=n.batches!=null,r=e.testFunction,s=[];if(n.verbose>0)throw new ft("Verbose mode is not implemented yet.");N.assert(!a||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=loe(t)?t:await t.iterator(),o=0,l=0;for(;!a||l<n.batches;){let c=await i.next();if(s=X(()=>{if(c.value){let{xs:u,ys:h}=PV(e,c.value),d=u.concat(h),p=X(()=>r(d));if(et(d),l===0)for(let m=0;m<p.length;++m)s.push(ze(0));let f=d[0].shape[0];for(let m=0;m<p.length;++m){let g=p[m],y=s[m];s[m]=X(()=>re(s[m],G(f,g))),l>0&&et(y)}et(p),o+=f,++l}return s}),c.done){a&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<s.length;++c){let u=s[c];s[c]=Ce(s[c],o),et(u)}return hr(s)}function RS(e){N.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function fg(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(a=>gc(a,t,n-t)):gc(e,t,n-t)}function wk(e,t){return X(()=>e==null?null:Array.isArray(e)?e.map(n=>wk(n,t)):gV(e,t.dtype==="int32"?t:ye(t,"int32")))}function DS(e,t){let n=[],a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function VV(e){let t=[];e instanceof at&&(e=[e]);for(let n=0;n<e.length;++n){let a=e[n];if(a.rank===1)t.push(Yb(a,1));else{if(a.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function Ws(e,t){if(e==null)return;let n=[];if(t instanceof at)n.push(t.id);else if(Array.isArray(t))t.forEach(r=>n.push(r.id));else if(t!=null)for(let r in t){let s=t[r];n.push(s.id)}let a=[];if(e instanceof at)n.indexOf(e.id)===-1&&a.push(e);else if(Array.isArray(e))e.forEach(r=>{n.indexOf(r.id)===-1&&a.push(r)});else if(e!=null)for(let r in e){let s=e[r];n.indexOf(s.id)===-1&&a.push(s)}a.forEach(r=>{r.isDisposed||r.dispose()})}function coe(e){return e instanceof at}function _k(e){return Array.isArray(e)}function nM(e){return!coe(e)&&!_k(e)}function aM(e,t,n,a=!0,r=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(_k(e)&&e.length>0)i=!0;else if(nM(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new Y(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(nM(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new Y(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(e[i])}}else if(_k(e)){if(e=e,e.length!==t.length)throw new Y(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new Y(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=VV(s),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new Y(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!a)continue;let c=o.shape[l],u=n[i][l];if(u!=null&&u>=0&&c!==u)throw new Y(`${r} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function hoe(e,t,n){let a=Al(e.map(s=>s.shape[0]));a.sort();let r=Al(t.map(s=>s.shape[0]));if(r.sort(),a.length>1)throw new Y(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(r.length>1)throw new Y(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(a.length>0&&r.length>0&&!N.arraysEqual(a,r))throw new Y(`Input Tensors should have the same number of samples as target Tensors. Found ${a[0]} input sample(s) and ${r[0]} target sample(s).`)}function doe(e,t,n){let a=[wd,K1,Ay];for(let r=0;r<e.length;++r){let s=e[r],i=t[r],o=n[r];if(i!=null){if(i===Ay&&s.shape[s.shape.length-1]===1)throw new Y(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(a.indexOf(i)!==-1){let l=s.shape.slice(1),c=o.slice(1);for(let u=0;u<l.length;++u){let h=l[u],d=c[u];if(d!=null&&h!==d)throw new Y(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function rM(e,t,n,a=!0,r=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new Y(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new Y(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new Y(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!a)continue;let c=o.shape[l],u=n[i][l];if(u!=null&&u!==c)throw new Y(`Error when checking ${r}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function poe(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(a=>n);{let a=[];for(let r of t){let s=n.hasOwnProperty(r)?n[r]:[];Array.isArray(s)||(s=[s]),a.push(s)}return a}}var foe="layers-model",vo=class extends toe{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new Y("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Xie(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Kie(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof zo))throw new Y("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let s in e.loss)if(this.outputNames.indexOf(s)===-1)throw new Y(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)e.loss[s]==null&&console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),t.push(AS(e.loss[s]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Y(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(s=>AS(s))}else{let s=AS(e.loss);this.outputs.forEach(i=>{t.push(s)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let i=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],mc("loss",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([i,s]),this.metricsNames.push(this.outputNames[s]+"_loss"))}});let a=poe(e.metrics,this.outputNames),r=(s,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[s]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,s])};mc("metric",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=a[s];(o=>{let l="",c,u,h;for(let d of o){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){let f=this.internalOutputShapes[s];f[f.length-1]===1||this.lossFunctions[s]===K1?["accuracy","acc"].indexOf(d)!==-1?u=xN:["crossentropy","ce"].indexOf(d)!==-1&&(u=$V):this.lossFunctions[s]===P0?["accuracy","acc"].indexOf(d)!==-1?u=MV:["crossentropy","ce"].indexOf(d)!==-1&&(u=OV):["accuracy","acc"].indexOf(d)!==-1?u=wN:["crossentropy","ce"].indexOf(d)!==-1&&(u=_N);let m;["accuracy","acc"].indexOf(d)!==-1?m="acc":["crossentropy","ce"].indexOf(d)!==-1&&(m="ce"),h=u,c=l+m}else h=qie(d),c=l+nx(d);let p;mc(c,()=>{p=h}),r(s,c,p)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let a=n.batchSize==null?32:n.batchSize;RS(a);let r=this.standardizeUserDataXY(e,t,!0,a);try{let s=r[0].concat(r[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,s,a,n.verbose,n.steps);return hr(o)}finally{Ws(r[0],e),Ws(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),uoe(this,e,t)}checkNumSamples(e,t,n,a="steps"){let r;if(n!=null){if(r=null,t!=null)throw new Y(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new Y(`Either the input data should have a defined shape, or ${a} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new Y("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),s=new gp;if(e instanceof at&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Y(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new Y(`No value is provided for the model's input ${o.name}`);s.add(o,l)}let i=kg(r,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Fc(null,e.length),n=e.length;for(let a of this.layers){let r=Array.isArray(a.output)?a.output:[a.output],s=r.map(i=>i.name);for(let i=0;i<e.length;++i){let o=s.indexOf(e[i]);if(o!==-1&&(t[i]=r[o],n--),n===0)break}if(n===0)break}if(n>0){let a=[];throw t.forEach((r,s)=>{r==null&&a.push(e[s])}),new Y(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(a)}`)}return t}predictLoop(e,t=32,n=!1){return X(()=>{let a=this.checkNumSamples(e);if(n)throw new ft("Verbose predictLoop() is not implemented yet.");let r=DS(a,t),s=this.outputs.map(i=>[]);for(let i=0;i<r.length;++i)X(()=>{let o=r[i][0],l=r[i][1],c=fg(e,o,l),u=[];if(Array.isArray(c))for(let d=0;d<c.length;++d)u.push({key:this.inputs[d],value:c[d]});else u.push({key:this.inputs[0],value:c});let h=new gp(u);return kg(this.outputs,h)}).forEach((o,l)=>s[l].push(o));return hr(s.map(i=>Qt(i,0)))})}predict(e,t={}){let n=VV(e);rM(n,this.inputNames,this.feedInputShapes,!1);try{let a=t.batchSize==null?32:t.batchSize;return RS(a),this.predictLoop(n,a)}finally{Ws(n,e)}}predictOnBatch(e){rM(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,a){if(this.optimizer_==null)throw new Ti("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let r=[];for(let s=0;s<this.feedOutputShapes.length;++s){let i=this.feedOutputShapes[s];this.feedLossFns[s]===P0?r.push(i.slice(0,i.length-1).concat([1])):r.push(i)}if(e=aM(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=aM(t,this.feedOutputNames,r,!1,"target"),hoe(e,t),doe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&a!=null&&a>0&&e[0].shape[0]%a!==0)throw new Y(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${a}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,a,r=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,r,s);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(a!=null){let c=LV(a,this.outputNames);l=[];for(let u=0;u<c.length;++u)l.push(await zV(o[u],null,c[u]))}return[i,o,l]}testLoop(e,t,n,a=0,r){return X(()=>{let s=this.checkNumSamples(t,n,r,"steps"),i=[];if(a>0)throw new ft("Verbose mode is not implemented yet.");if(r!=null)throw new ft("steps mode in testLoop() is not implemented yet");{let o=DS(s,n),l=Ft(Ys(0,s));for(let c=0;c<o.length;++c){let u=o[c][0],h=o[c][1],d=gc(l,u,h-u),p=wk(t,d),f=e(p);if(c===0)for(let m=0;m<f.length;++m)i.push(ze(0));for(let m=0;m<f.length;++m){let g=f[m];i[m]=re(i[m],G(h-u,g))}}for(let c=0;c<i.length;++c)i[c]=Ce(i[c],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let a=e[n],r=a;if(W$(e,a)>1){let s=W$(e.slice(0,n),a);r+=`_${s}`}t.push(r)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],i=()=>{let l=[];for(let d=0;d<this.inputs.length;++d)l.push({key:this.inputs[d],value:n[d]});let c=new gp(l),u=kg(this.outputs,c,{training:!0}),h;for(let d=0;d<this.lossFunctions.length;++d){let p=this.lossFunctions[d],f=p(a[d],u[d]);r[d]!=null&&(f=aoe(f,r[d]));let m=wn(f);t.push(m),d===0?h=f:h=re(h,f)}for(let d=0;d<this.metricsTensors.length;++d){let p;if(this.outputs.length>1&&d<this.outputs.length)p=t[d];else{let f=this.metricsTensors[d][0],m=this.metricsTensors[d][1];p=wn(f(a[m],u[m]))}Jn(p),s.push(p)}return h=wn(h),this.calculateLosses().forEach(d=>{h=re(h,d)}),h},o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>X(()=>{let t=[],n,a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let l=0;l<this.inputs.length;++l)s.push({key:this.inputs[l],value:a[l]});let i=new gp(s),o=kg(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let c=this.lossFunctions[l],u=wn(c(r[l],o[l]));l===0?n=u:n=re(n,u),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let c=this.metricsTensors[l][0],u=this.metricsTensors[l][1],h=wn(c(r[u],o[u]));t.push(h)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let a,r,s,i,o,l,c,u,h;try{let d=n.batchSize==null?32:n.batchSize;RS(d);let p=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,d);a=p[0],r=p[1],h=p[2];let f=!1,m;if(n.validationData!=null&&n.validationData.length>0){if(f=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new ft("validationData including sample weights is not supported yet."):new Y(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let M=await this.standardizeUserData(o,l,null,null,!0,d);c=M[0],u=M[1],m=c.concat(u)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){f=!0;let M=Math.floor(a[0].shape[0]*(1-n.validationSplit)),S=a[0].shape[0];c=fg(a,M,S),s=a,a=fg(a,0,M),u=fg(r,M,S),i=r,r=fg(r,0,M),m=c.concat(u)}else n.validationSteps!=null&&(f=!0);let g=a.concat(r).concat(h);this.checkTrainableWeightsConsistency();let y=this.makeTrainFunction(),v=this.getDedupedMetricsNames(),x,w;f?(this.makeTestFunction(),x=this.testFunction,w=v.slice().concat(v.map(M=>"val_"+M))):(x=null,m=[],w=v.slice());let k=CV(n.callbacks,n.yieldEvery);return await this.fitLoop(y,g,v,d,n.epochs,n.verbose,k,x,m,n.shuffle,w,n.initialEpoch,null,null)}finally{this.isTraining=!1,Ws(a,e),Ws(r,t),Ws(s,e),Ws(i,t),Ws(c,o),Ws(u,l),h!=null&&et(h)}}async fitLoop(e,t,n,a,r,s,i,o,l,c,u,h,d,p){a==null&&(a=32),r==null&&(r=1),c==null&&(c=!0),h==null&&(h=0);let f=!1;if(o!=null&&l!=null&&(f=!0),p!=null&&(f=!0,d==null))throw new Y("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m=this.checkNumSamples(t,a,d,"steps_per_epoch"),g;m!=null&&(g=Ys(0,m)),s==null&&(s=1);let{callbackList:y,history:v}=AV(i,s,r,h,m,d,a,f,u);y.setModel(this),this.history=v,await y.onTrainBegin(),this.stopTraining_=!1;for(let x=h;x<r;++x){await y.onEpochBegin(x);let w={};if(d!=null)throw new ft("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new ft("batch shuffling is not implemneted yet");c&&N.shuffle(g);let k=Ft(g),M=DS(m,a);for(let S=0;S<M.length;++S){let I={};if(await y.onBatchBegin(S,I),X(()=>{let E=M[S][0],R=M[S][1],A=gc(k,E,R-E);I.batch=S,I.size=R-E;let _=wk(t,A),D=e(_);for(let j=0;j<n.length;++j){let q=n[j],B=D[j];I[q]=B,Jn(B)}if(S===M.length-1&&f){let j=this.testLoop(o,l,a);for(let q=0;q<n.length;++q){let B=n[q],Q=j[q];Jn(Q),w["val_"+B]=Q}}}),await y.onBatchEnd(S,I),kV(I),this.stopTraining_)break}k.dispose()}if(await y.onEpochEnd(x,w),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return ioe(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),a=n[0],r=n[1],s=this.makeTrainFunction()(a.concat(r)),i=[];for(let o of s){let l=await o.data();i.push(l[0])}return et(s),Ws(n[0],e),Ws(n[1],t),hr(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let s=0;s<a.length;++s)n&&!a[s].trainable||t.push({name:a[s].originalName,tensor:r[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=ak().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-ak().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=io(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>io(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let a of t)if(typeof n[a]=="string")e[a]=io(n[a]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[io(nx(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>io(nx(e)));{let e={};for(let t in this.metrics)e[t]=io(nx(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=Ry(e.optimizer_config),n=Xs(t),a;if(typeof e.loss=="string")a=ac(e.loss);else if(Array.isArray(e.loss))a=e.loss.map(s=>ac(s));else if(e.loss!=null){a={};for(let s in e.loss)a[s]=ac(e.loss[s])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(s=>ac(s));else if(e.metrics!=null){r={};for(let s in e.metrics)r[s]=ac(e.metrics[s])}this.compile({loss:a,metrics:r,optimizer:n})}async save(e,t){if(typeof e=="string"){let r=Ca.getSaveHandlers(e);if(r.length===0)throw new Y(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Y(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Y("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Ca.encodeWeights(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:foe,generatedBy:`TensorFlow.js tfjs-layers v${SN}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let r="optimizer",{data:s,specs:i}=await Ca.encodeWeights(await this.optimizer.getWeights(),r);n.specs.push(...i),n.data=Ca.concatenateArrayBuffers([n.data,s])}return this.userDefinedMetadata!=null&&(J$(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){J$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};vo.className="Model";de.registerClass(vo);var BV=class extends vo{};BV.className="Functional";de.registerClass(BV);async function moe(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let a=Ry(n),r=Xs(a,t);if(e.weightsManifest!=null){let s=await Ca.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map(o=>o.originalName)),i={};for(let o of r.weights)i[o.originalName]=s[o.originalName];r.loadWeights(i),et(s)}return r}async function goe(e,t){if(t==null&&(t={}),typeof e=="string"){let n=Ca.getLoadHandlers(e,t);if(n.length===0)n.push(Ca.browserHTTPRequest(e,t));else if(n.length>1)throw new Y(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return yoe(e,void 0,t)}async function yoe(e,t,n){if(n==null&&(n={}),e.load==null)throw new Y("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let a=await e.load(),r=a.modelTopology;r.model_config!=null&&(r=r.model_config);let s=n.strict==null?!0:n.strict,i=a.weightData!=null&&a.weightSpecs!=null&&s,o=Xs(Ry(r),t,i),l=a.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),a.userDefinedMetadata!=null&&o.setUserDefinedMetadata(a.userDefinedMetadata),a.weightData!=null){if(a.weightSpecs==null)throw new Y("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:c,optimizerWeights:u}=boe(a.weightData,a.weightSpecs);o.loadWeights(c,s),o.optimizer!=null&&u.length>0&&await o.optimizer.setWeights(u),et(c),et(u.map(h=>h.tensor))}return o}function boe(e,t){let n=Ca.decodeWeights(e,t),a={},r=[];return t.forEach(s=>{s.group==="optimizer"?r.push({name:s.name,tensor:n[s.name]}):a[s.name]=n[s.name]}),{modelWeights:a,optimizerWeights:r}}var X1=class Sk extends vo{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:L1("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new Y(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof Sk||t instanceof vo,a;if(n){if(a=t,a.outputs.length!==1)throw new Y("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(a.inputs.length!==1)throw new Y("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new Y("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let r=xV({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(n)this.outputs=a.outputs,this.inputs=a.inputs;else{if(t.inboundNodes.length!==1)throw new Y(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new Y("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=vV(this.outputs[0])}this.inboundNodes=[],new H1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Fc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if($t(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new vo({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,a=console.log){this.built||this.build(),super.summary(t,n,a)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,a={}){if(!this.built)throw new Ti("The model needs to be compiled before being used.");return this.model.evaluate(t,n,a)}async evaluateDataset(t,n){if(!this.built)throw new Ti("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,a={}){if(!this.built)throw new Ti("The model needs to be compiled before being used.");return this.model.fit(t,n,a)}async fitDataset(t,n){if(!this.built)throw new Ti("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,a={},r=!1){let s,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new Y("Legacy serialization format not supported yet.");s=n}else N.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof Sk))throw new ft(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let l of s){let c=Xs(l,void 0,r);r&&c.setFastWeightInitDuringBuild(!0),o.add(c)}return o}set stopTraining(t){if(this.model==null)throw new Y("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new Y("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let a={};a.className=n.getClassName(),a.config=n.getConfig(),t.push(a)}return{name:this.name,layers:t}}};X1.className="Sequential";de.registerClass(X1);function voe(e){return new vo(e)}function xoe(e){return new X1(e)}function UV(e){return xV(e)}function woe(e,t){bN.registerCallbackConstructor(e,t)}var Wa=class extends de.Serializable{getConfig(){return{}}},WV=class extends Wa{apply(e,t=1){return Vse(e,t)}};WV.className="elu";de.registerClass(WV);var jV=class extends Wa{apply(e){return x1(e)}};jV.className="selu";de.registerClass(jV);var GV=class extends Wa{apply(e){return Bt(e)}};GV.className="relu";de.registerClass(GV);var HV=class extends Wa{apply(e){return X(()=>Hl(6,Bt(e)))}};HV.className="relu6";de.registerClass(HV);var qV=class extends Wa{apply(e){return e}};qV.className="linear";de.registerClass(qV);var KV=class extends Wa{apply(e){return Rs(e)}};KV.className="sigmoid";de.registerClass(KV);var XV=class extends Wa{apply(e){return Use(e)}};XV.className="hardSigmoid";de.registerClass(XV);var QV=class extends Wa{apply(e){return bd(e)}};QV.className="softplus";de.registerClass(QV);var YV=class extends Wa{apply(e){return Bse(e)}};YV.className="softsign";de.registerClass(YV);var ZV=class extends Wa{apply(e){return Gl(e)}};ZV.className="tanh";de.registerClass(ZV);var IN=class extends Wa{apply(e,t=-1){return bu(e,t)}};IN.className="softmax";de.registerClass(IN);var JV=class extends Wa{apply(e,t=-1){return p1(e,t)}};JV.className="logSoftmax";de.registerClass(JV);var eB=class extends Wa{apply(e){return X(()=>X(()=>{let t=Math.sqrt(2),n=G(.5,re(1,c1(Ce(e,t))));return G(e,n)}))}};eB.className="gelu";de.registerClass(eB);var tB=class extends Wa{apply(e){return X(()=>G(.5,G(e,re(1,Gl(G(va(Ce(2,Math.PI)),re(e,G(.044715,Li(e,3)))))))))}};tB.className="gelu_new";de.registerClass(tB);var nB=class extends Wa{apply(e){return X(()=>G(e,Gl(bd(e))))}};nB.className="mish";de.registerClass(nB);var aB=class extends Wa{apply(e,t=1){return X(()=>G(Rs(G(e,t)),e))}};aB.className="swish";de.registerClass(aB);function Xl(e){return e.getClassName()}function $S(e,t={}){return Qb(e,de.SerializationMap.getMap().classNameMap,t,"activation")}function Ql(e){if(e==null){let t={};return t.className="linear",t.config={},$S(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},$S(t)}else return e instanceof Wa?e:$S(e)}function kN(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var rB=class extends de.Serializable{},tv=class extends rB{constructor(e){super(),kN(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return X(()=>{let t=_n([1]);return this.hasL1&&(t=re(t,De(G(this.l1,On(e))))),this.hasL2&&(t=re(t,De(G(this.l2,Zb(e))))),K(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};tv.className="L1L2";de.registerClass(tv);function _oe(e){return kN(e),new tv({l1:e!=null?e.l1:null,l2:0})}function Soe(e){return kN(e),new tv({l2:e!=null?e.l2:null,l1:0})}var sM={l1l2:"L1L2"};function nn(e){return nN(e)}function iM(e,t={}){return Qb(e,de.SerializationMap.getMap().classNameMap,t,"regularizer")}function yn(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in sM?sM[e]:e,config:{}};return iM(t)}else return e instanceof rB?e:iM(e)}var TN=class extends mt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=He(e);let n=Bt(e);return this.maxValue!=null&&(n=Va(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};TN.className="ReLU";de.registerClass(TN);var EN=class extends mt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=He(e);return Pb(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};EN.className="LeakyReLU";de.registerClass(EN);var NN=class extends mt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=gn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=yn(e.alphaRegularizer),this.alphaConstraint=sa(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new Y(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=$t(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new zn({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=He(e),Gb(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Sn(this.alphaInitializer),alphaRegularizer:nn(this.alphaRegularizer),alphaConstraint:ra(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};NN.className="PReLU";de.registerClass(NN);var CN=class extends mt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new ft(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=He(e);return Tm(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};CN.className="ELU";de.registerClass(CN);var AN=class extends mt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=He(e);return G(n,ye(sr(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};AN.className="ThresholdedReLU";de.registerClass(AN);var RN=class extends mt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new IN().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return X(()=>{let n=He(e),a=t.mask;if(a!=null){let r=G(Ie(pr(n.shape),ye(a,n.dtype)),ze(-1e9));n=re(n,r)}return this.axis instanceof Array?this.axis.length>1?Ba(Ie(n,Bb(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};RN.className="Softmax";de.registerClass(RN);function Ep(e,t,n){if(typeof e=="number")return Fc(e,t);if(e.length!==t)throw new Y(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let a=0;a<t;++a){let r=e[a];if(!Fse(r))throw new Y(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${r}`)}return e}function Qs(e,t,n,a,r=1){if(e==null)return e;let s=t+(t-1)*(r-1),i;return n==="same"?i=e:i=e-s+1,Math.floor((i+a-1)/a)}function _i(e,t,n,a){if(e==null)return null;if(a==="valid")e=e*t+Kl([n-t,0]);else if(a==="same")e=e*t;else throw new Y(`Unsupport padding mode: ${a}.`);return e}function DN(e,t){return X(()=>($n(t),t==="channelsFirst"?lt(e,[0,2,3,1]):e))}function sB(e,t){return X(()=>($n(t),t==="channelsFirst"?lt(e,[0,2,3,4,1]):e))}function Ioe(e,t,n,a=1,r="valid",s,i=1){return X(()=>{if(s==null&&(s=Zs()),$n(s),e.shape.length!==3)throw new Y(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new Y(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new Y(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(s==="channelsFirst"&&(e=lt(e,[0,2,1])),r==="causal")throw new ft("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=i1(e,t,a,r==="same"?"same":"valid","NWC",i);return n!=null&&(o=si(o,n)),o})}function oM(e,t,n,a=[1,1],r="valid",s,i,o=null){return X(()=>{if(s==null&&(s=Zs()),$n(s),e.rank!==3&&e.rank!==4)throw new Y(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new Y(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=DN(e,s);if(r==="causal")throw new ft("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Jp.conv2d({x:l,filter:t,strides:a,pad:r==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),s==="channelsFirst"&&(l=lt(l,[0,3,1,2])),l})}function koe(e,t,n,a=[1,1,1],r="valid",s,i){return X(()=>{if(s==null&&(s=Zs()),$n(s),e.rank!==4&&e.rank!==5)throw new Y(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new Y(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=sB(e,s);if(r==="causal")throw new ft("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=iE(o,t,a,r==="same"?"same":"valid","NDHWC",i),n!=null&&(o=si(o,n)),s==="channelsFirst"&&(o=lt(o,[0,4,1,2,3])),o})}var iB=class oB extends mt{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",oB.verifyArgs(n),this.rank=t,ma(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new ft(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ep(n.kernelSize,t,"kernelSize"),this.strides=Ep(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,ds(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,$n(this.dataFormat),this.activation=Ql(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=gn(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=sa(n.biasConstraint),this.biasRegularizer=yn(n.biasRegularizer),this.activityRegularizer=yn(n.activityRegularizer),this.dilationRate=Ep(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Y(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Y(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Y(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(wi("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!aN(t.kernelSize,"number",1,3))throw new Y(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Xl(this.activation),useBias:this.useBias,biasInitializer:Sn(this.biasInitializer),biasRegularizer:nn(this.biasRegularizer),activityRegularizer:nn(this.activityRegularizer),biasConstraint:ra(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},Q1=class lB extends iB{constructor(t,n){super(t,n),this.kernel=null,lB.verifyArgs(n),this.filters=n.filters,ma(this.filters,"filters"),this.kernelInitializer=gn(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=sa(n.kernelConstraint),this.kernelRegularizer=yn(n.kernelRegularizer)}build(t){t=$t(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new Y(`The channel dimension of the input should be defined. Found ${t[n]}`);let a=t[n],r=this.kernelSize.concat([a,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:a}}],this.built=!0}call(t,n){return X(()=>{t=He(t);let a,r=this.bias==null?null:this.bias.read(),s=cV(this.activation.getClassName());if(s!=null&&this.rank===2)a=oM(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)a=Ioe(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)a=oM(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)a=koe(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new ft("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(a=this.activation.apply(a))}return a})}computeOutputShape(t){t=$t(t);let n=[],a=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<a.length;++s){let i=Qs(a[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);n.push(i)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){let t={filters:this.filters,kernelInitializer:Sn(this.kernelInitializer),kernelRegularizer:nn(this.kernelRegularizer),kernelConstraint:ra(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new Y(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},Y1=class uB extends Q1{constructor(t){super(2,t),uB.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!aN(t.kernelSize,"number",1,2))throw new Y(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};Y1.className="Conv2D";de.registerClass(Y1);var Z1=class cB extends Q1{constructor(t){super(3,t),cB.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new Y(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};Z1.className="Conv3D";de.registerClass(Z1);var $N=class extends Y1{constructor(e){if(super(e),this.inputSpec=[new zn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Y(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=$t(e),e.length!==4)throw new Y("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Y("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new zn({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return X(()=>{let n=He(e);if(n.shape.length!==4)throw new Y(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],s,i;this.dataFormat==="channelsFirst"?(s=2,i=3):(s=1,i=2);let o=a[s],l=a[i],c=this.kernelSize[0],u=this.kernelSize[1],h=this.strides[0],d=this.strides[1],p=_i(o,h,c,this.padding),f=_i(l,d,u,this.padding),m=[r,p,f,this.filters];this.dataFormat!=="channelsLast"&&(n=lt(n,[0,2,3,1]));let g=o1(n,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=lt(g,[0,3,1,2])),this.bias!=null&&(g=si(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=$t(e);let t=e.slice(),n,a,r;this.dataFormat==="channelsFirst"?(n=1,a=2,r=3):(n=3,a=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[a]=_i(t[a],o,s,this.padding),t[r]=_i(t[r],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};$N.className="Conv2DTranspose";de.registerClass($N);var MN=class extends Z1{constructor(e){if(super(e),this.inputSpec=[new zn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Y(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=$t(e),e.length!==5)throw new Y("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Y("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new zn({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return X(()=>{let n=He(e);if(n.shape.length!==5)throw new Y(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],s,i,o;this.dataFormat==="channelsFirst"?(o=2,s=3,i=4):(o=1,s=2,i=3);let l=a[o],c=a[s],u=a[i],h=this.kernelSize[0],d=this.kernelSize[1],p=this.kernelSize[2],f=this.strides[0],m=this.strides[1],g=this.strides[2],y=_i(l,f,h,this.padding),v=_i(c,m,d,this.padding),x=_i(u,g,p,this.padding),w=[r,y,v,x,this.filters];this.dataFormat!=="channelsLast"&&(n=lt(n,[0,2,3,4,1]));let k=oE(n,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(k=lt(k,[0,4,1,2,3])),this.bias!==null&&(k=si(k,this.bias.read(),this.dataFormat)),this.activation!==null&&(k=this.activation.apply(k)),k})}computeOutputShape(e){e=$t(e);let t=e.slice(),n,a,r,s;this.dataFormat==="channelsFirst"?(n=1,a=2,r=3,s=4):(n=4,a=1,r=2,s=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[a]=_i(t[a],c,i,this.padding),t[r]=_i(t[r],u,o,this.padding),t[s]=_i(t[s],h,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};MN.className="Conv3DTranspose";de.registerClass(MN);var hB=class extends Q1{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new Y("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new Y("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new Y(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=gn(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=yn(t.depthwiseRegularizer),this.depthwiseConstraint=sa(t.depthwiseConstraint),this.pointwiseInitializer=gn(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=yn(t.pointwiseRegularizer),this.pointwiseConstraint=sa(t.pointwiseConstraint)}build(e){if(e=$t(e),e.length<this.rank+2)throw new Y(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new Y(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let i=0;i<this.rank;++i)r.push(1);r.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new zn({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return X(()=>{e=He(e);let n;if(this.rank===1)throw new ft("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=lt(e,[0,2,3,1])),n=Am(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=si(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=lt(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Sn(this.depthwiseInitializer),e.pointwiseInitializer=Sn(this.pointwiseInitializer),e.depthwiseRegularizer=nn(this.depthwiseRegularizer),e.pointwiseRegularizer=nn(this.pointwiseRegularizer),e.depthwiseConstraint=ra(this.depthwiseConstraint),e.pointwiseConstraint=ra(this.pointwiseConstraint),e}};hB.className="SeparableConv";var ON=class extends hB{constructor(e){super(2,e)}};ON.className="SeparableConv2D";de.registerClass(ON);var FN=class dB extends Q1{constructor(t){super(1,t),dB.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!aN(t.kernelSize,"number",1,1))throw new Y(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};FN.className="Conv1D";de.registerClass(FN);var LN=class extends mt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return X(()=>{if(e=He(e),this.dataFormat==="channelsLast"){let n=tx(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return tx(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=tx(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return tx(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};LN.className="Cropping2D";de.registerClass(LN);var zN=class extends mt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,$n(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,$se(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return X(()=>{let n=He(e),a=n.shape;if(this.dataFormat==="channelsFirst"){n=lt(n,[0,2,3,1]);let r=this.size[0]*a[2],s=this.size[1]*a[3],i=this.interpolation==="nearest"?Yr.resizeNearestNeighbor(n,[r,s]):Yr.resizeBilinear(n,[r,s]);return lt(i,[0,3,1,2])}else{let r=this.size[0]*a[1],s=this.size[1]*a[2];return this.interpolation==="nearest"?Yr.resizeNearestNeighbor(n,[r,s]):Yr.resizeBilinear(n,[r,s])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};zN.className="UpSampling2D";de.registerClass(zN);function Toe(e,t,n=[1,1],a="valid",r,s){return X(()=>{r==null&&(r=Zs()),$n(r);let i=DN(e,r);if(e.rank!==4)throw new Y(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new Y(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=yd(i,t,n,a==="same"?"same":"valid","NHWC",s),r==="channelsFirst"&&(i=lt(i,[0,3,1,2])),i})}var PN=class extends iB{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=gn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=sa(e.depthwiseConstraint),this.depthwiseRegularizer=yn(e.depthwiseRegularizer)}build(e){if(e=$t(e),e.length<4)throw new Y(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new Y(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return X(()=>{e=He(e);let n=Toe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=si(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=$t(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],a=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=Qs(t,this.kernelSize[0],this.padding,this.strides[0]),s=Qs(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],a,r,s]:[e[0],r,s,a]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Sn(this.depthwiseInitializer),e.depthwiseRegularizer=nn(this.depthwiseRegularizer),e.depthwiseConstraint=ra(this.depthwiseRegularizer),e}};PN.className="DepthwiseConv2D";de.registerClass(PN);function pB(e,t,n,a){if(Array.isArray(e)){if(t!=null||n!=null)throw new Y("When inputs is an array, neither initialState or constants should be provided");a!=null&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(s){return s==null||Array.isArray(s)?s:[s]}return t=r(t),n=r(n),{inputs:e,initialState:t,constants:n}}function fB(e,t,n,a=!1,r,s,i=!1,o=!1){return X(()=>{let l=t.shape.length;if(l<3)throw new Y(`Input should be at least 3D, but is ${l}D.`);let c=[1,0].concat(Ys(2,l));t=lt(t,c),s!=null,i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=ye(ye(r,"bool"),"float32"),r.rank===l-1&&(r=pa(r,-1)),r=lt(r,c)),a&&(t=hs(t,0),r!=null&&(r=hs(r,0)));let u=[],h,d=n,p=t.shape[0],f=Tn(t),m;r!=null&&(m=Tn(r));for(let y=0;y<p;++y){let v=f[y],x=X(()=>e(v,d));if(r==null)h=x[0],d=x[1];else{let w=X(()=>{let k=m[y],M=Ie(Pr(k),k),S=re(G(x[0],k),G(d[0],M)),I=d.map((E,R)=>re(G(x[1][R],k),G(E,M)));return{output:S,newStates:I}});h=w.output,d=w.newStates}o&&u.push(h)}let g;return o&&(g=Bn(u,1)),[h,g,d]})}var Po=class mB extends mt{constructor(t){super(t);let n;if(t.cell==null)throw new Y("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new t_({cells:t.cell}):n=t.cell,n.stateSize==null)throw new Y("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new zn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Ys(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){yk(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let a=n[0],r;if(this.returnSequences?r=[t[0],t[1],a]:r=[t[0],a],this.returnState){let s=[];for(let i of n)s.push([t[0],i]);return[r].concat(s)}else return r}computeMask(t,n){return X(()=>{Array.isArray(n)&&(n=n[0]);let a=this.returnSequences?n:null;if(this.returnState){let r=this.states.map(s=>null);return[a].concat(r)}else return a})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let a=0;a<t;++a)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new ft("Constants support is not implemented in RNN yet.");yk(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,a=t.slice(2);this.inputSpec[0]=new zn({shape:[n,null,...a]});let r=[t[0]].concat(t.slice(2));this.cell.build(r);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!N.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),s))throw new Y(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(i=>new zn({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){X(()=>{if(!this.stateful)throw new al("Cannot call resetStates() on an RNN Layer that is not stateful.");let a=this.inputSpec[0].shape[0];if(a==null)throw new Y("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>_n([a,r])):this.states_=[_n([a,this.cell.stateSize])];else if(t==null)et(this.states_),this.keptStates!=null&&(et(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>_n([a,r])):this.states_[0]=_n([a,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new Y(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):et(this.states_);for(let r=0;r<this.states_.length;++r){let s=t[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[a,i];if(!N.arraysEqual(s.shape,o))throw new Y(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>Jn(r.clone()))})}apply(t,n){let a=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});let s=pB(t,a,r,this.numConstants);t=s.inputs,a=s.initialState,r=s.constants;let i=[],o=[];if(a!=null){n.initialState=a,i=i.concat(a),this.stateSpec=[];for(let l of a)this.stateSpec.push(new zn({shape:l.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(n.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof Js){let l=[t].concat(i),c=this.inputSpec.concat(o),u=this.inputSpec;this.inputSpec=c;let h=super.apply(l,n);return this.inputSpec=u,h}else return super.apply(t,n)}call(t,n){return X(()=>{let a=n==null?null:n.mask,r=n==null?null:n.training,s=n==null?null:n.initialState;t=He(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new Y(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:r},l=fB((p,f)=>{let m=this.cell.call([p].concat(f),o);return[m[0],m.slice(1)]},t,s,this.goBackwards,a,null,this.unroll,this.returnSequences),c=l[0],u=l[1],h=l[2];this.stateful&&this.resetStates(h,r);let d=this.returnSequences?u:c;return this.returnState?[d].concat(h):d})}getInitialState(t){return X(()=>{let n=_n(t.shape);return n=De(n,[1,2]),n=Yb(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(a=>a>1?mk(n,[1,a]):n):this.cell.stateSize>1?[mk(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let a=this.cell.getConfig();return this.getClassName()===mB.className&&(n.cell={className:this.cell.getClassName(),config:a}),Object.assign(Object.assign(Object.assign({},a),t),n)}static fromConfig(t,n,a={}){let r=n.cell,s=Xs(r,a);return new t(Object.assign(n,{cell:s}))}};Po.className="RNN";de.registerClass(Po);var nv=class extends mt{},J1=class extends nv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ma(this.units,"units"),this.activation=Ql(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=yn(e.kernelRegularizer),this.recurrentRegularizer=yn(e.recurrentRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.kernelConstraint=sa(e.kernelConstraint),this.recurrentConstraint=sa(e.recurrentConstraint),this.biasConstraint=sa(e.biasConstraint),this.dropout=ef([1,Kl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ef([1,Kl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=$t(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return X(()=>{if(e=e,e.length!==2)throw new Y(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let a=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Yl({ones:()=>Pr(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Yl({ones:()=>Pr(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));let r,s=this.dropoutMask,i=this.recurrentDropoutMask;s!=null?r=Ri(G(e,s),this.kernel.read()):r=Ri(e,this.kernel.read()),this.bias!=null&&(r=si(r,this.bias.read())),i!=null&&(n=G(n,i));let o=re(r,Ri(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Xl(this.activation),useBias:this.useBias,kernelInitializer:Sn(this.kernelInitializer),recurrentInitializer:Sn(this.recurrentInitializer),biasInitializer:Sn(this.biasInitializer),kernelRegularizer:nn(this.kernelRegularizer),recurrentRegularizer:nn(this.recurrentRegularizer),biasRegularizer:nn(this.biasRegularizer),activityRegularizer:nn(this.activityRegularizer),kernelConstraint:ra(this.kernelConstraint),recurrentConstraint:ra(this.recurrentConstraint),biasConstraint:ra(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};J1.className="SimpleRNNCell";de.registerClass(J1);var VN=class extends Po{constructor(e){e.cell=new J1(e),super(e)}call(e,t){return X(()=>{this.cell.dropoutMask!=null&&(et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return new e(t)}};VN.className="SimpleRNN";de.registerClass(VN);var e_=class extends nv{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Y("GRUCell does not support reset_after parameter set to true.");this.units=e.units,ma(this.units,"units"),this.activation=Ql(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ql(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=yn(e.kernelRegularizer),this.recurrentRegularizer=yn(e.recurrentRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.kernelConstraint=sa(e.kernelConstraint),this.recurrentConstraint=sa(e.recurrentConstraint),this.biasConstraint=sa(e.biasConstraint),this.dropout=ef([1,Kl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ef([1,Kl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=$t(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return X(()=>{if(e=e,e.length!==2)throw new Y(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Yl({ones:()=>Pr(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Yl({ones:()=>Pr(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let r=this.dropoutMask,s=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=G(e,r[0]));let c=Ri(e,this.kernel.read());this.useBias&&(c=si(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=G(a,s[0]));let u=this.recurrentKernel.read(),[h,d]=fr(u,[2*this.units,this.units],u.rank-1),p=Ri(a,h),[f,m,g]=fr(c,3,c.rank-1),[y,v]=fr(p,2,p.rank-1);i=this.recurrentActivation.apply(re(f,y)),o=this.recurrentActivation.apply(re(m,v));let x=Ri(G(o,a),d);l=this.activation.apply(re(g,x));let w=re(G(i,a),G(re(1,on(i)),l));return[w,w]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Xl(this.activation),recurrentActivation:Xl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Sn(this.kernelInitializer),recurrentInitializer:Sn(this.recurrentInitializer),biasInitializer:Sn(this.biasInitializer),kernelRegularizer:nn(this.kernelRegularizer),recurrentRegularizer:nn(this.recurrentRegularizer),biasRegularizer:nn(this.biasRegularizer),activityRegularizer:nn(this.activityRegularizer),kernelConstraint:ra(this.kernelConstraint),recurrentConstraint:ra(this.recurrentConstraint),biasConstraint:ra(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};e_.className="GRUCell";de.registerClass(e_);var BN=class extends Po{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new e_(e),super(e)}call(e,t){return X(()=>{this.cell.dropoutMask!=null&&(et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};BN.className="GRU";de.registerClass(BN);var av=class extends nv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,ma(this.units,"units"),this.activation=Ql(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ql(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=yn(e.kernelRegularizer),this.recurrentRegularizer=yn(e.recurrentRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.kernelConstraint=sa(e.kernelConstraint),this.recurrentConstraint=sa(e.recurrentConstraint),this.biasConstraint=sa(e.biasConstraint),this.dropout=ef([1,Kl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ef([1,Kl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=$t(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let a;if(this.useBias){if(this.unitForgetBias){let r=this.biasInitializer,s=this.units;a=new(t=class extends Fs{apply(i,o){let l=r.apply([s]),c=new P1().apply([s]),u=r.apply([s*2]);return G$(G$(l,c),u)}},t.className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return X(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new Y(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let a=e[1],r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Yl({ones:()=>Pr(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Yl({ones:()=>Pr(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,o,l,c,u;0<this.dropout&&this.dropout<1&&(e=G(e,s[0]));let h=Ri(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=G(a,i[0])),h=re(h,Ri(a,this.recurrentKernel.read())),this.useBias&&(h=si(h,this.bias.read()));let[d,p,f,m]=fr(h,4,h.rank-1);o=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),c=re(G(l,r),G(o,this.activation.apply(f))),u=this.recurrentActivation.apply(m);let g=G(u,this.activation.apply(c));return[g,g,c]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Xl(this.activation),recurrentActivation:Xl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Sn(this.kernelInitializer),recurrentInitializer:Sn(this.recurrentInitializer),biasInitializer:Sn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:nn(this.kernelRegularizer),recurrentRegularizer:nn(this.recurrentRegularizer),biasRegularizer:nn(this.biasRegularizer),activityRegularizer:nn(this.activityRegularizer),kernelConstraint:ra(this.kernelConstraint),recurrentConstraint:ra(this.recurrentConstraint),biasConstraint:ra(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};av.className="LSTMCell";de.registerClass(av);var UN=class extends Po{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new av(e),super(e)}call(e,t){return X(()=>{this.cell.dropoutMask!=null&&(et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};UN.className="LSTM";de.registerClass(UN);var t_=class extends nv{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return X(()=>{e=e;let n=e.slice(1),a=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?a.push(n.splice(0,i.stateSize.length)):a.push(n.splice(0,1));a.reverse();let r=[],s;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=a[i],i===0?s=[e[0]].concat(n):s=[s[0]].concat(n),s=o.call(s,t),r.push(s.slice(1))}n=[];for(let i of r.slice().reverse())n.push(...i);return[s[0]].concat(n)})}build(e){yk(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,a)=>{mc(`RNNCell_${a}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=a=>({className:a.getClassName(),config:a.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let a=[];for(let r of t.cells)a.push(Xs(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return bk(e)}setWeights(e){let t=[];for(let n of this.cells){let a=n.weights.length,r=e.splice(a);for(let s=0;s<n.weights.length;++s)t.push([n.weights[s],r[s]])}dN(t)}};t_.className="StackedRNNCells";de.registerClass(t_);function Yl(e){let{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),n):yV(t(),n),o=()=>Jb(i,t,a);return!r||r<=1?Jn(o().clone()):Array(r).fill(void 0).map(o).map(l=>Jn(l.clone()))}var Eoe=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]]);return n},gB=class extends Po{constructor(e){if(e.unroll)throw new ft("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new ft("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new zn({ndim:5})]}call(e,t){return X(()=>{if(this.cell.dropoutMask!=null&&(et(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(et(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Y("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return X(()=>{let{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)],s=_n(r);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){X(()=>{if(!this.stateful)throw new al("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(n[0]==null)throw new Y("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>_n(r)):this.states_=[_n(r)];else if(e==null)et(this.states_),this.keptStates!=null&&(et(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>_n(r)):this.states_[0]=_n(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Y(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):et(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],o=r;if(!N.arraysEqual(i.shape,o))throw new Y(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Jn(s.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:s,dilationRate:i}=this.cell,o=t==="channelsFirst",l=e[o?3:2],c=e[o?4:3],u=Qs(l,a[0],r,s[0],i[0]),h=Qs(c,a[1],r,s[1],i[1]);return[...e.slice(0,2),...o?[n,u,h]:[u,h,n]]}};gB.className="ConvRNN2D";var n_=class extends av{constructor(e){let{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,ma(this.filters,"filters"),this.kernelSize=Ep(n,2,"kernelSize"),this.kernelSize.forEach(o=>ma(o,"kernelSize")),this.strides=Ep(a||1,2,"strides"),this.strides.forEach(o=>ma(o,"strides")),this.padding=r||"valid",ds(this.padding),this.dataFormat=s||"channelsLast",$n(this.dataFormat),this.dilationRate=Ep(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>ma(o,"dilationRate"))}build(e){var t;e=$t(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new Y(`The channel dimension of the input should be defined. Found ${e[n]}`);let a=e[n],r=4,s=this.kernelSize.concat([a,this.filters*r]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,c=this.filters;o=new(t=class extends Fs{apply(u,h){let d=l.apply([c]),p=pr([c]),f=l.apply([c*2]);return rN([d,p,f])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return X(()=>{if(e.length!==3)throw new Y(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,a=e[0],r=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Yl({ones:()=>Pr(a),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(J,ae,ne)=>!ae||!ae[ne]?J:G(ae[ne],J),c=l(a,o,0),u=l(a,o,1),h=l(a,o,2),d=l(a,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Yl({ones:()=>Pr(r),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let p=this.recurrentDropoutMask,f=l(r,p,0),m=l(r,p,1),g=l(r,p,2),y=l(r,p,3),v=3,[x,w,k,M]=fr(this.kernel.read(),i,v),[S,I,E,R]=this.useBias?fr(this.bias.read(),i):[null,null,null,null];c=this.inputConv(c,x,S,this.padding),u=this.inputConv(u,w,I,this.padding),h=this.inputConv(h,k,E,this.padding),d=this.inputConv(d,M,R,this.padding);let[A,_,D,j]=fr(this.recurrentKernel.read(),i,v);f=this.recurrentConv(f,A),m=this.recurrentConv(m,_),g=this.recurrentConv(g,D),y=this.recurrentConv(y,j);let q=this.recurrentActivation.apply(re(c,f)),B=this.recurrentActivation.apply(re(u,m)),Q=re(G(B,s),G(q,this.activation.apply(re(h,g)))),H=G(this.recurrentActivation.apply(re(d,y)),this.activation.apply(Q));return[H,H,Q]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=Eoe(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){let r=Ja(e,t,this.strides,a||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?si(r,n,this.dataFormat):r}recurrentConv(e,t){return Ja(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};n_.className="ConvLSTM2DCell";de.registerClass(n_);var WN=class extends gB{constructor(e){let t=new n_(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};WN.className="ConvLSTM2D";de.registerClass(WN);var a_=class extends mt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(this.noiseShape[a]==null?t[a]:this.noiseShape[a]);return n}call(e,t){return X(()=>{this.invokeCallHook(e,t);let n=He(e);if(0<this.rate&&this.rate<1){let a=t.training==null?!1:t.training,r=this.getNoiseShape(n);return Jb(()=>yV(n,this.rate,r,this.seed),()=>n,a)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};a_.className="Dropout";de.registerClass(a_);var jN=class extends a_{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};jN.className="SpatialDropout1D";de.registerClass(jN);var GN=class extends mt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,ma(this.units,"units"),this.activation=Ql(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=gn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=gn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=sa(e.kernelConstraint),this.biasConstraint=sa(e.biasConstraint),this.kernelRegularizer=yn(e.kernelRegularizer),this.biasRegularizer=yn(e.biasRegularizer),this.activityRegularizer=yn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=$t(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=$t(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return X(()=>{this.invokeCallHook(e,t);let n=He(e),a=cV(this.activation.getClassName()),r;return a!=null?r=Ri(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=Ri(n,this.kernel.read()),this.bias!=null&&(r=si(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){let e={units:this.units,activation:Xl(this.activation),useBias:this.useBias,kernelInitializer:Sn(this.kernelInitializer),biasInitializer:Sn(this.biasInitializer),kernelRegularizer:nn(this.kernelRegularizer),biasRegularizer:nn(this.biasRegularizer),activityRegularizer:nn(this.activityRegularizer),kernelConstraint:ra(this.kernelConstraint),biasConstraint:ra(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};GN.className="Dense";de.registerClass(GN);var HN=class extends mt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=$t(e);for(let t of e.slice(1))if(t==null)throw new Y(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Rl(e,1)]}call(e,t){return X(()=>{this.invokeCallHook(e,t);let n=He(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let a=[0];for(let r=2;r<n.rank;++r)a.push(r);a.push(1),n=lt(n,a)}return Pse(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};HN.className="Flatten";de.registerClass(HN);var qN=class extends mt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Ql(e.activation)}call(e,t){return X(()=>{this.invokeCallHook(e,t);let n=He(e);return this.activation.apply(n)})}getConfig(){let e={activation:Xl(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};qN.className="Activation";de.registerClass(qN);var KN=class extends mt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return X(()=>(e=He(e),Lse(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};KN.className="RepeatVector";de.registerClass(KN);var XN=class extends mt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",a=t.slice(),r=1,s=null;for(let o=0;o<a.length;++o){let l=a[o];if(this.isUnknown(l))if(s===null)s=o;else throw new Y("Can only specifiy one unknown dimension.");else r*=l}let i=Rl(e);if(s!==null){if(r===0||i%r!==0)throw new Y(n);a[s]=i/r}else if(i!==r)throw new Y(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return X(()=>{this.invokeCallHook(e,t);let n=He(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return K(n,r)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};XN.className="Reshape";de.registerClass(XN);var QN=class extends mt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Ys(1,e.dims.length+1);if(!N.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new zn({ndim:this.dims.length+1})]}computeOutputShape(e){e=$t(e);let t=e.slice();return this.dims.forEach((n,a)=>{t[a+1]=e[n]}),t}call(e,t){return lt(He(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};QN.className="Permute";de.registerClass(QN);var YN=class extends mt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=He(e);return Ty(Mc(n,this.maskValue),-1)}call(e,t){return X(()=>{this.invokeCallHook(e,t);let n=He(e),a=Ty(Mc(n,this.maskValue),-1,!0);return G(n,ye(a,n.dtype))})}};YN.className="Masking";de.registerClass(YN);var ZN=class extends mt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Vt(e.inputLength))}this.inputDim=e.inputDim,ma(this.inputDim,"inputDim"),this.outputDim=e.outputDim,ma(this.outputDim,"outputDim"),this.embeddingsInitializer=gn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=yn(e.embeddingsRegularizer),this.activityRegularizer=yn(e.activityRegularizer),this.embeddingsConstraint=sa(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return X(()=>this.maskZero?(e=He(e),Mc(e,_t(e))):null)}computeOutputShape(e){if(e=$t(e),this.inputLength==null)return[...e,this.outputDim];let t=Vt(this.inputLength);if(t.length!==e.length-1)throw new Y(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let a=0;a<t.length;++a){let r=t[a],s=e[a+1];if(r!=null&&s!=null&&r!==s)throw new Y(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return X(()=>{this.invokeCallHook(e,t);let n=He(e);n.dtype!=="int32"&&(n=No(n,"int32"));let a=gV(this.embeddings.read(),K(n,[n.size]));return K(a,$t(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Sn(this.embeddingsInitializer),embeddingsRegularizer:nn(this.embeddingsRegularizer),activityRegularizer:nn(this.activityRegularizer),embeddingsConstraint:ra(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};ZN.className="Embedding";de.registerClass(ZN);var _d=class extends mt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new ft}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){let r=e[e.length-t.length+a],s=t[a];if(r==null||s==null||r<0||s<0)n.push(null);else if(r===1)n.push(s);else if(s===1)n.push(r);else{if(r!==s)throw new Y("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[$t(e)]),e=e,e.length<2)throw new Y(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=Al(t),t.length>1)throw new Y(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let a=e.map(r=>r.length);e.indexOf(null)===-1&&Al(a).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return X(()=>{if(e=e,this.reshapeRequired){let n=[],a=e.map(r=>r.rank);if(a.indexOf(null)===-1){let r=Kl(a);for(let s of e){let i=s.rank;for(let o=0;o<r-i;++o)s=Yb(s,1);n.push(s)}return this.mergeFunction(n)}else{let r=!1;for(let o of e){let l=o.rank;if(l==null){let c=o.shape,u=c[0],h=c.slice(1).concat([u]),d=K(o,[u].concat(Rl(c.slice(1))));d=lt(d,[1,0]),d=K(d,h),n.push(d),r=!0}else if(l>1){let c=Ys(1,l).concat([0]);n.push(lt(o,c)),r=!0}else n.push(o)}let s=this.mergeFunction(n),i=s.rank;if(r){if(i==null){let o=s.shape,l=o.length,c=o[l-1],u=[c].concat(o.slice(0,o.length-1));s=K(lt(K(s,[-1,c]),[1,0]),u)}else if(i>1){let o=[i-1].concat(Ys(0,i-1));s=lt(s,o)}}return s}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let a=1;a<e.length;++a){let r=e[a]==null?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(let a of e)a!=null&&a[0]!==null&&n.push(a[0]);return n=Al(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return X(()=>{if(t==null)return null;if(!Array.isArray(t))throw new Y("`mask` should be an Array");if(!Array.isArray(e))throw new Y("`inputs` should be an Array");if(t.length!==e.length)throw new Y(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(a=>a==null))return null;t=t.map(a=>a==null?a:pa(a,0));let n=t[0];for(let a=1;a<t.length-1;++a)n=Ms(n,t[a]);return n})}},JN=class extends _d{constructor(e){super(e)}mergeFunction(e){return X(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=re(t,e[n]);return t})}};JN.className="Add";de.registerClass(JN);var eC=class extends _d{constructor(e){super(e)}mergeFunction(e){return X(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=G(t,e[n]);return t})}};eC.className="Multiply";de.registerClass(eC);var tC=class extends _d{constructor(e){super(e)}mergeFunction(e){return X(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=re(t,e[n]);return G(1/e.length,t)})}};tC.className="Average";de.registerClass(tC);var nC=class extends _d{constructor(e){super(e)}mergeFunction(e){return X(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Gi(t,e[n]);return t})}};nC.className="Maximum";de.registerClass(nC);var aC=class extends _d{constructor(e){super(e)}mergeFunction(e){return X(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Hl(t,e[n]);return t})}};aC.className="Minimum";de.registerClass(aC);var rC=class extends _d{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new Y("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let a of e)if(a!=null){t=!1;break}if(t)return;let n=[];for(let a=0;a<e.length;++a){let r=e[a].slice();r.splice(this.axis,1);let s=!1;for(let i of n)if(N.arraysEqual(i,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new Y("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return X(()=>rN(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new Y("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(let r of t.slice(1)){if(n[a]==null||r[a]==null){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new Y("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Y("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Y(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return X(()=>{let n=!0;if(t.forEach(s=>{if(s!=null){n=!1;return}}),n)return null;let a=[];for(let s=0;s<e.length;++s)t[s]==null?a.push(ye(Pr(e[s]),"bool")):t[s].rank<e[s].rank?a.push(pa(t[s],-1)):a.push(t[s]);let r=Qt(a,this.axis);return s1(r,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};rC.className="Concatenate";de.registerClass(rC);function mg(e,t){for(;e<0;)e+=t;return e}function Noe(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new ft("batchDot is not implemented for tensors of 4D or higher rank yet");if(N.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),N.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new ft("batchDot is not implemented for complex64-type Tensors yet.");let a=e.shape.length,r=t.shape.length;n==null&&(n=[a-1,r-2]);let s=n;return X(()=>{let i;if(a>r){i=a-r;let l=[];for(let c=0;c<i;++c)l.push(1);t=K(t,t.shape.concat(l))}else if(r>a){i=r-a;let l=[];for(let c=0;c<i;++c)l.push(1);e=K(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=De(G(e,t),s[0]):o=De(G(lt(e,[1,0]),t),s[1]);else{let l=s[0]!==e.shape.length-1,c=s[1]===t.shape.length-1;o=ot(e,t,l,c)}if(i>0){let l;a>r?l=a+r-3:l=a-1;let c=[];for(let u=l;u<l+i;++u)c.push(u);o=vu(o,c)}return o.shape.length===1&&(o=pa(o,1)),o})}var sC=class extends _d{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){N.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new ft("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new Y(`Dimension incompatibility: ${t[a[0]]} !== ${n[a[1]]}`)}mergeFunction(e){if(e.length!==2)throw new Y(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],a;return Array.isArray(this.axes)?a=this.axes.map((r,s)=>mg(r,e[s].shape.length)):a=[mg(this.axes,t.shape.length),mg(this.axes,n.shape.length)],this.normalize&&(t=z0(t,a[0]),n=z0(n,a[1])),Noe(t,n,a)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[mg(this.axes,e.length),mg(this.axes,t.length)],n}computeOutputShape(e){N.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new ft("Dot layer does not support tensors of 4D or higher rank yet.");let a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);let r=t.concat(n);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};sC.className="Dot";de.registerClass(sC);var iC=class extends mt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return X(()=>{this.invokeCallHook(e,t);let n=He(e);return Jb(()=>re(z1(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};iC.className="GaussianNoise";de.registerClass(iC);var oC=class extends mt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return X(()=>{this.invokeCallHook(e,t);let n=He(e);return this.rate>0&&this.rate<1?Jb(()=>{let a=Math.sqrt(this.rate/(1-this.rate));return G(n,z1(n.shape,1,a))},()=>n,t.training||!1):n})}};oC.className="GaussianDropout";de.registerClass(oC);var lC=class extends mt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||He(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return X(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Jb(()=>{let a=He(e),r=-1.6732632423543772*1.0507009873554805,s=Fo(yu(n),this.rate);s=No(s,"float32");let i=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-i*r*this.rate,l=re(G(a,s),G(re(s,-1),r));return re(G(l,i),o)},()=>He(e),t.training||!1)}return e})}};lC.className="AlphaDropout";de.registerClass(lC);function Dy(e,t,n,a,r,s=.001){let i;if(e.rank===2)i=Q2(e,t,n,a,r,s);else if(e.rank===3)i=Y2(e,t,n,a,r,s);else if(e.rank===4)i=Z2(e,t,n,a,r,s);else throw new ft(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function Coe(e,t,n,a,r=.001){return X(()=>{let s=Wb(e,a),i=s.mean,o=s.variance;return[Dy(e,i,o,n,t,r),i,o]})}function Aoe(e,t,n,a,r=.001){return X(()=>{let s=Wb(e,a),i=s.mean,o=s.variance,l=[];for(let p of Ys(0,e.rank))a.indexOf(p)!==-1?l.push(1):l.push(e.shape[p]);let c=K(i,l),u=K(o,l),h=t==null?null:K(t,l),d=n==null?null:K(n,l);return[Dy(e,c,u,d,h,r),i,o]})}function Roe(e,t,n,a,r=.001){return N.arraysEqual(a.slice().sort(),Ys(0,e.rank-1))?Coe(e,t,n,a,r):Aoe(e,t,n,a,r)}var uC=class extends mt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=gn(e.betaInitializer||"zeros"),this.gammaInitializer=gn(e.gammaInitializer||"ones"),this.movingMeanInitializer=gn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=gn(e.movingVarianceInitializer||"ones"),this.betaConstraint=sa(e.betaConstraint),this.gammaConstraint=sa(e.gammaConstraint),this.betaRegularizer=yn(e.betaRegularizer),this.gammaRegularizer=yn(e.gammaRegularizer)}build(e){e=$t(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new Y(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new zn({ndim:e.length,axes:{[t]:n}})];let a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return X(()=>{let n=t.training==null?!1:t.training,a=He(e),r=a.shape,s=r.length,i=Ys(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=Fc(1,s);l[o]=r[o];let c=i.slice();c.sort();let u=!N.arraysEqual(c,Ys(0,s).slice(0,s-1)),h=()=>{if(u){let g=K(this.movingMean.read(),l),y=K(this.movingVariance.read(),l),v=this.center?K(this.beta.read(),l):null,x=this.scale?K(this.gamma.read(),l):null;return Dy(a,g,y,v,x,this.epsilon)}else return Dy(a,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return h();let[d,p,f]=Roe(a,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(g,y,v)=>{X(()=>{let x=1-v,w=g.read(),k=G(Ie(w,y),x);g.write(Ie(w,k))})};return m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Sn(this.betaInitializer),gammaInitializer:Sn(this.gammaInitializer),movingMeanInitializer:Sn(this.movingMeanInitializer),movingVarianceInitializer:Sn(this.movingVarianceInitializer),betaRegularizer:nn(this.betaRegularizer),gammaRegularizer:nn(this.gammaRegularizer),betaConstraint:ra(this.betaConstraint),gammaConstraint:ra(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};uC.className="BatchNormalization";de.registerClass(uC);var cC=class extends mt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=gn(e.betaInitializer||"zeros"),this.gammaInitializer=gn(e.gammaInitializer||"ones"),this.betaRegularizer=yn(e.betaRegularizer),this.gammaRegularizer=yn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=$t(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(let r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==Al(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(r=>e[r]),a=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){let n=He(e),a=n.shape,r=a.length;return X(()=>{let{mean:s,variance:i}=Wb(n,this.axis,!0),o=Fc(1,r);for(let p of this.axis)o[p]=a[p];let l=p=>p!=null&&p.shape.length!==r?K(p,o):p,c=this.scale?l(this.gamma.read()):null,u=this.center?l(this.beta.read()):null,h=[],d=[];for(let p=0;p<r;++p)this.axis.indexOf(p)!==-1?(h.push(a[p]),d.push(1)):(h.push(1),d.push(a[p]));return s=Dr(s,h),i=Dr(i,h),c!=null&&(c=Dr(c,d)),u!=null&&(u=Dr(u,d)),Dy(n,s,i,u,c,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Sn(this.betaInitializer),gammaInitializer:Sn(this.gammaInitializer),betaRegularizer:nn(this.betaRegularizer),gammaRegularizer:nn(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};cC.className="LayerNormalization";de.registerClass(cC);function Doe(e,t,n){return X(()=>{if(e.rank!==4)throw new Y(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new Y("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Zs()),n!=="channelsLast"&&n!=="channelsFirst")throw new Y(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let a;return n==="channelsFirst"?a=[[0,0],[0,0],t[0],t[1]]:a=[[0,0],t[0],t[1],[0,0]],ri(e,a)})}var hC=class extends mt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Zs():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new Y(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new Y(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new Y(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new zn({ndim:4})]}computeOutputShape(e){e=$t(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return X(()=>Doe(He(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};hC.className="ZeroPadding2D";de.registerClass(hC);function r_(e,t,n,a,r,s){return X(()=>{$n(r),dV(s),ds(a),n==null&&(n=[1,1]),a==null&&(a="valid"),r==null&&(r=Zs()),s==null&&(s="max"),e=DN(e,r);let i,o=a==="same"?"same":"valid";return s==="max"?i=ca(e,t,n,o):i=Oo(e,t,n,o),r==="channelsFirst"&&(i=lt(i,[0,3,1,2])),i})}function yB(e,t,n,a,r,s){return X(()=>{$n(r),dV(s),ds(a),n==null&&(n=[1,1,1]),a==null&&(a="valid"),r==null&&(r=Zs()),s==null&&(s="max"),e=sB(e,r);let i,o=a==="same"?"same":"valid";return s==="max"?i=_E(e,t,n,o):i=X2(e,t,n,o),r==="channelsFirst"&&(i=lt(i,[0,4,1,2,3])),i})}var bB=class extends mt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new Y(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(ma(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new Y(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);ma(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,ds(this.padding),this.inputSpec=[new zn({ndim:3})]}computeOutputShape(e){e=$t(e);let t=Qs(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return X(()=>{this.invokeCallHook(e,t),e=Yb(He(e),2);let n=this.poolingFunction(He(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return vu(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},dC=class extends bB{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return $n(r),ds(a),r_(e,t,n,a,r,"max")}};dC.className="MaxPooling1D";de.registerClass(dC);var pC=class extends bB{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return $n(r),ds(a),r_(e,t,n,a,r,"avg")}};pC.className="AveragePooling1D";de.registerClass(pC);var vB=class extends mt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new Y(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];ma(this.poolSize,"poolSize"),ma(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,$n(this.dataFormat),ds(this.padding),this.inputSpec=[new zn({ndim:4})]}computeOutputShape(e){e=$t(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Qs(t,this.poolSize[0],this.padding,this.strides[0]),n=Qs(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return X(()=>(this.invokeCallHook(e,t),this.poolingFunction(He(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},fC=class extends vB{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return $n(r),ds(a),r_(e,t,n,a,r,"max")}};fC.className="MaxPooling2D";de.registerClass(fC);var mC=class extends vB{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return $n(r),ds(a),r_(e,t,n,a,r,"avg")}};mC.className="AveragePooling2D";de.registerClass(mC);var xB=class extends mt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new Y(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];ma(this.poolSize,"poolSize"),ma(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,$n(this.dataFormat),ds(this.padding),this.inputSpec=[new zn({ndim:5})]}computeOutputShape(e){e=$t(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],a=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Qs(t,this.poolSize[0],this.padding,this.strides[0]),n=Qs(n,this.poolSize[1],this.padding,this.strides[1]),a=Qs(a,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return X(()=>(this.invokeCallHook(e,t),this.poolingFunction(He(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},gC=class extends xB{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return $n(r),ds(a),yB(e,t,n,a,r,"max")}};gC.className="MaxPooling3D";de.registerClass(gC);var yC=class extends xB{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return $n(r),ds(a),yB(e,t,n,a,r,"avg")}};yC.className="AveragePooling3D";de.registerClass(yC);var wB=class extends mt{constructor(e){super(e),this.inputSpec=[new zn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new ft}},bC=class extends wB{constructor(e){super(e||{})}call(e,t){return X(()=>{let n=He(e);return wn(n,1)})}};bC.className="GlobalAveragePooling1D";de.registerClass(bC);var vC=class extends wB{constructor(e){super(e||{})}call(e,t){return X(()=>{let n=He(e);return is(n,1)})}};vC.className="GlobalMaxPooling1D";de.registerClass(vC);var _B=class extends mt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,$n(this.dataFormat),this.inputSpec=[new zn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new ft}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},xC=class extends _B{call(e,t){return X(()=>{let n=He(e);return this.dataFormat==="channelsLast"?wn(n,[1,2]):wn(n,[2,3])})}};xC.className="GlobalAveragePooling2D";de.registerClass(xC);var wC=class extends _B{call(e,t){return X(()=>{let n=He(e);return this.dataFormat==="channelsLast"?is(n,[1,2]):is(n,[2,3])})}};wC.className="GlobalMaxPooling2D";de.registerClass(wC);var SB=class extends mt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let a=t.layer,r=Xs(a,n);delete t.layer;let s={layer:r};return Object.assign(s,t),new e(s)}},_C=class extends SB{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=$t(e),e.length<3)throw new Y(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=$t(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return X(()=>(e=He(e),fB((n,a)=>[He(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};_C.className="TimeDistributed";de.registerClass(_C);function $oe(e){xd(Dse,"BidirectionalMergeMode",e)}var Moe="concat",SC=class extends SB{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Xs(n),t.goBackwards=t.goBackwards!==!0;let a={};if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=Xs(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Moe:e.mergeMode,$oe(this.mergeMode),e.weights)throw new ft("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,a,r;return this.returnState&&(r=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,a=[n]):this.mergeMode==null?a=[n,n.slice()]:a=[n],this.returnState?this.mergeMode==null?a.concat(r).concat(r.slice()):[n].concat(r).concat(r.slice()):hr(a)}apply(e,t){let n=t==null?null:t.initialState,a=t==null?null:t.constants;t==null&&(t={});let r=pB(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&a==null)return super.apply(e,t);let s=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new Y("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let c=n.map(u=>new zn({shape:u.shape}));this.forwardLayer.stateSpec=c.slice(0,l/2),this.backwardLayer.stateSpec=c.slice(l/2),i.push(...c)}if(a!=null)throw new ft("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof Js;for(let l of s)if(l instanceof Js!==o)throw new Y("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[e].concat(s),c=this.inputSpec.concat(i),u=this.inputSpec;this.inputSpec=c;let h=super.apply(l,t);return this.inputSpec=u,h}else return super.apply(e,t)}call(e,t){return X(()=>{let n=t.initialState,a,r;if(n==null)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let s;this.returnState&&(Array.isArray(a)&&(s=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=hs(r,1));let i;return this.mergeMode==="concat"?i=rN([a,r]):this.mergeMode==="sum"?i=re(a,r):this.mergeMode==="ave"?i=G(.5,re(a,r)):this.mergeMode==="mul"?i=G(a,r):this.mergeMode==null&&(i=[a,r]),this.returnState?this.mergeMode==null?i.concat(s):[i].concat(s):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){mc(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),mc(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let a=this.forwardLayer.states.map(r=>null);return Array.isArray(n)?n.concat(a).concat(a):[n].concat(a).concat(a)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Xs(t.layer);if(delete t.layer,t.numConstants!=null)throw new ft("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let a=t;return a.layer=n,new e(a)}};SC.className="Bidirectional";de.registerClass(SC);var IC=class extends mt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return X(()=>(e=He(e),e.dtype!=="float32"&&(e=No(e,"float32")),re(G(e,this.scale),this.offset)))}};IC.className="Rescaling";de.registerClass(IC);var{resizeBilinear:Ooe,cropAndResize:Foe}=Yr,kC=class extends mt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,r,s,i,o){return X(()=>{let l,c=!1,u=t/s,h=n/i,d=(a+t)/s,p=(r+n)/i,f=[u,h,d,p],m=[];e.rank===3?(c=!0,l=Bn([e])):l=e;for(let x=0;x<l.shape[0];x++)m.push(f);let g=Za(m,[m.length,4]),y=Oc(0,m.length,1,"int32"),v=Foe(l,g,y,[a,r],"nearest");return No(c?He(Tn(v)):v,o)})}upsize(e,t,n,a){return X(()=>{let r=Ooe(e,[t,n]);return No(r,a)})}call(e,t){return X(()=>{let n=He(e),a=n.dtype,r=n.shape,s=r[r.length-3],i=r[r.length-2],o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,s,i,a):this.upsize(e,this.height,this.width,a)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=$t(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};kC.className="CenterCrop";de.registerClass(kC);function Loe(e,t,n,a){let r=He(e);if(r.dtype!=="int32"&&(r=No(r,"int32")),t==="int")return r;let s=r.shape;if(r.rank===0&&(r=pa(r,-1)),t==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=pa(r,-1)),r.rank>2)throw new Y(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${r.rank}.`);let i=["multiHot","oneHot"].includes(t),o=r,l;if(typeof a<"u"&&t==="count"?l=D0(o,a,n,i):l=D0(o,[],n,i),t!=="tfIdf")return l;if(a)return G(l,a);throw new Y("When outputMode is 'tfIdf', weights must be provided.")}var TC=class extends mt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=$t(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return X(()=>{e=He(e),e.dtype!=="int32"&&(e=No(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new Y(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=He(t.countWeights)}let a=is(e),r=qp(e),s=sr(this.numTokens,a).bufferSync().get(0),i=Fo(r,0).bufferSync().get(0);if(!(s&&i))throw new Y(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Loe(e,this.outputMode,this.numTokens,n)})}};TC.className="CategoryEncoding";de.registerClass(TC);var zoe=["bilinear","nearest"],lM=new Set(zoe),EC=class extends mt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(lM.has(e.interpolation))this.interpolation=e.interpolation;else throw new Y(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=$t(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return X(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return Yr.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Yr.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...lM]} are supported`)})}};EC.className="Resizing";de.registerClass(EC);var IB=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};IB.className="RandomSeed";var kB=class extends mt{constructor(e){super(e),this.randomGenerator=new IB(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};kB.className="BaseRandomLayer";var Poe=["bilinear","nearest"],uM=new Set(Poe),NC=class extends kB{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new Y(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new Y(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Y(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(uM.has(n))this.interpolation=n;else throw new Y(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=$t(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return X(()=>{let n=He(e);this.imgHeight=n.shape[n.shape.length-3];let a=n.shape[n.shape.length-2];this.widthFactor=yu([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*a;r=Math.round(r);let s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return Yr.resizeBilinear(e,s);case"nearest":return Yr.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...uM]} are supported`)}})}};NC.className="RandomWidth";de.registerClass(NC);function Voe(e){return new $m(e)}function Boe(e){return new CN(e)}function Uoe(e){return new TN(e)}function Woe(e){return new EN(e)}function joe(e){return new NN(e)}function Goe(e){return new RN(e)}function Hoe(e){return new AN(e)}function qoe(e){return new FN(e)}function Koe(e){return new Y1(e)}function Xoe(e){return new $N(e)}function Qoe(e){return new Z1(e)}function Yoe(e){return new MN(e)}function Zoe(e){return new ON(e)}function Joe(e){return new LN(e)}function ele(e){return new zN(e)}function tle(e){return new PN(e)}function nle(e){return new qN(e)}function ale(e){return new GN(e)}function rle(e){return new a_(e)}function sle(e){return new jN(e)}function ile(e){return new HN(e)}function ole(e){return new KN(e)}function lle(e){return new XN(e)}function ule(e){return new QN(e)}function cle(e){return new ZN(e)}function hle(e){return new JN(e)}function dle(e){return new tC(e)}function ple(e){return new rC(e)}function fle(e){return new nC(e)}function mle(e){return new aC(e)}function gle(e){return new eC(e)}function yle(e){return new sC(e)}function ble(e){return new uC(e)}function vle(e){return new cC(e)}function xle(e){return new hC(e)}function CC(e){return new pC(e)}function wle(e){return CC(e)}function _le(e){return CC(e)}function AC(e){return new mC(e)}function Sle(e){return AC(e)}function Ile(e){return AC(e)}function RC(e){return new yC(e)}function kle(e){return RC(e)}function Tle(e){return RC(e)}function Ele(e){return new bC(e)}function Nle(e){return new xC(e)}function TB(e){return new vC(e)}function EB(e){return new wC(e)}function NB(e){return new dC(e)}function CB(e){return new fC(e)}function Cle(e){return new gC(e)}function Ale(e){return new BN(e)}function Rle(e){return new e_(e)}function Dle(e){return new UN(e)}function $le(e){return new av(e)}function Mle(e){return new VN(e)}function Ole(e){return new J1(e)}function Fle(e){return new WN(e)}function Lle(e){return new n_(e)}function zle(e){return new Po(e)}function Ple(e){return new t_(e)}function Vle(e){return new SC(e)}function Ble(e){return new _C(e)}var Ule=TB,Wle=EB,jle=NB,Gle=CB;function Hle(e){return new iC(e)}function qle(e){return new oC(e)}function Kle(e){return new lC(e)}function Xle(e){return new YN(e)}function Qle(e){return new IC(e)}function Yle(e){return new kC(e)}function Zle(e){return new EC(e)}function Jle(e){return new TC(e)}function eue(e){return new NC(e)}var AB={};tt(AB,{MAPE:()=>hue,MSE:()=>fue,binaryAccuracy:()=>tue,binaryCrossentropy:()=>nue,categoricalAccuracy:()=>rue,categoricalCrossentropy:()=>sue,cosineProximity:()=>lue,mape:()=>due,meanAbsoluteError:()=>uue,meanAbsolutePercentageError:()=>cue,meanSquaredError:()=>pue,mse:()=>mue,precision:()=>iue,r2Score:()=>gue,recall:()=>oue,sparseCategoricalAccuracy:()=>aue});function tue(e,t){return xN(e,t)}function nue(e,t){return $V(e,t)}function aue(e,t){return MV(e,t)}function rue(e,t){return wN(e,t)}function sue(e,t){return _N(e,t)}function iue(e,t){return DV(e,t)}function oue(e,t){return zie(e,t)}function lue(e,t){return vN(e,t)}function uue(e,t){return q1(e,t)}function cue(e,t){return Mm(e,t)}function hue(e,t){return Mm(e,t)}function due(e,t){return Mm(e,t)}function pue(e,t){return wd(e,t)}function fue(e,t){return wd(e,t)}function mue(e,t){return wd(e,t)}function gue(e,t){return Pie(e,t)}var RB={};tt(RB,{modelFromJSON:()=>moe});var DB={};tt(DB,{l1:()=>bue,l1l2:()=>yue,l2:()=>vue});function yue(e){return new tv(e)}function bue(e){return _oe(e)}function vue(e){return Soe(e)}var $B=class extends tf{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof vo))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function ax(e,t){return e<t}function cM(e,t){return e>t}var MB=class extends $B{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new ft("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=ax:this.mode==="max"?this.monitorFunc=cM:this.monitor.indexOf("acc")!==-1?this.monitorFunc=cM:this.monitorFunc=ax,this.monitorFunc===ax&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===ax?1/0:-1/0}async onEpochEnd(e,t){await Jo(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function xue(e){return new MB(e)}var wue={earlyStopping:xue},_ue=Z();_ue.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Sr;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(Sr||(Sr={}));var hM;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(hM||(hM={}));var DC={};function Sue(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};DC[e]=n}function OB(e){return DC[e]}function Iue(e){delete DC[e]}function C(e,t,n,a,r){let s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,c=o<0?t.inputNames.length+o:o;if(s.type==="tensor")return Ea(t.inputNames[c],n,a,r);if(s.type==="tensors"){let d=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((p,f)=>{var m;return((m=d[f])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(p=>Ea(p,n,a,r))}let u=Ea(t.inputNames[c],n,a,r),h=u.dataSync();return s.type==="number"?h[0]:N.toNestedArray(u.shape,h)}let i=t.attrParams[e];return i&&i.value}function Ea(e,t,n,a){let[r,s]=Nr(e,n);if(a!=null){let o=a.getHashTableHandleByName(r);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[W0(r,o)]);return i!==void 0?t[W0(r,i)][s]:void 0}function dM(e,t,n){return t[W0(e,n.currentContextId)]}function oo(e,t){let[n,a,r]=Nr(e,t);return[W0(n,t&&t.currentContextId),a,r]}function W0(e,t){return t?`${e}-${t}`:e}function Nr(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let s=t.parseNodeNameCache.get(e);if(s!=null)return s}let a=e.split(":"),r;if(a.length===1)r=[e,0,void 0];else{let s=a[0],i=a.length===3?a[1]:void 0,o=Number(a[a.length-1]);r=[s,o,i]}return n&&t.parseNodeNameCache.set(e,r),r}function zx(e,t,n){let a=C("pad",e,t,n);if(a==="explicit"){a=C("explicitPaddings",e,t,n);let r=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)r[s][0]=a[s*2],r[s][1]=a[s*2+1];return r}return a}function lo(e){return e.kept?e:Ci(e)}var FB={};tt(FB,{json:()=>kue});var kue=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],LB={};tt(LB,{json:()=>Tue});var Tue=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zB={};tt(zB,{json:()=>Eue});var Eue=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],PB={};tt(PB,{json:()=>Nue});var Nue=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],VB={};tt(VB,{json:()=>Cue});var Cue=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],BB={};tt(BB,{json:()=>Aue});var Aue=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],UB={};tt(UB,{json:()=>Rue});var Rue=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],WB={};tt(WB,{json:()=>Due});var Due=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],jB={};tt(jB,{json:()=>$ue});var $ue=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],GB={};tt(GB,{json:()=>Mue});var Mue=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],HB={};tt(HB,{json:()=>Oue});var Oue=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],qB={};tt(qB,{json:()=>Fue});var Fue=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],KB={};tt(KB,{json:()=>Lue});var Lue=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],XB={};tt(XB,{json:()=>zue});var zue=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],QB={};tt(QB,{json:()=>Pue});var Pue=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],YB={};tt(YB,{json:()=>Vue});var Vue=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],ZB={};tt(ZB,{json:()=>Bue});var Bue=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],JB={};tt(JB,{json:()=>Uue});var Uue=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],eU={};tt(eU,{json:()=>Wue});var Wue=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],pM=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[FB,LB,zB,PB,VB,BB,UB,WB,jB,GB,HB,qB,KB,XB,QB,YB,ZB,JB,eU],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,a)=>(n[a.tfOpName]=a,n),{})}transformGraph(e,t={}){let n=e.node,a=[],r=[],s=[],i=n.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?a.push(f[m.name]):m.op==="Const"?r.push(f[m.name]):(m.input==null||m.input.length===0)&&s.push(f[m.name]),f),{}),o=[],l=[],c={},u={};t!=null&&(c=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));let h=Object.keys(i);h.forEach(f=>{let m=i[f];m.inputNames.forEach((g,y)=>{let[v,,x]=oo(g),w=i[v];if(w.outputs!=null){let k=w.outputs.indexOf(x);if(k!==-1){let M=`${v}:${k}`;m.inputNames[y]=M}}m.inputs.push(w),w.children.push(m)})}),Object.keys(u).length===0?h.forEach(f=>{let m=i[f];m.children.length===0&&l.push(m)}):Object.keys(u).forEach(f=>{let[m]=oo(f),g=i[m];g!=null&&(g.signatureKey=u[f],l.push(g))}),Object.keys(c).length>0?Object.keys(c).forEach(f=>{let[m]=oo(f),g=i[m];g&&(g.signatureKey=c[f],o.push(g))}):o=a;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((f,m)=>(f[m.signature.name]=this.mapFunction(m),f),{}));let p={nodes:i,inputs:o,outputs:l,weights:r,placeholders:a,signature:t,functions:d};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=OB(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(a=>a.startsWith("^")?a.slice(1):a),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((a,r)=>(a[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},a),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((a,r)=>{let s=r.type,i;switch(r.type){case"string":i=Ik(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Ik(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":i=Rk(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Rk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":i=Tk(e.attr,r.tfName,r.defaultValue||0),i===void 0&&r.tfDeprecatedName&&(i=Tk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":i=Ak(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Ak(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":i=kk(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=kk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":i=$k(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=$k(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":i=Ck(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Ck(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":i=Dk(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Dk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":i=Ek(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Ek(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":i=Nk(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Nk(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":i=fM(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=fM(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return a[r.name]={value:i,type:s},a},{})),n}mapFunction(e){let t=e.nodeDef,n=[],a=[],r={};t!=null&&(r=t.reduce((c,u)=>(c[u.name]=this.mapNode(u),u.op==="Const"&&a.push(c[u.name]),c),{}));let s=[],i=[];e.signature.inputArg.forEach(c=>{let[u]=oo(c.name),h={name:u,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:$C(c.type),type:"dtype"}},children:[]};h.signatureKey=c.name,s.push(h),r[u]=h}),Object.keys(r).forEach(c=>{let u=r[c];u.inputNames.forEach((h,d)=>{let[p,,f]=oo(h),m=r[p];if(m.outputs!=null){let g=m.outputs.indexOf(f);if(g!==-1){let y=`${p}:${g}`;u.inputNames[d]=y}}u.inputs.push(m),m.children.push(u)})});let o=e.ret;e.signature.outputArg.forEach(c=>{let[u,h]=oo(o[c.name]),d=r[u];d!=null&&(d.defaultOutput=h,i.push(d))});let l=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:i,weights:a,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function jue(e){let t=Z().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function tU(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):jue(e);return t?n:n.toLowerCase()}function Ik(e,t,n,a=!1){let r=e[t];return r!=null?tU(r.s,a):n}function kk(e,t,n){let a=e[t];return a?a.b:n}function Tk(e,t,n){let a=e[t]||{},r=a.i!=null?a.i:a.f!=null?a.f:n;return typeof r=="number"?r:parseInt(r,10)}function $C(e){switch(typeof e=="string"&&(e=Sr[e]),e){case Sr.DT_FLOAT:case Sr.DT_HALF:return"float32";case Sr.DT_INT32:case Sr.DT_INT64:case Sr.DT_INT8:case Sr.DT_UINT8:return"int32";case Sr.DT_BOOL:return"bool";case Sr.DT_DOUBLE:return"float32";case Sr.DT_STRING:return"string";case Sr.DT_COMPLEX64:case Sr.DT_COMPLEX128:return"complex64";default:return null}}function fM(e,t,n){let a=e[t];return a&&a.func?a.func.name:n}function Ek(e,t,n){let a=e[t];return a&&a.type?$C(a.type):n}function Nk(e,t,n){let a=e[t];return a&&a.list&&a.list.type?a.list.type.map(r=>$C(r)):n}function nU(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function Ck(e,t,n){let a=e[t];return a&&a.shape?nU(a.shape):n}function Ak(e,t,n){let a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function Rk(e,t,n,a=!1){let r=e[t];return r&&r.list&&r.list.s?r.list.s.map(s=>tU(s,a)):n}function Dk(e,t,n){let a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(r=>nU(r)):n}function $k(e,t,n){let a=e[t];return a&&a.list&&a.list.b?a.list.b:n}var Gue=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(a=>this.getInput(a)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((a,r)=>(a[r]=this.getAttr(r),a),{}))}getInput(e){return Ea(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return Ea(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return Tk(this.node.rawAttrs,e,t);if(n.s!=null)return Ik(this.node.rawAttrs,e,t);if(n.b!=null)return kk(this.node.rawAttrs,e,t);if(n.shape!=null)return Ck(this.node.rawAttrs,e,t);if(n.type!=null)return Ek(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return Ak(this.node.rawAttrs,e,t);if(n.list.s!=null)return Rk(this.node.rawAttrs,e,t);if(n.list.shape!=null)return Dk(this.node.rawAttrs,e,t);if(n.list.b!=null)return $k(this.node.rawAttrs,e,t);if(n.list.type!=null)return Nk(this.node.rawAttrs,e,t)}return t}},wa={};tt(wa,{OP_SCOPE_SUFFIX:()=>O2,abs:()=>On,acos:()=>V2,acosh:()=>B2,add:()=>re,addN:()=>g4,all:()=>s1,any:()=>Ty,argMax:()=>Rc,argMin:()=>U2,asin:()=>W2,asinh:()=>j2,atan:()=>G2,atan2:()=>H2,atanh:()=>q2,avgPool:()=>Oo,avgPool3d:()=>X2,basicLSTMCell:()=>x4,batchNorm:()=>gd,batchNorm2d:()=>Q2,batchNorm3d:()=>Y2,batchNorm4d:()=>Z2,batchToSpaceND:()=>Fb,bincount:()=>J2,bitwiseAnd:()=>w4,booleanMaskAsync:()=>cP,broadcastArgs:()=>_4,broadcastTo:()=>fc,buffer:()=>ut,cast:()=>ye,ceil:()=>eE,clipByValue:()=>Va,clone:()=>Ci,complex:()=>Eo,concat:()=>Qt,concat1d:()=>tE,concat2d:()=>nE,concat3d:()=>aE,concat4d:()=>rE,conv1d:()=>i1,conv2d:()=>Ja,conv2dTranspose:()=>o1,conv3d:()=>iE,conv3dTranspose:()=>oE,cos:()=>Lb,cosh:()=>l1,cosineWindow:()=>R1,cumprod:()=>Cy,cumsum:()=>u1,denseBincount:()=>D0,depthToSpace:()=>lE,depthwiseConv2d:()=>yd,diag:()=>I4,dilation2d:()=>uE,div:()=>Ce,divNoNan:()=>cE,dot:()=>hE,dropout:()=>VE,einsum:()=>nc,elu:()=>Tm,enclosingPowerOfTwo:()=>BE,ensureShape:()=>T4,equal:()=>Lr,erf:()=>c1,euclideanNorm:()=>fE,exp:()=>Ba,expandDims:()=>pa,expm1:()=>mE,eye:()=>h1,fft:()=>qb,fill:()=>Mr,floor:()=>Nm,floorDiv:()=>r1,fused:()=>Jp,gather:()=>Cm,gatherND:()=>fP,greater:()=>sr,greaterEqual:()=>Fo,ifft:()=>Zp,imag:()=>zb,image:()=>Yr,inTopKAsync:()=>mP,irfft:()=>I1,isFinite:()=>gE,isInf:()=>yE,isNaN:()=>bE,leakyRelu:()=>Pb,less:()=>Kp,lessEqual:()=>gu,linalg:()=>jE,linspace:()=>R4,localResponseNormalization:()=>vE,log:()=>zr,log1p:()=>Vb,logSigmoid:()=>xE,logSoftmax:()=>p1,logSumExp:()=>Bb,logicalAnd:()=>Ms,logicalNot:()=>Ub,logicalOr:()=>f1,logicalXor:()=>wE,losses:()=>EP,lowerBound:()=>$4,matMul:()=>ot,max:()=>is,maxPool:()=>ca,maxPool3d:()=>_E,maxPoolWithArgmax:()=>M4,maximum:()=>Gi,mean:()=>wn,meshgrid:()=>O4,min:()=>qp,minimum:()=>Hl,mirrorPad:()=>SE,mod:()=>IE,moments:()=>Wb,movingAverage:()=>hP,mul:()=>G,multiRNNCell:()=>F4,multinomial:()=>L4,neg:()=>on,norm:()=>Em,notEqual:()=>Mc,oneHot:()=>Xp,ones:()=>pr,onesLike:()=>Pr,op:()=>W,outerProduct:()=>z4,pad:()=>ri,pad1d:()=>P4,pad2d:()=>V4,pad3d:()=>B4,pad4d:()=>U4,pool:()=>kE,pow:()=>Li,prelu:()=>Gb,print:()=>P2,prod:()=>TE,raggedGather:()=>W4,raggedRange:()=>j4,raggedTensorToTensor:()=>G4,rand:()=>H4,randomGamma:()=>Q4,randomNormal:()=>g1,randomStandardNormal:()=>Y4,randomUniform:()=>yu,randomUniformInt:()=>Z4,range:()=>Oc,real:()=>Qp,reciprocal:()=>RE,relu:()=>Bt,relu6:()=>y1,reshape:()=>K,reverse:()=>hs,reverse1d:()=>J4,reverse2d:()=>eP,reverse3d:()=>tP,reverse4d:()=>nP,rfft:()=>Kb,round:()=>b1,rsqrt:()=>v1,scalar:()=>ze,scatterND:()=>dP,searchSorted:()=>m1,selu:()=>x1,separableConv2d:()=>Am,setdiff1dAsync:()=>aP,sigmoid:()=>Rs,sign:()=>DE,signal:()=>TP,sin:()=>w1,sinh:()=>_1,slice:()=>vt,slice1d:()=>Hb,slice2d:()=>S1,slice3d:()=>Rm,slice4d:()=>Yp,softmax:()=>bu,softplus:()=>bd,spaceToBatchND:()=>jb,sparse:()=>NP,sparseToDense:()=>pP,spectral:()=>kP,split:()=>fr,sqrt:()=>va,square:()=>Xt,squaredDifference:()=>k1,squeeze:()=>vu,stack:()=>Bn,step:()=>vd,stridedSlice:()=>$E,string:()=>CP,sub:()=>Ie,sum:()=>De,tan:()=>ME,tanh:()=>Gl,tensor:()=>Za,tensor1d:()=>Ft,tensor2d:()=>Ai,tensor3d:()=>T1,tensor4d:()=>ql,tensor5d:()=>rP,tensor6d:()=>sP,tensorScatterUpdate:()=>oP,tile:()=>Dr,topk:()=>FE,transpose:()=>lt,truncatedNormal:()=>C1,unique:()=>LE,unsortedSegmentSum:()=>A1,unstack:()=>Tn,upperBound:()=>lP,variable:()=>zE,where:()=>ga,whereAsync:()=>PE,zeros:()=>_n,zerosLike:()=>_t});var Hue=(e,t,n,a=wa)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(C("a",e,t,n),C("b",e,t,n))];case"AddN":return[a.addN(C("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(C("a",e,t,n),C("b",e,t,n))];case"Mul":return[a.mul(C("a",e,t,n),C("b",e,t,n))];case"RealDiv":case"Div":return[a.div(C("a",e,t,n),C("b",e,t,n))];case"DivNoNan":return[a.divNoNan(C("a",e,t,n),C("b",e,t,n))];case"FloorDiv":return[a.floorDiv(C("a",e,t,n),C("b",e,t,n))];case"Sub":return[a.sub(C("a",e,t,n),C("b",e,t,n))];case"Minimum":return[a.minimum(C("a",e,t,n),C("b",e,t,n))];case"Maximum":return[a.maximum(C("a",e,t,n),C("b",e,t,n))];case"Pow":return[a.pow(C("a",e,t,n),C("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(C("a",e,t,n),C("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},que=(e,t,n,a=wa)=>{switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(C("x",e,t,n))];case"Acos":return[a.acos(C("x",e,t,n))];case"Acosh":return[a.acosh(C("x",e,t,n))];case"Asin":return[a.asin(C("x",e,t,n))];case"Asinh":return[a.asinh(C("x",e,t,n))];case"Atan":return[a.atan(C("x",e,t,n))];case"Atan2":return[a.atan2(C("x",e,t,n),C("y",e,t,n))];case"Atanh":return[a.atanh(C("x",e,t,n))];case"Ceil":return[a.ceil(C("x",e,t,n))];case"Complex":return[a.complex(C("real",e,t,n),C("imag",e,t,n))];case"Cos":return[a.cos(C("x",e,t,n))];case"Cosh":return[a.cosh(C("x",e,t,n))];case"Elu":return[a.elu(C("x",e,t,n))];case"Erf":return[a.erf(C("x",e,t,n))];case"Exp":return[a.exp(C("x",e,t,n))];case"Expm1":return[a.expm1(C("x",e,t,n))];case"Floor":return[a.floor(C("x",e,t,n))];case"Log":return[a.log(C("x",e,t,n))];case"Log1p":return[a.log1p(C("x",e,t,n))];case"Imag":return[a.imag(C("x",e,t,n))];case"Neg":return[a.neg(C("x",e,t,n))];case"Reciprocal":return[a.reciprocal(C("x",e,t,n))];case"Real":return[a.real(C("x",e,t,n))];case"Relu":return[a.relu(C("x",e,t,n))];case"Round":return[a.round(C("x",e,t,n))];case"Selu":return[a.selu(C("x",e,t,n))];case"Sigmoid":return[a.sigmoid(C("x",e,t,n))];case"Sin":return[a.sin(C("x",e,t,n))];case"Sign":return[a.sign(C("x",e,t,n))];case"Sinh":return[a.sinh(C("x",e,t,n))];case"Softplus":return[a.softplus(C("x",e,t,n))];case"Sqrt":return[a.sqrt(C("x",e,t,n))];case"Square":return[a.square(C("x",e,t,n))];case"Tanh":return[a.tanh(C("x",e,t,n))];case"Tan":return[a.tan(C("x",e,t,n))];case"ClipByValue":return[a.clipByValue(C("x",e,t,n),C("clipValueMin",e,t,n),C("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(C("x",e,t,n))];case"Rsqrt":return[a.rsqrt(Ea(e.inputNames[0],t,n))];case"LeakyRelu":return[a.leakyRelu(C("x",e,t,n),C("alpha",e,t,n))];case"Prelu":return[a.prelu(C("x",e,t,n),C("alpha",e,t,n))];case"IsNan":return[a.isNaN(Ea(e.inputNames[0],t,n))];case"IsInf":return[a.isInf(Ea(e.inputNames[0],t,n))];case"IsFinite":return[a.isFinite(Ea(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function ws(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){N.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let a=0;a<e.length;a++){let r=e[a],s=t[a];N.assert(r<0||s<0||r===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function mM(e){return!(typeof e=="number"||e.some(t=>t<0))}function gg(e,t,n){let a=Mk(e,n),r=!mM(a);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);if(r&&t.forEach(s=>{a=Mk(s.shape,a)}),!mM(a))throw new Error(`Non-fully-defined elementShape: ${a}`);return a}function Mk(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let a=0;a<e.length;++a){let r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[a]=r>=0?r:s}return n}var Kue=class{constructor(e,t,n,a,r,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=ze(0),Jn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ws(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Jn(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,a)=>this.write(n,t[a]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let a=0;a<this.size();a++)e.push(a)}if(e.length===0)return Za([],[0].concat(this.elementShape));let n=this.readMany(e);return ws(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Bn(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Za([],[0].concat(this.elementShape));let t=[];for(let a=0;a<this.size();a++)t.push(a);let n=this.readMany(t);return ws(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Qt(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Tn(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,a=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let r=n===0?0:t.size/n,s=[];X(()=>{t=K(t,[1,n,r]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:a[o-1],0],c=[1,e[o],r];s[o]=K(vt(t,l,c),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},s_=class Ok{get id(){return this.idTensor.id}constructor(t,n,a,r=-1){this.tensors=t,this.elementShape=n,this.elementDtype=a,t!=null&&t.forEach(s=>{if(a!==s.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${s.dtype}`);ws(n,s.shape,"TensorList shape mismatch: "),Jn(s)}),this.idTensor=ze(0),this.maxNumElements=r,Jn(this.idTensor)}copy(){return new Ok([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,a=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(a!==-1&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);ws(t,this.elementShape,"TensorList shape mismatch: ");let r=gg(this.elementShape,this.tensors,t);return X(()=>{let s=this.tensors.map(i=>K(i,r));return Bn(s,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let a=gg(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,ws(r.shape,t,"TensorList shape mismatch: "),K(r,a)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(ws(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Jn(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new Ok([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let a=0;a<Math.min(this.tensors.length,t);++a)n.tensors[a]=this.tensors[a];return n}getItem(t,n,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);ws(this.tensors[t].shape,n,"TensorList shape mismatch: ");let r=gg(this.elementShape,this.tensors,n);return K(this.tensors[t],r)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);ws(this.elementShape,n.shape,"TensorList shape mismatch: "),Jn(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,a){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);ws(this.elementShape,a,"TensorList shape mismatch: "),t=t.slice(0,this.size());let r=gg(this.elementShape,this.tensors,a);return t.length===0?Za([],[0].concat(r)):X(()=>{let s=t.map(i=>K(this.tensors[i],r));return Bn(s,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);ws(this.elementShape,n,"TensorList shape mismatch: ");let a=gg(this.elementShape,this.tensors,n);return this.size()===0?Za([],[0].concat(a)):X(()=>{let r=this.tensors.map(s=>K(s,a));return Qt(r,0)})}};function Xue(e,t,n){let a=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let r=e.shape.slice(1);ws(r,t,"TensorList shape mismatch: ");let s=Tn(e);return new s_(s,t,a)}function Que(e,t,n,a){return new s_([],e,t,a)}function Yue(e,t,n,a){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let r=Math.max(...t);if(a!=null&&a!==-1&&r>=a)throw new Error(`Max index must be < array size (${r}  vs. ${a})`);let s=new s_([],n,e.dtype,a),i=Tn(e,0);return t.forEach((o,l)=>{s.setItem(o,i[l])}),s}function Zue(e,t,n){let a=0,r=t.map(u=>(a+=u,a));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${a}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=Mk(s,n),o=a===0?0:e.size/a,l=X(()=>{let u=[];e=K(e,[1,a,o]);for(let h=0;h<t.length;++h){let d=[0,h===0?0:r[h-1],0],p=[1,t[h],o];u[h]=K(vt(e,d,p),i)}return e.dispose(),u}),c=new s_([],n,e.dtype,t.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}var Jue=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let a=C("thenBranch",e,t,n),r=C("elseBranch",e,t,n),s=C("cond",e,t,n),i=C("args",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let a=C("body",e,t,n),r=C("cond",e,t,n),s=C("args",e,t,n),i=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(u=>u.id),l=await i[0].data();i.forEach(u=>{!u.kept&&o.indexOf(u.id)===-1&&u.dispose()});let c=s;for(;l[0];){let u=c;c=await n.functionMap[a].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);let h=c.map(p=>p.id);u.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});let d=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return c}case"LoopCond":{let a=C("pred",e,t,n);return[lo(a)]}case"Switch":{let a=C("pred",e,t,n),r=C("data",e,t,n);return r.kept||(r=lo(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{let a=e.inputNames.find(r=>Ea(r,t,n)!==void 0);if(a){let r=Ea(a,t,n);return[lo(r)]}return}case"Enter":{let a=C("frameName",e,t,n),r=C("tensor",e,t,n);return n.enterFrame(a),[lo(r)]}case"Exit":{let a=C("tensor",e,t,n);return n.exitFrame(),[lo(a)]}case"NextIteration":{let a=C("tensor",e,t,n);return n.nextIteration(),[lo(a)]}case"TensorArrayV3":{let a=C("size",e,t,n),r=C("dtype",e,t,n),s=C("elementShape",e,t,n),i=C("dynamicSize",e,t,n),o=C("clearAfterRead",e,t,n),l=C("identicalElementShapes",e,t,n),c=C("name",e,t,n),u=new Kue(c,r,a,s,l,i,o);return n.addTensorArray(u),[u.idTensor,ze(1)]}case"TensorArrayWriteV3":{let a=C("tensorArrayId",e,t,n),r=C("index",e,t,n),s=C("tensor",e,t,n),i=n.getTensorArray(a.id);return i.write(r,s),[i.idTensor]}case"TensorArrayReadV3":{let a=C("tensorArrayId",e,t,n),r=C("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{let a=C("tensorArrayId",e,t,n),r=C("indices",e,t,n),s=C("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case"TensorArrayScatterV3":{let a=C("tensorArrayId",e,t,n),r=C("indices",e,t,n),s=C("tensor",e,t,n),i=n.getTensorArray(a.id);return i.scatter(r,s),[i.idTensor]}case"TensorArrayConcatV3":{let a=C("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),s=C("dtype",e,t,n);return[r.concat(s)]}case"TensorArraySplitV3":{let a=C("tensorArrayId",e,t,n),r=C("tensor",e,t,n),s=C("lengths",e,t,n),i=n.getTensorArray(a.id);return i.split(s,r),[i.idTensor]}case"TensorArraySizeV3":{let a=C("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return[ze(r.size(),"int32")]}case"TensorArrayCloseV3":{let a=C("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{let a=C("tensorListId",e,t,n),r=C("index",e,t,n),s=C("tensor",e,t,n),i=n.getTensorList(a.id);return i.setItem(r,s),[i.idTensor]}case"TensorListGetItem":{let a=C("tensorListId",e,t,n),r=C("index",e,t,n),s=C("elementShape",e,t,n),i=C("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let a=C("indices",e,t,n),r=C("tensor",e,t,n),s=C("elementShape",e,t,n),i=C("numElements",e,t,n),o=Yue(r,a,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let a=C("elementShape",e,t,n),r=C("elementDType",e,t,n),s;e.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=C(s,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=Que(a,r,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let a=C("tensorListId",e,t,n),r=C("indices",e,t,n),s=C("elementShape",e,t,n),i=C("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,i,s)]}case"TensorListStack":{let a=C("tensorListId",e,t,n),r=C("elementShape",e,t,n),s=C("elementDType",e,t,n),i=C("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,s,i)]}case"TensorListFromTensor":{let a=C("tensor",e,t,n),r=C("elementShape",e,t,n),s=C("elementDType",e,t,n),i=Xue(a,r,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let a=C("tensorListId",e,t,n),r=n.getTensorList(a.id),s=C("dtype",e,t,n),i=C("elementShape",e,t,n);return[r.concat(s,i)]}case"TensorListPushBack":{let a=C("tensorListId",e,t,n),r=C("tensor",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{let a=C("tensorListId",e,t,n),r=C("elementShape",e,t,n),s=C("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case"TensorListSplit":{let a=C("tensor",e,t,n),r=C("elementShape",e,t,n),s=C("lengths",e,t,n),i=Zue(a,s,r);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let a=C("tensorListId",e,t,n),r=n.getTensorList(a.id);return[ze(r.size(),"int32")]}case"TensorListResize":{let a=C("tensorListId",e,t,n),r=C("size",e,t,n),s=n.getTensorList(a.id).resize(r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function gM(e,t,n){let[a,r]=C("fusedOps",e,t,n),s=a==="biasadd",i=!s,o=r==="prelu",l=a==="fusedbatchnorm",c=C("numArgs",e,t,n);if(s){if(o&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let u=C("strides",e,t,n),h=zx(e,t,n),d=C("dataFormat",e,t,n).toUpperCase(),p=C("dilations",e,t,n),[f,m]=C("args",e,t,n);i&&(m=f,f=void 0);let g=C("leakyreluAlpha",e,t,n);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:g}}var ece=(e,t,n,a=wa)=>{switch(e.op){case"Conv1D":{let r=C("stride",e,t,n),s=C("pad",e,t,n),i=C("dataFormat",e,t,n).toUpperCase(),o=C("dilation",e,t,n);return[a.conv1d(C("x",e,t,n),C("filter",e,t,n),r,s,i,o)]}case"Conv2D":{let r=C("strides",e,t,n),s=zx(e,t,n),i=C("dataFormat",e,t,n).toUpperCase(),o=C("dilations",e,t,n);return[a.conv2d(C("x",e,t,n),C("filter",e,t,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=gM(e,t,n);return[a.fused.conv2d({x:C("x",e,t,n),filter:C("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=gM(e,t,n);return[a.fused.depthwiseConv2d({x:C("x",e,t,n),filter:C("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=C("outputShape",e,t,n),s=C("strides",e,t,n),i=zx(e,t,n);return[a.conv2dTranspose(C("x",e,t,n),C("filter",e,t,n),r,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=C("strides",e,t,n),s=zx(e,t,n),i=C("dilations",e,t,n),o=C("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(C("input",e,t,n),C("filter",e,t,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("dataFormat",e,t,n).toUpperCase(),o=C("dilations",e,t,n);return[a.conv3d(C("x",e,t,n),C("filter",e,t,n),[r[1],r[2],r[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("kernelSize",e,t,n);return[a.avgPool(C("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPool":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("kernelSize",e,t,n);return[a.maxPool(C("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("kernelSize",e,t,n),o=C("includeBatchInIndex",e,t,n),{result:l,indexes:c}=a.maxPoolWithArgmax(C("x",e,t,n),[i[1],i[2]],[r[1],r[2]],s,o);return[l,c]}case"AvgPool3D":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("kernelSize",e,t,n);return[a.avgPool3d(C("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("kernelSize",e,t,n);return[a.maxPool3d(C("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{let r=C("strides",e,t,n),s=C("pad",e,t,n),i=C("dilations",e,t,n),o=r[1],l=r[2],c=i[1],u=i[2];return[a.dilation2d(C("x",e,t,n),C("filter",e,t,n),[o,l],s,[c,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},tce=(e,t,n,a=wa)=>{switch(e.op){case"Fill":{let r=C("shape",e,t,n),s=C("dtype",e,t,n),i=C("value",e,t,n);return[a.fill(r,i,s)]}case"LinSpace":{let r=C("start",e,t,n),s=C("stop",e,t,n),i=C("num",e,t,n);return[a.linspace(r,s,i)]}case"Multinomial":{let r=C("logits",e,t,n),s=C("numSamples",e,t,n),i=C("seed",e,t,n);return[a.multinomial(r,s,i)]}case"OneHot":{let r=C("indices",e,t,n),s=C("depth",e,t,n),i=C("onValue",e,t,n),o=C("offValue",e,t,n),l=C("dtype",e,t,n);return[a.oneHot(r,s,i,o,l)]}case"Ones":return[a.ones(C("shape",e,t,n),C("dtype",e,t,n))];case"OnesLike":return[a.onesLike(C("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(C("shape",e,t,n),C("dtype",e,t,n),C("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(C("shape",e,t,n),C("minval",e,t,n),C("maxval",e,t,n),C("dtype",e,t,n))];case"RandomUniformInt":return[a.randomUniformInt(C("shape",e,t,n),C("minval",e,t,n),C("maxval",e,t,n),C("seed",e,t,n))];case"Range":{let r=C("start",e,t,n),s=C("stop",e,t,n),i=C("step",e,t,n);return[a.range(r,s,i,C("dtype",e,t,n))]}case"TruncatedNormal":{let r=C("shape",e,t,n),s=C("mean",e,t,n),i=C("stdDev",e,t,n),o=C("seed",e,t,n);return[a.truncatedNormal(r,s,i,C("dtype",e,t,n),o)]}case"Zeros":return[a.zeros(C("shape",e,t,n),C("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(C("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function MS(e,t,n){let a=C("boxes",e,t,n),r=C("scores",e,t,n),s=C("maxOutputSize",e,t,n),i=C("iouThreshold",e,t,n),o=C("scoreThreshold",e,t,n),l=C("softNmsSigma",e,t,n);return{boxes:a,scores:r,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var nce=async(e,t,n,a,r=wa)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=MS(e,t,n),h=await r.image.nonMaxSuppressionWithScoreAsync(s,i,o,l,c,u);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=MS(e,t,n),u=C("padToMaxOutputSize",e,t,n),h=await r.image.nonMaxSuppressionPaddedAsync(s,i,o,l,c,u);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=MS(e,t,n);return[await r.image.nonMaxSuppressionAsync(s,i,o,l,c)]}case"Where":{let s=r.cast(C("condition",e,t,n),"bool"),i=[await r.whereAsync(s)];return s.dispose(),i}case"ListDiff":return r.setdiff1dAsync(C("x",e,t,n),C("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},ace=(e,t,n,a=wa)=>{switch(e.op){case"LowerBound":{let r=C("sortedSequence",e,t,n),s=C("values",e,t,n);return[a.lowerBound(r,s)]}case"TopKV2":{let r=C("x",e,t,n),s=C("k",e,t,n),i=C("sorted",e,t,n),o=a.topk(r,s,i);return[o.values,o.indices]}case"UpperBound":{let r=C("sortedSequence",e,t,n),s=C("values",e,t,n);return[a.upperBound(r,s)]}case"Unique":{let r=C("x",e,t,n),s=a.unique(r);return[s.values,s.indices]}case"UniqueV2":{let r=C("x",e,t,n),s=C("axis",e,t,n),i=a.unique(r,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},rce=(e,t,n,a=wa)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=C("default",e,t,n);return[Ea(e.name,t,n)||r];case"Placeholder":return[Ea(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let u=C("x",e,t,n);return[lo(u)]}case"IdentityN":return C("x",e,t,n).map(u=>lo(u));case"Snapshot":let s=C("x",e,t,n);return[lo(s)];case"Shape":return[a.tensor1d(C("x",e,t,n).shape,"int32")];case"ShapeN":return C("x",e,t,n).map(u=>a.tensor1d(u.shape));case"Size":return[a.scalar(C("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(C("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":let i=C("x",e,t,n),o=C("data",e,t,n),l=C("message",e,t,n),c=C("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<o.length;u++)console.log(Array.prototype.slice.call(o[u].dataSync()).slice(0,c));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},sce=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=ze(0),this.tensorMap=new Map,Jn(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ze(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(a=>a.dispose()),this.tensorMap.clear(),X(()=>{let a=Tn(t),r=n.length,s=a.length;N.assert(r===s,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`);for(let i=0;i<r;i++){let o=n[i],l=a[i];Jn(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return X(()=>{let a=[];for(let r=0;r<n.length;r++){let s=n[r],i=this.findWithDefault(s,t);a.push(i)}return Bn(a)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},ice=async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{let r=a.getHashTableHandleByName(e.name);if(r!=null)return[r];{let s=C("keyDType",e,t,n),i=C("valueDType",e,t,n),o=new sce(s,i);return a.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let r=C("tableHandle",e,t,n,a),s=C("keys",e,t,n),i=C("values",e,t,n);return[await a.getHashTableById(r.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let r=C("tableHandle",e,t,n,a),s=C("keys",e,t,n),i=C("defaultValue",e,t,n);return[await a.getHashTableById(r.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let r=C("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},oce=(e,t,n,a=wa)=>{switch(e.op){case"ResizeBilinear":{let r=C("images",e,t,n),s=C("size",e,t,n),i=C("alignCorners",e,t,n),o=C("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(r,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let r=C("images",e,t,n),s=C("size",e,t,n),i=C("alignCorners",e,t,n),o=C("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(r,[s[0],s[1]],i,o)]}case"CropAndResize":{let r=C("image",e,t,n),s=C("boxes",e,t,n),i=C("boxInd",e,t,n),o=C("cropSize",e,t,n),l=C("method",e,t,n),c=C("extrapolationValue",e,t,n);return[a.image.cropAndResize(r,s,i,o,l,c)]}case"ImageProjectiveTransformV3":{let r=C("images",e,t,n),s=C("transforms",e,t,n),i=C("outputShape",e,t,n),o=C("fillValue",e,t,n),l=C("interpolation",e,t,n),c=C("fillMode",e,t,n);return[a.image.transform(r,s,l.toLowerCase(),c.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},lce=(e,t,n,a=wa)=>{switch(e.op){case"Equal":return[a.equal(C("a",e,t,n),C("b",e,t,n))];case"NotEqual":return[a.notEqual(C("a",e,t,n),C("b",e,t,n))];case"Greater":return[a.greater(C("a",e,t,n),C("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(C("a",e,t,n),C("b",e,t,n))];case"Less":return[a.less(C("a",e,t,n),C("b",e,t,n))];case"LessEqual":return[a.lessEqual(C("a",e,t,n),C("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(C("a",e,t,n),C("b",e,t,n))];case"LogicalNot":return[a.logicalNot(C("a",e,t,n))];case"LogicalOr":return[a.logicalOr(C("a",e,t,n),C("b",e,t,n))];case"Select":case"SelectV2":return[a.where(C("condition",e,t,n),C("a",e,t,n),C("b",e,t,n))];case"BitwiseAnd":return[a.bitwiseAnd(C("a",e,t,n),C("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},uce=(e,t,n,a=wa)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(C("a",e,t,n),C("b",e,t,n),C("transposeA",e,t,n),C("transposeB",e,t,n))];case"Einsum":return[a.einsum(C("equation",e,t,n),...C("tensors",e,t,n))];case"Transpose":return[a.transpose(C("x",e,t,n),C("perm",e,t,n))];case"_FusedMatMul":let[r,s]=C("fusedOps",e,t,n),i=r==="biasadd",o=s==="prelu",l=C("numArgs",e,t,n),c=C("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,h]=C("args",e,t,n);return[a.fused.matMul({a:C("a",e,t,n),b:C("b",e,t,n),transposeA:C("transposeA",e,t,n),transposeB:C("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:h,leakyreluAlpha:c})];case"MatrixBandPart":return[a.linalg.bandPart(C("a",e,t,n),C("numLower",e,t,n),C("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},cce=(e,t,n,a=wa)=>{switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(C("x",e,t,n),C("axis",e,t,n),C("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[a.batchNorm(C("x",e,t,n),C("mean",e,t,n),C("variance",e,t,n),C("offset",e,t,n),C("scale",e,t,n),C("epsilon",e,t,n))];case"FusedBatchNormV3":return[a.batchNorm(C("x",e,t,n),C("mean",e,t,n),C("variance",e,t,n),C("offset",e,t,n),C("scale",e,t,n),C("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(C("x",e,t,n),C("radius",e,t,n),C("bias",e,t,n),C("alpha",e,t,n),C("beta",e,t,n))];case"Softmax":return[a.softmax(C("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(C("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},hce=(e,t,n,a=wa)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:r,outputDenseValues:s}=a.raggedGather(C("paramsNestedSplits",e,t,n),C("paramsDenseValues",e,t,n),C("indices",e,t,n),C("outputRaggedRank",e,t,n));return r.concat(s)}case"RaggedRange":{let{rtNestedSplits:r,rtDenseValues:s}=a.raggedRange(C("starts",e,t,n),C("limits",e,t,n),C("splits",e,t,n));return[r,s]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor(C("shape",e,t,n),C("values",e,t,n),C("defaultValue",e,t,n),C("rowPartitionTensors",e,t,n),C("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},dce=(e,t,n,a=wa)=>{switch(e.op){case"Max":{let o=C("axis",e,t,n),l=C("keepDims",e,t,n);return[a.max(C("x",e,t,n),o,l)]}case"Mean":{let o=C("axis",e,t,n),l=C("keepDims",e,t,n);return[a.mean(C("x",e,t,n),o,l)]}case"Min":{let o=C("axis",e,t,n),l=C("keepDims",e,t,n);return[a.min(C("x",e,t,n),o,l)]}case"Sum":{let o=C("axis",e,t,n),l=C("keepDims",e,t,n);return[a.sum(C("x",e,t,n),o,l)]}case"All":{let o=C("axis",e,t,n),l=C("keepDims",e,t,n);return[a.all(C("x",e,t,n),o,l)]}case"Any":{let o=C("axis",e,t,n),l=C("keepDims",e,t,n);return[a.any(C("x",e,t,n),o,l)]}case"ArgMax":{let o=C("axis",e,t,n);return[a.argMax(C("x",e,t,n),o)]}case"ArgMin":{let o=C("axis",e,t,n);return[a.argMin(C("x",e,t,n),o)]}case"Prod":{let o=C("axis",e,t,n),l=C("keepDims",e,t,n);return[a.prod(C("x",e,t,n),o,l)]}case"Cumprod":{let o=C("axis",e,t,n),l=C("exclusive",e,t,n),c=C("reverse",e,t,n);return[a.cumprod(C("x",e,t,n),o,l,c)]}case"Cumsum":{let o=C("axis",e,t,n),l=C("exclusive",e,t,n),c=C("reverse",e,t,n);return[a.cumsum(C("x",e,t,n),o,l,c)]}case"Bincount":let r=C("x",e,t,n),s=C("weights",e,t,n),i=C("size",e,t,n);return[a.bincount(r,s,i)];case"DenseBincount":{let o=C("x",e,t,n),l=C("weights",e,t,n),c=C("size",e,t,n),u=C("binaryOutput",e,t,n);return[a.denseBincount(o,l,c,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},pce=(e,t,n,a=wa)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=C("n",e,t,n),s=C("axis",e,t,n),i=C("tensors",e,t,n);return i=i.slice(0,r),[a.concat(i,s)]}case"Gather":{let r=C("x",e,t,n),s=C("indices",e,t,n);return[a.gather(r,a.cast(s,"int32"),0)]}case"GatherV2":{let r=C("axis",e,t,n),s=C("batchDims",e,t,n),i=C("x",e,t,n),o=C("indices",e,t,n);return[a.gather(i,a.cast(o,"int32"),r,s)]}case"Reverse":{let r=C("dims",e,t,n),s=[];for(let o=0;o<r.length;o++)r[o]&&s.push(o);let i=C("x",e,t,n);return[a.reverse(i,s)]}case"ReverseV2":{let r=C("axis",e,t,n),s=C("x",e,t,n);return[a.reverse(s,r)]}case"Slice":{let r=C("begin",e,t,n),s=C("size",e,t,n);return[a.slice(C("x",e,t,n),r,s)]}case"StridedSlice":{let r=C("begin",e,t,n),s=C("end",e,t,n),i=C("strides",e,t,n),o=C("beginMask",e,t,n),l=C("endMask",e,t,n),c=C("ellipsisMask",e,t,n),u=C("newAxisMask",e,t,n),h=C("shrinkAxisMask",e,t,n),d=C("x",e,t,n);return[a.stridedSlice(d,r,s,i,o,l,c,u,h)]}case"Pack":return X(()=>{let r=C("axis",e,t,n),s=C("tensors",e,t,n),i=s[0].shape,o=a.squeeze(s[0]).shape,l=s.map(c=>{let u=N.arraysEqual(c.shape,i);if(!u&&!N.arraysEqual(a.squeeze(c).shape,o))throw new Error("the input tensors shape does not match");return u?c:a.reshape(c,i)});return[a.stack(l,r)]});case"Unpack":{let r=C("axis",e,t,n),s=C("tensor",e,t,n);return a.unstack(s,r)}case"Tile":{let r=C("reps",e,t,n);return[a.tile(C("x",e,t,n),r)]}case"Split":case"SplitV":{let r=C("axis",e,t,n),s=C("numOrSizeSplits",e,t,n),i=C("x",e,t,n);return a.split(i,s,r)}case"ScatterNd":{let r=C("indices",e,t,n),s=C("values",e,t,n),i=C("shape",e,t,n);return[a.scatterND(r,s,i)]}case"GatherNd":{let r=C("x",e,t,n),s=C("indices",e,t,n);return[a.gatherND(r,s)]}case"SparseToDense":{let r=C("sparseIndices",e,t,n),s=C("outputShape",e,t,n),i=C("sparseValues",e,t,n),o=C("defaultValue",e,t,n);return[a.sparseToDense(r,i,s,i.dtype===o.dtype?o:a.cast(o,i.dtype))]}case"TensorScatterUpdate":{let r=C("indices",e,t,n),s=C("values",e,t,n),i=C("tensor",e,t,n);return[a.tensorScatterUpdate(i,r,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},fce=(e,t,n,a=wa)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows(C("indices",e,t,n),C("values",e,t,n),C("denseShape",e,t,n),C("defaultValue",e,t,n));return[r,s,i,o]}case"SparseReshape":{let{outputIndices:r,outputShape:s}=a.sparse.sparseReshape(C("inputIndices",e,t,n),C("inputShape",e,t,n),C("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(C("data",e,t,n),C("indices",e,t,n),C("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(C("data",e,t,n),C("indices",e,t,n),C("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},mce=(e,t,n,a=wa)=>{switch(e.op){case"FFT":return[a.fft(C("x",e,t,n))];case"IFFT":return[a.ifft(C("x",e,t,n))];case"RFFT":return[a.rfft(C("x",e,t,n))];case"IRFFT":return[a.irfft(C("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},gce=(e,t,n,a=wa)=>{switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace(C("input",e,t,n),C("pattern",e,t,n),C("rewrite",e,t,n),C("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:r,nGramsSplits:s}=a.string.stringNGrams(C("data",e,t,n),C("dataSplits",e,t,n),C("separator",e,t,n),C("nGramWidths",e,t,n),C("leftPad",e,t,n),C("rightPad",e,t,n),C("padWidth",e,t,n),C("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{let{indices:r,values:s,shape:i}=a.string.stringSplit(C("input",e,t,n),C("delimiter",e,t,n),C("skipEmpty",e,t,n));return[r,s,i]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(C("input",e,t,n),C("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},yce=(e,t,n,a=wa)=>{switch(e.op){case"Cast":return[a.cast(C("x",e,t,n),C("dtype",e,t,n))];case"ExpandDims":{let r=C("axis",e,t,n);return[a.expandDims(C("x",e,t,n),r)]}case"Squeeze":{let r=C("axis",e,t,n);return[a.squeeze(C("x",e,t,n),r)]}case"Reshape":return[a.reshape(C("x",e,t,n),C("shape",e,t,n))];case"EnsureShape":return[a.ensureShape(C("x",e,t,n),C("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(C("x",e,t,n),C("padding",e,t,n),C("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(C("x",e,t,n),C("padding",e,t,n),C("constantValue",e,t,n))];case"SpaceToBatchND":{let r=C("blockShape",e,t,n),s=C("paddings",e,t,n);return[a.spaceToBatchND(C("x",e,t,n),r,s)]}case"BatchToSpaceND":{let r=C("blockShape",e,t,n),s=C("crops",e,t,n);return[a.batchToSpaceND(C("x",e,t,n),r,s)]}case"DepthToSpace":{let r=C("blockSize",e,t,n),s=C("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(C("x",e,t,n),r,s)]}case"BroadcastTo":return[a.broadcastTo(C("x",e,t,n),C("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(C("s0",e,t,n),C("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function yM(e,t,n,a,r=X){let s=((i,o,l)=>{switch(i.category){case"arithmetic":return r(()=>Hue(i,o,l));case"basic_math":return r(()=>que(i,o,l));case"control":return Jue(i,o,l);case"convolution":return r(()=>ece(i,o,l));case"creation":return r(()=>tce(i,o,l));case"dynamic":return nce(i,o,l);case"evaluation":return r(()=>ace(i,o,l));case"image":return r(()=>oce(i,o,l));case"graph":return r(()=>rce(i,o,l));case"logical":return r(()=>lce(i,o,l));case"matrices":return r(()=>uce(i,o,l));case"normalization":return r(()=>cce(i,o,l));case"ragged":return r(()=>hce(i,o,l));case"reduction":return r(()=>dce(i,o,l));case"slice_join":return r(()=>pce(i,o,l));case"sparse":return r(()=>fce(i,o,l));case"spectral":return r(()=>mce(i,o,l));case"string":return r(()=>gce(i,o,l));case"transformation":return r(()=>yce(i,o,l));case"hash_table":return ice(i,o,l,a);case"custom":let c=OB(i.op);if(c&&c.customExecutor)return c.customExecutor(new Gue(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return N.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var bM=class{constructor(e={},t={},n={},a={},r){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function vM(e,t,n,a){let r=new Set,s=[],i=null,o=null,l=new Set,c=new Set(Object.keys(e).map(d=>Nr(d)[0]));a=a||[];let u=new Set(a.map(d=>Nr(d.name)[0])),h=[...t];for(;h.length>0;){let d=h.pop();if((rc(d)||kce(d)||Tce(d))&&i==null&&(i=d,o=i.children.map(p=>p.name).filter(p=>r.has(p))),r.add(d.name),n[d.name]==null&&!c.has(d.name)&&!u.has(d.name)){if(d.inputs.length===0){s.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:i,syncInputs:o}}function bce(e,t){let{usedNodes:n,inputs:a}=t,r=Object.keys(a).map(g=>Nr(g)[0]).map(g=>e.nodes[g]),s=e.initNodes||[],i=g=>n.has(typeof g=="string"?g:g.name);function o(g){return[...new Map(g.map(y=>[y.name,y])).values()]}let l=o([...r,...e.weights,...s]).filter(i),c=o([...l,...Object.values(e.nodes)]).filter(i),u=new Map(c.map(g=>[g.name,g])),h={};for(let g of c){h[g.name]=h[g.name]||0;for(let y of g.children)i(y)||(h[y.name]=Number.POSITIVE_INFINITY),h[y.name]=(h[y.name]||0)+1}let d=Object.entries(h).filter(([,g])=>g===0).map(([g])=>g),p=[...d];for(;d.length>0;){let g=d.pop(),y=u.get(g);for(let v of y.children.filter(i))--h[v.name]===0&&(p.push(v.name),d.push(v.name))}let f=p.map(g=>u.get(g)),m=vce(f,l);return xce(m,l),m}function vce(e,t){let n=new Map(e.map(s=>[s.name,s])),a=t.map(s=>s.name),r=new Set(a);for(;a.length>0;){let s=a.pop(),i=n.get(s);for(let o of i.children)!n.has(o.name)||r.has(o.name)||(r.add(o.name),a.push(o.name))}return e.filter(s=>r.has(s.name))}var rx=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function xce(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),a=new Set(t.map(o=>o.name)),r=o=>a.has(typeof o=="string"?o:o.name),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o=="string"?o:o.name);for(let o of e){for(let l of o.children.filter(i)){if(!n.has(l.name))throw new rx(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new rx(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!r(o))for(let l of o.inputs){if(!n.has(l.name))throw new rx(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new rx(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function wce(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,a=e.map((o,l)=>rc(o)?n:l),r=o=>{let l=a[t.get(o.name)];return l??-1},s=e.map((o,l)=>o.children.map(r).reduce((c,u)=>Math.max(c,u),a[l])),i=new Map;for(let o=0;o<e.length;++o){let l=s[o];if(l===n)continue;let c=e[o],u=e[l];i.has(u.name)||i.set(u.name,[]),i.get(u.name).push(c)}return i}var _ce=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Sce=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Ice=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function rc(e){return _ce.has(e.op)}function kce(e){return Sce.has(e.op)}function Tce(e){return Ice.has(e.op)}var xM=class aU{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(a=>t[a].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(a=>{this._functionExecutorMap[a]=new aU(t.functions[a],this)})}getCompilationKey(t,n){let a=t.map(s=>s.name).sort(),r=n.map(s=>s.name).sort();return a.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,n){let a=vM(t,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:i}=a;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){let c=n.map(h=>h.name),u=Object.keys(t);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${u}]. Missing the following inputs: [${r}]`)}let o=bce(this.graph,a),l=wce(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return Jn(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,a])=>[n,this.cloneTensorList(a)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let a=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let r=a.map(d=>this.graph.nodes[Nr(d)[0]]),s=n.map(d=>Nr(d)[0]),i=new Set(s),o=s.map(d=>this.graph.nodes[d]);o.length===0&&(o=this._outputs);let l=this.getCompilationKey(r,o),c=this.compiledMap.get(l);c==null&&(c=this.compile(t,o),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=Z().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let u={},h={};return X(()=>{let d=new bM(this.weightMap,u,h,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{let[v,x]=Nr(y,d),w=[];w[x]=t[y],p[v]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[v]=this.cloneTensorList(w))});let f=this.getFrozenTensorIds(p),{orderedNodes:m,nodeLiveUntilMap:g}=c;for(let y of m){if(p[y.name])continue;let v=yM(y,p,d,this._resourceManager);if(N.isPromise(v))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);p[y.name]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(v)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,p,d,f,i,g.get(y.name))}return this.parent==null&&d.dispose(f),n.map(y=>Ea(y,p,d))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(a=>t[a]).map(a=>a.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(t,n,a,r,s,i,o){if(!(rc(n)||i.has(t))){for(let l of a[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(rc(l))continue;let c=dM(l.name,a,r);if(c!=null)for(let u of c){if(!u||u.kept||s.has(u.id))continue;let h=o[u.id];h===1?(u.dispose(),delete o[u.id]):h!=null&&o[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,a,r,s,i){function o(l){return rc(l)||s.has(l.name)}if(!(rc(t)||i==null))for(let l of i){if(o(l))continue;let c=dM(l.name,n,a);for(let u of c)!u||u.kept||r.has(u.id)||u.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,a=!1,r={},s={}){this.disposeIntermediateTensors(),a||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=Z().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let i=new bM(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,a),l=n.map(d=>Ea(d,o,i)),c=l.map(d=>d.id),u=Object.keys(t).map(d=>t[d].id),h=new Set([...c,...u,...this.weightIds]);return Object.values(o).forEach(d=>{d.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&i.dispose(h),l}async executeFunctionAsync(t,n,a){let r=t.reduce((s,i,o)=>(s[this.inputs[o].name]=i,s),{});return this._executeAsync(r,this.outputNodes,!0,n,a)}async executeWithControlFlow(t,n,a,r){let s=Object.keys(t),i=s.map(w=>this.graph.nodes[Nr(w)[0]]),o=a.map(w=>Nr(w)[0]),l=new Set(o),c=o.map(w=>this.graph.nodes[w]);c.length===0&&(c=this._outputs);let{usedNodes:u,missingInputs:h,dynamicNode:d,syncInputs:p}=vM(t,c,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:n.currentContext})),m=Object.assign({},this.weightMap);Object.keys(t).forEach(w=>{let[k,M]=Nr(w),S=[];S[M]=t[w],m[k]=S});let g={},y=this.getFrozenTensorIds(m),v={};for(;f.length>0;){let w=this.processStack(i,f,n,m,v,y,l,g,u);await Promise.all(w)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let x=c.filter(w=>!rc(w)&&!Ea(w.name,m,n)).map(w=>w.name);if(x.length>0){let w="";throw d!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${s}]. Consider providing the following inputs: [${h}]. ${w}`)}return m}processStack(t,n,a,r,s,i,o,l,c){let u=[];for(;n.length>0;){let h=n.pop();a.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&C("isConstant",h.node,r,a)&&([d]=oo(h.node.name,a)),r[h.node.name]==null){let p=yM(h.node,r,a,this._resourceManager);d||([d]=oo(h.node.name,a));let f=a.currentContext;N.isPromise(p)?u.push(p.then(m=>(r[d]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(m)),a.currentContext=f,this.checkTensorForDisposal(d,h.node,r,a,i,o,l),this.processChildNodes(h.node,n,a,r,s,c),m))):(r[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,r,a,i,o,l),this.processChildNodes(h.node,n,a,r,s,c))}else this.processChildNodes(h.node,n,a,r,s,c)}return u}processChildNodes(t,n,a,r,s,i){t.children.forEach(o=>{let[l]=oo(o.name,a);s[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(c=>!!Ea(c,r,a))&&(s[l]=!0,n.push({contexts:a.currentContext,node:o})):o.inputNames.every(c=>!!Ea(c,r,a))&&(s[l]=!0,n.push({contexts:a.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let a=t[n],[r]=Nr(n),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,o=i.length===a.shape.length&&a.shape.every((l,c)=>i[c]===-1||i[c]===l);N.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${a.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&N.assert(a.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${a.dtype}`)})}mapInputs(t){var n,a;let r={};for(let s in t){let i=(a=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||a===void 0?void 0:a[s];i!=null?r[i.name]=t[s]:r[s]=t[s]}return r}checkInputs(t){let n=Object.keys(t).filter(a=>{let[r]=Nr(a);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var a,r;let s=(r=(a=this._signature)===null||a===void 0?void 0:a.outputs)===null||r===void 0?void 0:r[n];return s!=null?s.name:n},{})}checkOutputs(t){t.forEach(n=>{let[a]=Nr(n);if(!this.graph.nodes[a])throw new Error(`The output '${n}' is not found in the graph`)})}},Ece=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},Nce="?tfjs-format=file",Cce="model.json",MC=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=Ca){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new Ece}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return N.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await i4(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,a=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let r=this.artifacts.userDefinedMetadata;r.signature!=null&&(a=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}if(this.signature=a,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new xM(pM.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let r=pM.Instance.transformGraph(e.modelInitializer);this.initializer=new xM(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof at?[e]:e,n={};return t.forEach((a,r)=>n[this.structuredOutputKeys[r]]=a),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof at)&&!Array.isArray(e)){let r=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(r!=null)for(let s in r){let i=r[s];i.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let a=0;return this.inputNodes.reduce((r,s)=>{var i,o,l;let c=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[s])===null||l===void 0?void 0:l.resourceId;return c!=null?r[s]=this.resourceIdToCapturedInput[c]:r[s]=e[a++],r},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let a=0;a<n.length;a++){let r=n[a],s=t[r];this.resourceIdToCapturedInput[s.resourceId]=e[a]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&et(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function Ace(e,t={},n=Ca){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=Dce(e));let a=new MC(e,t,n);return await a.load(),a}function Rce(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[a,r]=e;if(!a)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in a))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in a))throw new Error("Model JSON is missing 'weightsManifest'");let s=Ca.getWeightSpecs(a.weightsManifest),i=Ca.getModelArtifactsForJSONSync(a,s,r);t=Ca.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=Ca.fromMemorySync(e);else throw new Error("Unknown model format");let n=new MC(t);return n.load(),n}function Dce(e){return e.endsWith("/")||(e=e+"/"),`${e}${Cce}${Nce}`}var $ce="4.22.0",rU={};tt(rU,{CSVDataset:()=>mU,Dataset:()=>Om,FileDataSource:()=>_U,TextLineDataset:()=>fU,URLDataSource:()=>SU,array:()=>nhe,csv:()=>mhe,func:()=>ghe,generator:()=>yhe,microphone:()=>vhe,version_data:()=>xhe,webcam:()=>bhe,zip:()=>ahe});var Mce=cu(zw()),Oce=cu(zw());function Fce(e,t){return j0(e,t)}function j0(e,t,n=new Map,a=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let r=t(e);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(nf(e)){let s=Array.isArray(e)?[]:{};a.add(e);for(let i in e){let o=e[i],l=j0(o,t,n,a);s[i]=l}return a.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,r.value),r.value}function Lce(e,t=iU){return sU(e,t)}function sU(e,t,n=new Set){let a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");let r=t(e);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(nf(a)){let s=Array.isArray(a)?[]:{};n.add(a);for(let i in a){let o=e.map(c=>c[i]),l=sU(o,t,n);s[i]=l}return n.delete(a),s}else throw new Error(`Can't recurse into non-iterable type: ${a}`);else return r.value}function iU(e){return e===null?null:nf(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function oU(e,t){let n=new Map;j0(e,t,n);for(let a of Array.from(n.keys())){let r=n.get(a);if(N.isPromise(r)){let s=await r;n.set(a,s)}}return j0(e,t,n)}function nf(e){let t=!1;if(Z().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=Tz();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof at)&&!(e instanceof Promise)&&!t)}function zce(e){return e==null||Pce(e)||Array.isArray(e)||typeof e=="object"&&e instanceof at||N.isTypedArray(e)}function Pce(e){return e===null||typeof e!="object"&&typeof e!="function"}function Vce(e){return Fce(e,Bce)}function Bce(e){return e instanceof at?{value:e.clone(),recurse:!1}:nf(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var lU=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},uU=class cU extends lU{constructor(){super(cU.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),a=this.length();for(let r=0;r<a;r++)n[r]=this.get(this.wrap(this.begin+r));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=a}};uU.INITIAL_CAPACITY=32;function hU(e){return new jce(e)}function OC(e){return new Gce(e)}function Uce(e,t){return new dU(e,t)}function Wce(e,t=yl.FAIL){return new ehe(e,t)}var xa=class{async toArray(){let t=[],n=await this.next();for(;!n.done;)t.push(n.value),n=await this.next();return t}async toArrayForTest(){let t=this.prefetch(100),n=[],a=await t.next();for(;!a.done;)n.push(a.value),a=await t.next();return n}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let n=await this.next(),a=t(n.value);for(;!n.done&&a;)n=await this.next(),a=t(n.value)}handleErrors(t){return new Zce(this,t)}filter(t){return new Qce(this,t)}map(t){return new Yce(this,t)}mapAsync(t){return new wM(this,t)}serialMapAsync(t){return new wM(this,t).serial()}flatmap(t){return new Jce(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(n=>n===!0)}rowMajorBatch(t,n=!0){return new Xce(this,t,n)}columnMajorBatch(t,n=!0,a=iU){return this.rowMajorBatch(t,n).map(r=>Lce(r,a))}concatenate(t,n){return new dU(hU([this,t]),n)}take(t){return t<0||t==null?this:new Kce(this,t)}skip(t){return t<0||t==null?this:new qce(this,t)}prefetch(t){return new pU(this,t)}shuffle(t,n){return new the(this,t,n)}serial(){return new Hce(this)}},jce=class extends xa{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:Vce(e),done:!1}}},Gce=class extends xa{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},Hce=class extends xa{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},qce=class extends xa{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;et(e.value)}return this.upstream.next()}},Kce=class extends xa{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},Xce=class extends xa{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},Qce=class extends xa{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;et(e.value)}}},Yce=class extends xa{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Ks.getTensorsInContainer(e.value),n=this.transform(e.value),a=Ks.getTensorsInContainer(n);for(let r of t)Ks.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},Zce=class extends xa{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},wM=class extends xa{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Ks.getTensorsInContainer(e.value),n=await this.transform(e.value),a=Ks.getTensorsInContainer(n);for(let r of t)Ks.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},FC=class extends xa{constructor(){super(),this.outputQueue=new uU,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},Jce=class extends FC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Ks.getTensorsInContainer(e.value),n=this.transform(e.value),a=Ks.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let r of t)Ks.isTensorInList(r,a)||r.dispose();return!0}},dU=class extends xa{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},yl;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(yl||(yl={}));var ehe=class extends xa{constructor(e,t=yl.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function a(s){return s instanceof xa?{value:s.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let r=await oU(this.iterators,a);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case yl.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case yl.SHORTEST:return{value:null,done:!0};case yl.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},pU=class extends xa{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new lU(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},the=class extends pU{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Oce.alea(n||N.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},Om=class{constructor(){this.size=null}batch(e,t=!0){let n=this;N.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let a;return this.size===1/0||this.size==null?a=this.size:t?a=Math.ceil(this.size/e):a=Math.floor(this.size/e),Tr(async()=>(await n.iterator()).columnMajorBatch(e,t,rhe),a)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Tr(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Tr(async()=>(await t.iterator()).filter(a=>X(()=>e(a))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Tr(async()=>(await t.iterator()).map(n=>X(()=>e(n))),this.size)}mapAsync(e){let t=this;return Tr(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Tr(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Tr(async()=>{let a=OC(async()=>({value:await t.iterator(),done:!1}));return Uce(a.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Tr(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let a=this,r=Mce.alea(t||N.now().toString());return Tr(async()=>{let s=r.int32();return n&&(s+=r.int32()),(await a.iterator()).shuffle(e,s.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Tr(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Om.MAX_BUFFER_SIZE=1e4;function Tr(e,t=null){return new class extends Om{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function nhe(e){return Tr(async()=>hU(e),e.length)}function ahe(e){if(!nf(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return Tr(async()=>{let n=await oU(e,a=>{if(a instanceof Om)return{value:a.iterator(),recurse:!1};if(nf(a))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return Wce(n,yl.SHORTEST)},t)}function rhe(e){if(e===null)return null;let t=e[0];return zce(t)?{value:she(e),recurse:!1}:{value:null,recurse:!0}}function she(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof at?Bn(e):Za(e)}var fU=class extends Om{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},sx='"',yg=Symbol("out"),_M=Symbol("field"),ix=Symbol("quote"),OS=Symbol("quoteafterquote"),SM=Symbol("quoteinquote"),mU=class extends Om{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&N.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((a,r)=>(a[r]=a[r]+1||1,a),{}),n=Object.keys(t).filter(a=>t[a]>1);if(N.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let a of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(a)===-1)throw new Error('The key "'+a+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new fU(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(N.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},a={};for(let r=0;r<this.fullColumnNames.length;r++){let s=this.fullColumnNames[r],i=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[r],l=null;if(o==="")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let c=Number(o);if(isNaN(c))i&&i.dtype==="bool"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=c;else switch(i.dtype){case"float32":l=c;break;case"int32":l=Math.floor(c);break;case"bool":l=this.getBoolean(o);break;default:l=c}}i&&i.isLabel?a[s]=l:n[s]=l}}return Object.keys(a).length===0?n:{xs:n,ys:a}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],a=0,r=e.length,s=yg;for(let i=0;i<r;i++)switch(s){case yg:switch(e.charAt(i)){case sx:a=i+1,s=ix;break;case this.delimiter:if(a=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),s=yg;break;default:s=_M,a=i;break}break;case _M:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(a,i)),s=yg,a=i+1;break}break;case ix:switch(e.charAt(i)){case sx:s=OS;break}break;case OS:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(a,i-1)),s=yg,a=i+1;break;case sx:s=ix;break;default:s=SM;break}break;case SM:switch(e.charAt(i)){case sx:s=ix;break}break}if(s===OS?n.push(e.substring(a,r-1)):n.push(e.substring(a)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},ihe=class gU extends xa{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!Z().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new gU(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(a){throw new Error(`Error thrown while initializing video stream: ${a.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,a=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(a.freqDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(a.timeDataQueue);n=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],a=0;return new Promise(r=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++a===this.numFrames&&(clearInterval(s),r({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,a=new Float32Array(t.length*n);return t.forEach((r,s)=>a.set(r,s*n)),a}getTensorFromAudioDataArray(t,n){let a=new Float32Array(N.sizeFromShape(n));return a.set(t,a.length-t.length),Za(a,n)}},ohe=class yU extends xa{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Ft([0],"int32"),this.webcamConfig.centerCrop){let a=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-a)/2,i=(1-r)/2,o=s+a,l=r+i;this.cropBox=Ai([i,s,l,o],[1,4])}else this.cropBox=Ai([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!Z().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let a=new yU(t,n);return await a.start(),a}async start(){this.webcamConfig.facingMode&&N.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Xb.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return X(()=>{let n=pa(ye(t,"float32"),0),a;a=Yr.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=a.shape;return K(a,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},bU=class{},vU=class extends xa{split(e){return new lhe(this,e)}},lhe=class extends vU{constructor(e,t){super(),this.upstream=e,this.impl=new uhe(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},uhe=class extends FC{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},che=class extends xa{decodeUTF8(){return new hhe(this)}},hhe=class extends vU{constructor(e){super(),this.upstream=e,this.impl=new dhe(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},dhe=class extends FC{constructor(e){if(super(),this.upstream=e,Z().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=Tz();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return Z().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},xU=class extends che{constructor(e,t={}){super(),this.file=e,this.options=t,N.assert(e instanceof Uint8Array||(Z().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let a=new FileReader;a.onload=s=>{let i=a.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},a.onabort=s=>t(new Error("Aborted")),a.onerror=s=>t(new Error(s.type));let r=this.file.slice(this.offset,n);a.readAsArrayBuffer(r)}this.offset=n}),done:!1}}};async function phe(e,t={},n){let a,r;typeof e=="string"?a=e:(a=e.url,r=fhe(e));let s=await(0,N.fetch)(a,r);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new xU(i,t)}else throw new Error(s.statusText)}var fhe=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function wU(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var _U=class extends bU{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(wU(this.input)&&Z().get("IS_NODE")){let e=E2();this.input=e.readFileSync(this.input.slice(7))}return new xU(this.input,this.options)}},SU=class extends bU{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return wU(this.url)?new _U(this.url,this.fileOptions).iterator():phe(this.url,this.fileOptions)}};function mhe(e,t={}){return new mU(new SU(e),t)}function ghe(e){let t=OC(e);return Tr(async()=>t)}function yhe(e){return Tr(async()=>{let t=await e();return OC(()=>t.next())})}async function bhe(e,t){return ohe.create(e,t)}async function vhe(e){return ihe.create(e)}var xhe="4.22.0";function $e(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&N.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var whe=Hi.whereImpl,LC=class IU extends ob{nextDataId(){return IU.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Pw(this,xs())}write(t,n,a){this.firstUse&&(this.firstUse=!1,Z().get("IS_NODE")&&O.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:a,refCount:1}),r}makeTensorInfo(t,n,a){let r;if(n==="string"&&a!=null&&a.length>0&&N.isString(a[0])){let s=a.map(i=>N.encodeString(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return{dataId:r,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,a,r,s){this.data.set(t,{values:n,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:a}=this.data.get(t);if(n==="complex64"){let r=this.readSync(a.real.dataId),s=this.readSync(a.imag.dataId);return O.mergeRealAndImagArrays(r,s)}return N.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let a=n.map(r=>N.decodeString(r));return ut(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ut(t.shape,t.dtype,n)}makeOutput(t,n,a){return xs().makeTensorFromTensorInfo(this.makeTensorInfo(n,a,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:a}=this.data.get(t);a!=null&&(this.disposeData(a.real.dataId,!0),this.disposeData(a.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=N.now();return t(),{kernelMs:N.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){$e([t],"where");let n=this.readSync(t.dataId);return whe(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};LC.nextDataId=0;var zC={};tt(zC,{addImpl:()=>EU,bincountImpl:()=>VC,bincountReduceImpl:()=>NU,bitwiseAndImpl:()=>CU,castImpl:()=>TU,ceilImpl:()=>AU,concatImpl:()=>BC,equalImpl:()=>RU,expImpl:()=>$U,expm1Impl:()=>OU,floorDivImpl:()=>LU,floorImpl:()=>FU,gatherNdImpl:()=>zU,gatherV2Impl:()=>PU,greaterEqualImpl:()=>BU,greaterImpl:()=>VU,lessEqualImpl:()=>WU,lessImpl:()=>UU,linSpaceImpl:()=>jU,logImpl:()=>GU,maxImpl:()=>HU,maximumImpl:()=>qU,minimumImpl:()=>KU,multiplyImpl:()=>UC,negImpl:()=>XU,notEqualImpl:()=>QU,prodImpl:()=>YU,raggedGatherImpl:()=>ZU,raggedRangeImpl:()=>JU,raggedTensorToTensorImpl:()=>e6,rangeImpl:()=>jC,rsqrtImpl:()=>t6,scatterImpl:()=>oc,sigmoidImpl:()=>xde,simpleAbsImpl:()=>kU,sliceImpl:()=>H0,sparseFillEmptyRowsImpl:()=>a6,sparseReshapeImpl:()=>r6,sparseSegmentReductionImpl:()=>GC,sqrtImpl:()=>Sde,squaredDifferenceImpl:()=>s6,staticRegexReplaceImpl:()=>i6,stridedSliceImpl:()=>o6,stringNGramsImpl:()=>HC,stringSplitImpl:()=>qC,stringToHashBucketFastImpl:()=>KC,subImpl:()=>l6,tileImpl:()=>u6,topKImpl:()=>h6,transposeImpl:()=>WC,uniqueImpl:()=>QC});function kU(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var _he=e=>{let{x:t}=e.inputs,n=e.backend;$e(t,"abs");let a=new Float32Array(N.sizeFromShape(t.shape)),r=n.data.get(t.dataId).values;return a=kU(r),n.makeOutput(a,t.shape,t.dtype)},She={kernelName:Sf,backendName:"cpu",kernelFunc:_he};function Mn(e){return(t,n,a,r,s)=>{let i=O.assertAndGetBroadcastShape(t,n),o=i.length,l=N.computeStrides(i),c=N.sizeFromShape(i),u=N.getTypedArrayFromDType(s,c),h=t.length,d=n.length,p=N.computeStrides(t),f=N.computeStrides(n),m=O.getBroadcastDims(t,i),g=O.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=e(a[y%a.length],r[y%r.length]);else for(let y=0;y<u.length;++y){let v=N.indexToLoc(y,o,l),x=v.slice(-h);m.forEach(S=>x[S]=0);let w=N.locToIndex(x,h,p),k=v.slice(-d);g.forEach(S=>k[S]=0);let M=N.locToIndex(k,d,f);u[y]=e(a[w],r[M])}return[u,i]}}function Ar(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=n.makeTensorInfo(a.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",i)},o}var Ihe={kernelName:Uw,backendName:"cpu",kernelFunc:Ar};function G0(e,t,n="float32"){if(n==="complex64"){let r=G0(e,t,"float32"),s=G0(e,t,"float32");return Ar({inputs:{real:r,imag:s},backend:e})}let a=N.makeZerosTypedArray(N.sizeFromShape(t),n);return e.makeTensorInfo(t,n,a)}function Pi(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var khe={kernelName:Eh,backendName:"cpu",kernelFunc:Pi};function Lc(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var The={kernelName:e1,backendName:"cpu",kernelFunc:Lc};function TU(e,t,n,a){if(a==="int32"){let r=Int32Array.from(e);return[t,"int32",r]}if(a==="bool"){let r=N.toTypedArray([0],n),[s,i]=Mn((o,l)=>o!==l?1:0)(t,[],e,r,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${a}`)}function Zl(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s==="complex64"){if(r.dtype==="complex64")return Pi({inputs:{x:r},backend:n});let u=G0(n,r.shape,r.dtype),h=Zl({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),d=Ar({inputs:{real:h,imag:u},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),d}if(r.dtype==="complex64"){let u=Lc({inputs:{input:r},backend:n}),h=Zl({inputs:{x:u},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(u),h}if(!N.hasEncodingLoss(r.dtype,s)){let u=Pi({inputs:{x:r},backend:n});return{dataId:u.dataId,shape:u.shape,dtype:s}}let i=n.data.get(r.dataId).values,[o,l,c]=TU(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,l,c)}var Ehe={kernelName:lh,backendName:"cpu",kernelFunc:Zl};function ia(e,t,n,a){return n==null?({inputs:r,backend:s})=>{let{a:i,b:o}=r,l=s;$e([i,o],e);let c=l.data.get(i.dataId).values,u=l.data.get(o.dataId).values,h=i.dtype==="string"?O.fromUint8ToStringArray(c):c,d=i.dtype==="string"?O.fromUint8ToStringArray(u):u,p=a||i.dtype,[f,m]=t(i.shape,o.shape,h,d,p);return l.makeTensorInfo(m,p,f)}:({inputs:r,backend:s})=>{let{a:i,b:o}=r,l=s;if(i.dtype==="complex64"||o.dtype==="complex64"){let c=Zl({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.real,d=u.complexTensorInfos.imag,p=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,m=Zl({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,v=g.complexTensorInfos.imag,x=l.data.get(y.dataId).values,w=l.data.get(v.dataId).values,[k,M,S]=n(i.shape,o.shape,p,f,x,w),I=l.makeTensorInfo(S,"float32",k),E=l.makeTensorInfo(S,"float32",M),R=Ar({inputs:{real:I,imag:E},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo(E),R}else{let c=l.data.get(i.dataId).values,u=l.data.get(o.dataId).values,h=a||i.dtype,[d,p]=t(i.shape,o.shape,c,u,h);return l.makeTensorInfo(p,h,d)}}}function PC(e){return(t,n,a,r,s,i)=>{let o=O.assertAndGetBroadcastShape(t,n),l=N.sizeFromShape(o),c=o.length,u=N.computeStrides(o),h=N.getTypedArrayFromDType("float32",l),d=N.getTypedArrayFromDType("float32",l),p=O.getBroadcastDims(t,o),f=O.getBroadcastDims(n,o),m=O.mergeRealAndImagArrays(a,r),g=O.mergeRealAndImagArrays(s,i),y=t.length,v=N.computeStrides(t),x=n.length,w=N.computeStrides(n);if(p.length+f.length===0)for(let k=0;k<h.length;k++){let M=k%m.length,S=k%g.length,I=e(m[M*2],m[M*2+1],g[S*2],g[S*2+1]);h[k]=I.real,d[k]=I.imag}else for(let k=0;k<h.length;k++){let M=N.indexToLoc(k,c,u),S=M.slice(-y);p.forEach(_=>S[_]=0);let I=N.locToIndex(S,y,v),E=M.slice(-x);f.forEach(_=>E[_]=0);let R=N.locToIndex(E,x,w),A=e(m[I*2],m[I*2+1],g[R*2],g[R*2+1]);h[k]=A.real,d[k]=A.imag}return[h,d,o]}}var EU=Mn((e,t)=>e+t),Nhe=PC((e,t,n,a)=>({real:e+n,imag:t+a})),af=ia(hu,EU,Nhe),Che={kernelName:hu,backendName:"cpu",kernelFunc:af};function VC(e,t,n,a,r){let s=N.sizeFromShape(a),i=N.makeZerosTypedArray(r,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(s>0?i[l]+=t[o]:i[l]+=1)}return i}function NU(e,t,n,a=!1){let r=e.shape[0],s=e.shape[1],i=ut([r,n],t.dtype);for(let o=0;o<r;o++)for(let l=0;l<s;l++){let c=e.get(o,l);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(a?i.set(1,o,c):t.size>0?i.set(i.get(o,c)+t.get(o,l),o,c):i.set(i.get(o,c)+1,o,c))}return i}var CU=Mn((e,t)=>e&t),Ahe=ia(Rf,CU),Rhe={kernelName:Rf,backendName:"cpu",kernelFunc:Ahe};function qi(e){return(t,n,a)=>{let r=N.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)r[s]=e(t[s],a);return r}}function jt(e,t,n){let a=qi(t);return xu(e,a,n)}function xu(e,t,n){return({inputs:a,attrs:r,backend:s})=>{let{x:i}=a;$e(i,e);let o=s,l=o.data.get(i.dataId).values,c;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=O.fromUint8ToStringArray(l)}else c=l;let u=n||i.dtype,h=t(c,u,r);return o.makeTensorInfo(i.shape,u,h)}}var AU=qi(e=>Math.ceil(e)),Dhe=xu(uh,AU),$he={kernelName:uh,backendName:"cpu",kernelFunc:Dhe};function BC(e,t,n,a){let r=N.getArrayFromDType(n,N.sizeFromShape(t));if(a&&n!=="string"){let s=0;e.forEach(i=>{let o=N.sizeFromShape(i.shape);r.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{let o=n==="string"?O.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let c=0;c<i.shape[0];++c){let u=c*t[1]+s;for(let h=0;h<i.shape[1];++h)r[u+h]=o[l++]}s+=i.shape[1]})}return r}var RU=Mn((e,t)=>e===t?1:0),DU=ia(Pf,RU,null,"bool"),Mhe={kernelName:Pf,backendName:"cpu",kernelFunc:DU},$U=qi(e=>Math.exp(e)),MU=xu(wh,$U,"float32"),Ohe={kernelName:wh,backendName:"cpu",kernelFunc:MU},OU=qi(e=>Math.expm1(e)),Fhe=xu(_h,OU),Lhe={kernelName:_h,backendName:"cpu",kernelFunc:Fhe},FU=qi(e=>Math.floor(e)),zhe=xu(Sh,FU),Phe={kernelName:Sh,backendName:"cpu",kernelFunc:zhe},LU=Mn((e,t)=>Math.floor(e/t)),Vhe=ia(Ih,LU,null,"int32"),Bhe={kernelName:Ih,backendName:"cpu",kernelFunc:Vhe};function zU(e,t,n,a,r,s,i,o,l){let c=ut([a,s],n);for(let u=0;u<a;u++){let h=[],d=0;for(let p=0;p<r;p++){let f=e[u*r+p];d+=f*i[p],h.push(f)}if(d<0||d>=l/s)throw new Error(`Invalid indices: ${h} does not index into ${o}`);for(let p=0;p<s;p++)c.values[u*s+p]=t.get(...t.indexToLoc(d*s+p))}return c}function PU(e,t,n){let a=ut(n,e.dtype);for(let r=0;r<a.size;++r){let s=a.indexToLoc(r).slice(),i=s[0],o=s[2],l=t.locToIndex([i,o]);s[2]=t.values[l];let c=e.locToIndex(s);0<=c&&c<e.values.length&&(a.values[r]=e.values[c])}return a}var VU=Mn((e,t)=>e>t?1:0),Uhe=ia(jf,VU,null,"bool"),Whe={kernelName:jf,backendName:"cpu",kernelFunc:Uhe},BU=Mn((e,t)=>e>=t?1:0),jhe=ia(Th,BU,null,"bool"),Ghe={kernelName:Th,backendName:"cpu",kernelFunc:jhe},UU=Mn((e,t)=>e<t?1:0),Hhe=ia(Gf,UU,null,"bool"),qhe={kernelName:Gf,backendName:"cpu",kernelFunc:Hhe},WU=Mn((e,t)=>e<=t?1:0),Khe=ia(Hf,WU,null,"bool"),Xhe={kernelName:Hf,backendName:"cpu",kernelFunc:Khe};function jU(e,t,n){let a=(t-e)/(n-1),r=N.makeZerosTypedArray(n,"float32");r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+a;return r}var GU=qi(e=>Math.log(e)),Qhe=xu(Dh,GU),Yhe={kernelName:Dh,backendName:"cpu",kernelFunc:Qhe};function HU(e,t,n,a){let r=N.getTypedArrayFromDType(a,N.sizeFromShape(n));for(let s=0;s<r.length;++s){let i=s*t,o=e[i];for(let l=0;l<t;++l){let c=e[i+l];(Number.isNaN(c)||c>o)&&(o=c)}r[s]=o}return r}var qU=Mn((e,t)=>Math.max(e,t)),Zhe=ia(Fh,qU),Jhe={kernelName:Fh,backendName:"cpu",kernelFunc:Zhe},KU=Mn((e,t)=>Math.min(e,t)),ede=ia(Vh,KU),tde={kernelName:Vh,backendName:"cpu",kernelFunc:ede},UC=Mn((e,t)=>e*t),nde=PC((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n})),i_=ia(Wh,UC,nde),ade={kernelName:Wh,backendName:"cpu",kernelFunc:i_};function XU(e,t,n){let a=N.createScalarValue(-1,n);return UC([],t,a,e,n)}function rde(e){let{inputs:t,backend:n}=e,{x:a}=t;$e(a,"neg");let r=n.data.get(a.dataId).values,[s,i]=XU(r,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,s)}var sde={kernelName:em,backendName:"cpu",kernelFunc:rde},QU=Mn((e,t)=>e!==t?1:0),ide=ia(tm,QU,null,"bool"),ode={kernelName:tm,backendName:"cpu",kernelFunc:ide};function WC(e,t,n,a,r){let s=t.length,i=N.sizeFromShape(t),o=N.computeStrides(t),l=N.computeStrides(r),c=N.getTypedArrayFromDType(n,N.sizeFromShape(r));for(let u=0;u<i;++u){let h=N.indexToLoc(u,s,o),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[a[f]];let p=N.locToIndex(d,s,l);c[p]=e[u]}return c}function br(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;$e(r,"transpose");let i=r.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=r.shape[s[u]];let l=a.data.get(r.dataId).values,c=WC(l,r.shape,r.dtype,s,o);return{dataId:a.write(c,o,r.dtype),shape:o,dtype:r.dtype}}var lde={kernelName:bo,backendName:"cpu",kernelFunc:br};function YU(e,t,n,a){let[r,s]=O.computeOutAndReduceShapes(e,a),i=us(t,"int32"),o=N.makeZerosTypedArray(N.sizeFromShape(r),i),l=N.sizeFromShape(s);for(let c=0;c<o.length;++c){let u=c*l,h=1;for(let d=0;d<l;++d)h*=n[u+d];o[c]=h}return{outVals:o,outShape:r,outDtype:i}}function ude(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;$e(r,"prod");let o=r.shape.length,l=N.parseAxisParam(s,r.shape),c=O.getAxesPermutation(l,o),u=l,h=r,d=[];c!=null&&(h=br({inputs:{x:r},backend:n,attrs:{perm:c}}),d.push(h),u=O.getInnerMostAxes(u.length,o));let p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=YU(h.shape,h.dtype,p,u),y=m;return i&&(y=O.expandShapeToKeepDim(m,l)),d.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(y,g,f)}var cde={kernelName:Kh,backendName:"cpu",kernelFunc:ude};function hde(e,t,n){e.forEach((a,r)=>{if(a<0||a>=n){let s=N.indexToLoc(r,t.length,N.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${a} is not in [0, ${n})`)}})}function dde(e,t){for(let n=0;n<e.length;++n){let a=e[n],r=n===e.length-1?t:e[n+1].length;if(a.length===0)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let s=1;s<a.length;++s)if(a[s-1]>a[s])throw new Error("Ragged splits must be sorted in ascending order")}}function pde(e,t,n,a){let r=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);dde(n,a);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];let u=t[c+1];for(let h=1;h<l+1;++h)o[c].push(h*u)}for(let c=0;c<e.length;++c){let u=e[c],h=e[c]+1;for(let d=0;d<n.length;++d){let p=n[d],f=d+t.length-1;if(f>=0){let m=o[f],g=m[m.length-1]-p[u];for(let y=u;y<h;++y)o[f].push(p[y+1]+g)}u=p[u],h=p[h]}h!==u&&(r.push([u,h]),s+=h-u)}return{outSplits:o,valueSlices:r,numValues:s}}function fde(e){let t=[];for(let n=0;n<e.length;++n){let a=e[n].length,r=N.getArrayFromDType("int32",a);t.push(r),e[n].forEach((s,i)=>r[i]=s)}return t}function IM(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function mde(e,t,n,a,r,s){let i=IM(t,2)[1],o=IM(s,2)[1],l=0;for(let c of n)for(let u=c[0];u<c[1];++u){for(let h=0;h<a;++h)r[l*o+h]=e[u*i+h];++l}}function gde(e,t,n,a,r){let s=t.slice();s[0]=r;let i=N.getArrayFromDType(n,N.sizeFromShape(s)),o=e.length,l=o===0?0:o/t[0];return mde(e,t,a,l,i,s),[i,s]}function ZU(e,t,n,a,r,s,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(hde(s,i,l),a.length===0)throw new Error("params.rank must be nonzero");let c=a[0],{outSplits:u,valueSlices:h,numValues:d}=pde(s,i,e,c),p=fde(u),f=gde(n,a,r,h,d);return[p,f[0],f[1]]}var kM=2147483647;function JU(e,t,n,a,r,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,l=r.length===0,c=i.length===0,u=[];o||u.push(t[0]),l||u.push(r[0]),c||u.push(i[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");let h=u.length===0?1:u[0],d=N.getArrayFromDType("int32",h+1);d[0]=0;for(let g=0;g<h;++g){let y=o?e[0]:e[g],v=l?a[0]:a[g],x=c?s[0]:s[g];if(x===0)throw new Error("Requires delta != 0");let w;if(x>0&&v<y||x<0&&v>y)w=0;else if(w=Math.ceil(Math.abs((v-y)/x)),w>kM)throw new Error(`Requires ((limit - start) / delta) <= ${kM}`);d[g+1]=d[g]+w}let p=d[h],f=N.getArrayFromDType(n,p),m=0;for(let g=0;g<h;++g){let y=d[g+1]-d[g],v=o?e[0]:e[g],x=c?s[0]:s[g];for(let w=0;w<y;++w)f[m++]=v,v+=x}return[d,f]}var bs=O.RowPartitionType,yde=class Fk{constructor(t,n,a,r,s,i,o,l,c,u){this.shape=t,this.shapeShape=n,this.values=a,this.valuesShape=r,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=O.getRowPartitionTypesHelper(u),this.raggedRank=O.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===bs.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===bs.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case bs.VALUE_ROWIDS:return Fk.getMaxWidthValueRowID(n);case bs.ROW_SPLITS:return Fk.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${bs[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let a=0;for(let r=0;r<n-1;++r){let s=t[r+1]-t[r];s>a&&(a=s)}return a}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let a=0,r=t[0],s=0;for(let i=1;i<n;++i){let o=t[i];o!==r&&(r=o,s=Math.max(i-a,s),a=i)}return Math.max(n-a,s)}tensorShapeFromTensor(t,n,a=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return EM(t,a)}calculateOutputSize(t){let n=this.valuesShape,a=this.defaultValueShape;O.validateDefaultValueShape(a,n);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=O.combineRaggedTensorToTensorShapes(this.raggedRank,r,n);s[0]<0&&(s[0]=t);for(let i=1;i<=this.raggedRank;++i)s[i]<0&&(s[i]=this.getMaxWidth(i));return s}calculateFirstParentOutputIndex(t,n,a){let r=Math.min(t,a),s=[],i=0;for(let o=0;o<r;++o,i+=n)s.push(i);for(let o=r;o<t;++o)s.push(-1);return N.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,n,a,r){let s=t.length,i=[];for(let o=0;o<s-1;++o){let l=t[o+1]-t[o],c=Math.min(r,l),u=n[o];u===-1&&(c=0);for(let h=0;h<c;++h)i.push(u),u+=a;for(let h=0;h<l-c;++h)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,a,r){let s=t.length,i=[];if(s===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let c=n[l];i.push(c);for(let u=1;u<s;++u){let h=t[u];if(h===l)c>=0&&(++o,o<r?c+=a:c=-1);else{if(o=0,l=h,h>=n.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);c=n[h]}i.push(c)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,a,r){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case bs.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,a,r);case bs.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,a,r);default:throw new Error(`Unsupported partition type: ${bs[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case bs.FIRST_DIM_SIZE:return t[0];case bs.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case bs.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${bs[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),a=new Array(this.raggedRank+1);a[a.length-1]=1;for(let i=a.length-2;i>=0;--i)a[i]=a[i+1]*n[i+1];let r=EM(n,!1),s=N.getArrayFromDType(this.valuesDType,N.sizeFromShape(r));if(a[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,a[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,a[o],n[o]);this.setOutput(this.raggedRank,i,s,r)}return[r,s]}setOutput(t,n,a,r){if(a.length===0)return;let s=this.values,i=a,o=r.slice();o=o.slice(t+1);let l=N.sizeFromShape(o),c=n.length,u=this.defaultValue;if(u.length!==l&&u.length!==1){let f=this.defaultValueShape;X(()=>{let m=K(u,f);u=fc(m,o).dataSync()})}let h=0,d=0,p=0;for(let f=0;f<=c;++f){let m=f<c?n[f]:-1;if(m===p){++p;continue}if(d<p){let g=s.subarray(h*l),y=i.subarray(d*l),v=(p-d)*l;TM(y,g,v)}if(f>=c){let g=a.length;m=Math.floor(g/l)}if(m>p)if(this.defaultValue.length===1)i.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;){let g=i.slice(p*l);TM(g,u,l),++p}m<0?(h=f+1,d=p):(h=f,d=p,p=d+1)}}};function TM(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function EM(e,t){let n=[];for(let a of e){if(a<0){if(!t)throw new Error(`Dimension ${a} must be >= 0`);if(a<-1)throw new Error(`Dimension ${a} must be >= -1`);a=-1}n.push(a)}return n}function e6(e,t,n,a,r,s,i,o,l,c){return new yde(e,t,n,a,r,s,i,o,l,c).compute()}function jC(e,t,n,a){let r=e===t,s=e<t&&n<0,i=t<e&&n>1;if(r||s||i)return N.makeZerosTypedArray(0,a);let o=Math.abs(Math.ceil((t-e)/n)),l=N.makeZerosTypedArray(o,a);t<e&&n===1&&(n=-1),l[0]=e;for(let c=1;c<l.length;c++)l[c]=l[c-1]+n;return l}var t6=qi(e=>1/Math.sqrt(e)),bde=xu(nd,t6),vde={kernelName:nd,backendName:"cpu",kernelFunc:bde};function oc(e,t,n,a,r,s,i,o,l,c){let u=[a/r,r],h=e.values,d=t.values;if(a===0)return ut(n,t.dtype);let p=l instanceof Vn?l:ut(u,t.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<s;f++){let m=[],g=0;for(let y=0;y<i;y++){let v=h[f*i+y];m.push(v),g+=v*o[y]}if(g<0||g>=a/r)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let y=0;y<r;y++)c?p.values[g*r+y]+=d[f*r+y]:p.values[g*r+y]=t.rank===0?d[0]:d[f*r+y]}return p}var xde=qi(e=>1/(1+Math.exp(-e))),n6=jt(od,e=>1/(1+Math.exp(-e))),wde={kernelName:od,backendName:"cpu",kernelFunc:n6};function H0(e,t,n,a,r){let s=aa.isSliceContinous(a,t,n),i=N.sizeFromShape(n),o=N.computeStrides(a);if(s){let h=aa.computeFlatOffset(t,o);return r==="string"?e.slice(h,h+i):e.subarray(h,h+i)}let l=r==="string"?O.fromUint8ToStringArray(e):e,c=ut(a,r,l),u=ut(n,r);for(let h=0;h<u.size;++h){let d=u.indexToLoc(h),p=d.map((f,m)=>f+t[m]);u.set(c.get(...p),...d)}return r==="string"?O.fromStringArrayToUint8(u.values):u.values}function zc(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a;$e(r,"slice");let[o,l]=aa.parseSliceParams(r,s,i);aa.assertParamsValid(r,o,l);let c=n.data.get(r.dataId).values,u=H0(c,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,u)}var _de={kernelName:fm,backendName:"cpu",kernelFunc:zc};function a6(e,t,n,a,r,s,i){let o=t[0],l=s[0],c=new Array(l),u=new Array(o),h=t[1];if(l===0){if(o!==0)throw new Error(O.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let g=N.getArrayFromDType(n,0),y=N.getArrayFromDType(r,0);return[g,[0,h],y,c,u]}let d=!0,p=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let y=e[g*h];if(y<0)throw new Error(O.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=l)throw new Error(O.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,l));++f[y],d=d&&y>=p,p=y}let m=!0;for(let g=0;g<l;++g){let y=f[g]===0;c[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){let g=e,y=a;for(let v=0;v<o;++v)u[v]=v;return[g,[o,h],y,c,u]}else{let g=f[l-1],y=N.getArrayFromDType(n,g*h),v=N.getArrayFromDType(r,g),x=new Array(l).fill(0);for(let w=0;w<o;++w){let k=e[w*h],M=x[k],S=(k===0?0:f[k-1])+M;x[k]++;for(let I=0;I<h;++I)y[S*h+I]=e[w*h+I];v[S]=a[w],u[w]=S}for(let w=0;w<l;++w)if(x[w]===0){let k=w===0?0:f[w-1];y[k*h+0]=w;for(let M=1;M<h;++M)y[k*h+M]=0;v[k]=i}return[y,[g,h],v,c,u]}}function r6(e,t,n,a,r){let s=N.sizeFromShape(a),i=t[0],o=r.length,l=[],c=1,u=-1;for(let m=0;m<o;++m){let g=r[m];if(g===-1){if(u!==-1)throw new Error(O.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u,m));u=m,l.push(1)}else{if(g<0)throw new Error(O.getSparseReshapeNegativeOutputDimErrorMessage(m,g));c*=g,l.push(g)}}if(u!==-1){if(c<=0)throw new Error(O.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(s/c);if(c*m!==s)throw new Error(O.getSparseReshapeInputOutputMultipleErrorMessage(a,l));l[u]=m}if(N.sizeFromShape(l)!==s)throw new Error(O.getSparseReshapeInputOutputMismatchErrorMessage(a,l));let h=a.length,d=[];if(h>0){d[h-1]=1;for(let m=h-2;m>=0;--m)d[m]=d[m+1]*a[m+1]}let p=[];if(o>0){p[o-1]=1;for(let m=o-2;m>=0;--m)p[m]=p[m+1]*l[m+1]}let f=N.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let g=0;for(let y=0;y<h;++y)g+=e[m*h+y]*d[y];for(let y=0;y<o;++y)f[m*o+y]=Math.trunc(g/p[y]),g%=p[y]}return[f,[i,o],l]}function GC(e,t,n,a,r,s=!1,i=0){let o=a.length,l=[t[0],e.length/t[0]],c=l[1],u=o>0?r[o-1]+1:0;if(u<0)throw new Error(O.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=t.slice();h[0]=u;let d=h.reduce((v,x)=>v*x,1),p=N.getArrayFromDType(n,d);if(o===0)return u>0&&p.fill(i),[p,h];if(u<=0)throw new Error(O.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=r[f];for(;;){let v=0;if(m<o){if(v=r[m],y===v){++m;continue}if(y>=v)throw new Error(O.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=u)throw new Error(O.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,u));y>g&&p.fill(i,g*c,y*c);for(let x=f;x<m;++x){let w=a[x];if(w<0||w>=l[0])throw new Error(O.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x,a[x],l[0]));for(let k=0;k<c;k++)p[y*c+k]+=e[w*c+k]}if(s)for(let x=0;x<c;x++)p[y*c+x]/=m-f;if(f=m,++m,g=y+1,y=v,m>o)break}return g<u&&p.fill(i,g*c,u*c),[p,h]}var Sde=qi(e=>Math.sqrt(e)),Ide=jt(ud,e=>Math.sqrt(e)),kde={kernelName:ud,backendName:"cpu",kernelFunc:Ide},s6=Mn((e,t)=>{let n=e-t;return n*n}),Tde=ia(dd,s6),Ede={kernelName:dd,backendName:"cpu",kernelFunc:Tde},i6=qi((e,t)=>{let{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)}),Nde=xu(Ib,i6),Cde={kernelName:Ib,backendName:"cpu",kernelFunc:Nde};function o6(e,t,n,a){let r=ut(e,t.dtype);for(let s=0;s<r.size;s++){let i=r.indexToLoc(s),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+a[l];r.set(t.get(...o),...i)}return r}var Ade=class{constructor(e,t,n,a,r,s){this.separator=N.encodeString(e),this.nGramWidths=t,this.leftPad=N.encodeString(n),this.rightPad=N.encodeString(a),this.padWidth=r,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,s){for(let i=0;i<r;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),c=Math.max(0,o-(r-(i+1))),u=s-(l+c),h=t+(l>0?0:i-o),d=0;d+=l*this.leftPad.length;for(let y=0;y<u;++y)d+=e[h+y].length;d+=c*this.rightPad.length;let p=l+c+u-1;d+=p*this.separator.length,n[a+i]=new Uint8Array(d);let f=n[a+i],m=0,g=y=>y.forEach(v=>f[m++]=v);for(let y=0;y<l;++y)g(this.leftPad),g(this.separator);for(let y=0;y<u-1;++y)g(e[h+y]),g(this.separator);if(u>0){g(e[h+u-1]);for(let y=0;y<c;++y)g(this.separator),g(this.rightPad)}else{for(let y=0;y<c-1;++y)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,a=t.length;if(a>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<a;++l){let c=t[l]>=o;if(c=c&&t[l]<=n,!c)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let r=a-1,s=N.getArrayFromDType("int32",a);if(n===0||a===0){let o=new Array(n);for(let l=0;l<=r;++l)s[l]=0;return[o,s]}s[0]=0;for(let o=1;o<=r;++o){let l=t[o]-t[o-1],c=0;this.nGramWidths.forEach(u=>{c+=this.getNumNGrams(l,u)}),this.preserveShort&&l>0&&c===0&&(c=1),s[o]=s[o-1]+c}let i=new Array(s[r]);for(let o=0;o<r;++o){let l=t[o],c=s[o];if(this.nGramWidths.forEach(u=>{let h=t[o+1]-t[o],d=this.getNumNGrams(h,u);this.createNGrams(e,l,i,c,d,u),c+=d}),this.preserveShort&&c===s[o]){let u=t[o+1]-t[o];if(u===0)continue;let h=u+2*this.padWidth;this.createNGrams(e,l,i,c,1,h)}}return[i,s]}};function HC(e,t,n,a,r,s,i,o){return new Ade(n,a,r,s,i,o).compute(e,t)}function Rde(e,t,n,a){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)a.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&a.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!n||e.length!==0)&&a.push(e);return}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(r,s);(!n||i.length!==0)&&a.push(i),r=s+1}}function qC(e,t,n){let a=e.length,r=[],s=0,i=0,o=new Array(a);for(let d=0;d<a;++d){let p=r.length;Rde(e[d],t,n,r);let f=r.length-p;o[d]=f,s+=f,i=Math.max(i,f)}let l=N.getArrayFromDType("int32",s*2),c=new Array(s),u=[a,i],h=0;for(let d=0;d<a;++d)for(let p=0;p<o[d];++p)l[h*2]=d,l[h*2+1]=p,c[h]=r[h],++h;return[l,c,u]}function KC(e,t){let n=N.getArrayFromDType("int32",e.length);for(let a=0;a<e.length;++a)n[a]=N.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();return n}var l6=Mn((e,t)=>e-t),Dde=PC((e,t,n,a)=>({real:e-n,imag:t-a})),XC=ia(pd,l6,Dde),$de={kernelName:pd,backendName:"cpu",kernelFunc:XC};function u6(e,t){let n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];let a=ut(n,e.dtype);for(let r=0;r<a.values.length;++r){let s=a.indexToLoc(r),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%e.shape[l];let o=e.locToIndex(i);a.values[r]=e.values[o]}return a}var Tg=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function c6(e,t,n=0,a=e.length-1){for(;a>n;){if(a-n>600){let o=a-n+1,l=t-n+1,c=Math.log(o),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(o-u)/o)*Math.sign(l-o/2),d=Math.max(n,Math.floor(t-l*u/o+h)),p=Math.min(a,Math.floor(t+(o-l)*u/o+h));c6(e,t,d,p)}let r=e[t],s=n,i=a;for(N.swap(e,n,t),Tg(e[a],r)>0&&N.swap(e,n,a);s<i;){for(N.swap(e,s,i),s++,i--;Tg(e[s],r)<0;)s=s+1;for(;Tg(e[i],r)>0;)i=i-1}Tg(e[n],r)===0?N.swap(e,n,i):(i=i+1,N.swap(e,i,a)),i<=t&&(n=i+1),t<=i&&(a=i-1)}}function h6(e,t,n,a,r){let s=t[t.length-1],[i,o]=[e.length/s,s],l=N.getTypedArrayFromDType(n,i*a),c=N.getTypedArrayFromDType("int32",i*a);for(let h=0;h<i;h++){let d=h*o,p=e.subarray(d,d+o),f=new Array(p.length);p.forEach((v,x)=>f[x]={value:v,index:x}),a<f.length&&(c6(f,a),f=f.slice(0,a)),r&&f.sort(Tg);let m=h*a,g=l.subarray(m,m+a),y=c.subarray(m,m+a);for(let v=0;v<a;v++)g[v]=f[v].value,y[v]=f[v].index}let u=t.slice();return u[u.length-1]=a,[ut(u,n,l),ut(u,"int32",c)]}function QC(e,t,n,a){let r=N.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<r;f++)s[0]*=n[f];s[1]=n[r];for(let f=r+1;f<n.length;f++)s[2]*=n[f];let i=new Map,o=new Int32Array(n[r]),l=new Vn(s,a,e),c=[],u=s[0]===1&&s[2]===1;for(let f=0;f<n[r];f++){let m;if(u)m=e[f].toString();else{let y=[];for(let v=0;v<s[0];v++)for(let x=0;x<s[2];x++)y.push(l.get(v,f,x));m=y.join(",")}let g=i.get(m);if(g!=null)o[f]=g;else{let y=i.size;i.set(m,y),o[f]=y,c.push(f)}}let h=s.slice();h[1]=i.size;let d=new Vn(h,a);c.forEach((f,m)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)d.set(l.get(g,f,y),g,m,y)});let p=n.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:o}}var Mde="4.22.0";a1("cpu",()=>new LC,1);var d6=jt(vh,e=>e>=0?e:Math.exp(e)-1),Ode={kernelName:vh,backendName:"cpu",kernelFunc:d6};function p6(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a;$e([r],"leakyRelu");let i=N.sizeFromShape(r.shape),o=n.data.get(r.dataId).values,l=N.getTypedArrayFromDType("float32",i);for(let c=0;c<o.length;c++)l[c]=o[c]<0?s*o[c]:o[c];return n.makeTensorInfo(r.shape,"float32",l)}var Fde={kernelName:Rh,backendName:"cpu",kernelFunc:p6},Lde=Mn((e,t)=>e<0?t*e:e);function f6(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t;$e([a,r],"prelu");let s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,[o,l]=Lde(a.shape,r.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var zde={kernelName:qh,backendName:"cpu",kernelFunc:f6},m6=jt(Qh,e=>Math.max(0,e)),Pde={kernelName:Qh,backendName:"cpu",kernelFunc:m6},g6=jt(Jh,e=>Math.min(Math.max(0,e),6)),Vde={kernelName:Jh,backendName:"cpu",kernelFunc:g6};function q0(e,t,n,a,r){if(n==="linear")return Pi({inputs:{x:t},backend:e});if(n==="relu")return m6({inputs:{x:t},backend:e});if(n==="elu")return d6({inputs:{x:t},backend:e});if(n==="relu6")return g6({inputs:{x:t},backend:e});if(n==="prelu")return f6({inputs:{x:t,alpha:a},backend:e});if(n==="leakyrelu")return p6({inputs:{x:t},backend:e,attrs:{alpha:r}});if(n==="sigmoid")return n6({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function ln(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=N.sizeFromShape(r.shape),o=N.inferFromImplicitShape(s,i),l=N.sizeFromShape(o);N.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);let c=n.data.get(r.dataId);if(c.complexTensorInfos!=null){let u=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;u.shape=o,h.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}var Bde={kernelName:om,backendName:"cpu",kernelFunc:ln};function y6(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;$e([r,s],"matMul");let l=r.shape.length,c=s.shape.length,u=i?r.shape[l-2]:r.shape[l-1],h=o?s.shape[c-1]:s.shape[c-2],d=i?r.shape[l-1]:r.shape[l-2],p=o?s.shape[c-2]:s.shape[c-1],f=r.shape.slice(0,-2),m=s.shape.slice(0,-2),g=N.sizeFromShape(f),y=N.sizeFromShape(m),v=km.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);N.assert(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,u,d]:[g,d,u],w=o?[y,p,h]:[y,h,p],k=ln({inputs:{x:r},backend:n,attrs:{shape:x}}),M=ln({inputs:{x:s},backend:n,attrs:{shape:w}}),S=i?k.shape[1]:k.shape[2],I=i?k.shape[2]:k.shape[1],E=o?M.shape[1]:M.shape[2],R=Math.max(g,y),A=n.data.get(k.dataId).values,_=n.data.get(M.dataId).values,D=N.computeStrides(k.shape),j=N.computeStrides(M.shape),[q,B,Q]=i?[D[0],1,D[1]]:[D[0],D[1],1],[H,J,ae]=o?[1,j[1],j[0]]:[j[1],1,j[0]],ne=I*E,ue=ut([R,I,E],k.dtype),le=ue.values,he=n.blockSize;for(let me=0;me<R;me++){let Re=me%g,Ne=me%y;for(let xe=0;xe<I;xe+=he){let Le=Math.min(xe+he,I);for(let Pe=0;Pe<E;Pe+=he){let Xe=Math.min(Pe+he,E);for(let Ue=0;Ue<S;Ue+=he){let Et=Math.min(Ue+he,S);for(let st=xe;st<Le;st++)for(let bt=Pe;bt<Xe;bt++){let je=0;for(let gt=Ue;gt<Et;gt++){let Ot=A[Re*q+st*B+gt*Q],At=_[gt*H+bt*J+Ne*ae];je+=Ot*At}le[me*ne+(st*E+bt)]+=je}}}}}return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(M),n.makeTensorInfo(v,ue.dtype,ue.values)}var Ude={kernelName:oh,backendName:"cpu",kernelFunc:y6};function Wde(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=a,d,p,f,m=[];d=y6({inputs:{a:r,b:s},attrs:{transposeA:l,transposeB:c},backend:n}),i&&(p=af({inputs:{a:d,b:i},backend:n}),m.push(d),d=p),u&&(f=q0(n,d,u,o,h),m.push(d),d=f);for(let g of m)n.disposeIntermediateTensorInfo(g);return d}var jde={kernelName:Ic,backendName:"cpu",kernelFunc:Wde},Gde=jt(Zc,e=>Math.acos(e)),Hde={kernelName:Zc,backendName:"cpu",kernelFunc:Gde},qde=jt(Jc,e=>Math.acosh(e)),Kde={kernelName:Jc,backendName:"cpu",kernelFunc:qde};function Xde(e){let{inputs:t,backend:n}=e,a=t;$e(t,"addN");let r=a.map(o=>n.data.get(o.dataId).values),s=ut(a[0].shape,a[0].dtype),i=s.values;for(let o=0;o<a.length;o++){let l=r[o];for(let c=0;c<i.length;c++)i[c]+=l[c]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var Qde={kernelName:eh,backendName:"cpu",kernelFunc:Xde};function Yde(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;$e(r,"all");let o=N.parseAxisParam(s,r.shape),l=o,c=O.getAxesPermutation(l,r.shape.length),u=r;c!=null&&(u=br({inputs:{x:r},backend:n,attrs:{perm:c}}),l=O.getInnerMostAxes(l.length,r.shape.length)),O.assertAxesAreInnerMostDims("all",l,u.shape.length);let[h,d]=O.computeOutAndReduceShapes(u.shape,l),p=N.sizeFromShape(d),f=N.makeZerosTypedArray(N.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let v=y*p,x=m[v];for(let w=0;w<p;++w){let k=m[v+w];x=x&&k}f[y]=x}c!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(h,u.dtype,f);if(i){let y=O.expandShapeToKeepDim(h,o),v=ln({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),v}return g}var Zde={kernelName:If,backendName:"cpu",kernelFunc:Yde};function Jde(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;$e(r,"any");let o=N.parseAxisParam(s,r.shape),l=o,c=O.getAxesPermutation(l,r.shape.length),u=r;c!=null&&(u=br({inputs:{x:r},backend:n,attrs:{perm:c}}),l=O.getInnerMostAxes(l.length,r.shape.length)),O.assertAxesAreInnerMostDims("any",l,u.shape.length);let[h,d]=O.computeOutAndReduceShapes(u.shape,l),p=N.sizeFromShape(d),f=N.makeZerosTypedArray(N.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let v=y*p,x=m[v];for(let w=0;w<p;++w){let k=m[v+w];x=x||k}f[y]=x}c!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(h,u.dtype,f);if(i){let y=O.expandShapeToKeepDim(h,o),v=ln({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),v}return g}var epe={kernelName:kf,backendName:"cpu",kernelFunc:Jde};function tpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;$e(r,"argMax");let i=N.parseAxisParam(s,r.shape),o=O.getAxesPermutation(i,r.shape.length),l=r,c=[];o!=null&&(l=br({inputs:{x:r},backend:n,attrs:{perm:o}}),c.push(l),i=O.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],O.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[u,h]=O.computeOutAndReduceShapes(l.shape,i),d=N.sizeFromShape(u),p=N.makeZerosTypedArray(d,"int32"),f=N.sizeFromShape(h),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let y=g*f,v=m[y],x=0;for(let w=0;w<f;++w){let k=m[y+w];k>v&&(v=k,x=w)}p[g]=x}return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(u,"int32",p)}var npe={kernelName:Tf,backendName:"cpu",kernelFunc:tpe};function ape(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;$e(r,"argMin");let i=N.parseAxisParam(s,r.shape),o=O.getAxesPermutation(i,r.shape.length),l=r,c=[];o!=null&&(l=br({inputs:{x:r},backend:n,attrs:{perm:o}}),c.push(l),i=O.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],O.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[u,h]=O.computeOutAndReduceShapes(l.shape,i),d=N.sizeFromShape(u),p=N.makeZerosTypedArray(d,"int32"),f=N.sizeFromShape(h),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let y=g*f,v=m[y],x=0;for(let w=0;w<f;++w){let k=m[y+w];k<v&&(v=k,x=w)}p[g]=x}return c.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(u,"int32",p)}var rpe={kernelName:Ef,backendName:"cpu",kernelFunc:ape},spe=jt(th,e=>Math.asin(e)),ipe={kernelName:th,backendName:"cpu",kernelFunc:spe},ope=jt(nh,e=>Math.asinh(e)),lpe={kernelName:nh,backendName:"cpu",kernelFunc:ope},upe=jt(ah,e=>Math.atan(e)),cpe={kernelName:ah,backendName:"cpu",kernelFunc:upe},hpe=Mn((e,t)=>Math.atan2(e,t)),dpe=ia(sh,hpe),ppe={kernelName:sh,backendName:"cpu",kernelFunc:dpe},fpe=jt(rh,e=>Math.atanh(e)),mpe={kernelName:rh,backendName:"cpu",kernelFunc:fpe};function YC(e,t,n,a,r,s){let i=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,u=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=ut(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],v=r.outShape[2]*r.outShape[3],x=r.outShape[3];for(let w=0;w<r.batchSize;++w){let k=w*y,M=w*a[0];for(let S=0;S<r.inChannels;++S)for(let I=0;I<r.outHeight;++I){let E=I*i-d,R=Math.max(0,E),A=Math.min(r.inHeight,u+E),_=k+I*v;for(let D=0;D<r.outWidth;++D){let j=D*o-p,q=Math.max(0,j),B=Math.min(r.inWidth,h+j),Q=f,H=0,J=0;for(let ne=R;ne<A;ne+=l){let ue=M+ne*a[1];for(let le=q;le<B;le+=c){let he=ue+le*a[2],me=e[he+S];s==="max"&&me>Q?Q=me:s==="avg"&&(H+=me,J++)}if(isNaN(Q))break}let ae=_+D*x+S;g[ae]=s==="avg"?H/J:Q}}}return m}function b6(e,t,n,a,r=!1,s=!1){let i=ut(a.outShape,"int32"),o=a.strideHeight,l=a.strideWidth,c=a.dilationHeight,u=a.dilationWidth,h=a.effectiveFilterHeight,d=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,m=ut(t,n,e);for(let g=0;g<a.batchSize;++g)for(let y=0;y<a.inChannels;++y)for(let v=0;v<a.outHeight;++v){let x=v*o-p,w=x;for(;w<0;)w+=c;let k=Math.min(a.inHeight,h+x);for(let M=0;M<a.outWidth;++M){let S=M*l-f,I=S;for(;I<0;)I+=u;let E=Math.min(a.inWidth,d+S),R=Number.NEGATIVE_INFINITY,A=-1;for(let _=w;_<k;_+=c){let D=_-x;for(let j=I;j<E;j+=u){let q=j-S,B=m.get(g,_,j,y);B>R&&(R=B,r?A=s?((g*a.inHeight+_)*a.inWidth+j)*a.inChannels+y:(_*a.inWidth+j)*a.inChannels+y:A=D*d+q)}}i.set(A,g,v,M,y)}}return i}function v6(e,t,n,a,r,s){let i=r.strideDepth,o=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,u=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,v=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=ut(r.outShape,n),w=x.values,k=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],M=r.outShape[2]*r.outShape[3]*r.outShape[4],S=r.outShape[3]*r.outShape[4],I=r.outShape[4];for(let E=0;E<r.batchSize;++E){let R=E*k,A=E*a[0];for(let _=0;_<r.inChannels;++_)for(let D=0;D<r.outDepth;++D){let j=D*i-m,q=j;for(;q<0;)q+=c;let B=Math.min(r.inDepth,d+j),Q=R+D*M;for(let H=0;H<r.outHeight;++H){let J=H*o-g,ae=J;for(;ae<0;)ae+=u;let ne=Math.min(r.inHeight,p+J),ue=Q+H*S;for(let le=0;le<r.outWidth;++le){let he=le*l-y,me=he;for(;me<0;)me+=h;let Re=Math.min(r.inWidth,f+he),Ne=ue+le*I,xe=v,Le=0,Pe=0;for(let Ue=q;Ue<B;Ue+=c){let Et=A+Ue*a[1];for(let st=ae;st<ne;st+=u){let bt=Et+st*a[2];for(let je=me;je<Re;je+=h){let gt=bt+je*a[3],Ot=e[gt+_];if(s==="max"&&Ot>xe?xe=Ot:s==="avg"&&(Le+=Ot,Pe++),isNaN(xe))break}if(isNaN(xe))break}if(isNaN(xe))break}let Xe=Ne+_;w[Xe]=s==="avg"?Le/Math.max(Pe,1):xe}}}}return x}function gpe(e,t){let n=ut(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let v=y*a-d,x=v;for(;x<0;)x+=i;let w=Math.min(t.inDepth,c+v);for(let k=0;k<t.outHeight;++k){let M=k*r-p,S=M;for(;S<0;)S+=o;let I=Math.min(t.inHeight,u+M);for(let E=0;E<t.outWidth;++E){let R=E*s-f,A=R;for(;A<0;)A+=l;let _=Math.min(t.inWidth,h+R),D=Number.NEGATIVE_INFINITY,j=-1;for(let q=x;q<w;q+=i){let B=q-v;for(let Q=S;Q<I;Q+=o){let H=Q-M;for(let J=A;J<_;J+=l){let ae=J-R,ne=e.get(m,q,Q,J,g);ne>=D&&(D=ne,j=B*u*h+H*u+ae)}}}n.set(j,m,y,k,E,g)}}}return n}function ype(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;$e(r,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,c=1;N.assert(O.eitherStridesOrDilationsAreOne(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=O.computePool2DInfo(r.shape,s,i,c,o,l),h;if(u.filterWidth===1&&u.filterHeight===1&&N.arraysEqual(u.inShape,u.outShape))h=Pi({inputs:{x:r},backend:n});else{let d=n.data.get(r.dataId).values,p=N.computeStrides(r.shape),f=YC(d,r.shape,r.dtype,p,u,"avg");h=n.makeTensorInfo(u.outShape,r.dtype,f.values)}return h}var bpe={kernelName:ih,backendName:"cpu",kernelFunc:ype};function vpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=a;$e(r,"avgPool3d");let u=O.computePool3DInfo(r.shape,s,i,1,o,l,c),h=n.data.get(r.dataId).values,d=v6(h,r.shape,r.dtype,N.computeStrides(r.shape),u,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}var xpe={kernelName:Nf,backendName:"cpu",kernelFunc:vpe};function wpe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=a;$e([r,s],"avgPool3DGrad");let u=O.computePool3DInfo(s.shape,i,o,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,v=u.dilationHeight,x=u.dilationWidth,w=u.effectiveFilterDepth,k=u.effectiveFilterHeight,M=u.effectiveFilterWidth,S=w-1-u.padInfo.front,I=M-1-u.padInfo.left,E=k-1-u.padInfo.top,R=ut(s.shape,"float32"),A=1/(f*m*g),_=n.bufferSync(r);for(let D=0;D<u.batchSize;++D)for(let j=0;j<u.inChannels;++j)for(let q=0;q<u.inDepth;++q)for(let B=0;B<u.inHeight;++B)for(let Q=0;Q<u.inWidth;++Q){let H=q-S,J=B-E,ae=Q-I,ne=0;for(let ue=0;ue<w;ue+=y){let le=(H+ue)/h;if(!(le<0||le>=u.outDepth||Math.floor(le)!==le))for(let he=0;he<k;he+=v){let me=(J+he)/d;if(!(me<0||me>=u.outHeight||Math.floor(me)!==me))for(let Re=0;Re<M;Re+=x){let Ne=(ae+Re)/p;if(Ne<0||Ne>=u.outWidth||Math.floor(Ne)!==Ne)continue;let xe=_.get(D,le,me,Ne,j);ne+=xe}}}R.set(ne*A,D,q,B,Q,j)}return n.makeTensorInfo(R.shape,R.dtype,R.values)}var _pe={kernelName:cb,backendName:"cpu",kernelFunc:wpe};function Spe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;$e([r,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:c}=a,u=O.computePool2DInfo(i.shape,o,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,v=u.effectiveFilterWidth,x=v-1-u.padInfo.left,w=y-1-u.padInfo.top,k=ut(i.shape,"float32"),M=1/(p*f),S=n.data.get(r.dataId).values,I=ut(r.shape,"float32",S);for(let E=0;E<u.batchSize;++E)for(let R=0;R<u.inChannels;++R)for(let A=0;A<u.inHeight;++A)for(let _=0;_<u.inWidth;++_){let D=A-w,j=_-x,q=0;for(let B=0;B<y;B+=m){let Q=(D+B)/h;if(!(Q<0||Q>=u.outHeight||Math.floor(Q)!==Q))for(let H=0;H<v;H+=g){let J=(j+H)/d;if(J<0||J>=u.outWidth||Math.floor(J)!==J)continue;let ae=I.get(E,Q,J,R);q+=ae}}k.set(q*M,E,A,_,R)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var Ipe={kernelName:ub,backendName:"cpu",kernelFunc:Spe};function kpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,scale:s,offset:i,mean:o,variance:l}=t;N.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),N.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),N.assert(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),$e([r,o,l,s,i],"batchNorm");let{varianceEpsilon:c}=a;c==null&&(c=.001);let u=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=p.length,v=d.length,x=h.length,w=0,k=0,M=0,S=0;for(let I=0;I<u.length;++I)m[I]=f[w++]+(u[I]-h[k++])*p[M++]/Math.sqrt(d[S++]+c),w>=g&&(w=0),k>=x&&(k=0),M>=y&&(M=0),S>=v&&(S=0);return n.makeTensorInfo(r.shape,r.dtype,m)}var Tpe={kernelName:kh,backendName:"cpu",kernelFunc:kpe};function Epe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;$e([r],"batchToSpaceND");let o=s.reduce((y,v)=>y*v),l=O.getReshaped(r.shape,s,o),c=O.getPermuted(l.length,s.length),u=O.getReshapedPermuted(r.shape,s,o),h=O.getSliceBeginCoords(i,s.length),d=O.getSliceSize(u,i,s.length),p=ln({inputs:{x:r},backend:n,attrs:{shape:l}}),f=br({inputs:{x:p},backend:n,attrs:{perm:c}}),m=ln({inputs:{x:f},backend:n,attrs:{shape:u}}),g=zc({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var Npe={kernelName:Cf,backendName:"cpu",kernelFunc:Epe};function Cpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,c=VC(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,c)}var Ape={kernelName:Af,backendName:"cpu",kernelFunc:Cpe};function Rpe(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=O.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Dpe={kernelName:hb,backendName:"cpu",kernelFunc:Rpe},$pe=jt(du,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),Mpe={kernelName:du,backendName:"cpu",kernelFunc:$pe},Ope=e=>{let{x:t}=e.inputs,n=e.backend,a=new Float32Array(N.sizeFromShape(t.shape)),r=n.data.get(t.dataId),s=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let c=0;c<o.length;c++){let u=o[c],h=l[c];a[c]=Math.hypot(u,h)}return n.makeOutput(a,t.shape,"float32")},Fpe={kernelName:db,backendName:"cpu",kernelFunc:Ope};function rf(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var Lpe={kernelName:Qw,backendName:"cpu",kernelFunc:rf};function sf(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=N.parseAxisParam(r,t[0].shape)[0],i=t.map(m=>m.shape);O.assertParamsConsistent(i,s);let o=O.computeOutShape(t.map(m=>m.shape),s);if(N.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(m=>N.sizeFromShape(m.shape)>0);if(l.length===1)return Pi({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let m=l.map(w=>Lc({inputs:{input:w},backend:n})),g=l.map(w=>rf({inputs:{input:w},backend:n})),y=sf({inputs:m,backend:n,attrs:{axis:s}}),v=sf({inputs:g,backend:n,attrs:{axis:s}}),x=Ar({inputs:{real:y,imag:v},backend:n});return m.forEach(w=>n.disposeIntermediateTensorInfo(w)),g.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),x}let c=l.map(m=>{let g=[-1,N.sizeFromShape(m.shape.slice(s))];return ln({inputs:{x:m},backend:n,attrs:{shape:g}})}),u=c.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=O.computeOutShape(c.map(m=>m.shape),1);let h=c[0].shape[0]===1,d=BC(u,o,t[0].dtype,h),p=O.computeOutShape(l.map(m=>m.shape),s),f=n.makeTensorInfo(p,t[0].dtype,d);return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var zpe={kernelName:Df,backendName:"cpu",kernelFunc:sf};function x6(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:c,dimRoundingMode:u}=a;$e([r,s],"conv2d");let h=O.convertConv2DDataFormat(l),d=O.computeConv2DInfo(r.shape,s.shape,i,c,o,u,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,v=d.padInfo.top,x=d.dataFormat==="channelsLast",w=new Vn(d.outShape,r.dtype),k=N.computeStrides(r.shape),M=N.computeStrides(s.shape),S=k[0],I=x?k[1]:k[2],E=x?k[2]:1,R=x?1:k[1],A=w.strides[0],_=x?w.strides[1]:w.strides[2],D=x?w.strides[2]:1,j=x?1:w.strides[1],q=n.data.get(r.dataId).values,B=n.data.get(s.dataId).values,Q=w.values;for(let H=0;H<d.batchSize;++H){let J=H*S,ae=H*A;for(let ne=0;ne<d.outHeight;++ne){let ue=ae+ne*_,le=ne*d.strideHeight-v;for(let he=0;he<p;++he){let me=le+he*m;if(me<0||me>=d.inHeight)continue;let Re=he*M[0],Ne=J+me*I;for(let xe=0;xe<d.outWidth;++xe){let Le=ue+xe*D,Pe=xe*d.strideWidth-y;for(let Xe=0;Xe<f;++Xe){let Ue=Pe+Xe*g;if(Ue<0||Ue>=d.inWidth)continue;let Et=Re+Xe*M[1],st=Ne+Ue*E,bt=Et;for(let je=0;je<d.inChannels;++je){let gt=q[st+je*R];for(let Ot=0;Ot<d.outChannels;++Ot)Q[Le+Ot*j]+=gt*B[bt+Ot];bt+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,Q)}var Ppe={kernelName:ch,backendName:"cpu",kernelFunc:x6};function Vpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:u}=a;$e([r,s],"conv2dBackpropFilter");let h=O.convertConv2DDataFormat(l),d=O.computeConv2DInfo(r.shape,u,i,1,o,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y=d.dataFormat==="channelsLast",v=new Vn(d.filterShape,"float32"),x=d.padInfo.left,w=d.padInfo.top,k=n.data.get(r.dataId).values,M=n.data.get(s.dataId).values,S=new Vn(r.shape,r.dtype,k),I=new Vn(s.shape,s.dtype,M);for(let E=0;E<m;++E){let R=Math.max(0,Math.ceil((w-E)/p)),A=Math.min(d.outHeight,(d.inHeight+w-E)/p);for(let _=0;_<g;++_){let D=Math.max(0,Math.ceil((x-_)/f)),j=Math.min(d.outWidth,(d.inWidth+x-_)/f);for(let q=0;q<d.inChannels;++q)for(let B=0;B<d.outChannels;++B){let Q=0;for(let H=0;H<d.batchSize;++H)for(let J=R;J<A;++J){let ae=E+J*p-w;for(let ne=D;ne<j;++ne){let ue=_+ne*f-x;y?Q+=S.get(H,ae,ue,q)*I.get(H,J,ne,B):Q+=S.get(H,q,ae,ue)*I.get(H,B,J,ne)}}v.set(Q,E,_,q,B)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var Bpe={kernelName:Ww,backendName:"cpu",kernelFunc:Vpe};function Upe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:c,dimRoundingMode:u}=a;$e([r,s],"conv2dBackpropInput");let h=N.computeStrides(s.shape),d=N.computeStrides(r.shape),p=O.convertConv2DDataFormat(c),f=O.computeConv2DInfo(i,s.shape,o,1,l,u,!1,p),m=new Vn(f.inShape,"float32"),g=m.values,y=n.data.get(r.dataId).values,v=n.data.get(s.dataId).values,[x,w,k]=h,{batchSize:M,filterHeight:S,filterWidth:I,inChannels:E,inHeight:R,inWidth:A,outChannels:_,outHeight:D,outWidth:j,strideHeight:q,strideWidth:B}=f;p=f.dataFormat;let Q=S-1-f.padInfo.top,H=I-1-f.padInfo.left,J=p==="channelsLast",ae=m.strides[0],ne=J?m.strides[1]:m.strides[2],ue=J?m.strides[2]:1,le=J?1:m.strides[1],he=d[0],me=J?d[1]:d[2],Re=J?d[2]:1,Ne=J?1:d[1];for(let xe=0;xe<M;++xe)for(let Le=0;Le<E;++Le)for(let Pe=0;Pe<R;++Pe){let Xe=Pe-Q,Ue=Math.max(0,Math.ceil(Xe/q)),Et=Math.min(D,(S+Xe)/q);for(let st=0;st<A;++st){let bt=st-H,je=Math.max(0,Math.ceil(bt/B)),gt=Math.min(j,(I+bt)/B),Ot=0;for(let pt=Ue;pt<Et;++pt){let Nn=pt*q-Xe;for(let Cn=je;Cn<gt;++Cn){let ge=Cn*B-bt,Ze=he*xe+me*pt+Re*Cn,ht=x*(S-1-Nn)+w*(I-1-ge)+k*Le;for(let kn=0;kn<_;++kn){let vn=y[Ze+Ne*kn],Da=v[ht+kn];Ot+=vn*Da}}}let At=ae*xe+ne*Pe+ue*st+le*Le;g[At]=Ot}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var Wpe={kernelName:hh,backendName:"cpu",kernelFunc:Upe};function jpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;$e([r,s],"conv3d");let c=O.computeConv3DInfo(r.shape,s.shape,i,l,o),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=c,y=g.front,v=g.left,x=g.top,w=new Vn(c.outShape,r.dtype),k=n.data.get(r.dataId).values,M=n.data.get(s.dataId).values,S=w.values,I=N.computeStrides(r.shape),E=N.computeStrides(s.shape);for(let R=0;R<c.batchSize;++R){let A=R*I[0],_=R*w.strides[0];for(let D=0;D<c.outDepth;++D){let j=_+D*w.strides[1],q=D*c.strideDepth-y;for(let B=0;B<u;++B){let Q=q+B*p;if(Q<0||Q>=c.inDepth)continue;let H=B*E[0],J=A+Q*I[1];for(let ae=0;ae<c.outHeight;++ae){let ne=j+ae*w.strides[2],ue=ae*c.strideHeight-x;for(let le=0;le<h;++le){let he=ue+le*f;if(he<0||he>=c.inHeight)continue;let me=H+le*E[1],Re=J+he*I[2];for(let Ne=0;Ne<c.outWidth;++Ne){let xe=ne+Ne*c.outChannels,Le=Ne*c.strideWidth-v;for(let Pe=0;Pe<d;++Pe){let Xe=Le+Pe*m;if(Xe<0||Xe>=c.inWidth)continue;let Ue=me+Pe*E[2],Et=Re+Xe*c.inChannels,st=Ue;for(let bt=0;bt<c.inChannels;++bt){let je=k[Et+bt];for(let gt=0;gt<c.outChannels;++gt)S[xe+gt]+=je*M[st+gt];st+=c.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var Gpe={kernelName:dh,backendName:"cpu",kernelFunc:jpe};function Hpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a;$e([r,s],"conv3dBackpropFilterV2");let c=N.computeStrides(r.shape),u=N.computeStrides(s.shape),h=O.computeConv3DInfo(r.shape,l,i,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,v=new Vn(h.filterShape,"float32"),x=v.values,[w,k,M,S]=v.strides,I=n.data.get(s.dataId).values,[E,R,A,_]=u,D=n.data.get(r.dataId).values,[j,q,B,Q]=c,H=h.padInfo.front,J=h.padInfo.left,ae=h.padInfo.top;for(let ne=0;ne<m;++ne){let ue=Math.max(0,Math.ceil((H-ne)/d)),le=Math.min(h.outDepth,(h.inDepth+H-ne)/d),he=ne*w;for(let me=0;me<g;++me){let Re=Math.max(0,Math.ceil((ae-me)/p)),Ne=Math.min(h.outHeight,(h.inHeight+ae-me)/p),xe=me*k+he;for(let Le=0;Le<y;++Le){let Pe=Math.max(0,Math.ceil((J-Le)/f)),Xe=Math.min(h.outWidth,(h.inWidth+J-Le)/f),Ue=Le*M+xe;for(let Et=0;Et<h.inChannels;++Et){let st=Et*S+Ue;for(let bt=0;bt<h.outChannels;++bt){let je=0;for(let gt=0;gt<h.batchSize;++gt){let Ot=gt*j,At=gt*E;for(let pt=ue;pt<le;++pt){let Nn=(ne+pt*d-H)*q+Ot,Cn=pt*R+At;for(let ge=Re;ge<Ne;++ge){let Ze=(me+ge*p-ae)*B+Nn,ht=ge*A+Cn;for(let kn=Pe;kn<Xe;++kn){let vn=(Le+kn*f-J)*Q+Ze,Da=kn*_+ht;je+=D[vn+Et]*I[Da+bt]}}}}x[st+bt]=je}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var qpe={kernelName:$f,backendName:"cpu",kernelFunc:Hpe};function Kpe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a;$e([r],"conv3dBackpropInputV2");let c=N.computeStrides(r.shape),u=N.computeStrides(s.shape),h=O.computeConv3DInfo(l,s.shape,o,1,i),d=new Vn(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,v=n.data.get(r.dataId).values,[x,w,k,M]=c,S=n.data.get(s.dataId).values,[I,E,R,A]=u,{batchSize:_,filterDepth:D,filterHeight:j,filterWidth:q,inChannels:B,inDepth:Q,inHeight:H,inWidth:J,outChannels:ae,outDepth:ne,outHeight:ue,outWidth:le,strideDepth:he,strideHeight:me,strideWidth:Re}=h,Ne=D-1-h.padInfo.front,xe=j-1-h.padInfo.top,Le=q-1-h.padInfo.left;for(let Pe=0;Pe<_;++Pe)for(let Xe=0;Xe<B;++Xe)for(let Ue=0;Ue<Q;++Ue){let Et=Ue-Ne,st=Math.max(0,Math.ceil(Et/he)),bt=Math.min(ne,(D+Et)/he);for(let je=0;je<H;++je){let gt=je-xe,Ot=Math.max(0,Math.ceil(gt/me)),At=Math.min(ue,(j+gt)/me);for(let pt=0;pt<J;++pt){let Nn=pt-Le,Cn=Math.max(0,Math.ceil(Nn/Re)),ge=Math.min(le,(q+Nn)/Re),Ze=0;for(let ht=st;ht<bt;++ht){let kn=ht*he-Et;for(let vn=Ot;vn<At;++vn){let Da=vn*me-gt;for(let ii=Cn;ii<ge;++ii){let Cu=ii*Re-Nn,ps=x*Pe+w*ht+k*vn+M*ii,Bo=I*(D-1-kn)+E*(j-1-Da)+R*(q-1-Cu)+A*Xe;for(let Ga=0;Ga<ae;++Ga){let fs=v[ps+Ga],An=S[Bo+Ga];Ze+=fs*An}}}}p[f*Pe+m*Ue+g*je+y*pt+Xe]=Ze}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}var Xpe={kernelName:Mf,backendName:"cpu",kernelFunc:Kpe},Qpe=jt(ph,e=>Math.cos(e)),Ype={kernelName:ph,backendName:"cpu",kernelFunc:Qpe},Zpe=jt(fh,e=>Math.cosh(e)),Jpe={kernelName:fh,backendName:"cpu",kernelFunc:Zpe};function efe(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:c}=a,[u,h,d,p]=r.shape,f=s.shape[0],[m,g]=o,y=ut([f,m,g,p],"float32"),v=n.data.get(s.dataId).values,x=n.data.get(i.dataId).values,w=n.data.get(r.dataId).values,k=N.computeStrides(r.shape),M=N.computeStrides(y.shape);for(let S=0;S<f;S++){let I=S*4,E=v[I],R=v[I+1],A=v[I+2],_=v[I+3],D=x[S];if(D>=u)continue;let j=m>1?(A-E)*(h-1)/(m-1):0,q=g>1?(_-R)*(d-1)/(g-1):0;for(let B=0;B<m;B++){let Q=m>1?E*(h-1)+B*j:.5*(E+A)*(h-1);if(Q<0||Q>h-1){for(let H=0;H<g;H++)for(let J=0;J<p;J++){let ae=J+H*M[2]+B*M[1]+S*M[0];y.values[ae]=c}continue}if(l==="bilinear"){let H=Math.floor(Q),J=Math.ceil(Q),ae=Q-H;for(let ne=0;ne<g;ne++){let ue=g>1?R*(d-1)+ne*q:.5*(R+_)*(d-1);if(ue<0||ue>d-1){for(let Re=0;Re<p;Re++){let Ne=Re+ne*M[2]+B*M[1]+S*M[0];y.values[Ne]=c}continue}let le=Math.floor(ue),he=Math.ceil(ue),me=ue-le;for(let Re=0;Re<p;Re++){let Ne=Re+le*k[2]+H*k[1]+D*k[0],xe=w[Ne];Ne=Re+he*k[2]+H*k[1]+D*k[0];let Le=w[Ne];Ne=Re+le*k[2]+J*k[1]+D*k[0];let Pe=w[Ne];Ne=Re+he*k[2]+J*k[1]+D*k[0];let Xe=w[Ne],Ue=xe+(Le-xe)*me,Et=Pe+(Xe-Pe)*me;Ne=Re+ne*M[2]+B*M[1]+S*M[0],y.values[Ne]=Ue+(Et-Ue)*ae}}}else for(let H=0;H<g;++H){let J=g>1?R*(d-1)+H*q:.5*(R+_)*(d-1);if(J<0||J>d-1){for(let ue=0;ue<p;ue++){let le=ue+H*M[2]+B*M[1]+S*M[0];y.values[le]=c}continue}let ae=Math.round(J),ne=Math.round(Q);for(let ue=0;ue<p;ue++){let le=ue+ae*k[2]+ne*k[1]+D*k[0],he=ue+H*M[2]+B*M[1]+S*M[0];y.values[he]=w[le]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var tfe={kernelName:Ff,backendName:"cpu",kernelFunc:efe};function nfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;$e(r,"cumprod");let l=O.getAxesPermutation([s],r.shape.length),c=r;l!=null&&(c=br({inputs:{x:r},backend:n,attrs:{perm:l}}));let u=O.getInnerMostAxes(1,r.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);let h=us(c.dtype,"int32"),d=N.makeOnesTypedArray(N.sizeFromShape(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=o?(y,v)=>y+f-v-1:(y,v)=>y+v;for(let y=0;y<p.length;y+=f)for(let v=0;v<f;v++){let x=m(y,v);if(v===0)d[x]=i?1:p[x];else{let w=m(y,v-1);d[x]=i?p[w]*d[w]:p[x]*d[w]}}let g=n.makeTensorInfo(c.shape,h,d);if(l!=null){let y=O.getUndoAxesPermutation(l),v=br({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(c),v}return g}var afe={kernelName:Of,backendName:"cpu",kernelFunc:nfe};function rfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;$e(r,"cumsum");let l=O.getAxesPermutation([s],r.shape.length),c=r;l!=null&&(c=br({inputs:{x:r},backend:n,attrs:{perm:l}}));let u=O.getInnerMostAxes(1,r.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);let h=us(c.dtype,"int32"),d=N.makeZerosTypedArray(N.sizeFromShape(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=o?(y,v)=>y+f-v-1:(y,v)=>y+v;for(let y=0;y<p.length;y+=f)for(let v=0;v<f;v++){let x=m(y,v);if(v===0)d[x]=i?0:p[x];else{let w=m(y,v-1);d[x]=i?p[w]+d[w]:p[x]+d[w]}}let g=n.makeTensorInfo(c.shape,h,d);if(l!=null){let y=O.getUndoAxesPermutation(l),v=br({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(c),v}return g}var sfe={kernelName:mh,backendName:"cpu",kernelFunc:rfe};function ife(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){let l=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,u=VC(l,c,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}else if(r.shape.length===2){let l=n.bufferSync(r),c=n.bufferSync(s),u=NU(l,c,i,o);return n.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var ofe={kernelName:pb,backendName:"cpu",kernelFunc:ife};function lfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a;N.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=r.shape[0],l=r.shape[1],c=r.shape[2],u=r.shape[3],h=l*s,d=c*s,p=u/(s*s),f=n.data.get(r.dataId).values,m=new Float32Array(o*h*d*p),g=0;for(let y=0;y<o;++y)for(let v=0;v<h;++v){let x=Math.floor(v/s),w=v%s;for(let k=0;k<d;++k){let M=Math.floor(k/s),S=k%s,I=(w*s+S)*p;for(let E=0;E<p;++E){let R=E+I+u*(M+c*(x+l*y));m[g++]=f[R]}}}return n.makeTensorInfo([o,h,d,p],r.dtype,m)}var ufe={kernelName:Lf,backendName:"cpu",kernelFunc:lfe};function w6(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:c}=a;$e([r,s],"depthwiseConv2DNative");let u=N.computeStrides(r.shape),h=N.computeStrides(s.shape),d=l;d==null&&(d=[1,1]),N.assert(O.eitherStridesOrDilationsAreOne(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let p=O.computeConv2DInfo(r.shape,s.shape,i,d,o,c,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:v}=p,x=v.left,w=v.top,k=p.outChannels/p.inChannels,M=new Vn(p.outShape,r.dtype),S=n.data.get(r.dataId).values,I=n.data.get(s.dataId).values,E=M.values;for(let R=0;R<p.batchSize;++R){let A=R*u[0],_=R*M.strides[0];for(let D=0;D<p.outHeight;++D){let j=_+D*M.strides[1],q=D*p.strideHeight-w;for(let B=0;B<f;++B){let Q=q+B*g;if(Q<0||Q>=p.inHeight)continue;let H=B*h[0],J=A+Q*u[1];for(let ae=0;ae<p.outWidth;++ae){let ne=j+ae*M.strides[2],ue=ae*p.strideWidth-x;for(let le=0;le<m;++le){let he=ue+le*y;if(he<0||he>=p.inWidth)continue;let me=H+le*h[1],Re=J+he*p.inChannels,Ne=ne,xe=me;for(let Le=0;Le<p.inChannels;++Le){let Pe=S[Re+Le];for(let Xe=0;Xe<k;++Xe)E[Ne+Xe]+=Pe*I[xe+Xe];Ne+=k,xe+=k}}}}}}return n.makeTensorInfo(M.shape,M.dtype,M.values)}var cfe={kernelName:gh,backendName:"cpu",kernelFunc:w6};function hfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:c,filterShape:u}=a;$e([r,s],"depthwiseConv2dNativeBackpropFilter");let h=O.computeConv2DInfo(r.shape,u,i,o,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new Vn(h.filterShape,"float32"),y=h.padInfo.left,v=h.padInfo.top,x=h.outChannels/h.inChannels,w=n.data.get(r.dataId).values,k=new Vn(r.shape,r.dtype,w),M=n.data.get(s.dataId).values,S=new Vn(s.shape,s.dtype,M);for(let I=0;I<f;++I){let E=Math.max(0,Math.ceil((v-I)/d)),R=Math.min(h.outHeight,(h.inHeight+v-I)/d);for(let A=0;A<m;++A){let _=Math.max(0,Math.ceil((y-A)/p)),D=Math.min(h.outWidth,(h.inWidth+y-A)/p);for(let j=0;j<h.outChannels;++j){let q=Math.trunc(j/x),B=j%x,Q=0;for(let H=0;H<h.batchSize;++H)for(let J=E;J<R;++J){let ae=I+J*d-v;for(let ne=_;ne<D;++ne){let ue=A+ne*p-y;Q+=k.get(H,ae,ue,q)*S.get(H,J,ne,j)}}g.set(Q,I,A,q,B)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var dfe={kernelName:jw,backendName:"cpu",kernelFunc:hfe};function pfe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:c,inputShape:u}=a;$e([r,s],"depthwiseConv2DNativeBackpropInput");let h=N.computeStrides(r.shape),d=N.computeStrides(s.shape),p=O.computeConv2DInfo(u,s.shape,i,o,l,c,!0),f=new Vn(p.inShape,"float32"),m=f.values,[g,y,v]=f.strides,x=n.data.get(r.dataId).values,[w,k,M]=h,S=n.data.get(s.dataId).values,[I,E,R]=d,{batchSize:A,filterHeight:_,filterWidth:D,inChannels:j,inHeight:q,inWidth:B,outChannels:Q,outHeight:H,outWidth:J,strideHeight:ae,strideWidth:ne}=p,ue=_-1-p.padInfo.top,le=D-1-p.padInfo.left,he=Q/j;for(let me=0;me<A;++me)for(let Re=0;Re<j;++Re)for(let Ne=0;Ne<q;++Ne){let xe=Ne-ue,Le=Math.max(0,Math.ceil(xe/ae)),Pe=Math.min(H,(_+xe)/ae);for(let Xe=0;Xe<B;++Xe){let Ue=Xe-le,Et=Math.max(0,Math.ceil(Ue/ne)),st=Math.min(J,(D+Ue)/ne),bt=0;for(let je=Le;je<Pe;++je){let gt=je*ae-xe;for(let Ot=Et;Ot<st;++Ot){let At=Ot*ne-Ue,pt=w*me+k*je+M*Ot,Nn=I*(_-1-gt)+E*(D-1-At)+R*Re;for(let Cn=0;Cn<he;++Cn){let ge=Re*he+Cn,Ze=x[pt+ge],ht=S[Nn+Cn];bt+=Ze*ht}}}m[g*me+y*Ne+v*Xe+Re]=bt}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var ffe={kernelName:Gw,backendName:"cpu",kernelFunc:pfe};function mfe(e){let{inputs:t,backend:n}=e,{x:a}=t,r=N.sizeFromShape(a.shape),s=n.data.get(a.dataId).values,i=ut([r,r],a.dtype),o=i.values;for(let c=0;c<s.length;c++)o[c*r+c]=s[c];let l=[...a.shape,...a.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var gfe={kernelName:fb,backendName:"cpu",kernelFunc:mfe},yfe={kernelName:yh,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r}=e,{strides:s,pad:i,dilations:o}=n,l=t,c=l.data.get(a.dataId).values,u=a.shape.length,h=l.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:M,filterWidth:S,dilationHeight:I,dilationWidth:E,outShape:R}=O.computeDilation2DInfo(a.shape,r.shape,s,i,"NHWC",o),A=N.sizeFromShape(R),_=R.length,D=N.getArrayFromDType(a.dtype,A);for(let j=0;j<p;++j)for(let q=0;q<y;++q){let B=q*w-x.top;for(let Q=0;Q<v;++Q){let H=Q*k-x.left;for(let J=0;J<g;++J){let ae=Number.MIN_SAFE_INTEGER;for(let ue=0;ue<M;++ue){let le=B+ue*I;if(le>=0&&le<f)for(let he=0;he<S;++he){let me=H+he*E;if(me>=0&&me<m){let Re=N.locToIndex([j,le,me,J],u,N.computeStrides(a.shape)),Ne=N.locToIndex([ue,he,J],d,N.computeStrides(r.shape)),xe=c[Re]+h[Ne];xe>ae&&(ae=xe)}}}let ne=N.locToIndex([j,q,Q,J],_,N.computeStrides(R));D[ne]=ae}}}return{dataId:l.write(N.toTypedArray(D,a.dtype),R,a.dtype),shape:R,dtype:a.dtype}}},bfe={kernelName:Gp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:l}=n,c=t,u=N.toNestedArray(a.shape,c.data.get(a.dataId).values),h=N.toNestedArray(r.shape,c.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:M,dilationHeight:S,dilationWidth:I,outShape:E}=O.computeDilation2DInfo(a.shape,r.shape,i,o,"NHWC",l);N.assert(s.rank===E.length,()=>`Error in ${Gp}, dy must have the same rank as output ${E.length}, but got ${s.rank}`);let R=N.toNestedArray(E,c.data.get(s.dataId).values),A=N.makeZerosNestedTypedArray(r.shape,r.dtype);for(let _=0;_<d;++_)for(let D=0;D<g;++D){let j=D*x-v.top;for(let q=0;q<y;++q){let B=q*w-v.left;for(let Q=0;Q<m;++Q){let H=Number.MIN_SAFE_INTEGER,J=0,ae=0;for(let ne=0;ne<k;++ne){let ue=j+ne*S;if(ue>=0&&ue<p)for(let le=0;le<M;++le){let he=B+le*I;if(he>=0&&he<f){let me=u[_][ue][he][Q]+h[ne][le][Q];me>H&&(H=me,J=ne,ae=le)}}}A[J][ae][Q]+=R[_][D][q][Q]}}}return{dataId:c.write(N.toTypedArray(A,a.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},vfe={kernelName:jp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:l}=n,c=t,u=N.toNestedArray(a.shape,c.data.get(a.dataId).values),h=N.toNestedArray(r.shape,c.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:M,dilationHeight:S,dilationWidth:I,outShape:E}=O.computeDilation2DInfo(a.shape,r.shape,i,o,"NHWC",l);N.assert(s.rank===E.length,()=>`Error in ${jp}, dy must have the same rank as output ${E.length}, but got ${s.rank}`);let R=N.toNestedArray(E,c.data.get(s.dataId).values),A=N.makeZerosNestedTypedArray(a.shape,a.dtype);for(let _=0;_<d;++_)for(let D=0;D<g;++D){let j=D*x-v.top;for(let q=0;q<y;++q){let B=q*w-v.left;for(let Q=0;Q<m;++Q){let H=Number.MIN_SAFE_INTEGER,J=j<0?0:j,ae=B<0?0:B;for(let ne=0;ne<k;++ne){let ue=j+ne*S;if(ue>=0&&ue<p)for(let le=0;le<M;++le){let he=B+le*I;if(he>=0&&he<f){let me=u[_][ue][he][Q]+h[ne][le][Q];me>H&&(H=me,J=ue,ae=he)}}}A[_][J][ae][Q]+=R[_][D][q][Q]}}}return{dataId:c.write(N.toTypedArray(A,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function xfe(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:s,options:i}=a,{contextOptions:o,imageOptions:l}=i||{},c=(l==null?void 0:l.alpha)||1,u=(o==null?void 0:o.contextType)||"2d";if(u!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let h=s.getContext(u,(o==null?void 0:o.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${u} type.`);let[d,p]=r.shape.slice(0,2),f=r.shape.length===2?1:r.shape[2],m=n.data.get(r.dataId).values,g=r.dtype==="float32"?255:1,y=new Uint8ClampedArray(p*d*4);for(let x=0;x<d*p;++x){let w=[0,0,0,255*c];for(let M=0;M<f;M++){let S=m[x*f+M];if(r.dtype==="float32"){if(S<0||S>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${S}.`)}else if(r.dtype==="int32"&&(S<0||S>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${S}.`);f===1?(w[0]=S*g,w[1]=S*g,w[2]=S*g):w[M]=S*g}let k=x*4;y[k+0]=Math.round(w[0]),y[k+1]=Math.round(w[1]),y[k+2]=Math.round(w[2]),y[k+3]=Math.round(w[3])}s.width=p,s.height=d;let v=new ImageData(y,p,d);return h.putImageData(v,0,0),r}var wfe={kernelName:Hw,backendName:"cpu",kernelFunc:xfe};function rv(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;$e(r,"sum");let o;r.dtype==="bool"?o=Zl({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):o=Pi({inputs:{x:r},backend:n});let l=o.shape.length,c=N.parseAxisParam(s,o.shape),u=O.getAxesPermutation(c,l),h=c,d=o;u!=null&&(d=br({inputs:{x:o},backend:n,attrs:{perm:u}}),h=O.getInnerMostAxes(h.length,l)),O.assertAxesAreInnerMostDims("sum",h,d.shape.length);let[p,f]=O.computeOutAndReduceShapes(d.shape,h),m=O.upcastType(d.dtype,"int32"),g=G0(n,p,m),y=N.sizeFromShape(f),v=n.data.get(g.dataId).values,x=n.data.get(d.dataId).values;for(let w=0;w<v.length;++w){let k=w*y,M=0;for(let S=0;S<y;++S)M+=x[k+S];v[w]=M}if(i){let w=O.expandShapeToKeepDim(g.shape,c),k=g;g=ln({inputs:{x:g},backend:n,attrs:{shape:w}}),n.disposeIntermediateTensorInfo(k)}return n.disposeIntermediateTensorInfo(o),u!=null&&n.disposeIntermediateTensorInfo(d),g}var _fe={kernelName:cd,backendName:"cpu",kernelFunc:rv};function Sfe(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:l}=O.decodeEinsumEquation(r,s.length);O.checkEinsumDimSizes(i.length,l,s);let{path:c,steps:u}=O.getEinsumComputePath(o,l),h=u.length,d=null,p=i.length,f=[];for(let m=0;m<h;++m){for(let g of u[m]){let{permutationIndices:y,expandDims:v}=O.getEinsumPermutation(p,l[g]),x;O.isIdentityPermutation(y)?x=s[g]:(x=br({inputs:{x:s[g]},backend:n,attrs:{perm:y}}),f.push(x));let w=x.shape.slice();for(let k=0;k<v.length;++k)w.splice(v[k],0,1);N.arraysEqual(x.shape,w)||(x=ln({inputs:{x},backend:n,attrs:{shape:w}}),f.push(x)),d===null?d=x:(d=i_({inputs:{a:x,b:d},backend:n}),f.push(d))}m<h-1&&(c[m]>=0&&(d=rv({inputs:{x:d},backend:n,attrs:{axis:c[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var Ife={kernelName:qw,backendName:"cpu",kernelFunc:Sfe};function kfe(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t;$e([a,r],"eluGrad");let s=new Float32Array(N.sizeFromShape(r.shape)),i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values;for(let l=0;l<i.length;++l){let c=i[l];c>=0?s[l]=o[l]:s[l]=o[l]*(c+1)}return n.makeTensorInfo(r.shape,"float32",s)}var Tfe={kernelName:zf,backendName:"cpu",kernelFunc:kfe},Efe=O.ERF_P,Nfe=O.ERF_A1,Cfe=O.ERF_A2,Afe=O.ERF_A3,Rfe=O.ERF_A4,Dfe=O.ERF_A5,$fe=jt(xh,e=>{let t=Math.sign(e),n=Math.abs(e),a=1/(1+Efe*n);return t*(1-((((Dfe*a+Rfe)*a+Afe)*a+Cfe)*a+Nfe)*a*Math.exp(-n*n))}),Mfe={kernelName:xh,backendName:"cpu",kernelFunc:$fe};function K0(e){let{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:s}=a,i=r.shape.length,o=r.shape.slice(),l=s;return s<0&&(N.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),ln({inputs:{x:r},backend:n,attrs:{shape:o}})}var Ofe={kernelName:Vf,backendName:"cpu",kernelFunc:K0},Ffe=Mn((e,t)=>e/t),ZC=ia(bh,Ffe),Lk={kernelName:bh,backendName:"cpu",kernelFunc:ZC};function _6(e,t,n){let a=e.shape,r=a[0],s=a[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,c=[r,s],u=N.sizeFromShape(c),h=N.getTypedArrayFromDType("float32",u),d=N.getTypedArrayFromDType("float32",u);for(let g=0;g<r;g++){let y=zc({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),v=zc({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),x=Ar({inputs:{real:y,imag:v},backend:n}),{real:w,imag:k}=Lfe(x,t,n),M=O.mergeRealAndImagArrays(w,k);for(let S=0;S<s;S++){let I=O.getComplexWithIndex(M,S);h[g*s+S]=I.real,d[g*s+S]=I.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(x)}let p=n.makeTensorInfo(c,"float32",h),f=n.makeTensorInfo(c,"float32",d),m=Ar({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function Lfe(e,t,n){let a=N.sizeFromShape(e.shape),r=n.data.get(e.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(zfe(a)){let o=zk(s,i,a,t,n),l=[e.shape[0],e.shape[1]];if(t){let c=n.makeTensorInfo(l,"float32",o.real),u=n.makeTensorInfo(l,"float32",o.imag),h=n.makeTensorInfo([],"float32",N.createScalarValue(a,"float32")),d=Pi({inputs:{x:h},backend:n}),p=Lk.kernelFunc({inputs:{a:c,b:h},backend:n}),f=Lk.kernelFunc({inputs:{a:u,b:d},backend:n}),m=n.data.get(p.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}else{let o=O.mergeRealAndImagArrays(s,i),l=Pfe(o,a,t);return O.splitRealAndImagArrays(l)}}function zfe(e){return(e&e-1)===0}function zk(e,t,n,a,r){if(n===1)return{real:e,imag:t};let s=O.mergeRealAndImagArrays(e,t),i=n/2,o=O.complexWithEvenIndex(s),l=o.real,c=o.imag,u=[l.length],h=r.makeTensorInfo(u,"float32",l),d=r.makeTensorInfo(u,"float32",c),p=Ar({inputs:{real:h,imag:d},backend:r}),f=O.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],v=r.makeTensorInfo(y,"float32",m),x=r.makeTensorInfo(y,"float32",g),w=Ar({inputs:{real:v,imag:x},backend:r}),k=zk(l,c,i,a,r),M=k.real,S=k.imag,I=[M.length],E=r.makeTensorInfo(I,"float32",M),R=r.makeTensorInfo(I,"float32",S),A=Ar({inputs:{real:E,imag:R},backend:r}),_=zk(m,g,i,a,r),D=_.real,j=_.imag,q=[D.length],B=r.makeTensorInfo(q,"float32",D),Q=r.makeTensorInfo(q,"float32",j),H=Ar({inputs:{real:B,imag:Q},backend:r}),J=O.exponents(n,a),ae=[J.real.length],ne=r.makeTensorInfo(ae,"float32",J.real),ue=r.makeTensorInfo(ae,"float32",J.imag),le=Ar({inputs:{real:ne,imag:ue},backend:r}),he=i_({inputs:{a:le,b:H},backend:r}),me=af({inputs:{a:A,b:he},backend:r}),Re=XC({inputs:{a:A,b:he},backend:r}),Ne=Lc({inputs:{input:me},backend:r}),xe=Lc({inputs:{input:Re},backend:r}),Le=rf({inputs:{input:me},backend:r}),Pe=rf({inputs:{input:Re},backend:r}),Xe=sf({inputs:[Ne,xe],backend:r,attrs:{axis:0}}),Ue=sf({inputs:[Le,Pe],backend:r,attrs:{axis:0}}),Et=r.data.get(Xe.dataId).values,st=r.data.get(Ue.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(ne),r.disposeIntermediateTensorInfo(ue),r.disposeIntermediateTensorInfo(le),r.disposeIntermediateTensorInfo(he),r.disposeIntermediateTensorInfo(me),r.disposeIntermediateTensorInfo(Re),r.disposeIntermediateTensorInfo(Ne),r.disposeIntermediateTensorInfo(Le),r.disposeIntermediateTensorInfo(xe),r.disposeIntermediateTensorInfo(Pe),r.disposeIntermediateTensorInfo(Xe),r.disposeIntermediateTensorInfo(Ue),{real:Et,imag:st}}function Pfe(e,t,n){let a=new Float32Array(t*2);for(let r=0;r<t;r++){let s=0,i=0;for(let o=0;o<t;o++){let l=O.exponent(r*o,t,n),c=O.getComplexWithIndex(e,o);s+=c.real*l.real-c.imag*l.imag,i+=c.real*l.imag+c.imag*l.real}n&&(s/=t,i/=t),O.assignToTypedArray(a,s,i,r)}return a}function Vfe(e){let{inputs:t,backend:n}=e,{input:a}=t,r=N.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=ln({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),l=_6(o,!1,n),c=ln({inputs:{x:l},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}var Bfe={kernelName:Kw,backendName:"cpu",kernelFunc:Vfe};function JC(e){let{backend:t,attrs:n}=e,{shape:a,value:r,dtype:s}=n,i=s||N.inferDtype(r),o=N.getArrayFromDType(i,N.sizeFromShape(a));return Wfe(o,r),t.makeTensorInfo(a,i,o)}var Ufe={kernelName:mb,backendName:"cpu",kernelFunc:JC};function Wfe(e,t,n){e.fill(t)}var jfe={kernelName:Bf,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,r=n,s=N.getTypedArrayFromDType(a.dtype,N.sizeFromShape(a.shape)),[i,o,l,c]=a.shape,u=r.data.get(a.dataId).values;for(let h=0;h<i;h++){let d=h*l*o*c;for(let p=0;p<o;p++){let f=p*(l*c);for(let m=0;m<l;m++){let g=m*c;for(let y=0;y<c;y++){let v=Math.round(l-m-1),x=d+f+g+y,w=u[x];if(v>=0&&v<l){let k=v*c,M=d+f+k+y;w=u[M]}s[x]=w}}}}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function Gfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a,m=x6({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(i){let g=m;if(u==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=ln({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=af({inputs:{a:m,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else m=af({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(p){let g=m;if(u==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let y=ln({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=q0(n,m,p,y,f),n.disposeIntermediateTensorInfo(y)}else m=q0(n,m,p,o,f);n.disposeIntermediateTensorInfo(g)}return m}var Hfe={kernelName:kc,backendName:"cpu",kernelFunc:Gfe};function qfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a,m=w6({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(i){let g=m;m=af({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(p){let g=m;m=q0(n,m,p,o,f),n.disposeIntermediateTensorInfo(g)}return m}var Kfe={kernelName:Tc,backendName:"cpu",kernelFunc:qfe};function Xfe(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=N.sizeFromShape(a.shape),i=r.shape,o=i[i.length-1],[l,c,u,h]=O.prepareAndValidate(a,r);if(c===0)return n.makeTensorInfo(l,a.dtype,[]);let d=n.data.get(r.dataId).values,p=n.bufferSync(a),f=zU(d,p,a.dtype,c,o,u,h,a.shape,s);return n.makeTensorInfo(l,a.dtype,f.values)}var Qfe={kernelName:Wf,backendName:"cpu",kernelFunc:Xfe};function Yfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a;$e([r,s],"gatherV2");let l=N.parseAxisParam(i,r.shape)[0],c=n.data.get(s.dataId).values,u=r.shape[l];for(let w=0;w<c.length;++w){let k=c[w];N.assert(k<=u-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${u-1}]`)}let h=o;o==null&&(h=0);let d=N.sizeFromShape(s.shape),p=O.segment_util.collectGatherOpShapeInfo(r,s,l,h),f=ln({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=ln({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=n.bufferSync(m),v=n.bufferSync(f),x=PU(v,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,x.dtype,x.values)}var Zfe={kernelName:Uf,backendName:"cpu",kernelFunc:Yfe};function Jfe(e){let{inputs:t,backend:n}=e,{input:a}=t,r=N.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=ln({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),l=_6(o,!0,n),c=ln({inputs:{x:l},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}var eme={kernelName:Xw,backendName:"cpu",kernelFunc:Jfe},tme=jt(Nh,e=>Number.isFinite(e)?1:0,"bool"),nme={kernelName:Nh,backendName:"cpu",kernelFunc:tme},ame=jt(Ch,e=>Math.abs(e)===1/0?1:0,"bool"),rme={kernelName:Ch,backendName:"cpu",kernelFunc:ame},sme=jt(Ah,e=>Number.isNaN(e)?1:0,"bool"),ime={kernelName:Ah,backendName:"cpu",kernelFunc:sme};function ome(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=jU(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}var lme={kernelName:qf,backendName:"cpu",kernelFunc:ome},ume=jt($h,e=>Math.log1p(e)),cme={kernelName:$h,backendName:"cpu",kernelFunc:ume},hme=Mn((e,t)=>e&&t),dme=ia(Kf,hme,null,"bool"),pme={kernelName:Kf,backendName:"cpu",kernelFunc:dme},fme=jt(Xf,e=>e?0:1,"bool"),mme={kernelName:Xf,backendName:"cpu",kernelFunc:fme},gme=Mn((e,t)=>e||t),yme=ia(Qf,gme,null,"bool"),bme={kernelName:Qf,backendName:"cpu",kernelFunc:yme};function vme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a;$e(r,"LRN");let c=r.shape[3],u=c-1,h=n.data.get(r.dataId).values,d=N.sizeFromShape(r.shape),p=new Float32Array(d);function f(m){let g=m%c,y=m-g+Math.max(0,g-s),v=m-g+Math.min(g+s,u),x=0;for(;y<=v;y++){let w=h[y];x+=w*w}return x}for(let m=0;m<d;m++){let g=f(m),y=h[m]*Math.pow(i+o*g,-l);p[m]=y}return n.makeTensorInfo(r.shape,r.dtype,p)}var xme={kernelName:Mh,backendName:"cpu",kernelFunc:vme};function wme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:c,beta:u}=a;$e(i,"LRNGrad");let h=N.sizeFromShape(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(h),y=h;for(let v=0;v<y;v++){let x=v%d,w=v-x+Math.max(0,x-o),k=v-x+Math.min(d,x+o+1),M=0;for(let S=w;S<k;S++)M+=Math.pow(f[S],2);M=c*M+l;for(let S=w;S<k;S++){let I=-2*c*u*f[S]*m[v]/M;v===S&&(I+=Math.pow(M,-u)),I*=p[v],g[S]+=I}}return n.makeTensorInfo(i.shape,r.dtype,g)}var _me={kernelName:Yf,backendName:"cpu",kernelFunc:wme};function S6(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=n,l=r.shape,c=l.length,u=N.parseAxisParam(s,l),h=u,d=O.getAxesPermutation(h,c),p=o.data.get(r.dataId).values;if(d!=null){let w=new Array(c);for(let k=0;k<w.length;k++)w[k]=l[d[k]];p=WC(p,l,r.dtype,d,w),h=O.getInnerMostAxes(h.length,c),l=w}$e(r,"max"),O.assertAxesAreInnerMostDims("max",h,c);let[f,m]=O.computeOutAndReduceShapes(l,h),g=N.sizeFromShape(m),y=HU(p,g,f,r.dtype),v=o.write(y,f,r.dtype),x=f;return i&&(x=O.expandShapeToKeepDim(f,u)),{dataId:v,shape:x,dtype:r.dtype}}var Sme={kernelName:Oh,backendName:"cpu",kernelFunc:S6};function Ime(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;$e(r,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,c=1;N.assert(O.eitherStridesOrDilationsAreOne(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=O.computePool2DInfo(r.shape,s,i,c,o,l),h;if(u.filterWidth===1&&u.filterHeight===1&&N.arraysEqual(u.inShape,u.outShape))h=Pi({inputs:{x:r},backend:n});else{let d=n.data.get(r.dataId).values,p=N.computeStrides(r.shape),f=YC(d,r.shape,r.dtype,p,u,"max");h=n.makeTensorInfo(u.outShape,r.dtype,f.values)}return h}var kme={kernelName:Lh,backendName:"cpu",kernelFunc:Ime};function Tme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=a;$e(r,"maxPool3d");let u=O.computePool3DInfo(r.shape,s,i,1,o,l,c),h=n.data.get(r.dataId).values,d=v6(h,r.shape,r.dtype,N.computeStrides(r.shape),u,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}var Eme={kernelName:Zf,backendName:"cpu",kernelFunc:Tme};function Nme(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=a;$e([r,s],"maxPool3DGrad");let u=O.computePool3DInfo(s.shape,i,o,1,l,c),h=n.bufferSync(s),d=gpe(h,u),p=u.strideDepth,f=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,v=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,M=x-1-u.padInfo.front,S=k-1-u.padInfo.left,I=w-1-u.padInfo.top,E=ut(s.shape,"float32"),R=n.bufferSync(r);for(let A=0;A<u.batchSize;++A)for(let _=0;_<u.inChannels;++_)for(let D=0;D<u.inDepth;++D)for(let j=0;j<u.inHeight;++j)for(let q=0;q<u.inWidth;++q){let B=D-M,Q=j-I,H=q-S,J=0;for(let ae=0;ae<x;ae+=g){let ne=(B+ae)/p;if(!(ne<0||ne>=u.outDepth||Math.floor(ne)!==ne))for(let ue=0;ue<w;ue+=y){let le=(Q+ue)/f;if(!(le<0||le>=u.outHeight||Math.floor(le)!==le))for(let he=0;he<k;he+=v){let me=(H+he)/m;if(me<0||me>=u.outWidth||Math.floor(me)!==me)continue;let Re=x*w*k-1-d.get(A,ne,le,me,_),Ne=ae*w*k+ue*k+he,xe=Re===Ne?1:0;if(xe===0)continue;let Le=R.get(A,ne,le,me,_);J+=Le*xe}}}E.set(J,A,D,j,q,_)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}var Cme={kernelName:yb,backendName:"cpu",kernelFunc:Nme};function Ame(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;$e([s,i],"maxPoolGrad");let{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=a,d=O.computePool2DInfo(o.shape,l,c,1,u,h),p=n.data.get(o.dataId).values,f=ut(d.outShape,o.dtype,b6(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,v=d.dilationWidth,x=d.effectiveFilterHeight,w=d.effectiveFilterWidth,k=w-1-d.padInfo.left,M=x-1-d.padInfo.top,S=ut(o.shape,"float32"),I=n.data.get(r.dataId).values,E=ut(r.shape,"float32",I);for(let R=0;R<d.batchSize;++R)for(let A=0;A<d.inChannels;++A)for(let _=0;_<d.inHeight;++_)for(let D=0;D<d.inWidth;++D){let j=_-M,q=D-k,B=0;for(let Q=0;Q<x;Q+=y){let H=(j+Q)/m;if(!(H<0||H>=d.outHeight||Math.floor(H)!==H))for(let J=0;J<w;J+=v){let ae=(q+J)/g;if(ae<0||ae>=d.outWidth||Math.floor(ae)!==ae)continue;let ne=x*w-1-f.get(R,H,ae,A),ue=Q*w+J,le=ne===ue?1:0;if(le===0)continue;let he=E.get(R,H,ae,A);B+=he*le}}S.set(B,R,_,D,A)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}var Rme={kernelName:gb,backendName:"cpu",kernelFunc:Ame};function Dme(e,t,n,a,r){let s=N.computeStrides(t),i=YC(e,t,n,s,r,"max"),o=b6(e,t,n,r,!0,a);return[i.values,o.values]}var $me={kernelName:bb,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;$e(a,"MaxPoolWithArgmax");let c=l.data.get(a.dataId).values,u=O.computePool2DInfo(a.shape,r,s,[1,1],i),[h,d]=Dme(c,a.shape,a.dtype,o,u),p=l.write(h,u.outShape,a.dtype),f=l.write(d,u.outShape,a.dtype);return[{dataId:p,shape:u.outShape,dtype:a.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};function Mme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=N.parseAxisParam(s,r.shape),l=O.computeOutAndReduceShapes(r.shape,o)[1],c=N.sizeFromShape(l),u=[],h=n.makeTensorInfo([],"float32",new Float32Array([c]));u.push(h);let d=Zl({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});u.push(d);let p=ZC({inputs:{a:d,b:h},backend:n});u.push(p);let f=rv({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:i}});return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var Ome={kernelName:zh,backendName:"cpu",kernelFunc:Mme};function Fme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;$e(r,"min");let o=N.parseAxisParam(s,r.shape),l=o,c=O.getAxesPermutation(l,r.shape.length),u=r;c!=null&&(u=br({inputs:{x:r},backend:n,attrs:{perm:c}}),l=O.getInnerMostAxes(l.length,r.shape.length)),O.assertAxesAreInnerMostDims("min",l,u.shape.length);let[h,d]=O.computeOutAndReduceShapes(u.shape,l),p=N.sizeFromShape(d),f=N.makeZerosTypedArray(N.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let v=y*p,x=m[v];for(let w=0;w<p;++w){let k=m[v+w];(Number.isNaN(k)||k<x)&&(x=k)}f[y]=x}c!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(h,u.dtype,f);if(i){let y=O.expandShapeToKeepDim(h,o),v=ln({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),v}return g}var Lme={kernelName:Ph,backendName:"cpu",kernelFunc:Fme};function zme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:i}=a;$e(r,"mirrorPad");let o=s.map((v,x)=>v[0]+r.shape[x]+v[1]),l=s.map(v=>v[0]),c=s.map((v,x)=>v[0]+r.shape[x]),u=i==="reflect"?0:1,h=n.data.get(r.dataId).values,d=r.shape.length,p=N.computeStrides(r.shape),f=N.sizeFromShape(o),m=o.length,g=N.computeStrides(o),y=N.getTypedArrayFromDType(r.dtype,f);for(let v=0;v<f;v++){let x=N.indexToLoc(v,m,g);for(let k=0;k<m;k++)x[k]<l[k]?x[k]=l[k]*2-x[k]-u:x[k]>=c[k]&&(x[k]=(c[k]-1)*2-x[k]+u);x=x.map((k,M)=>k-l[M]);let w=N.locToIndex(x,d,p);y[v]=h[w]}return{dataId:n.write(y,o,r.dtype),shape:o,dtype:r.dtype}}var Pme={kernelName:Bh,backendName:"cpu",kernelFunc:zme},Vme=Mn((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),Bme=ia(Uh,Vme),Ume={kernelName:Uh,backendName:"cpu",kernelFunc:Bme},Wme=cu(zw());function I6(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=r.shape.length,o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=N.parseAxisParam([o],r.shape),c=S6({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=O.expandShapeToKeepDim(c.shape,l),h=ln({inputs:{x:c},backend:n,attrs:{shape:u}}),d=XC({inputs:{a:r,b:h},backend:n}),p=MU({inputs:{x:d},backend:n}),f=rv({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=ln({inputs:{x:f},backend:n,attrs:{shape:u}}),g=ZC({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var jme={kernelName:hd,backendName:"cpu",kernelFunc:I6};function Gme(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;$e(r,"multinomial");let l=o?r:I6({inputs:{logits:r},backend:n,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=n.data.get(l.dataId).values,d=[c,s],p=N.makeZerosTypedArray(N.sizeFromShape(d),"int32");for(let f=0;f<c;++f){let m=f*u,g=new Float32Array(u-1);g[0]=h[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+h[m+x];let y=Wme.alea(i.toString()),v=f*s;for(let x=0;x<s;++x){let w=y();p[v+x]=g.length;for(let k=0;k<g.length;k++)if(w<g[k]){p[v+x]=k;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}var Hme={kernelName:Jf,backendName:"cpu",kernelFunc:Gme},qme=Hi.nonMaxSuppressionV3Impl;function Kme(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=a;$e(r,"NonMaxSuppression");let c=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:h}=qme(c,u,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var Xme={kernelName:nm,backendName:"cpu",kernelFunc:Kme},Qme=Hi.nonMaxSuppressionV4Impl;function Yme(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=a;$e(r,"NonMaxSuppressionPadded");let u=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=Qme(u,h,i,o,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var Zme={kernelName:am,backendName:"cpu",kernelFunc:Yme},Jme=Hi.nonMaxSuppressionV5Impl;function ege(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=a;$e(r,"NonMaxSuppressionWithScore");let u=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,d=i,p=o,f=l,m=c,{selectedIndices:g,selectedScores:y}=Jme(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var tge={kernelName:rm,backendName:"cpu",kernelFunc:ege};function nge(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a;$e(r,"oneHot");let c=N.sizeFromShape(r.shape),u=new Float32Array(c*i);u.fill(l);let h=n.data.get(r.dataId).values;for(let d=0;d<c;++d)h[d]>=0&&h[d]<i&&(u[d*i+h[d]]=o);return n.makeTensorInfo([...r.shape,i],s,u)}var age={kernelName:jh,backendName:"cpu",kernelFunc:nge};function X0(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(a.dtype==="complex64"){let r=Lc({inputs:{input:a},backend:n}),s=X0({inputs:{x:r},backend:n}),i=rf({inputs:{input:a},backend:n}),o=X0({inputs:{x:i},backend:n}),l=Ar({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return JC({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}var rge={kernelName:Sm,backendName:"cpu",kernelFunc:X0};function k6(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(a.dtype==="complex64"){let r=Lc({inputs:{input:a},backend:n}),s=k6({inputs:{x:r},backend:n}),i=rf({inputs:{input:a},backend:n}),o=X0({inputs:{x:i},backend:n}),l=Ar({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return JC({backend:n,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}var sge={kernelName:sm,backendName:"cpu",kernelFunc:k6};function T6(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return K0({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{N.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),N.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let h=K0({inputs:{input:u},backend:n,attrs:{dim:r}});return o.push(h),h}),c=sf({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(u=>n.disposeIntermediateTensorInfo(u)),c}var ige={kernelName:im,backendName:"cpu",kernelFunc:T6};function oge(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;$e(r,"pad");let o=s.map((y,v)=>y[0]+r.shape[v]+y[1]),l=s.map(y=>y[0]),c=n.data.get(r.dataId).values,u=N.sizeFromShape(r.shape),h=r.shape.length,d=N.computeStrides(r.shape),p=N.sizeFromShape(o),f=o.length,m=N.computeStrides(o),g=N.getTypedArrayFromDType(r.dtype,p);i!==0&&g.fill(i);for(let y=0;y<u;y++){let v=N.indexToLoc(y,h,d).map((w,k)=>w+l[k]),x=N.locToIndex(v,f,m);g[x]=c[y]}return{dataId:n.write(g,o,r.dtype),shape:o,dtype:r.dtype}}var E6={kernelName:Gh,backendName:"cpu",kernelFunc:oge},lge=Mn((e,t)=>Math.pow(e,t)),uge=ia(Hh,lge),cge={kernelName:Hh,backendName:"cpu",kernelFunc:uge};function hge(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,l=r.map(y=>n.data.get(y.dataId).values),c=r.map(y=>y.shape),u=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,[d,p,f]=ZU(l,c,u,s.shape,s.dtype,h,i.shape),m=d.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}var dge={kernelName:Yw,backendName:"cpu",kernelFunc:hge};function pge(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[c,u]=JU(i,a.shape,a.dtype,o,r.shape,l,s.shape),h=n.makeTensorInfo([c.length],"int32",c),d=n.makeTensorInfo([u.length],a.dtype,u);return[h,d]}var fge={kernelName:Zw,backendName:"cpu",kernelFunc:pge};function mge(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=a,c=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,d=o.map(g=>n.data.get(g.dataId).values),p=o.map(g=>g.shape),[f,m]=e6(c,r.shape,u,s.shape,s.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,m)}var gge={kernelName:Jw,backendName:"cpu",kernelFunc:mge};function yge(e){let{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:i}=n,o=jC(a,r,i,s);return t.makeTensorInfo([o.length],s,o)}var bge={kernelName:vb,backendName:"cpu",kernelFunc:yge},vge=jt(Xh,e=>1/e),xge={kernelName:Xh,backendName:"cpu",kernelFunc:vge};function wge(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;$e(r,"resizeBilinear");let l=N.computeStrides(r.shape),[c,u]=o,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(N.sizeFromShape([h,c,u,f])),y=[s&&c>1?d-1:d,s&&u>1?p-1:p],v=[s&&c>1?c-1:c,s&&u>1?u-1:u],x=0,w=y[0]/v[0],k=y[1]/v[1];for(let M=0;M<h;M++)for(let S=0;S<c;S++){let I;i?I=w*(S+.5)-.5:I=w*S;let E=Math.max(0,Math.floor(I)),R=I-E,A=Math.min(d-1,Math.ceil(I)),_=M*l[0]+E*l[1],D=M*l[0]+A*l[1];for(let j=0;j<u;j++){let q;i?q=k*(j+.5)-.5:q=k*j;let B=Math.max(0,Math.floor(q)),Q=q-B,H=Math.min(p-1,Math.ceil(q)),J=_+B*l[2],ae=D+B*l[2],ne=_+H*l[2],ue=D+H*l[2];for(let le=0;le<f;le++){let he=m[J+le],me=m[ae+le],Re=m[ne+le],Ne=m[ue+le],xe=he+(Re-he)*Q,Le=me+(Ne-me)*Q,Pe=xe+(Le-xe)*R;g[x++]=Pe}}}return n.makeTensorInfo([h,c,u,f],"float32",g)}var _ge={kernelName:Zh,backendName:"cpu",kernelFunc:wge};function Sge(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;$e([s,r],"resizeBilinearGrad");let o=N.computeStrides(r.shape),[l,c,u,h]=r.shape,[,d,p]=s.shape,f=new Float32Array(l*c*u*h),m=[i&&d>1?c-1:c,i&&p>1?u-1:u],g=[i&&d>1?d-1:d,i&&p>1?p-1:p],y=m[0]/g[0],v=m[1]/g[1],x=n.data.get(s.dataId).values,w=0;for(let k=0;k<l;k++){let M=k*o[0];for(let S=0;S<d;S++){let I=S*y,E=Math.floor(I),R=Math.min(Math.ceil(I),c-1),A=M+E*o[1],_=M+R*o[1],D=I-E,j=1-D;for(let q=0;q<p;q++){let B=q*v,Q=Math.floor(B),H=Math.min(Math.ceil(B),u-1),J=B-Q,ae=1-J,ne=A+Q*o[2],ue=A+H*o[2],le=_+Q*o[2],he=_+H*o[2],me=j*ae,Re=j*J,Ne=D*ae,xe=D*J;for(let Le=0;Le<h;Le++){let Pe=x[w++];f[ne+Le]+=Pe*me,f[ue+Le]+=Pe*Re,f[le+Le]+=Pe*Ne,f[he+Le]+=Pe*xe}}}}return n.makeTensorInfo([l,u,c,h],"float32",f)}var Ige={kernelName:um,backendName:"cpu",kernelFunc:Sge};function kge(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;$e(r,"resizeNearestNeighbor");let l=N.computeStrides(r.shape),[c,u]=o,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(h*c*u*f),y=[s&&c>1?d-1:d,s&&u>1?p-1:p],v=[s&&c>1?c-1:c,s&&u>1?u-1:u],x=y[0]/v[0],w=y[1]/v[1],k=0;for(let M=0;M<h;M++){let S=M*l[0];for(let I=0;I<c;I++){let E=i?x*(I+.5):x*I,R=Math.min(d-1,s?Math.round(E):Math.floor(E));i&&(R=Math.max(0,R));let A=S+R*l[1];for(let _=0;_<u;_++){let D=i?w*(_+.5):w*_,j=Math.min(p-1,s?Math.round(D):Math.floor(D));i&&(j=Math.max(0,j));let q=A+j*l[2];for(let B=0;B<f;B++){let Q=m[q+B];g[k++]=Q}}}}return n.makeTensorInfo([h,c,u,f],r.dtype,g)}var Tge={kernelName:Yh,backendName:"cpu",kernelFunc:kge};function Ege(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;$e([s,r],"resizeNearestNeighborGrad");let o=N.computeStrides(r.shape),l=N.computeStrides(s.shape),[c,u,h,d]=r.shape,[,p,f]=s.shape,m=new Float32Array(c*u*h*d),g=n.data.get(s.dataId).values,y=[i&&p>1?u-1:u,i&&f>1?h-1:h],v=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=y[0]/v[0],w=y[1]/v[1],k=1/x,M=1/w,S=Math.ceil(k)*2+2,I=Math.ceil(M)*2+2;for(let E=0;E<c;E++){let R=E*o[0];for(let A=0;A<u;A++){let _=R+A*o[1],D=Math.floor(A*k),j=Math.floor(D-S/2);for(let q=0;q<h;q++){let B=_+q*o[2],Q=Math.floor(q*M),H=Math.floor(Q-I/2);for(let J=0;J<d;J++){let ae=0;for(let ne=0;ne<S;ne++){let ue=ne+j;if(ue<0||ue>=p)continue;let le=R+ue*l[1],he=ue*x,me=Math.min(u-1,i?Math.round(he):Math.floor(he));if(A===me)for(let Re=0;Re<I;Re++){let Ne=Re+H;if(Ne<0||Ne>=f)continue;let xe=le+Ne*l[2],Le=Ne*w,Pe=Math.min(h-1,i?Math.round(Le):Math.floor(Le));q===Pe&&(ae+=g[xe+J])}}m[B+J]=ae}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}var Nge={kernelName:lm,backendName:"cpu",kernelFunc:Ege};function Cge(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a;$e(r,"reverse");let i=r.shape.length,o=N.parseAxisParam(s,r.shape);if(i===0)return Pi({inputs:{x:r},backend:n});let l=new Vn(r.shape,r.dtype),c=n.bufferSync(r);for(let u=0;u<l.size;u++){let h=l.indexToLoc(u),d=h.slice();o.forEach(p=>d[p]=r.shape[p]-1-d[p]),l.set(c.get(...d),...h)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var Age={kernelName:ed,backendName:"cpu",kernelFunc:Cge},Rge={kernelName:Im,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,l=N.getTypedArrayFromDType(a.dtype,N.sizeFromShape(a.shape)),[c,u,h,d]=a.shape,[p,f]=O.getImageCenter(i,u,h),m=255,g=Math.sin(r),y=Math.cos(r),v=o.data.get(a.dataId).values;for(let x=0;x<c;x++){let w=x*h*u*d;for(let k=0;k<u;k++){let M=k*(h*d);for(let S=0;S<h;S++){let I=S*d;for(let E=0;E<d;E++){let R=[c,k,S,E],A=R[2],_=R[1],D=(A-p)*y-(_-f)*g,j=(A-p)*g+(_-f)*y;D=Math.round(D+p),j=Math.round(j+f);let q=s;if(typeof s!="number"&&(E===3?q=m:q=s[E]),D>=0&&D<h&&j>=0&&j<u){let Q=j*(h*d),H=D*d,J=w+Q+H+E;q=v[J]}let B=w+M+I+E;l[B]=q}}}}return{dataId:o.write(l,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},Dge=jt(td,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),$ge={kernelName:td,backendName:"cpu",kernelFunc:Dge};function Mge(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=O.calculateShapes(s,r,i),d=!0,p=n.bufferSync(r),f=n.bufferSync(s),m=oc(p,f,i,h,c,l,o,u,0,d);return n.makeTensorInfo(i,m.dtype,m.values)}var Oge={kernelName:cm,backendName:"cpu",kernelFunc:Mge};function Fge(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function Lge(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}function zge(e,t,n,a,r,s){let i=N.getArrayFromDType("int32",n*r);for(let o=0;o<n;++o){let l=e.slice(o*a,(o+1)*a),c=o*r;for(let u=0;u<r;++u)i[c+u]=s==="left"?Fge(l,t[u+c]):Lge(l,t[u+c])}return i}function Pge(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,c=zge(o,l,r.shape[0],r.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",c)}var Vge={kernelName:dm,backendName:"cpu",kernelFunc:Pge};function Bge(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t;$e([a,r,s],"select");let i=a.shape.length,o=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,u=us(r.dtype,s.dtype),h=N.makeZerosTypedArray(N.sizeFromShape(r.shape),u),d=0,p=i===0||i>1||r.shape.length===1?1:N.sizeFromShape(r.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<p;m++)o[f]===1?h[d++]=l[f]:h[d++]=c[f];return n.makeTensorInfo(r.shape,u,h)}var Uge={kernelName:pm,backendName:"cpu",kernelFunc:Bge},Wge=O.SELU_SCALEALPHA,jge=O.SELU_SCALE,Gge=jt(ad,e=>e>=0?jge*e:Wge*(Math.exp(e)-1)),Hge={kernelName:ad,backendName:"cpu",kernelFunc:Gge},qge=jt(id,e=>e<0?-1:e>0?1:0),Kge={kernelName:id,backendName:"cpu",kernelFunc:qge},Xge=jt(rd,e=>Math.sin(e)),Qge={kernelName:rd,backendName:"cpu",kernelFunc:Xge},Yge=jt(sd,e=>Math.sinh(e)),Zge={kernelName:sd,backendName:"cpu",kernelFunc:Yge},Jge=11920928955078125e-23,NM=Math.log(Jge)+2,eye=jt(ld,e=>{let t=e>-NM,n=e<NM,a=Math.exp(e),r;return n?r=a:t?r=e:r=Math.log(1+a),r}),tye={kernelName:ld,backendName:"cpu",kernelFunc:eye};function nye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;$e([r],"spaceToBatchND");let o=N.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<r.shape.length;++g)l.push([0,0]);let c=E6.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),u=O.getReshaped(c.shape,s,o,!1),h=O.getPermuted(u.length,s.length,!1),d=O.getReshapedPermuted(c.shape,s,o,!1),p=ln({inputs:{x:c},backend:n,attrs:{shape:u}}),f=br({inputs:{x:p},backend:n,attrs:{perm:h}}),m=ln({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}var aye={kernelName:mm,backendName:"cpu",kernelFunc:nye};function rye(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values[0],[h,d,p,f,m]=a6(o,a.shape,a.dtype,l,r.dtype,c,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}var sye={kernelName:xb,backendName:"cpu",kernelFunc:rye};function iye(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(r.dataId).values),o=n.data.get(a.dataId).values,l=Array.from(n.data.get(s.dataId).values),[c,u,h]=r6(o,a.shape,a.dtype,i,l);return[n.makeTensorInfo(u,a.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}var oye={kernelName:ym,backendName:"cpu",kernelFunc:iye};function lye(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[c,u]=GC(i,a.shape,a.dtype,o,l,!0);return n.makeTensorInfo(u,a.dtype,c)}var uye={kernelName:wb,backendName:"cpu",kernelFunc:lye};function cye(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[c,u]=GC(i,a.shape,a.dtype,o,l);return n.makeTensorInfo(u,a.dtype,c)}var hye={kernelName:_b,backendName:"cpu",kernelFunc:cye};function dye(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=O.calculateShapes(s,r,o),p=!1,f=n.bufferSync(r),m;switch(s.dtype){case"bool":{let g=n.bufferSync(s),y=!!n.data.get(i.dataId).values[0];m=oc(f,g,o,d,u,c,l,h,y,p);break}case"float32":{let g=n.bufferSync(s),y=n.data.get(i.dataId).values[0];m=oc(f,g,o,d,u,c,l,h,y,p);break}case"int32":{let g=n.bufferSync(s),y=n.data.get(i.dataId).values[0];m=oc(f,g,o,d,u,c,l,h,y,p);break}case"string":{let g=n.bufferSync(s),y=N.decodeString(n.data.get(i.dataId).values[0]);m=oc(f,g,o,d,u,c,l,h,y,p);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}var pye={kernelName:bm,backendName:"cpu",kernelFunc:dye};function fye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=N.parseAxisParam(i,r.shape)[0],l=O.prepareSplitSize(r,s,o),c=new Array(r.shape.length).fill(0),u=r.shape.slice();return l.map(h=>{let d=[...u];d[o]=h;let p=zc({inputs:{x:r},backend:n,attrs:{begin:c,size:d}});return c[o]+=h,p})}var mye={kernelName:gm,backendName:"cpu",kernelFunc:fye},gye={kernelName:Sb,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,a=t;$e(n,"square");let r=a.data.get(n.dataId).values,s=new Float32Array(r.length);for(let i=0;i<r.length;++i){let o=r[i];s[i]=o*o}return{dataId:a.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},yye=jt(fu,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),bye={kernelName:fu,backendName:"cpu",kernelFunc:yye};function vye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a;$e(r,"stridedSlice");let{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:v,end:x,strides:w}=aa.sliceInfo(r.shape,s,i,o,l,c,u,h,d),k;if(m)k=ln({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||y){N.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let M=aa.computeOutShape(v,x,w),S=zc({inputs:{x:r},backend:n,attrs:{begin:v,size:M}});k=ln({inputs:{x:S},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(S)}else{let M=n.bufferSync(r),S=o6(p,M,w,v);k=n.makeTensorInfo(f,S.dtype,S.values)}return k}var xye={kernelName:vm,backendName:"cpu",kernelFunc:vye};function wye(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:c}=a,{data:u,dataSplits:h}=t,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,m]=HC(d,p,r,s,i,o,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}var _ye={kernelName:kb,backendName:"cpu",kernelFunc:wye};function Sye(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[c,u,h]=qC(o,l,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var Iye={kernelName:Tb,backendName:"cpu",kernelFunc:Sye};function kye(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(s.dataId).values,o=KC(i,r);return n.makeTensorInfo(s.shape,"int32",o)}var Tye={kernelName:Eb,backendName:"cpu",kernelFunc:kye},Eye=jt(fd,e=>Math.tan(e)),Nye={kernelName:fd,backendName:"cpu",kernelFunc:Eye},Cye=jt(md,e=>Math.tanh(e)),Aye={kernelName:md,backendName:"cpu",kernelFunc:Cye};function Rye(e){let{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:c,outputSize:u}=O.calculateShapes(s,r,a.shape),h=!1,d=n.bufferSync(r),p=n.bufferSync(s),f=n.bufferSync(a),m=oc(d,p,a.shape,u,l,o,i,c,f,h);return n.makeTensorInfo(a.shape,m.dtype,m.values)}var Dye={kernelName:hm,backendName:"cpu",kernelFunc:Rye};function $ye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;$e(r,"tile");let i=u6(n.bufferSync(r),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var Mye={kernelName:pu,backendName:"cpu",kernelFunc:$ye};function Oye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a;$e(r,"topk");let o=n.data.get(r.dataId).values,[l,c]=h6(o,r.shape,r.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}var Fye={kernelName:xm,backendName:"cpu",kernelFunc:Oye};function Lye(e){let{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:c}=n,[u,h,d,p]=r.shape,[f,m]=c??[h,d],g=[u,f,m,p],y=N.computeStrides(r.shape),v=y[0],x=y[1],w=y[2],k=N.computeStrides(g),M=k[0],S=k[1],I=k[2],E=N.getTypedArrayFromDType(r.dtype,N.sizeFromShape(g));E.fill(l);let R=a.data.get(r.dataId).values,A=a.data.get(s.dataId).values;for(let _=0;_<u;++_){let D=s.shape[0]===1?A:A.subarray(_*8,_*8+8);for(let j=0;j<f;++j)for(let q=0;q<m;++q)for(let B=0;B<p;++B){let Q,H=D[6]*q+D[7]*j+1;if(H===0)continue;let J=(D[0]*q+D[1]*j+D[2])/H,ae=(D[3]*q+D[4]*j+D[5])/H,ne=CM(J,d,o),ue=CM(ae,h,o);switch(i){case"nearest":Q=Wye(R,h,d,v,x,w,_,ue,ne,B,l);break;case"bilinear":Q=jye(R,h,d,v,x,w,_,ue,ne,B,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let le=_*M+j*S+q*I+B;E[le]=Q}return a.makeTensorInfo(g,r.dtype,E)}return{dataId:a.write(E,g,r.dtype),shape:r.shape,dtype:r.dtype}}var zye={kernelName:wm,backendName:"cpu",kernelFunc:Lye};function CM(e,t,n){switch(n){case"reflect":return Pye(e,t);case"wrap":return Vye(e,t);case"nearest":return Uye(e,t);case"constant":default:return Bye(e)}}function Pye(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=2*t;n<a&&(n=a*Math.trunc(-n/a)+n),n=n<-t?n+a:-n-1}else if(n>t-1)if(t<=1)n=0;else{let a=2*t;n-=a*Math.trunc(n/a),n>=t&&(n=a-n-1)}return N.clamp(0,n,t-1)}function Vye(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=t-1;n+=t*(Math.trunc(-n/a)+1)}else if(n>t-1)if(t<=1)n=0;else{let a=t-1;n-=t*Math.trunc(n/a)}return N.clamp(0,n,t-1)}function Bye(e,t){return e}function Uye(e,t){return N.clamp(0,e,t-1)}function Eg(e,t,n,a,r,s,i,o,l,c,u){let h=i*a+o*r+l*s+c;return 0<=o&&o<t&&0<=l&&l<n?e[h]:u}function Wye(e,t,n,a,r,s,i,o,l,c,u){let h=Math.round(o),d=Math.round(l);return Eg(e,t,n,a,r,s,i,h,d,c,u)}function jye(e,t,n,a,r,s,i,o,l,c,u){let h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1,m=(f-l)*Eg(e,t,n,a,r,s,i,h,d,c,u)+(l-d)*Eg(e,t,n,a,r,s,i,h,f,c,u),g=(f-l)*Eg(e,t,n,a,r,s,i,p,d,c,u)+(l-d)*Eg(e,t,n,a,r,s,i,p,f,c,u);return(p-o)*m+(o-h)*g}function Gye(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;$e(s,"unique");let i=a.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:c}=QC(i,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,o),a.makeTensorInfo([c.length],"int32",c)]}var Hye={kernelName:Nb,backendName:"cpu",kernelFunc:Gye};function qye(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape.length,o=r.shape[s],l=new Array(i-1),c=0;for(let p=0;p<i;p++)p!==s&&(l[c++]=r.shape[p]);let u=new Array(i).fill(0),h=r.shape.slice();h[s]=1;let d=new Array(o);for(let p=0;p<d.length;p++){u[s]=p;let f=zc({inputs:{x:r},backend:n,attrs:{begin:u,size:h}});d[p]=ln({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return d}var Kye={kernelName:_m,backendName:"cpu",kernelFunc:qye};function Xye(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a;$e(r,"unsortedSegmentSum");let o=r.shape.length,l=s.shape.length,c=[],u=[],h=o-l,d=s;for(let f=0;f<h;++f){let m=K0({inputs:{input:d},backend:n,attrs:{dim:f+1}});d=m,u.push(m)}for(let f=0;f<i;++f){let m=N.createScalarValue(f,"int32"),g=n.makeTensorInfo([],"int32",m),y=DU({inputs:{a:g,b:d},backend:n}),v=Zl({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),x=i_({inputs:{a:v,b:r},backend:n}),w=rv({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});c.push(w),u.push(g),u.push(y),u.push(v),u.push(x),u.push(w)}let p=T6({inputs:c,backend:n,attrs:{axis:0}});return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var Qye={kernelName:Cb,backendName:"cpu",kernelFunc:Xye},Yye=[jde,She,Hde,Kde,Che,Qde,Zde,epe,npe,rpe,ipe,lpe,cpe,ppe,mpe,bpe,xpe,_pe,Ipe,Ude,Tpe,Npe,Ape,Rhe,Dpe,Ehe,$he,Mpe,Ihe,Fpe,zpe,Ppe,Bpe,Wpe,Gpe,qpe,Xpe,Ype,Jpe,tfe,afe,sfe,ofe,ufe,cfe,dfe,ffe,gfe,yfe,bfe,vfe,wfe,Ife,Ode,Tfe,Mhe,Mfe,Ohe,Ofe,Lhe,Bfe,Ufe,jfe,Phe,Bhe,Hfe,Kfe,Qfe,Zfe,Whe,Ghe,khe,eme,Lpe,nme,rme,ime,Fde,qhe,Xhe,lme,Yhe,cme,pme,mme,bme,xme,_me,Sme,Jhe,kme,Eme,Cme,Rme,$me,Ome,Lme,tde,Pme,Ume,Hme,ade,sde,Xme,Zme,tge,ode,age,sge,ige,E6,cge,zde,cde,dge,fge,gge,bge,The,Lk,xge,Pde,Vde,Bde,_ge,Ige,Tge,Nge,Age,Rge,$ge,vde,Oge,Vge,Uge,Hge,wde,Kge,Qge,Zge,_de,jme,tye,aye,sye,oye,uye,hye,pye,mye,kde,gye,Ede,Cde,bye,xye,_ye,Iye,Tye,$de,_fe,Nye,Aye,Dye,Mye,Fye,zye,lde,Hye,Kye,Qye,rge];for(let e of Yye)Ab(e);var N6={};tt(N6,{assertNotComplex:()=>Lm,bindCanvasToFramebuffer:()=>lbe,bindColorTextureToFramebuffer:()=>Vx,bindTextureToProgramUniformSampler:()=>j6,bindTextureUnit:()=>B6,bindVertexBufferToProgramAttribute:()=>Pk,callAndCheck:()=>Se,canBeRepresented:()=>A6,createFragmentShader:()=>$6,createFramebuffer:()=>V6,createProgram:()=>M6,createStaticIndexBuffer:()=>L6,createStaticVertexBuffer:()=>F6,createTexture:()=>z6,createVertexShader:()=>D6,getBatchDim:()=>Pc,getExtensionOrThrow:()=>Ng,getFramebufferErrorMessage:()=>G6,getMaxTexturesInShader:()=>X6,getNumChannels:()=>ibe,getProgramUniformLocation:()=>W6,getProgramUniformLocationOrThrow:()=>U6,getRowsCols:()=>Vc,getShapeAs3D:()=>Ag,getTextureShapeFromLogicalShape:()=>q6,getWebGLDisjointQueryTimerVersion:()=>Q6,getWebGLErrorMessage:()=>R6,getWebGLMaxTextureSize:()=>K6,hasExtension:()=>Jr,isCapableOfRenderingToFloatTexture:()=>Y6,isDownloadFloatTextureEnabled:()=>Z6,isReshapeFree:()=>My,isWebGLFenceEnabled:()=>J6,isWebGLVersionEnabled:()=>Bk,linkProgram:()=>O6,logShaderSourceAndInfoLog:()=>tA,resetMaxTextureSize:()=>ube,resetMaxTexturesInShader:()=>cbe,unbindColorTextureFromFramebuffer:()=>Vk,unbindTextureUnit:()=>obe,validateFramebuffer:()=>Cg,validateProgram:()=>Px,validateTextureSize:()=>P6});var sc={},ox={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function C6(e,t){sc[e]=t}function ei(e,t){if(!(e in sc)||t!=null){let a=Jye(e,t);if(a!==null)sc[e]=a;else return console.log("Could not get context for WebGL version",e),null}let n=sc[e];return n==null||n.isContextLost()?(delete sc[e],ei(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),sc[e])}function Zye(e){if(!Z().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Jye(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??Zye(e);return n.addEventListener("webglcontextlost",a=>{a.preventDefault(),delete sc[e]},!1),Z().getBool("SOFTWARE_WEBGL_ENABLED")&&(ox.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",ox)||n.getContext("experimental-webgl",ox):n.getContext("webgl2",ox)}var $y;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})($y||($y={}));var Zr;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Zr||(Zr={}));var Na;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Na||(Na={}));function sv(e,t){return[t,e]}function ebe(e,t){return e*t}function lx(e){let t=N.sizeFromShape(e),n=Math.ceil(t/4);return N.sizeToSquarishShape(n)}function Fm(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function tbe(e,t){let[n,a]=Fm(e,t);return n*a*4}function eA(e,t){let n=e,a,r,s,i,o,l,c,u,h,d;return Z().getNumber("WEBGL_VERSION")===2?(a=n.R32F,r=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,c=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(a=e.RGBA,r=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,c=4,u=4,h=t!=null?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function Se(e,t){let n=t();return Z().getBool("DEBUG")&&nbe(e),n}function nbe(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+R6(e,t))}var abe=596e-10,rbe=65504;function A6(e){return!!(Z().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||abe<Math.abs(e)&&Math.abs(e)<rbe)}function R6(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Ng(e,t){return Vo(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function D6(e,t){let n=Vo(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Se(e,()=>e.shaderSource(n,t)),Se(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function $6(e,t){let n=Vo(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Se(e,()=>e.shaderSource(n,t)),Se(e,()=>e.compileShader(n)),Z().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw tA(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var sbe=/ERROR: [0-9]+:([0-9]+):/g;function tA(e,t){let n=sbe.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let a=+n[1],r=e.split(`
`),s=r.length.toString().length+2,i=r.map((h,d)=>N.rightPad((d+1).toString(),s)+h),o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);let l=i.slice(0,a-1),c=i.slice(a-1,a),u=i.slice(a);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${N.rightPad(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function M6(e){return Vo(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function O6(e,t){if(Se(e,()=>e.linkProgram(t)),!Z().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Px(e,t){if(Se(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function F6(e,t){let n=Vo(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Se(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Se(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function L6(e,t){let n=Vo(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Se(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),Se(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function ibe(){return Z().getNumber("WEBGL_VERSION")===2?1:4}function z6(e){return Vo(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function P6(e,t){let n=Z().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let a=`[${e}x${t}]`;throw new Error("Requested texture size "+a+" is invalid.")}if(e>n||t>n){let a=`[${e}x${t}]`,r=`[${n}x${n}]`;throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}function V6(e){return Vo(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Pk(e,t,n,a,r,s,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(Se(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),Se(e,()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,s,i)),Se(e,()=>e.enableVertexAttribArray(o)),!0)}function B6(e,t,n){H6(e,n),Se(e,()=>e.activeTexture(e.TEXTURE0+n)),Se(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function obe(e,t){H6(e,t),Se(e,()=>e.activeTexture(e.TEXTURE0+t)),Se(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function U6(e,t,n){return Vo(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function W6(e,t,n){return e.getUniformLocation(t,n)}function j6(e,t,n,a){Se(e,()=>B6(e,t,a)),Se(e,()=>e.uniform1i(n,a))}function lbe(e){Se(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Se(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),Se(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function Vx(e,t,n){Se(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),Se(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function Vk(e,t){Se(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),Se(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Cg(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+G6(e,t))}function G6(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Vo(e,t,n){let a=Se(e,()=>t());if(a==null)throw new Error(n);return a}function H6(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){let r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Pc(e,t=2){return N.sizeFromShape(e.slice(0,e.length-t))}function Vc(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Ag(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Pc(e),...Vc(e)]),t}function q6(e,t=!1){let n=Z().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=Z().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");a===1/0&&Z().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n=n*2,a=a*2,e=e.map((o,l)=>l>=e.length-2?N.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=N.squeezeShape(e).newShape);let r=N.sizeFromShape(e),s=null;e.length<=1&&r<=n?s=[1,r]:e.length===2&&e[0]<=n&&e[1]<=n?s=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>a&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let o=Pc(e),l=2,c=2;e.length&&([l,c]=Vc(e)),r=o*(l/2)*(c/2),s=N.sizeToSquarishShape(r).map(u=>u*2)}else s=N.sizeToSquarishShape(r);return s}function ux(e){return e%2===0}function My(e,t){if(e=e.slice(-2),t=t.slice(-2),N.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],a=t[t.length-1];if(n===a||ux(n)&&ux(a)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&ux(e[0])&&ux(t[0])}var Bx,Ux;function K6(e){if(Bx==null){let t=ei(e);Bx=t.getParameter(t.MAX_TEXTURE_SIZE)}return Bx}function ube(){Bx=null}function cbe(){Ux=null}function X6(e){if(Ux==null){let t=ei(e);Ux=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ux)}function Q6(e){if(e===0)return 0;let t,n=ei(e);return Jr(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Jr(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Jr(e,t){return e.getExtension(t)!=null}function Bk(e){try{if(ei(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Y6(e){if(e===0)return!1;let t=ei(e);if(e===1){if(!Jr(t,"OES_texture_float"))return!1}else if(!Jr(t,"EXT_color_buffer_float"))return!1;return Uk(t)}function Z6(e){if(e===0)return!1;let t=ei(e);if(e===1){if(!Jr(t,"OES_texture_float")||!Jr(t,"WEBGL_color_buffer_float"))return!1}else{if(Jr(t,"EXT_color_buffer_float"))return Uk(t);let n="EXT_color_buffer_half_float";if(Jr(t,n)){let a=t.getExtension(n);return hbe(t,a)}return!1}return Uk(t)}function Uk(e){let t=eA(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function hbe(e,t){let n=eA(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(r),s}function J6(e){return e!==2?!1:ei(e).fenceSync!=null}function Lm(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&N.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Me=Z();Me.registerFlag("HAS_WEBGL",()=>Me.getNumber("WEBGL_VERSION")>0);Me.registerFlag("WEBGL_VERSION",()=>Bk(2)?2:Bk(1)?1:0);Me.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Me.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Me.get("WEBGL_VERSION")===2);Me.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Me.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Me.registerFlag("WEBGL_PACK",()=>Me.getBool("HAS_WEBGL"));Me.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_CLIP",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_REDUCE",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_LAZILY_UNPACK",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_CONV_IM2COL",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>K6(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>X6(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=Me.getNumber("WEBGL_VERSION");return e===0?0:Q6(e)});Me.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Me.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!$b.isMobile());Me.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Y6(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Me.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Me.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Me.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Z6(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_FENCE_API_ENABLED",()=>J6(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Me.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Me.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});Me.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>$b.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});Me.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Me.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Me.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Me.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Me.registerFlag("WEBGL_EXP_CONV",()=>!1);Me.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Me.getBool("IS_TEST"));Me.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Me.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Me.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Me.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function ir(){let e,t,n,a,r,s,i,o,l,c;return Z().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",a="in",r="texture",s="outputColor",i="out vec4 outputColor;",o=Z().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",a="varying",r="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:c}}function Sd(e,t,n="index"){let a=N.computeStrides(t);return a.map((r,s)=>{let i=`int ${e[s]} = ${n} / ${r}`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r}`:`index -= ${e[s]} * ${r}`;return`${i}; ${o};`}).join("")}function o_(e,t,n="index"){let a=N.computeStrides(t);return a.map((r,s)=>{let i=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join("")}function dbe(e,t){let n=e.length,a=e.map(s=>`${t}[${s}]`),r=new Array(n-1);r[n-2]=a[n-1];for(let s=n-3;s>=0;--s)r[s]=`(${r[s+1]} * ${a[s+1]})`;return r}function pbe(e,t,n="index"){let a=e.map((s,i)=>i),r=dbe(a,t);return r.map((s,i)=>{let o=`int ${e[i]} = ${n} / ${r[i]}`,l=i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`;return`${o}; ${l};`}).join("")}function nA(e){let t=N.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function aA(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var e5=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:t5}=O;function fbe(e,t,n){let a=[];if(e.forEach(d=>{let p=N.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?a.push(`uniform float ${d.name}${p>1?`[${p}]`:""};`):(a.push(`uniform sampler2D ${d.name};`),a.push(`uniform int offset${d.name};`)),n.enableShapeUniforms){let{uniformShape:f}=rA(n.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(f.length){case 1:a.push(`uniform int ${d.name}Shape;`);break;case 2:a.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:a.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:a.push(`uniform ivec4 ${d.name}Shape;`);break}a.push(`uniform ivec2 ${d.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;");break}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(d=>{a.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let r=a.join(`
`),s=e.map(d=>mbe(d,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=ir(),l=bbe(o),c,u,h=wbe(o);return t.isPacked?(c=gbe(t.logicalShape,i,n.enableShapeUniforms),u=xbe(o)):(c=ybe(t.logicalShape,i,n.enableShapeUniforms),u=vbe(o)),n.packedInputs&&(h+=kbe),[h,l,u,r,c,s,n.userCode].join(`
`)}function zm(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return Lbe(e,t);case 1:return Pbe(e,t);case 2:return Bbe(e,t);case 3:return Wbe(e,t);case 4:return Gbe(e,t);case 5:return Hbe(e);case 6:return qbe(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function n5(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return Fbe(e);case 1:return zbe(e,t);case 2:return Vbe(e,t);case 3:return Ube(e,t);default:return jbe(e,t)}}function mbe(e,t,n=!1,a){let r="";n?r+=n5(e,a):r+=zm(e,a);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?r+=Kbe(e,t):r+=Xbe(e,t)),r}function gbe(e,t,n){switch(e.length){case 0:return a5();case 1:return Tbe(e,t,n);case 2:return Mbe(e,t,n);case 3:return Nbe(e,t,n);default:return Abe(e,t,n)}}function ybe(e,t,n){switch(e.length){case 0:return a5();case 1:return Ebe(e,t,n);case 2:return Obe(e,t,n);case 3:return Cbe(e,t,n);case 4:return Rbe(e,t,n);case 5:return Dbe(e,t);case 6:return $be(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function bbe(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function vbe(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function xbe(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function wbe(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${_be}
    ${Sbe}
    ${Ibe}
  `}var _be=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Sbe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Ibe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,kbe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function a5(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Tbe(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return a[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${a[1]}.0);
      }
    `:a[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${a[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      return 2 * (resTexRC.x * ${a[1]} + resTexRC.y);
    }
  `}function Ebe(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function Nbe(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function Cbe(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${o_(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let a=Sd(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec3(r, c, d);
    }
  `}function Abe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let c=2;c<e.length-1;c++)i*=e[e.length-c-1],o=`
      int b${c} = index / ${i};
      index -= b${c} * ${i};
    `+o,l=`b${c}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));
      int index = resTexRC.x * ${a[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${e.length}(${l});
    }
  `}function Rbe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${o_(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let a=Sd(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${a}
      return ivec4(r, c, d, d2);
    }
  `}function Dbe(e,t){let n=Sd(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function $be(e,t){let n=Sd(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Mbe(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(N.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${a[0]}, ${a[1]}));
      }
    `;let r=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${a[0]}, ${a[1]}));

      int index = resTexRC.x * ${a[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function Obe(e,t,n){return N.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Id(e){return`offset${e}`}function Fbe(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=ir();return`
    vec4 ${n}() {
      return ${a.texture2D}(${t}, halfCR);
    }
  `}function Lbe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${a}() {return ${n};}`;let[r,s]=e.shapeInfo.texShape;if(r===1&&s===1)return`
      float ${a}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=Id(n);if(t)return`
    float ${a}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${a}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function zbe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=ir();if(t)return`
    vec4 ${a}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${a}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}function Pbe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${a}(int index) {
        ${Pm(e)}
      }
    `;let r=e.shapeInfo.texShape,s=r[0],i=r[1];if(i===1&&s===1)return`
      float ${a}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=Id(n);return i===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:s===1?t?`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${a}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${a}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function Vbe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=ir();if(s!=null&&N.arraysEqual(n,s))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);

        return ${l.texture2D}(${a}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${a}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${a}, uv);
    }
  `;let c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${a}, uv);
    }
  `}function Bbe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape;if(s!=null&&N.arraysEqual(n,s)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `;let d=s[0],p=s[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${a}, uv);
    }
  `}let{newShape:i,keptDims:o}=N.squeezeShape(n),l=i;if(l.length<n.length){let d=Vm(e,l),p=["row","col"];return`
      ${zm(d,t)}
      float ${r}(int row, int col) {
        return ${r}(${Bm(p,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Pm(e)}
      }
    `;let c=s[0],u=s[1],h=Id(a);return u===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${a}TexShape[0]));
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${a}, uv);
    }
  `:c===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${a}TexShape[1]), 0.5);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${a}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
        return sampleTexture(${a}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${a}, uv);
  }
`}function Ube(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){let d=n.slice(1),p=[1,2],f=Vm(e,d),m=["b","row","col"];return`
        ${n5(f,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Bm(m,p)});
        }
      `}let o=ir();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${a}, uv);
    }
  `;let l=i[0],c=i[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${o.texture2D}(${a}, uv);
    }
  `}function Wbe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=N.squeezeShape(n),c=o;if(c.length<n.length){let m=Vm(e,c),g=["row","col","depth"];return`
        ${zm(m,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Bm(g,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Pm(e)}
      }
    `;let u=e.shapeInfo.texShape,h=u[0],d=u[1],p=e.shapeInfo.flatOffset;if(d===s&&p==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${a}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${a}, uv);
        }
      `;if(d===i&&p==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${a}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${a}, uv);
    }
  `;let f=Id(a);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${a}Shape[1] * ${a}Shape[2];
      int stride1 = ${a}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
      return sampleTexture(${a}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${a}, uv);
      }
  `}function jbe(e,t){let n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=ir();if(t)return`
    vec4 ${a}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=l[0],u=l[1],h=Math.ceil(s[i-1]/2),d=h*Math.ceil(s[i-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,d*=s[i-m-1],f=`b${m} * ${d} + `+f;return`
    vec4 ${a}(${p}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${r.texture2D}(${n}, uv);
    }
  `}function Gbe(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:c}=N.squeezeShape(n);if(l.length<n.length){let v=Vm(e,l),x=["row","col","depth","depth2"];return`
      ${zm(v,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Bm(x,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${s}, 1)));
        ${Pm(e)}
      }
    `;let u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${a}Shape[3];`,m=`int stride1 = ${a}Shape[2] * stride2;`,g=`int stride0 = ${a}Shape[1] * stride1;`;if(p===o&&u==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${a}, uv);
      }
    `;if(p===s&&u==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${a}Shape[1] * ${a}Shape[2], ${a}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${a}, uv);
      }
    `;let y=Id(a);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${y});
      return sampleTexture(${a}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${y});
      return sampleTexture(${a}, uv);
    }
  `}function Hbe(e){let t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],s=t[3]*r,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:c}=N.squeezeShape(t);if(l.length<t.length){let m=Vm(e,l),g=["row","col","depth","depth2","depth3"];return`
      ${zm(m)}
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        return ${a}(${Bm(g,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${s}, ${r})) +
          depth3;
        ${Pm(e)}
      }
    `;let u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&u==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===r&&u==null)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=Id(n);return`
    float ${a}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${s} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function qbe(e){let t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=N.squeezeShape(t);if(r.length<t.length){let g=Vm(e,r),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${zm(g)}
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${a}(${Bm(y,s)});
      }
    `}let i=t[5],o=t[4]*i,l=t[3]*o,c=t[2]*l,u=t[1]*c;if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Pm(e)}
      }
    `;let h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&h==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&h==null)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=Id(n);return`
    float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Pm(e){let t=e.name,n=N.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Kbe(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=t5(e.shapeInfo.logicalShape,t.logicalShape),l=Zt(i),c=i-s,u,h=["x","y","z","w","u","v"];s===0?u="":i<2&&o.length>=1?u="coords = 0;":u=o.map(g=>`coords.${h[g+c]} = 0;`).join(`
`);let d="";i<2&&s>0?d="coords":d=e.shapeInfo.logicalShape.map((g,y)=>`coords.${h[y+c]}`).join(", ");let p="return outputValue;",f=N.sizeFromShape(e.shapeInfo.logicalShape)===1,m=N.sizeFromShape(t.logicalShape)===1;if(s===1&&!f&&!m)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!m)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){let g=s-2,y=s-1;o.indexOf(g)>-1&&o.indexOf(y)>-1?p="return vec4(outputValue.x);":o.indexOf(g)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(y)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${a}(${d});
      ${p}
    }
  `}function Xbe(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&N.arraysEqual(i,s))return`
      float ${r}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let c=Zt(l),u=t5(e.shapeInfo.logicalShape,t.logicalShape),h=l-o,d,p=["x","y","z","w","u","v"];o===0?d="":l<2&&u.length>=1?d="coords = 0;":d=u.map(m=>`coords.${p[m+h]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=e.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+h]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${d}
      return get${a}(${f});
    }
  `}function Zt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function rA(e,t,n){let{newShape:a,keptDims:r}=N.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):a,l=!e&&s>1&&!N.arraysEqual(t,n)&&a.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:r}}function Vm(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Bm(e,t){return t.map(n=>e[n]).join(", ")}function Qbe(e,t,n,a){let r=n.map((u,h)=>{let d={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(d.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[h],shapeInfo:d}}),s=r.map(u=>u.shapeInfo),i={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},o=fbe(r,i,t),l=$6(e.gl,o),c=e.createProgram(l);return Z().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(c),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:s,outShapeInfo:i},r5(e,t,c)))}function r5(e,t,n){let a=[],r=[],s,i,o,l=null,c=null;c=e.getUniformLocation(n,"NAN",!1),Z().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));let u=!1;for(let h of t.variableNames){let d={name:h,uniform:e.getUniformLocation(n,h,u),offset:e.getUniformLocation(n,`offset${h}`,u)};t.enableShapeUniforms&&(d.shape=e.getUniformLocation(n,`${h}Shape`,u),d.texShape=e.getUniformLocation(n,`${h}TexShape`,u)),a.push(d)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",u),o=e.getUniformLocation(n,"outShapeStrides",u),i=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(let h of t.customUniforms)r.push(e.getUniformLocation(n,h.name,u));return{variablesLocations:a,customUniformLocations:r,infLoc:l,nanLoc:c,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function AM(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,a)=>{let r=n.logicalShape,s=t[a],i=s.shape;if(!N.arraysEqual(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(n.isUniform&&s.isUniform)return;let o=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!N.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function Ybe(e,t,n,a,r){t.program.enableShapeUniforms||(AM(t.inShapeInfos,n),AM([t.outShapeInfo],[a]));let s=a.texData.texture,i=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),Z().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let c=n[l],{uniform:u,offset:h,shape:d,texShape:p}=t.variablesLocations[l];if(d){let{uniformShape:f}=rA(t.program.packedInputs,c.shape,c.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(d,new Int32Array(f));break;case 2:e.gl.uniform2iv(d,new Int32Array(f));break;case 3:e.gl.uniform3iv(d,new Int32Array(f));break;case 4:e.gl.uniform4iv(d,new Int32Array(f));break}}if(p&&e.gl.uniform2i(p,c.texData.texShape[0],c.texData.texShape[1]),u!=null){if(c.isUniform){if(N.sizeFromShape(c.shape)<2)e.gl.uniform1f(u,c.uniformValues[0]);else{let f=c.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(u,f)}continue}c.texData.slice!=null&&h!=null&&e.gl.uniform1i(h,c.texData.slice.flatOffset),e.setInputMatrixTexture(c.texData.texture.texture,u,l)}}let o=t.outShapeLocation;if(o)switch(a.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(a.shape));break}if(t.outShapeStridesLocation){let l=N.computeStrides(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let l=0;l<t.program.customUniforms.length;++l){let c=t.program.customUniforms[l],u=t.customUniformLocations[l],h=r[l];if(c.type==="float")e.gl.uniform1fv(u,h);else if(c.type==="vec2")e.gl.uniform2fv(u,h);else if(c.type==="vec3")e.gl.uniform3fv(u,h);else if(c.type==="vec4")e.gl.uniform4fv(u,h);else if(c.type==="int")e.gl.uniform1iv(u,h);else if(c.type==="ivec2")e.gl.uniform2iv(u,h);else if(c.type==="ivec3")e.gl.uniform3iv(u,h);else if(c.type==="ivec4")e.gl.uniform4iv(u,h);else throw Error(`uniform type ${c.type} is not supported yet.`)}e.executeProgram()}function Zbe(e,t,n){let a="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=rA(e.packedInputs,i.shape,l),d="",p="",f="";if(u.length===1&&e.packedInputs){let k=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${k[0]>1}_${k[1]>1}`}else if(u.length===2&&!e.packedInputs)p=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!e.packedInputs){let k=N.computeStrides(u);f=`${k[0]===l[1]}_${k[k.length-1]===l[1]}`}let m=i.shape.length,g=u.length===2&&N.arraysEqual(i.shape,l),y=N.sizeFromShape(i.shape)===1,v=O.getBroadcastDims(i.shape,n.shape),x=!e.packedInputs&&m===n.shape.length&&N.arraysEqual(l,n.texData.texShape),w=e.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;a+=`${m}_${x}_${c?h:""}_${u.length}_${y}_${v}_${g}_${d}_${p}_${f}_${w}_${o}`}else{let l=i.isUniform?"uniform":i.texData.texShape;a+=`${i.shape}_${l}_${o}`}});let r=e.userCode,s=e.constructor.name;return s+="_"+a+"_"+r+`${Z().getNumber("WEBGL_VERSION")}`,s}function ja(e){return Z().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var Jbe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=$y.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=ir();this.outputShape=e,this.enableShapeUniforms=ja(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?o_(["r","c","d"],e):Sd(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},eve=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=$y.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=ir();this.outputShape=e,this.enableShapeUniforms=ja(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?o_(["r","c","d"],e):Sd(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},tve=class{constructor(e){this.variableNames=["A"],this.outTexUsage=Zr.DOWNLOAD;let t=ir();this.outputShape=e,this.userCode=`
      ${e5}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},nve=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Zr.DOWNLOAD;let t=ir();this.outputShape=e,this.userCode=`
      ${e5}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},ave={R:0,G:1,B:2,A:3},RM=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let a=ir();this.outputShape=e,this.enableShapeUniforms=ja(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let o=n[i];s+=`
          if(offset == ${i}) {
            result = values[${ave[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?aA():nA(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${a.texture2D}(A, uv);
          ${s}
        }
        ${a.output} = vec4(${r}, 0., 0., 0.);
      }
    `}},rve=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=ir();this.outputShape=e,this.enableShapeUniforms=ja(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let o=s*2+i;a+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?aA():nA(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${a}

          ${n.output} = ${r};
        }
    `}},s5={};tt(s5,{bindVertexProgramAttributeStreams:()=>f5,createBufferFromOutputTexture:()=>y5,createFloat16MatrixTexture:()=>c5,createFloat16PackedMatrixTexture:()=>p5,createFloat32MatrixTexture:()=>u5,createIndexBuffer:()=>l5,createPackedMatrixTexture:()=>d5,createUnsignedBytesMatrixTexture:()=>h5,createVertexBuffer:()=>o5,createVertexShader:()=>i5,downloadByteEncodedFloatMatrixFromOutputTexture:()=>v5,downloadFloat32MatrixFromBuffer:()=>b5,downloadMatrixFromPackedOutputTexture:()=>w5,downloadPackedMatrixFromBuffer:()=>x5,getInternalFormatForFloat16MatrixTexture:()=>iA,getInternalFormatForFloat16PackedMatrixTexture:()=>uA,getInternalFormatForFloat32MatrixTexture:()=>sA,getInternalFormatForPackedMatrixTexture:()=>lA,getInternalFormatForUnsignedBytesMatrixTexture:()=>oA,uploadDenseMatrixToTexture:()=>m5,uploadPixelDataToTexture:()=>g5});function i5(e){let t=ir(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return D6(e,n)}function o5(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return F6(e,t)}function l5(e){let t=new Uint16Array([0,1,2,2,1,3]);return L6(e,t)}function iv(e,t,n,a,r,s){P6(t,n);let i=z6(e),o=e.TEXTURE_2D;return Se(e,()=>e.bindTexture(o,i)),Se(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),Se(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),Se(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),Se(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),Z().getNumber("WEBGL_VERSION")===1?Se(e,()=>e.texImage2D(o,0,a,t,n,0,r,s,null)):Se(e,()=>e.texStorage2D(o,1,a,t,n)),Se(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function sA(e){return e.internalFormatFloat}function u5(e,t,n,a){let[r,s]=sv(t,n);return iv(e,r,s,sA(a),a.textureFormatFloat,e.FLOAT)}function iA(e){return e.internalFormatHalfFloat}function c5(e,t,n,a){let[r,s]=sv(t,n);return iv(e,r,s,iA(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function oA(e){return e.downloadTextureFormat}function h5(e,t,n,a){let[r,s]=sv(t,n);return iv(e,r,s,oA(a),e.RGBA,e.UNSIGNED_BYTE)}function lA(e){return e.internalFormatPackedFloat}function d5(e,t,n,a){let[r,s]=Fm(t,n);return iv(e,r,s,lA(a),e.RGBA,e.FLOAT)}function uA(e){return e.internalFormatPackedHalfFloat}function p5(e,t,n,a){let[r,s]=Fm(t,n);return iv(e,r,s,uA(a),e.RGBA,a.textureTypeHalfFloat)}function f5(e,t,n){return Se(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Pk(e,t,"clipSpacePos",n,3,20,0)&&Pk(e,t,"uv",n,2,20,12)}function m5(e,t,n,a,r,s){Se(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;r instanceof Uint8Array?(i=new Uint8Array(n*a*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*a*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(r),Z().getNumber("WEBGL_VERSION")===2?Se(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,o,i)):Se(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,a,0,e.RGBA,o,i)),Se(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function g5(e,t,n){Se(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?Z().getNumber("WEBGL_VERSION")===2?Se(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):Se(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):Z().getNumber("WEBGL_VERSION")===2?Se(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):Se(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),Se(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function y5(e,t,n,a){let r=e.createBuffer();Se(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));let s=4*4*t*n;return Se(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),Se(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),Se(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}function b5(e,t,n){let a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}function v5(e,t,n,a){let[r,s]=sv(t,n),i=4,o=new Uint8Array(ebe(t*n,i));return Se(e,()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function x5(e,t,n,a,r,s,i,o){let l=e,c=new Float32Array(tbe(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function w5(e,t,n){let a=new Float32Array(t*n*4);return Se(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a)),a}var Wx=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=Z().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,C6(t,e)):this.gl=ei(t),e=this.gl,Z().getNumber("WEBGL_VERSION")===2){let r=e;this.createVertexArray=()=>Se(r,()=>r.createVertexArray()),this.bindVertexArray=s=>Se(r,()=>r.bindVertexArray(s)),this.deleteVertexArray=s=>Se(r,()=>r.deleteVertexArray(s)),this.getVertexArray=()=>Se(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){let r=e.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Se(e,()=>r.createVertexArrayOES()),this.bindVertexArray=s=>Se(e,()=>r.bindVertexArrayOES(s)),this.deleteVertexArray=s=>Se(e,()=>r.deleteVertexArrayOES(s)),this.getVertexArray=()=>Se(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Z().getNumber("WEBGL_VERSION")===1){let r="OES_texture_float",s="OES_texture_half_float";if(this.textureFloatExtension=Ng(this.gl,r),Jr(this.gl,s))this.textureHalfFloatExtension=Ng(this.gl,s);else if(Z().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Jr(this.gl,a))this.colorBufferHalfFloatExtension=Ng(this.gl,a);else if(Z().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Jr(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Jr(this.gl,a))this.colorBufferHalfFloatExtension=this.gl.getExtension(a);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=o5(this.gl),this.indexBuffer=l5(this.gl),this.framebuffer=V6(this.gl),this.textureConfig=eA(this.gl,this.textureHalfFloatExtension)}get debug(){return Z().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;Se(e,()=>e.finish()),Se(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Se(e,()=>e.deleteFramebuffer(this.framebuffer)),Se(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Se(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Se(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),u5(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),c5(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),h5(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),g5(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),m5(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),p5(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),d5(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Vk(this.gl,this.framebuffer),this.outputTexture=null),Se(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>v5(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,a,r,s){return x5(this.gl,e,t,n,a,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return b5(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let a=y5(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Z().getBool("WEBGL_FENCE_API_ENABLED")){let a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let s=a.clientWaitSync(r,0,0);return s===a.ALREADY_SIGNALED||s===a.CONDITION_SATISFIED},t=r}else Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>w5(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=i5(t));let n=M6(t);Se(t,()=>t.attachShader(n,this.vertexShader)),Se(t,()=>t.attachShader(n,e)),O6(t,n);let a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&Px(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;Se(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),f5(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Se(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Px(this.gl,this.program),Se(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?U6(this.gl,e,t):W6(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Se(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),j6(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[a,r]=Fm(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Px(this.gl,this.program),Cg(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Se(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Se(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Ng(this.gl,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.createQuery();return n.beginQuery(a.TIME_ELAPSED_EXT,r),r}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await N.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),a=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=sve(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Z().platform&&(n=Z().platform.setTimeoutCustom.bind(Z().platform)),N.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Vx(this.gl,e,this.framebuffer),this.debug&&Cg(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Vx(this.gl,this.outputTexture,this.framebuffer),this.debug&&Cg(this.gl)):Vk(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let a=this.gl;Vx(a,e,this.framebuffer),this.debug&&Cg(a),this.outputTexture=e,Se(a,()=>a.viewport(0,0,t,n)),Se(a,()=>a.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),Se(this.gl,()=>this.gl.scissor(e,t,n,a))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function sve(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:ive,bincountImpl:_5,bincountReduceImpl:ove,bitwiseAndImpl:lve,castImpl:uve,ceilImpl:cve,concatImpl:hve,equalImpl:dve,expImpl:pve,expm1Impl:fve,floorImpl:mve,gatherNdImpl:gve,gatherV2Impl:yve,greaterImpl:bve,greaterEqualImpl:vve,lessImpl:xve,lessEqualImpl:wve,linSpaceImpl:_ve,logImpl:Sve,maxImpl:Ive,maximumImpl:kve,minimumImpl:Tve,multiplyImpl:Eve,negImpl:Nve,notEqualImpl:Cve,prodImpl:Ave,raggedGatherImpl:Rve,raggedRangeImpl:Dve,raggedTensorToTensorImpl:$ve,rangeImpl:Mve,rsqrtImpl:Ove,scatterImpl:Fve,sigmoidImpl:Lve,simpleAbsImpl:S5,sliceImpl:zve,sparseFillEmptyRowsImpl:Pve,sparseReshapeImpl:Vve,sparseSegmentReductionImpl:I5,sqrtImpl:Bve,staticRegexReplaceImpl:Uve,stridedSliceImpl:Wve,stringNGramsImpl:jve,stringSplitImpl:Gve,stringToHashBucketFastImpl:Hve,subImpl:qve,tileImpl:Kve,topKImpl:Xve,transposeImpl:cA,uniqueImpl:Qve}=zC;function k5(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Ya(e,t){return t===1?[e]:k5(e,t)}function Yve(e,t){if(e===1)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}var Zve=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=ja(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=Ya("rc",this.rank),n=Zt(this.rank),a=this.getOutOfBoundsCondition(t),r=this.getSetup(t),s=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${a}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${s}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r=`${n===0?"r":"rp1"}, ${a===0?"c":"cp1"}`;for(let s=2;s<this.rank;s++)r=`${e[e.length-1-s]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],a=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${a};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},T5=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=ja(this.outputShape.length);let n="";for(let a=0;a<4;a++){let r="thisRC = rc;";a%2===1&&(r+="thisRC.z += 1;"),a>1&&(r+="thisRC.y += 1;"),n+=`
        ${r}
        ${a>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${a}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${a>0?"}":""}
      `}this.userCode=`
      ${Jve(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?aA():nA(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function Jve(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?pbe(["r","c","d"],"inputShape"):Sd(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var exe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let a=$M(t,n),r=MM(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);let s=DM(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[r].pop();return this.usedTextures[r].push(o),o}let i;return a===Na.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===Na.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===Na.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===Na.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===Na.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,a){if(this.freeTextures==null)return;let r=$M(n,a),s=MM(t,r,a);s in this.freeTextures||(this.freeTextures[s]=[]);let i=DM(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),o=Z().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],c=l&&l.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function txe(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function DM(e,t,n,a,r){let s=nxe(t,a),i;if(r){let[l,c]=Fm(e[0],e[1]);i=l*c}else{let[l,c]=sv(e[0],e[1]);i=l*c}let o=txe(n,s);return i*o}function nxe(e,t){switch(e){case Na.PACKED_2X2_FLOAT32:return lA(t);case Na.PACKED_2X2_FLOAT16:return uA(t);case Na.UNPACKED_FLOAT32:return sA(t);case Na.UNPACKED_FLOAT16:return iA(t);case Na.PACKED_4X1_UNSIGNED_BYTE:return oA(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function axe(e){return Z().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Na.PACKED_2X2_FLOAT32:Na.UNPACKED_FLOAT32:e?Na.PACKED_2X2_FLOAT16:Na.UNPACKED_FLOAT16}function $M(e,t){if(e===Zr.UPLOAD)return Na.PACKED_2X2_FLOAT32;if(e===Zr.RENDER||e==null)return axe(t);if(e===Zr.DOWNLOAD||e===Zr.PIXELS)return Na.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function MM(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var Ei=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=ja(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Ls="if (isnan(x)) return x;",rxe="return x;",OM="return abs(x);",sxe="return (x >= 0.0) ? x : (exp(x) - 1.0);",ixe=Ls+`
  return (x < 0.0) ? 0.0 : x;
`,oxe=Ls+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,rl="return x;",lxe="return 1.0 / (1.0 + exp(-1.0 * x));",uxe="return x;",cxe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,hxe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dxe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,pxe="return 1.0 / (1.0 + exp(-1.0 * x));",bl=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=ja(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},fxe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=ja(this.outputShape.length);let t=e.length,n=Ya("rc",t),a=Zt(t),r=Yve(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${a} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},mxe=Hi.whereImpl,gxe=1e-7,yxe=1e-4,FS={};function bxe(e){return e in FS||(FS[e]={}),FS[e]}var vxe=Z().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),xxe=600;function wxe(){return Z().global.screen==null?1024:Z().global.screen.height*Z().global.screen.width*window.devicePixelRatio*xxe/1024/1024}var hA=class E5 extends ob{nextDataId(){return E5.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Z().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof Wx)n=t;else{let a=ei(Z().getNumber("WEBGL_VERSION"),t);n=new Wx(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let a=ei(Z().getNumber("WEBGL_VERSION"));n=new Wx(a),this.binaryCache=bxe(Z().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new exe(this.gpgpu),this.numMBBeforeWarning=wxe(),this.texData=new Pw(this,xs())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,a,r,s,i){let o=this.makeTensorInfo(n,a),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[r,s]},l.texShape=[r,s];let c=Ag(n),u=new RM(c,!1,i),h=this.runWebGLProgram(u,[o],a,[[r,s]]);return h.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),h.dataId}write(t,n,a){if((Z().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Z().getBool("DEBUG"))&&this.checkNumericalProblems(t),a==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:a,values:t,usage:Zr.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,a,r,s){if(Z().getBool("DEBUG")&&this.checkNumericalProblems(n),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:a,dtype:r,values:n,usage:Zr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:a,dtype:r,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=n;if(i!=null){let d;l?d=new bl(o,rl):d=new Ei(o,rl);let p=this.runWebGLProgram(d,[{dataId:t,shape:o,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(a!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return a;let c=this.activeTimers!=null,u;c&&(u=N.now());let h;if(r==="complex64"){let d=this.readSync(s.real.dataId),p=this.readSync(s.imag.dataId);h=O.mergeRealAndImagArrays(d,p)}else h=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=N.now()-u),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){let f=this.pendingRead.get(t);return new Promise(m=>f.push(m))}let n=this.texData.get(t),{values:a,shape:r,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(s!=null){let f;l?f=new bl(r,rl):f=new Ei(r,rl);let m=this.runWebGLProgram(f,[{dataId:t,shape:r,dtype:i}],i),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(a!=null)return this.convertAndCacheOnCPU(t);if(Z().getBool("DEBUG")&&!Z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Z().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(i!=="complex64"&&Z().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);let f=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(f.texture.texture,...lx(r))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){let f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),m=f[0],g=f[1];h=O.mergeRealAndImagArrays(m,g)}else if(c==null)h=this.getValuesFromTexture(t);else{let f=N.sizeFromShape(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){let f=this.gpgpu.gl;Se(f,()=>f.deleteBuffer(c))}let d=this.convertAndCacheOnCPU(t,h),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach(f=>f(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&xs().removeDataId(t,this),this.pendingDeletes--),d}readToGPU(t,n={}){let a=this.texData.get(t),{values:r,shape:s,slice:i,dtype:o,isPacked:l,texture:c}=a;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;l?p=new bl(s,rl):p=new Ei(s,rl);let f=this.runWebGLProgram(p,[{dataId:t,shape:s,dtype:o}],o),m=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),m}if(c==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(t,n.customTexShape),h=xs().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let a=n.map(r=>N.decodeString(r));return ut(t.shape,t.dtype,a)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ut(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let a=t[n];if(!A6(a))throw Z().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${a} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:a,isPacked:r}=this.texData.get(t),s=N.sizeFromShape(n);if(Z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(t),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...lx(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(d),f}let i=Z().getBool("WEBGL_PACK")&&r===!0,o=i?Ag(n):n,l=i?new nve(o):new tve(o),c=this.runWebGLProgram(l,[{shape:o,dtype:a,dataId:t}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,a=[],r=!1;this.programTimersStack==null?(this.programTimersStack=a,r=!0):this.activeTimers.push(a),this.activeTimers=a,t();let s=N.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=N.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(s);o.kernelMs=N.sum(l),o.getExtraProfileInfo=()=>l.map((c,u)=>({name:i[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:N.now(),endMs:null}}endTimer(t){return Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=N.now(),t)}async getQueryTime(t){if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:a}=this.texData.get(t);return a!=null&&(this.disposeData(a.real.dataId,n),this.disposeData(a.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:a,texShape:r,usage:s,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,a),this.textureManager.releaseTexture(n,r,s,i)));let u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=vxe){return Z().getBool("WEBGL_CPU_FORWARD")&&t.every(a=>this.texData.get(a.dataId).texture==null&&N.sizeFromShape(a.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){O.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return mxe(t.shape,n)}packedUnaryOp(t,n,a){let r=new bl(t.shape,n),s=this.compileAndRun(r,[t],a);return xs().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let r=S5(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(Z().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,OM,t.dtype);let n=new Ei(t.shape,OM),a=this.compileAndRun(n,[t]);return xs().makeTensorFromTensorInfo(a)}makeTensorInfo(t,n,a){let r;if(n==="string"&&a!=null&&a.length>0&&N.isString(a[0])){let s=a.map(i=>N.encodeString(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:n}}makeOutput(t,n,a){return xs().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,a),this)}unpackTensor(t){let n=new fxe(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new Zve(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let a=[Pc(t.shape),...Vc(t.shape)],r={dtype:t.dtype,shape:a,dataId:t.dataId},s=[Pc(n),...Vc(n)],i=new T5(s,a),o=!0,l=[a],c=this.runWebGLProgram(i,[r],t.dtype,l,o);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(t,n){let a=this.texData.get(t),{isPacked:r,shape:s,dtype:i}=a;if(n!=null){let d=N.sizeFromShape(s),p=n[0]*n[1]*4;N.assert(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=Ag(s),l;r?l=new eve(o):l=new Jbe(o);let c=!0,u=[n??lx(o)],h=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,u,c,n);return{dtype:i,shape:s,dataId:h.dataId}}runWebGLProgram(t,n,a,r,s=!1,i){let o=this.makeTensorInfo(t.outputShape,a),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===$y.DENSE){let y=i??lx(t.outputShape);l.texShape=y.map(v=>v*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),N.sizeFromShape(o.shape)===0)return l.values=N.getTypedArrayFromDType(o.dtype,0),o;let c=[],u=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(y.dataId);if(v.texture==null){if(!t.packedInputs&&N.sizeFromShape(y.shape)<=Z().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:v.values};t.packedInputs&&(v.isPacked=!0,v.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!v.isPacked!=!!t.packedInputs)y=v.isPacked?this.unpackTensor(y):this.packTensor(y),c.push(y),v=this.texData.get(y.dataId);else if(v.isPacked&&!My(v.shape,y.shape)){let x=y,w=y.shape;y.shape=v.shape,y=this.packedReshape(y,w),c.push(y),v=this.texData.get(y.dataId),x.shape=w}return{shape:y.shape,texData:v,isUniform:!1}});this.uploadToGPU(o.dataId);let h={shape:o.shape,texData:l,isUniform:!1},d=Zbe(t,u,h),p=this.getAndSaveBinary(d,()=>Qbe(this.gpgpu,t,u,h)),f=this.activeTimers!=null,m;f&&(m=this.startTimer()),Z().get("ENGINE_COMPILE_ONLY")||Ybe(this.gpgpu,p,u,h,r),c.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(m=this.endTimer(m),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(m)}));let g=Z().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){let y=N.now();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!Z().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){let y=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),y}return o}compileAndRun(t,n,a,r,s=!1){return a=a||n[0].dtype,this.runWebGLProgram(t,n,a,r,s)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Z().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=X(()=>{if(!Z().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=Z().getBool("DEBUG");Z().set("DEBUG",!1);let n=this.abs(ze(1e-8)).dataSync()[0];if(Z().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?gxe:yxe}uploadToGPU(t){let n=this.texData.get(t),{shape:a,dtype:r,values:s,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;let c=this.activeTimers!=null,u;c&&(u=N.now());let h=n.texShape;if(h==null&&(h=q6(a,l),n.texShape=h),s!=null){let d=Ag(a),p,f=h[1],m=h[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!g)&&([f,m]=Fm(h[0],h[1])),l?p=new rve(d,g):p=new RM(d,g);let y=g?[m,f]:h,v=this.makeTensorInfo(y,r),x=this.texData.get(v.dataId);g?x.usage=Zr.PIXELS:x.usage=Zr.UPLOAD,x.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),f,m,s);let w=[[m,f]],k=this.runWebGLProgram(p,[v],r,w,!0),M=this.texData.get(k.dataId);n.texShape=M.texShape,n.isPacked=M.isPacked,n.usage=M.usage,Z().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(n.texture=M.texture,n.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(v),c&&(this.uploadWaitMs+=N.now()-u)}else{let d=this.acquireTexture(h,o,r,l);n.texture=d}}convertAndCacheOnCPU(t,n){let a=this.texData.get(t),{dtype:r}=a;return n!=null&&(a.values=_xe(n,r)),a.values}acquireTexture(t,n,a,r){if(this.numBytesInGPU+=this.computeBytes(t,a),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,r)}computeBytes(t,n){return t[0]*t[1]*N.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let a=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(s){throw s}});t.push(a)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await eN(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(tA(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:a,infLoc:r,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=r5(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=a,t.infLoc=r,t.nanLoc=s,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,a){t.channels=t.channels||"RGBA";let{texture:r,height:s,width:i,channels:o}=t,l=xs().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let c=l.writeTexture(r,n,a,s,i,o);return xs().makeTensorFromDataId(c,n,a,l)}};hA.nextDataId=0;function _xe(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let a=0;a<n.length;++a)n[a]=Math.round(e[a]);return n}else throw new Error(`Unknown dtype ${t}`)}var Sxe="4.22.0";function N5(){Z().set("WEBGL_FORCE_F16_TEXTURES",!0)}$b.isBrowser()&&a1("webgl",()=>new hA,2);var Ixe={forceHalfFloat:N5},dA=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,Bc=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=O.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=ja(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},kd=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,Um=class{constructor(e,t,n,a=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=O.assertAndGetBroadcastShape(t,n);let r=this.outputShape.length;this.enableShapeUniforms=ja(r);let s="";if(a)if(r===0||N.sizeFromShape(this.outputShape)===1)s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(s=`
          ${Zt(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=Ya("coords",r);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${i[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${i[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${i[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${i[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}};function Vr(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var kxe={kernelName:Eh,backendName:"webgl",kernelFunc:Vr};function wu(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,"complex64"),i=n.texData.get(s.dataId),o=Vr({inputs:{x:a},backend:n}),l=Vr({inputs:{x:r},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var Txe={kernelName:Uw,backendName:"webgl",kernelFunc:wu},C5="return (a < 0.) ? b * a : a;",A5=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Exe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a,i=n.makeTensorInfo([],"float32",N.createScalarValue(s,"float32")),o=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Um(A5,r.shape,i.shape):new Bc(C5,r.shape,i.shape),l=n.runWebGLProgram(o,[r,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var Nxe={kernelName:Rh,backendName:"webgl",kernelFunc:Exe},R5="return (a < 0.) ? b * a : a;",D5=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Cxe(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Um(D5,a.shape,r.shape):new Bc(R5,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],"float32")}var Axe={kernelName:qh,backendName:"webgl",kernelFunc:Cxe},Wm="if (isnan(x)) return x;";function Ct({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:a}){return({inputs:r,backend:s})=>{let{x:i}=r,o=s,l=a||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let h=o.texData.get(i.dataId),d=n(h.values,l);return o.makeTensorInfo(i.shape,l,d)}let c=Z().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,u;return c?u=new bl(i.shape,t):u=new Ei(i.shape,e),o.runWebGLProgram(u,[i],l)}}function Ra({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:a=!1,cpuKernelImpl:r,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:c}=i,u=o;if(a&&l.dtype==="complex64"){let f=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{let[w,k]=x,M={dataId:w.dataId,dtype:w.dtype,shape:l.shape},S={dataId:k.dataId,dtype:k.dtype,shape:c.shape},I=new Bc(e,l.shape,c.shape);return u.runWebGLProgram(I,[M,S],us(w.dtype,k.dtype))}),v=wu({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),v}let h=s||us(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&r!=null){let f=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,g=l.dtype==="string"?O.fromUint8ToStringArray(f):f,y=l.dtype==="string"?O.fromUint8ToStringArray(m):m,[v,x]=r(l.shape,c.shape,g,y,h),w=u.makeTensorInfo(x,h),k=u.texData.get(w.dataId);return k.values=v,w}let d=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,p;return d?p=new Um(t,l.shape,c.shape,n):p=new Bc(e,l.shape,c.shape),u.runWebGLProgram(p,[l,c],h)}}function Oy(e,t=!1){if(e==="linear")return t?uxe:rxe;if(e==="relu")return t?hxe:ixe;if(e==="elu")return t?cxe:sxe;if(e==="relu6")return t?dxe:oxe;if(e==="prelu")return t?D5:R5;if(e==="leakyrelu")return t?A5:C5;if(e==="sigmoid")return t?pxe:lxe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var $5=class{constructor(e,t,n,a=!1,r=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ja(this.outputShape.length);let c=a?e[1]:e[2],u=Math.ceil(c/2),h=a?"i * 2, rc.y":"rc.y, i * 2",d=r?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:m=`vec4 activation(vec4 x) {
          ${i}
        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let v="rc.x",x="rc.x";e[0]<t[0]?v=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${u}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${v};
        int batchB = ${x};
        for (int i = 0; i < ${u}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${f[0]});
          result += (${p[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${g}

        setOutput(result);
      }
    `}},FM={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},LM=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=O.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},zM="return a * b;";function pA(e){let{inputs:t,backend:n}=e,{a,b:r}=t,s=O.upcastType(a.dtype,r.dtype);if(a.dtype==="complex64"){let o=n.texData.get(a.dataId),l=n.texData.get(r.dataId),c=new LM(FM.REAL,a.shape,r.shape),u=new LM(FM.IMAG,a.shape,r.shape),h=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:a.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],d=n.runWebGLProgram(c,h,"float32"),p=n.runWebGLProgram(u,h,"float32"),f=wu({inputs:{real:d,imag:p},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([a,r])){let o=n.texData.get(a.dataId),l=n.texData.get(r.dataId),[c,u]=Eve(a.shape,r.shape,o.values,l.values,s),h=n.makeTensorInfo(u,s),d=n.texData.get(h.dataId);return d.values=c,h}let i;return Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Um(zM,a.shape,r.shape):i=new Bc(zM,a.shape,r.shape),n.runWebGLProgram(i,[a,r],s)}var Rxe={kernelName:Wh,backendName:"webgl",kernelFunc:pA};function Dxe(e,t,n){let a=[Pc(e.shape),...Vc(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[Pc(t),...Vc(t)],i=new T5(s,a),o=!0,l=[a],c=n.runWebGLProgram(i,[r],e.dtype,l,o);return{dataId:c.dataId,shape:t,dtype:c.dtype}}function _e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=n,o=N.sizeFromShape(r.shape),l=N.inferFromImplicitShape(s,o),c=N.sizeFromShape(l);N.assert(o===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let u=i.texData.get(r.dataId);return u.isPacked&&!My(r.shape,l)&&!(u.texture!==null&&My(u.shape,l))?Dxe(r,l,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}var $xe={kernelName:om,backendName:"webgl",kernelFunc:_e},PM=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i=Math.floor(n/4)*4,o=n%4,l="sumValue += dot(values, ones);";if(t!=null){let u=1/t;l=`sumValue += dot(values * ${N.isInt(u)?u.toPrecision(2):u}, ones);`}let c="";r%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},Mxe=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let c=Math.floor(n/4)*4,u=n%4,h=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(i="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(i="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let p="";r%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${u===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${u===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${u===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${l});
      }
    `}};function Oxe(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],a=O.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}function Td(e,t,n,a){let r=Oxe(e.shape),s=e;for(let i=0;i<r.length;i++){let{inSize:o,windowSize:l,outSize:c}=r[i],u,h;n==="mean"?u=i===0?new PM({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:c},o):new PM({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:c}):u=new Mxe({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:c},n),h=s,s=a.runWebGLProgram(u,[s],t),h.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(h)}return s}var Fxe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let a=Zt(this.rank),r=Lxe(t);this.userCode=`
    void main() {
      ${a} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}};function Lxe(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}var zxe=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let c=0;c<n.length;c++)n[c]=e[t[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let a=Zt(this.rank),r=k5("rc",this.rank),s=new Array(this.rank);for(let c=0;c<t.length;c++)s[t[c]]=r[c];let i=`vec2(${s.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`
    void main() {
      ${a} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function l_(e,t,n){let a=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zxe(e.shape,t):new Fxe(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function Pxe(e,t,n,a){let r=t,s=e.shape.length,i=N.parseAxisParam(r,e.shape),o=i,l=O.getAxesPermutation(o,s),c=l!=null,u=e;c&&(u=l_(e,l,a),o=O.getInnerMostAxes(o.length,s)),O.assertAxesAreInnerMostDims("sum",o,s);let[h,d]=O.computeOutAndReduceShapes(u.shape,o),p=h;n&&(p=O.expandShapeToKeepDim(h,i));let f=N.sizeFromShape(d),m=N.sizeFromShape(e.shape)/f,g=_e({inputs:{x:u},attrs:{shape:[m,f]},backend:a}),y=n1(e.dtype),v=Td(g,y,"sum",a),x=_e({inputs:{x:v},attrs:{shape:p},backend:a});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(v),c&&a.disposeIntermediateTensorInfo(u),x}function u_(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;return Pxe(r,s,i,n)}var Vxe={kernelName:cd,backendName:"webgl",kernelFunc:u_};function er(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,i=n,o=r.shape.length,l=new Array(o);for(let u=0;u<l.length;u++)l[u]=r.shape[s[u]];let c;if(i.shouldExecuteOnCPU([r])){let u=i.texData.get(r.dataId).values,h=cA(u,r.shape,r.dtype,s,l);c=i.makeTensorInfo(l,r.dtype);let d=i.texData.get(c.dataId);d.values=h}else c=l_(r,s,i);return c}var Bxe={kernelName:bo,backendName:"webgl",kernelFunc:er},M5=1e3;function Q0({a:e,b:t,transposeA:n,transposeB:a,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let c=e.shape.length,u=t.shape.length,h=n?e.shape[c-2]:e.shape[c-1],d=a?t.shape[u-1]:t.shape[u-2],p=n?e.shape[c-1]:e.shape[c-2],f=a?t.shape[u-2]:t.shape[u-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=N.sizeFromShape(m),v=N.sizeFromShape(g),x=km.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);N.assert(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`);let w=n?[y,h,p]:[y,p,h],k=a?[v,f,d]:[v,d,f],M=_e({inputs:{x:e},backend:r,attrs:{shape:w}}),S=_e({inputs:{x:t},backend:r,attrs:{shape:k}}),I=[M,S],E=Math.max(y,v),R=n?M.shape[1]:M.shape[2],A=s!=null,_=i!=null,D=l==="leakyrelu",j=l!=null?Oy(l,!0):null,q=A||_||D||j!=null,B;if((p===1||f===1)&&R>M5&&q===!1){let H=M,J=S;n&&(H=er({inputs:{x:M},backend:r,attrs:{perm:[0,2,1]}}),I.push(H)),a&&(J=er({inputs:{x:S},backend:r,attrs:{perm:[0,2,1]}}),I.push(J));let ae=f!==1,ne=f===1,ue=H;ae&&(ue=_e({inputs:{x:H},backend:r,attrs:{shape:[E,R,1]}}),I.push(ue));let le=f===1?2:1,he=J;ne&&(he=_e({inputs:{x:J},backend:r,attrs:{shape:[E,1,R]}}),I.push(he));let me=pA({inputs:{a:ue,b:he},backend:r});B=u_({inputs:{x:me},backend:r,attrs:{axis:le,keepDims:!0}}),I.push(me)}else{let H=us(e.dtype,t.dtype),J=new $5(w,k,[E,p,f],n,a,A,j,_,D),ae=[M,S];if(s!=null&&ae.push(s),_&&ae.push(i),D){let ne=r.makeTensorInfo([],"float32",N.createScalarValue(o,"float32"));ae.push(ne),I.push(ne)}B=r.runWebGLProgram(J,ae,H)}let Q=_e({inputs:{x:B},backend:r,attrs:{shape:x}});I.push(B);for(let H of I)r.disposeIntermediateTensorInfo(H);return Q}function Uxe(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=a;return Q0({a:r,b:s,transposeA:l,transposeB:c,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:u})}var Wxe={kernelName:Ic,backendName:"webgl",kernelFunc:Uxe},VM="return abs(x);";function jxe(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&a.dtype!=="complex64"){let s=n.texData.get(a.dataId),i=S5(s.values);return n.makeTensorInfo(a.shape,a.dtype,i)}let r;return Z().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new bl(a.shape,VM):r=new Ei(a.shape,VM),n.runWebGLProgram(r,[a],a.dtype)}var Gxe={kernelName:Sf,backendName:"webgl",kernelFunc:jxe},Hxe=Ls+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,qxe=Ct({opSnippet:Hxe}),Kxe={kernelName:Zc,backendName:"webgl",kernelFunc:qxe},Xxe=Ls+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Qxe=Ct({opSnippet:Xxe}),Yxe={kernelName:Jc,backendName:"webgl",kernelFunc:Qxe},BM="return a + b;",Zxe=Ra({opSnippet:BM,packedOpSnippet:BM,supportsComplex:!0,cpuKernelImpl:ive}),Jxe={kernelName:hu,backendName:"webgl",kernelFunc:Zxe},e0e=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let n=[];this.variableNames.forEach(r=>{n.push(`float v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${a};
        setOutput(result);
      }
    `}},t0e=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let n=[];this.variableNames.forEach(r=>{n.push(`vec4 v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${a};
        setOutput(result);
      }
    `}};function jx(e){let{inputs:t,backend:n}=e,a=t;if(a.length===1)return Vr({inputs:{x:a[0]},backend:n});if(a.length>Z().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(a.length/2),l=jx({inputs:a.slice(0,o),backend:n}),c=jx({inputs:a.slice(o),backend:n});return jx({inputs:[l,c],backend:n})}let r=a.map(o=>o.dtype).reduce((o,l)=>us(o,l)),s=a.map(o=>o.shape),i=Z().getBool("WEBGL_PACK")?new t0e(a[0].shape,s):new e0e(a[0].shape,s);return n.runWebGLProgram(i,a,r)}var n0e={kernelName:eh,backendName:"webgl",kernelFunc:jx};function a0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=N.parseAxisParam(s,r.shape),c=l,u=O.getAxesPermutation(c,o),h=r;u!=null&&(h=er({inputs:{x:r},backend:n,attrs:{perm:u}}),c=O.getInnerMostAxes(c.length,o)),O.assertAxesAreInnerMostDims("all",c,o);let[d,p]=O.computeOutAndReduceShapes(h.shape,c),f=N.sizeFromShape(p),m=_e({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),g=Td(m,m.dtype,"all",n),y;if(i){let v=O.expandShapeToKeepDim(d,l);y=_e({inputs:{x:g},backend:n,attrs:{shape:v}})}else y=_e({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(h),y}var r0e={kernelName:If,backendName:"webgl",kernelFunc:a0e};function s0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=N.parseAxisParam(s,r.shape),c=l,u=O.getAxesPermutation(c,o),h=r;u!=null&&(h=er({inputs:{x:r},backend:n,attrs:{perm:u}}),c=O.getInnerMostAxes(c.length,o)),O.assertAxesAreInnerMostDims("any",c,o);let[d,p]=O.computeOutAndReduceShapes(h.shape,c),f=N.sizeFromShape(p),m=_e({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),g=Td(m,m.dtype,"any",n),y;if(i){let v=O.expandShapeToKeepDim(d,l);y=_e({inputs:{x:g},backend:n,attrs:{shape:v}})}else y=_e({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(h),y}var i0e={kernelName:kf,backendName:"webgl",kernelFunc:s0e},o0e=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:a,batchSize:r,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${a}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},l0e=class{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,N.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let r=e[e.length-1],s=Math.ceil(r/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),a||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,l=Zt(o),c=Ya("coords",o),u,h;if(s===1){h=o+1;let S=Zt(h);u=`
        ${S} sourceLocR = ${S}(${c.join()}, 0);
        ++${c[o-1]};
        ${S} sourceLocG = ${S}(${c.join()}, 0);
        ++${c[o-2]};
        ${S} sourceLocA = ${S}(${c.join()}, 0);
        --${c[o-1]};
        ${S} sourceLocB = ${S}(${c.join()}, 0);
        --${c[o-2]};`}else h=o,u=`
        ${l} sourceLocR = coords;
        ++${c[o-1]};
        ${l} sourceLocG = coords;
        ++${c[o-2]};
        ${l} sourceLocA = coords;
        --${c[o-1]};
        ${l} sourceLocB = coords;
        --${c[o-2]};`;let d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(S=>"int "+S),m=Ya("sourceLocR",h-1).concat("inIdx.r"),g=Ya("sourceLocG",h-1).concat("inIdx.g"),y=Ya("sourceLocB",h-1).concat("inIdx.b"),v=Ya("sourceLocA",h-1).concat("inIdx.a"),x=n==="max"?"greaterThan":"lessThan",w=a?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${v.join()})));`,k=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,M=a?"":`
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${f.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${M}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${c[o-2]} < ${i[o-2]-1};
        ${u}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${w}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function O5(e,t,n,a=null){let r=t.shape[0],s=t.shape[1];a!=null&&(r=a.shape[0],s=a.shape[1]);let i=O.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:r,outSize:Math.ceil(s/i)},l=new o0e(o,n,a==null),c=[t];a!=null&&c.push(a);let u=e.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;let h=O5(e,t,n,u);return e.disposeIntermediateTensorInfo(u),h}function F5(e,t,n,a=null){let r=a!=null?a.shape:t.shape,s=r[r.length-1],i=O.computeOptimalWindowSize(s),o=new l0e(r,i,n,a==null),l=a==null?[t]:[t,a],c=e.runWebGLProgram(o,l,"int32");if(c.shape.length===t.shape.length){let u=F5(e,t,n,c);return e.disposeIntermediateTensorInfo(c),u}return c}function L5(e,t,n,a){let r=[n];if(O.assertAxesAreInnerMostDims("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!Z().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),s.push(l));let[c,u]=O.computeOutAndReduceShapes(l.shape,r),h=N.sizeFromShape(u),d=_e({inputs:{x:l},backend:e,attrs:{shape:[-1,h]}});s.push(d);let p=O5(e,d,a);s.push(p);let f=_e({inputs:{x:p},backend:e,attrs:{shape:c}});return s.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return F5(e,t,a)}function u0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=N.parseAxisParam(s,r.shape),o=O.getAxesPermutation(i,r.shape.length),l=r,c=[];o!=null&&(l=er({inputs:{x:r},backend:n,attrs:{perm:o}}),c.push(l),i=O.getInnerMostAxes(i.length,l.shape.length)),O.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let u=L5(n,l,i[0],"max");return c.forEach(h=>n.disposeIntermediateTensorInfo(h)),u}var c0e={kernelName:Tf,backendName:"webgl",kernelFunc:u0e};function h0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=N.parseAxisParam(s,r.shape),o=O.getAxesPermutation(i,r.shape.length),l=r,c=[];o!=null&&(l=er({inputs:{x:r},backend:n,attrs:{perm:o}}),c.push(l),i=O.getInnerMostAxes(i.length,l.shape.length)),O.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let u=L5(n,l,i[0],"min");return c.forEach(h=>n.disposeIntermediateTensorInfo(h)),u}var d0e={kernelName:Ef,backendName:"webgl",kernelFunc:h0e},p0e=Ls+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,f0e=Ct({opSnippet:p0e}),m0e={kernelName:th,backendName:"webgl",kernelFunc:f0e},g0e=Ls+"return log(x + sqrt(x * x + 1.0));",y0e=Ct({opSnippet:g0e}),b0e={kernelName:nh,backendName:"webgl",kernelFunc:y0e},v0e=Ls+`
  return atan(x);
`,x0e=Ct({opSnippet:v0e}),w0e={kernelName:ah,backendName:"webgl",kernelFunc:x0e},_0e=dA+`
  return atan(a, b);
`,S0e=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+kd+`
  return result;
`,I0e=Ra({opSnippet:_0e,packedOpSnippet:S0e}),k0e={kernelName:sh,backendName:"webgl",kernelFunc:I0e},T0e=Ls+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,E0e=Ct({opSnippet:T0e}),N0e={kernelName:rh,backendName:"webgl",kernelFunc:E0e},Fy=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let f=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let S=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${d}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${u};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${S} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${a?r?m:g:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(x="avgValue / max(count, 1.0)");let w=Math.floor(s/4)*4,k=s%4,M=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${d}, ${p});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${u};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${w}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${M}
          }

          int xC = xCCorner + ${w};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${M}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${M}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${M}
          }
        }
        setOutput(${x});
      }
    `}},fA=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,u=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let v=t==="avg",x="0.0";if(v||(x="-1.0 / 1e-20"),n){let E=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${m}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${u}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${E} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${a?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / max(count, 1.0)");let M=Math.floor(s/4)*4,S=s%4,I=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${M}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${I}
            }

            int xC = xCCorner + ${M};
            if (${S===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${S===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${S===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${I}
            }
          }
        }
        setOutput(${k});
      }
    `}};function C0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;Lm(r,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,c=1;N.assert(O.eitherStridesOrDilationsAreOne(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=O.computePool2DInfo(r.shape,s,i,c,o,l);if(u.filterWidth===1&&u.filterHeight===1&&N.arraysEqual(u.inShape,u.outShape))return Vr({inputs:{x:r},backend:n});let h=new Fy(u,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}var A0e={kernelName:ih,backendName:"webgl",kernelFunc:C0e};function R0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=a,u=[1,1,1],h=O.computePool3DInfo(r.shape,s,i,u,o,l,c),d=new fA(h,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}var D0e={kernelName:Nf,backendName:"webgl",kernelFunc:R0e},$0e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=o-1-e.padInfo.top,u=l-1-e.padInfo.left,h=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${u});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},M0e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,u=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*a);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function O0e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:l,pad:c,dimRoundingMode:u}=a,h=[1,1,1],d=O.computePool3DInfo(i.shape,o,l,h,c,u),p=new M0e(d);return n.runWebGLProgram(p,[r],i.dtype)}var F0e={kernelName:cb,backendName:"webgl",kernelFunc:O0e};function L0e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;Lm([r,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:c}=a,u=O.computePool2DInfo(i.shape,o,l,1,c),h=new $0e(u);return n.runWebGLProgram(h,[r],i.dtype)}var z0e={kernelName:ub,backendName:"webgl",kernelFunc:L0e};function P0e(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;return Q0({a:r,b:s,transposeA:i,transposeB:o,backend:n})}var V0e={kernelName:oh,backendName:"webgl",kernelFunc:P0e},B0e=class{constructor(e,t,n,a,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],O.assertAndGetBroadcastShape(e,t),O.assertAndGetBroadcastShape(e,n);let i="0.0";a!=null&&(O.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";r!=null&&(O.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},U0e=class{constructor(e,t,n,a,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],O.assertAndGetBroadcastShape(e,t),O.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";a!=null&&(O.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";r!=null&&(O.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}},W0e=({inputs:e,backend:t,attrs:n})=>{let{x:a,mean:r,variance:s,offset:i,scale:o}=e;N.assert(r.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),N.assert(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),N.assert(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let c=[a,r,s],u=null;i!=null&&(u=i.shape,c.push(i));let h=null;o!=null&&(h=o.shape,c.push(o));let d=Z().getBool("WEBGL_PACK_NORMALIZATION")?new U0e(a.shape,r.shape,s.shape,u,h,l):new B0e(a.shape,r.shape,s.shape,u,h,l);return t.runWebGLProgram(d,c,c[0].dtype)},j0e={kernelName:kh,backendName:"webgl",kernelFunc:W0e},G0e=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Zt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=H0e(this.rank),a,r=e.map((s,i)=>`sourceLoc.${Wk[i]} = start[${i}] + coords.${Wk[i]};`);a=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${a}
        setOutput(getSource(${n}));
      }
    `}},Wk=["x","y","z","w","u","v"];function H0e(e){if(e===1)return"sourceLoc";if(e<=6)return Wk.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var q0e=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Zt(this.rank),n=Ya("coords",this.rank),a=Ya("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${a.slice(-2).join()})`,s=`getChannel(getSource(${a.join()}), ${r})`,i=`
      result.x = ${s};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${a[this.rank-1]};
        result.y = ${s};
        --${a[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${a[this.rank-2]};
        result.z = ${s};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${a[this.rank-1]};
          result.w = ${s};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,u)=>`start[${u}]`).join()});`:e.map((c,u)=>`${a[u]} = ${n[u]} + start[${u}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function K0e(e,t,n,a){let r=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),i=a.texData.get(s.dataId);Object.assign(i,r),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=aa.computeFlatOffset(t,N.computeStrides(e.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||e.dataId};let l=a.dataRefCount.get(i.slice.origDataId)||1;return a.dataRefCount.set(i.slice.origDataId,l+1),s}function jm(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a,[o,l]=aa.parseSliceParams(r,s,i);if(aa.assertParamsValid(r,o,l),N.sizeFromShape(l)===0)return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype==="string"){let h=n.texData.get(r.dataId),d=zve(h.values,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,d)}let{isPacked:c}=n.texData.get(r.dataId),u=aa.isSliceContinous(r.shape,o,l);if(c||!u){let h=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new q0e(l):new G0e(l),d=[o];return n.runWebGLProgram(h,[r],r.dtype,d)}return n.uploadToGPU(r.dataId),K0e(r,o,l,n)}var X0e={kernelName:fm,backendName:"webgl",kernelFunc:jm},Q0e=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;N.assert(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((v,x)=>v*x),l=O.getReshaped(r.shape,s,o),c=O.getPermuted(l.length,s.length),u=O.getReshapedPermuted(r.shape,s,o),h=O.getSliceBeginCoords(i,s.length),d=O.getSliceSize(u,i,s.length),p=[],f=_e({inputs:{x:r},backend:n,attrs:{shape:l}}),m=er({inputs:{x:f},backend:n,attrs:{perm:c}}),g=_e({inputs:{x:m},backend:n,attrs:{shape:u}}),y=jm({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(v=>n.disposeIntermediateTensorInfo(v)),y},Y0e={kernelName:Cf,backendName:"webgl",kernelFunc:Q0e};function Z0e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.readSync(r.dataId),l=n.readSync(s.dataId),c=_5(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,c)}var J0e={kernelName:Af,backendName:"webgl",kernelFunc:Z0e},ewe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,twe=`
  return float(int(a.r) & int(b.r));
`;function nwe(e){let{inputs:t,backend:n}=e,{a,b:r}=t,s=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=Z().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,r])||i===1){let l=n.texData.get(a.dataId).values,c=n.texData.get(r.dataId).values,[u,h]=lve(a.shape,r.shape,l,c,a.dtype),d=n.makeTensorInfo(h,a.dtype),p=n.texData.get(d.dataId);return p.values=u,d}let o;return s?o=new Um(ewe,a.shape,r.shape,!1):o=new Bc(twe,a.shape,r.shape),n.runWebGLProgram(o,[a,r],a.dtype)}var awe={kernelName:Rf,backendName:"webgl",kernelFunc:nwe};function rwe(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),o=O.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var swe={kernelName:hb,backendName:"webgl",kernelFunc:rwe},iwe="return float(a != b);",z5=Ra({opSnippet:iwe,cpuKernelImpl:Cve,dtype:"bool"}),owe={kernelName:tm,backendName:"webgl",kernelFunc:z5};function ov(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return Vr({inputs:{x:r.complexTensorInfos.real},backend:n})}var lwe={kernelName:e1,backendName:"webgl",kernelFunc:ov},uwe="return float(int(x));";function cwe(e,t){let n=new Ei(e.shape,uwe),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}function jk(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s==="complex64"){if(r.dtype==="complex64")return Vr({inputs:{x:r},backend:n});let i=_n(r.shape),o=jk({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),l=wu({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(r.dtype==="complex64"){let i=ov({inputs:{input:r},backend:n}),o=jk({inputs:{x:i},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(i),o}if(!N.hasEncodingLoss(r.dtype,s)){let i=Vr({inputs:{x:r},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(n.shouldExecuteOnCPU([r])){let i=n.texData.get(r.dataId).values,[o,l,c]=uve(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,l,c)}if(s==="int32")return cwe(r,n);if(s==="bool"){let i=n.makeTensorInfo([],"bool",N.getTypedArrayFromDType("bool",1)),o=z5({inputs:{a:r,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}var hwe={kernelName:lh,backendName:"webgl",kernelFunc:jk},UM="return ceil(x);",dwe=Ct({opSnippet:UM,packedOpSnippet:UM,cpuKernelImpl:cve}),pwe={kernelName:uh,backendName:"webgl",kernelFunc:dwe},fwe=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},mwe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function gwe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,o;Z().getBool("WEBGL_PACK_CLIP")?o=new mwe(r.shape):o=new fwe(r.shape);let l=[[s],[i]];return n.runWebGLProgram(o,[r],r.dtype,l)}var ywe={kernelName:du,backendName:"webgl",kernelFunc:gwe},bwe=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function WM(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function vwe(e){let{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new bwe(a.shape),i=[WM(a,r.complexTensorInfos.real),WM(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var xwe={kernelName:db,backendName:"webgl",kernelFunc:vwe},wwe=class{constructor(e){this.outputShape=[],this.outputShape=O.computeOutShape(e,1),this.variableNames=e.map((s,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let i=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`)}let a=t.length,r=t[t.length-1];n.push(`else setOutput(getT${a}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},_we=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=O.computeOutShape(e,t);let n=this.outputShape,a=n.length,r=Zt(a),s=Ya("coords",a),i=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map((f,m)=>`T${m}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],c=i.slice(-2),u=i.join(),h=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${u}), vec2(${c.join()}));
        }`;for(let f=1;f<o.length;f++){let m=o[f-1];h+=`
        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {
          return getChannel(
            getT${f}(${cx(i,l,m)}),
            vec2(${cx(c,l,m)}));
        }`}let d=o.length,p=o[o.length-1];h+=`
        return getChannel(
          getT${d}(${cx(i,l,p)}),
          vec2(${cx(c,l,p)}));`,this.userCode=`
      float getValue(${i.map(f=>"int "+f)}) {
        ${h}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[a-1]} = ${s[a-1]} + 1;
        if (${s[a-1]} < ${n[a-1]}) {
          result.g = getValue(${s});
        }

        ${s[a-2]} = ${s[a-2]} + 1;
        if (${s[a-2]} < ${n[a-2]}) {
          result.a = getValue(${s});
        }

        ${s[a-1]} = ${s[a-1]} - 1;
        if (${s[a-2]} < ${n[a-2]} &&
            ${s[a-1]} < ${n[a-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}};function cx(e,t,n){let a=e.indexOf(t);return e.map((r,s)=>s===a?`${r} - ${n}`:r).join()}function c_(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return Vr({inputs:{x:r.complexTensorInfos.imag},backend:n})}var Swe={kernelName:Qw,backendName:"webgl",kernelFunc:c_};function Rg(e,t,n){let a=e[0].dtype;if(a==="complex64"){let p=e.map(v=>ov({inputs:{input:v},backend:n})),f=e.map(v=>c_({inputs:{input:v},backend:n})),m=Rg(p,t,n),g=Rg(f,t,n),y=wu({inputs:{real:m,imag:g},backend:n});return p.forEach(v=>n.disposeIntermediateTensorInfo(v)),f.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}let r=n.shouldExecuteOnCPU(e);if(a==="string"&&(r=!0),r){let p=e.map(w=>{let k=[-1,N.sizeFromShape(w.shape.slice(t))];return _e({inputs:{x:w},backend:n,attrs:{shape:k}})}),f=p.map(w=>({vals:n.readSync(w.dataId),shape:w.shape})),m=O.computeOutShape(p.map(w=>w.shape),1),g=p[0].shape[0]===1,y=hve(f,m,a,g),v=O.computeOutShape(e.map(w=>w.shape),t),x=n.makeTensorInfo(v,a,y);return p.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}let s=e.filter(p=>N.sizeFromShape(p.shape)>0),i=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let p=i?new Ei(e[0].shape,rl):new bl(e[0].shape,rl);return n.runWebGLProgram(p,e,a)}let o=Z().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let p=[];for(let m=0;m<s.length;m+=o){let g=s.slice(m,m+o);p.push(Rg(g,t,n))}let f=Rg(p,t,n);for(let m of p)n.disposeIntermediateTensorInfo(m);return f}if(i){let p=new _we(s.map(f=>f.shape),t);return n.runWebGLProgram(p,s,a)}let{tensors2D:l,outShape:c}=Iwe(s,t,n),u=new wwe(l.map(p=>p.shape)),h=n.runWebGLProgram(u,l,a);l.forEach(p=>n.disposeIntermediateTensorInfo(p));let d=_e({inputs:{x:h},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(h),d}function Iwe(e,t,n){let a=O.computeOutShape(e.map(r=>r.shape),t);return{tensors2D:e.map(r=>_e({inputs:{x:r},attrs:{shape:[-1,N.sizeFromShape(r.shape.slice(t))]},backend:n})),outShape:a}}function P5(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=N.parseAxisParam(r,t[0].shape)[0],i=t.map(c=>c.shape);O.assertParamsConsistent(i,s);let o=O.computeOutShape(t.map(c=>c.shape),s);if(N.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(c=>N.sizeFromShape(c.shape)>0);return l.length===1?Vr({inputs:{x:l[0]},backend:n}):Rg(l,s,n)}var kwe={kernelName:Df,backendName:"webgl",kernelFunc:P5},V5=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,f=e.inChannels%4,m=e.dataFormat==="channelsLast",g=m?1:2,y=m?2:3,v=m?3:1,x="",w="";n&&(a?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:x=`
          float activation(float x) {
            ${n}
          }
        `,w="result = activation(result);");let k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${u};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${f===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${w}
        setOutput(result);
      }
    `}},Twe=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,u=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${a});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${u}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${f===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},B5=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ja(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,u=c,h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<c;m++)h+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;h+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<c;m++)h+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(u+1)/2;m++){let g=m*2;if(h+=`
           xC = xCCorner + ${g*o};
           `,i===1){if(g<c&&(s%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,o===1&&g>0?h+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<c)){let y=s%2===0?N.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,o>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:h+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):y===1?h+=`
                     xC${g+1} = xTexelC${g};
                     `:h+=`
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<c&&(s%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<c&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<c&&(h+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<c&&(h+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<c&&(h+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let d="",p="";n&&(a?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:r?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:d=`vec4 activation(vec4 x) {
           ${n}
         }`,p="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f}
         ${p}
         setOutput(result);
       }
     `}},Ewe=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=ja(this.outputShape.length);let{dataFormat:n}=t,a=ir(),r=n==="channelsLast",s=r?1:2,i=r?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let c=0;c<=1;c++)for(let u=0;u<=1;u++)l+=`
          blockIndex = rc.z + ${u};
          pos = rc.y + ${c};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+u}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+u}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${a.output} = result;
      }
    `}};function Y0(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function U5({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,c=a.texData.get(e.dataId),u=n.inChannels,h=l[0]*l[1]*l[2],d=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,m=!1,g,y=[];if(s!=null){let v=Y0(s.shape,p);v!=null&&(s=_e({inputs:{x:s},backend:a,attrs:{shape:v}}),y.push(s))}if(r!=null){let v=Y0(r.shape,p);v!=null&&(r=_e({inputs:{x:r},backend:a,attrs:{shape:v}}),y.push(r))}if(!((h===1||d===1)&&u>M5)&&c.isPacked&&p&&c.texture!=null&&l[2]%2!==0&&N.arraysEqual(c.shape.slice(-3),l.slice(-3))){let v=l[0]*l[1]*(l[2]+1),x={dataId:e.dataId,shape:[1,v,n.inChannels],dtype:e.dtype},w=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,N.assert(My(c.shape,x.shape),()=>`packed reshape ${c.shape} to ${x.shape} isn't free`);let k=_e({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(k);let M=Q0({a:x,b:k,backend:a,transposeA:f,transposeB:m,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),S=a.texData.get(M.dataId);N.assert(S.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=w,S.shape=n.outShape,g=Vr({inputs:{x:M},backend:a}),g.shape=n.outShape,y.push(M)}else{let v=n.outHeight*n.outWidth,x=_e({inputs:{x:e},backend:a,attrs:{shape:p?[n.batchSize,v,n.inChannels]:[n.batchSize,n.inChannels,v]}}),w=_e({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}}),k=Q0({a:p?x:w,b:p?w:x,transposeA:!p,transposeB:m,backend:a,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i});g=_e({inputs:{x:k},backend:a,attrs:{shape:n.outShape}}),y.push(x),y.push(w),y.push(k)}for(let v of y)a.disposeIntermediateTensorInfo(v);return g}function W5({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:d,dataFormat:p}=n,f=p==="channelsLast",m=l*c*u,g=d*h,y=[n.batchSize,m,g],v=!0,x=!1,w=[];if(s!=null){let H=Y0(s.shape,f);H!=null&&(s=_e({inputs:{x:s},backend:a,attrs:{shape:H}}),w.push(s))}if(r!=null){let H=Y0(r.shape,f);H!=null&&(r=_e({inputs:{x:r},backend:a,attrs:{shape:H}}),w.push(r))}let k=_e({inputs:{x:t},backend:a,attrs:{shape:[1,m,N.sizeFromShape(t.shape)/m]}});w.push(k);let M=new Ewe(y,n),S=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],I=a.runWebGLProgram(M,[e],"float32",S),E=_e({inputs:{x:I},backend:a,attrs:{shape:y}});w.push(I),w.push(E);let R=r!=null,A=s!=null,_=o==="leakyrelu",D=o?Oy(o,!0):null,j=new $5(f?E.shape:k.shape,f?k.shape:E.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],v,x,R,D,A,_),q=f?[E,k]:[k,E];if(r&&q.push(r),A&&q.push(s),_){let H=a.makeTensorInfo([],"float32",N.createScalarValue(i,"float32"));q.push(H),w.push(H)}let B=a.runWebGLProgram(j,q,"float32"),Q=_e({inputs:{x:B},backend:a,attrs:{shape:n.outShape}});w.push(B);for(let H of w)a.disposeIntermediateTensorInfo(H);return Q}function Nwe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:c,dimRoundingMode:u}=a,h=O.convertConv2DDataFormat(l),d=O.computeConv2DInfo(r.shape,s.shape,i,c,o,u,!1,h),p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=U5({x:r,filter:s,convInfo:d,backend:n});else if(d.strideWidth<=2&&h==="channelsLast"&&Z().getBool("WEBGL_EXP_CONV")){let m=new B5(d),g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(m,[r,s],"float32",g)}else if(Z().getBool("WEBGL_CONV_IM2COL"))p=W5({x:r,filter:s,convInfo:d,backend:n});else{let m=new V5(d);p=n.runWebGLProgram(m,[r,s],"float32")}let f=_e({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}var Cwe={kernelName:ch,backendName:"webgl",kernelFunc:Nwe},Awe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${a};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Rwe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,c=s?2:3,u=s?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${u}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Dwe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${a} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},$we=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,c=a-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${a}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${a} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Mwe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:u}=a,h=O.convertConv2DDataFormat(l),d=O.computeConv2DInfo(r.shape,u,i,1,o,c,!1,h),p=new Awe(d);return n.runWebGLProgram(p,[r,s],"float32")}var Owe={kernelName:Ww,backendName:"webgl",kernelFunc:Mwe},Fwe=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=ja(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function Lwe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:c,dimRoundingMode:u}=a,h=O.convertConv2DDataFormat(c),d=O.computeConv2DInfo(i,s.shape,o,1,l,u,!1,h);if(Z().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){let p=[[d.strideHeight,d.strideWidth]],f=new Fwe(d);return n.runWebGLProgram(f,[r,s],"float32",p)}else{let p=new Rwe(d);return n.runWebGLProgram(p,[r,s],"float32")}}var zwe={kernelName:hh,backendName:"webgl",kernelFunc:Lwe};function Pwe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a,c=O.computeConv3DInfo(r.shape,s.shape,i,l,o),u=new Twe(c);return n.runWebGLProgram(u,[r,s],"float32")}var Vwe={kernelName:dh,backendName:"webgl",kernelFunc:Pwe};function Bwe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a,c=O.computeConv3DInfo(r.shape,l,i,1,o),u=new Dwe(c);return n.runWebGLProgram(u,[r,s],"float32")}var Uwe={kernelName:$f,backendName:"webgl",kernelFunc:Bwe};function Wwe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a,c=O.computeConv3DInfo(l,s.shape,o,1,i),u=new $we(c);return n.runWebGLProgram(u,[r,s],"float32")}var jwe={kernelName:Mf,backendName:"webgl",kernelFunc:Wwe},Gwe=Wm+`
  return cos(x);
`,Hwe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${kd}
  return result;
`,qwe=Ct({opSnippet:Gwe,packedOpSnippet:Hwe}),Kwe={kernelName:ph,backendName:"webgl",kernelFunc:qwe},Xwe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Qwe=Ct({opSnippet:Xwe}),Ywe={kernelName:fh,backendName:"webgl",kernelFunc:Qwe},Zwe=class{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[c]=t,[u,h]=n;this.outputShape=[c,u,h,l];let d=a==="bilinear"?1:0,[p,f]=[`${i-1}.0`,`${o-1}.0`],[m,g,y]=u>1?[`${(i-1)/(u-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[v,x,w]=h>1?[`${(o-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${v});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${x};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${w};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},Jwe=e=>{let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:c}=a,u=new Zwe(r.shape,s.shape,o,l,c);return n.runWebGLProgram(u,[r,s,i],"float32")},e1e={kernelName:Ff,backendName:"webgl",kernelFunc:Jwe},Ly;(function(e){e.Prod="*",e.Sum="+"})(Ly||(Ly={}));var jM=class{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let r=this.outputShape.length,s=this.op===Ly.Prod?"1.0":"0.0",i=n?s:`getX(${GM(r,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",c="";n?(l=a?`end != ${o-1}`:"end != 0",c=a?"end + 1":"end - 1"):(l=a?`end + pow2 < ${o}`:"end >= pow2",c=a?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Zt(r)} coords = getOutputCoords();
        int end = ${HM(r,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${HM(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${GM(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function GM(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function HM(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function j5(e,t,n,a,r,s){let i=t.shape.length,o=O.getAxesPermutation([a],i),l=t;o!=null&&(l=er({inputs:{x:t},backend:n,attrs:{perm:o}}));let c=O.getInnerMostAxes(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${a}`);let u=l.shape[c],h=Vr({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){let p=new jM(e,l.shape,!1,s),f=[[d]],m=h;h=n.runWebGLProgram(p,[h],h.dtype,f),n.disposeIntermediateTensorInfo(m)}if(r){let d=new jM(e,l.shape,r,s),p=h;h=n.runWebGLProgram(d,[h],h.dtype),n.disposeIntermediateTensorInfo(p)}if(o!=null){let d=O.getUndoAxesPermutation(o),p=er({inputs:{x:h},backend:n,attrs:{perm:d}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),p}return h}function t1e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return j5(Ly.Prod,r,n,s,i,o)}var n1e={kernelName:Of,backendName:"webgl",kernelFunc:t1e};function a1e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return j5(Ly.Sum,r,n,s,i,o)}var r1e={kernelName:mh,backendName:"webgl",kernelFunc:a1e};function s1e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){let l=n.readSync(r.dataId),c=n.readSync(s.dataId),u=_5(l,c,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}else if(r.shape.length===2){let l=n.bufferSync(r),c=n.bufferSync(s),u=ove(l,c,i,o);return n.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var i1e={kernelName:pb,backendName:"webgl",kernelFunc:s1e},o1e=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function l1e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a,o=r.shape[0],l=i==="NHWC"?r.shape[1]:r.shape[2],c=i==="NHWC"?r.shape[2]:r.shape[3],u=i==="NHWC"?r.shape[3]:r.shape[1],h=l*s,d=c*s,p=u/(s*s),f=i==="NHWC"?[o,h,d,p]:[o,p,h,d],m=new o1e(f,s,i);return n.runWebGLProgram(m,[r],r.dtype)}var u1e={kernelName:Lf,backendName:"webgl",kernelFunc:l1e},G5=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ja(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",c="";n&&(a?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${u}
        ${c}
        setOutput(result);
      }
    `}},H5=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ja(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,h=u,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)d+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;d+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let g=0;g<u;g++)d+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(h+1)/2;g++){let y=g*2;if(d+=`
          xC = xCCorner + ${y*l};
          `,o===1){if(y<u&&(i%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,l===1&&y>0?d+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<u)){let v=i%2===0?N.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${v};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,l>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                    } else {
                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                    }
                    `:d+=`
                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                    `):v===1?d+=`
                    xC${y+1} = xTexelC${y};
                    `:d+=`
                    xCOffset = xC + ${v};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<u&&(i%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<u&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<u&&(d+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<u&&(d+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<u&&(d+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let p="",f="";n&&(a?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:r?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:p=`vec4 activation(vec4 x) {
          ${n}
        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${f}
        setOutput(result);
      }
    `}};function c1e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:c}=a,u=l;u==null&&(u=[1,1]),N.assert(O.eitherStridesOrDilationsAreOne(i,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let h=O.computeConv2DInfo(r.shape,s.shape,i,u,o,c,!0),d;Z().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new H5(h):d=new G5(h);let p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[r,s],"float32",p)}var h1e={kernelName:gh,backendName:"webgl",kernelFunc:c1e},d1e=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${a};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},p1e=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function f1e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:c,filterShape:u}=a,h=O.computeConv2DInfo(r.shape,u,i,o,l,c,!0),d=new d1e(h);return n.runWebGLProgram(d,[r,s],"float32")}var m1e={kernelName:jw,backendName:"webgl",kernelFunc:f1e};function g1e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:c,inputShape:u}=a,h=O.computeConv2DInfo(u,s.shape,i,o,l,c,!0),d=new p1e(h);return n.runWebGLProgram(d,[r,s],"float32")}var y1e={kernelName:Gw,backendName:"webgl",kernelFunc:g1e},b1e=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function v1e(e){let{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],s=N.sizeFromShape(a.shape),i=_e({inputs:{x:a},backend:n,attrs:{shape:[s]}}),o=new b1e(s),l=n.runWebGLProgram(o,[i],i.dtype),c=_e({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),c}var x1e={kernelName:fb,backendName:"webgl",kernelFunc:v1e},w1e=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:c}=e,{top:u,left:h}=a;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${s});
      const ivec2 pads = ivec2(${u}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function _1e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a,c=O.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",l),u,h=new w1e(c);u=n.runWebGLProgram(h,[r,s],"float32");let d=_e({inputs:{x:u},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(u),d}var S1e={kernelName:yh,backendName:"webgl",kernelFunc:_1e};function I1e(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:l}=O.decodeEinsumEquation(r,s.length);O.checkEinsumDimSizes(i.length,l,s);let{path:c,steps:u}=O.getEinsumComputePath(o,l),h=u.length,d=null,p=i.length,f=[];for(let m=0;m<h;++m){for(let g of u[m]){let{permutationIndices:y,expandDims:v}=O.getEinsumPermutation(p,l[g]),x;O.isIdentityPermutation(y)?x=s[g]:(x=er({inputs:{x:s[g]},backend:n,attrs:{perm:y}}),f.push(x));let w=x.shape.slice();for(let k=0;k<v.length;++k)w.splice(v[k],0,1);N.arraysEqual(x.shape,w)||(x=_e({inputs:{x},backend:n,attrs:{shape:w}}),f.push(x)),d===null?d=x:(d=pA({inputs:{a:x,b:d},backend:n}),f.push(d))}m<h-1&&(c[m]>=0&&(d=u_({inputs:{x:d},backend:n,attrs:{axis:c[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var k1e={kernelName:qw,backendName:"webgl",kernelFunc:I1e},T1e="return (x >= 0.0) ? x : (exp(x) - 1.0);",E1e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,N1e=Ct({opSnippet:T1e,packedOpSnippet:E1e}),C1e={kernelName:vh,backendName:"webgl",kernelFunc:N1e},A1e="return (b >= 0.0) ? a : a * (b + 1.0);",R1e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,D1e=e=>{let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Um(R1e,a.shape,r.shape):new Bc(A1e,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)},$1e={kernelName:zf,backendName:"webgl",kernelFunc:D1e},M1e=`
  return vec4(equal(a, b));
`,O1e="return float(a == b);",F1e=Ra({opSnippet:O1e,packedOpSnippet:M1e,dtype:"bool",cpuKernelImpl:dve}),L1e={kernelName:Pf,backendName:"webgl",kernelFunc:F1e},z1e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${O.ERF_P};
  float a1 = ${O.ERF_A1};
  float a2 = ${O.ERF_A2};
  float a3 = ${O.ERF_A3};
  float a4 = ${O.ERF_A4};
  float a5 = ${O.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,P1e=Ct({opSnippet:z1e}),V1e={kernelName:xh,backendName:"webgl",kernelFunc:P1e},B1e=Wm+`
  return exp(x);
`,U1e=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,q5=Ct({opSnippet:B1e,packedOpSnippet:U1e,cpuKernelImpl:pve,dtype:"float32"}),W1e={kernelName:wh,backendName:"webgl",kernelFunc:q5};function Gk(e){let{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=r;return r<0&&(N.assert(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+r+1),o.splice(l,0,1),_e({inputs:{x:s},backend:a,attrs:{shape:o}})}var j1e={kernelName:Vf,backendName:"webgl",kernelFunc:Gk},qM="return exp(x) - 1.0;",G1e=Ct({opSnippet:qM,packedOpSnippet:qM,cpuKernelImpl:fve}),H1e={kernelName:_h,backendName:"webgl",kernelFunc:G1e},KM=class{constructor(e,t,n){this.variableNames=["real","imag"];let a=t[1];this.outputShape=t;let r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${a}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${a});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${a}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function K5(e,t,n){let a=n.texData.get(e.dataId),r=N.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=r/s,o=_e({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,c=new KM("real",l,t),u=new KM("imag",l,t),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:l},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(c,h,"float32"),p=n.runWebGLProgram(u,h,"float32"),f=wu({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);let m=_e({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}function q1e(e){let{inputs:t,backend:n}=e,{input:a}=t;return K5(a,!1,n)}var K1e={kernelName:Kw,backendName:"webgl",kernelFunc:q1e},X1e=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function lv(e){let{backend:t,attrs:n}=e,{shape:a,value:r}=n,{dtype:s}=n;if(s=s||N.inferDtype(r),s==="string"){let i=N.getArrayFromDType(s,N.sizeFromShape(a));return i.fill(r),t.makeTensorInfo(a,s,i)}else{let i=new X1e(a,r),o=[[r]];return t.runWebGLProgram(i,[],s,o)}}var Q1e={kernelName:mb,backendName:"webgl",kernelFunc:lv},Y1e=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Z1e={kernelName:Bf,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,a=t,r=new Y1e(n.shape);return a.runWebGLProgram(r,[n],n.dtype)}},XM="return floor(x);",J1e=Ct({opSnippet:XM,packedOpSnippet:XM,cpuKernelImpl:mve}),e_e={kernelName:Sh,backendName:"webgl",kernelFunc:J1e},t_e=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,n_e=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,a_e=Ra({opSnippet:t_e,packedOpSnippet:n_e,dtype:"int32"}),r_e={kernelName:Ih,backendName:"webgl",kernelFunc:a_e},s_e=class{constructor(e){this.variableNames=["A"];let t=ir(),[n,a]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},i_e=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=ir(),[n,a]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${a}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},o_e={kernelName:C0,backendName:"webgl",kernelFunc:l_e},Gd,LS=Z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function l_e(e){let{inputs:t,backend:n,attrs:a}=e,{pixels:r}=t,{numChannels:s}=a,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,c]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[c,l],h=[c,l,s];if(o||i){let m=Z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Gd==null||m!==LS)&&(LS=m,Gd=document.createElement("canvas").getContext("2d",{willReadFrequently:LS})),Gd.canvas.width=l,Gd.canvas.height=c,Gd.drawImage(r,0,0,l,c),r=Gd.canvas}let d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=Zr.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);let p=Z().getBool("WEBGL_PACK")?new i_e(h):new s_e(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}function u_e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a,m=O.convertConv2DDataFormat(u),g=O.computeConv2DInfo(r.shape,s.shape,l,h,c,d,!1,m),y,v=[],x=i!=null,w=o!=null,k=p==="leakyrelu",M=()=>{let I=[r,s],E=(R,A)=>{if(A==="NCHW"&&R.shape.length===1&&R.shape[0]!==1){let _=_e({inputs:{x:R},backend:n,attrs:{shape:[R.shape[0],1,1]}});return v.push(_),_}return R};if(x&&I.push(E(i,u)),w&&I.push(E(o,u)),k){let R=n.makeTensorInfo([],"float32",N.createScalarValue(f,"float32"));I.push(R),v.push(R)}return I};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=U5({x:r,filter:s,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&Z().getBool("WEBGL_EXP_CONV")){let I=p?Oy(p,!0):null,E=new B5(g,x,I,w,k),R=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],A=M();y=n.runWebGLProgram(E,A,"float32",R)}else if(Z().getBool("WEBGL_CONV_IM2COL"))y=W5({x:r,filter:s,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{let I=p?Oy(p,!1):null,E=new V5(g,x,I,w,k),R=M();y=n.runWebGLProgram(E,R,"float32")}let S=_e({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return v.push(y),v.forEach(I=>n.disposeIntermediateTensorInfo(I)),S}var c_e={kernelName:kc,backendName:"webgl",kernelFunc:u_e};function h_e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=a,f=[],m=u;m==null&&(m=[1,1]),N.assert(O.eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let g=O.computeConv2DInfo(r.shape,s.shape,l,m,c,h,!0),y=Z().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,v=d?Oy(d,y):null,x=[r,s],w=i!=null,k=o!=null,M=d==="leakyrelu";if(w&&x.push(i),k&&x.push(o),M){let R=n.makeTensorInfo([],"float32",N.createScalarValue(p,"float32"));x.push(R),f.push(R)}let S;y?S=new H5(g,w,v,k,M):S=new G5(g,w,v,k,M);let I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],E=n.runWebGLProgram(S,x,"float32",I);return f.forEach(R=>n.disposeIntermediateTensorInfo(R)),E}var d_e={kernelName:Tc,backendName:"webgl",kernelFunc:h_e},p_e=class{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;let r=Zt(n.length),s=`
    int index;`;for(let i=0;i<this.sliceDim;i++)s+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function f_e(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,i=s[s.length-1],o=N.sizeFromShape(a.shape),[l,c,u,h]=O.prepareAndValidate(a,r),d=_e({inputs:{x:r},backend:n,attrs:{shape:[c,i]}}),p=_e({inputs:{x:a},backend:n,attrs:{shape:[N.sizeFromShape(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,r])||a.dtype==="string"){let y=n.readSync(r.dataId),v=n.bufferSync(a),x=gve(y,v,a.dtype,c,i,u,h,a.shape,o);return n.makeTensorInfo(l,a.dtype,x.values)}let f=new p_e(i,h,[c,u],a.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),g=_e({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}var m_e={kernelName:Wf,backendName:"webgl",kernelFunc:f_e},g_e=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Zt(this.rank),a=y_e(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${a}));
      }
    `}};function y_e(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)r===2?a.push("index"):a.push(`${n[r]}`);return a.join()}function X5(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a,l=N.parseAxisParam(i,r.shape)[0];if(Z().get("DEBUG")){let v=n.readSync(s.dataId),x=r.shape[l];for(let w=0;w<v.length;++w){let k=v[w];N.assert(k<=x-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${x-1}]`)}}let c=O.segment_util.collectGatherOpShapeInfo(r,s,l,o),u=N.sizeFromShape(s.shape),h=[],d=_e({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=_e({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);let f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let v=n.bufferSync(p),x=n.bufferSync(d),w=yve(x,v,f);return h.forEach(k=>n.disposeIntermediateTensorInfo(k)),n.makeTensorInfo(c.outputShape,w.dtype,w.values)}let m=new g_e(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);let y=_e({inputs:{x:g},backend:n,attrs:{shape:c.outputShape}});return h.forEach(v=>n.disposeIntermediateTensorInfo(v)),y}var b_e={kernelName:Uf,backendName:"webgl",kernelFunc:X5},v_e="return float(a > b);",x_e=`
  return vec4(greaterThan(a, b));
`,w_e=Ra({opSnippet:v_e,packedOpSnippet:x_e,cpuKernelImpl:bve,dtype:"bool"}),__e={kernelName:jf,backendName:"webgl",kernelFunc:w_e},S_e="return float(a >= b);",I_e=`
  return vec4(greaterThanEqual(a, b));
`,k_e=Ra({opSnippet:S_e,packedOpSnippet:I_e,dtype:"bool",cpuKernelImpl:vve}),T_e={kernelName:Th,backendName:"webgl",kernelFunc:k_e};function E_e(e){let{inputs:t,backend:n}=e,{input:a}=t;return K5(a,!0,n)}var N_e={kernelName:Xw,backendName:"webgl",kernelFunc:E_e},C_e="return float(!isnan(x) && !isinf(x));",A_e=Ct({opSnippet:C_e,dtype:"bool"}),R_e={kernelName:Nh,backendName:"webgl",kernelFunc:A_e},D_e="return float(isinf(x));",$_e=Ct({opSnippet:D_e,dtype:"bool"}),M_e={kernelName:Ch,backendName:"webgl",kernelFunc:$_e},O_e="return float(isnan(x));",F_e=Ct({opSnippet:O_e,dtype:"bool"}),L_e={kernelName:Ah,backendName:"webgl",kernelFunc:F_e},z_e="return float(a < b);",P_e=`
  return vec4(lessThan(a, b));
`,V_e=Ra({opSnippet:z_e,packedOpSnippet:P_e,cpuKernelImpl:xve,dtype:"bool"}),B_e={kernelName:Gf,backendName:"webgl",kernelFunc:V_e},U_e="return float(a <= b);",W_e=`
  return vec4(lessThanEqual(a, b));
`,j_e=Ra({opSnippet:U_e,packedOpSnippet:W_e,cpuKernelImpl:wve,dtype:"bool"}),G_e={kernelName:Hf,backendName:"webgl",kernelFunc:j_e};function H_e(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=_ve(a,r,s);return t.makeTensorInfo([i.length],"float32",i)}var q_e={kernelName:qf,backendName:"webgl",kernelFunc:H_e},K_e=Wm+`
  return x < 0.0 ? 0./0. : log(x);
`,X_e=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Q_e=Ct({opSnippet:K_e,packedOpSnippet:X_e,cpuKernelImpl:Sve}),Y_e={kernelName:Dh,backendName:"webgl",kernelFunc:Q_e},Z_e=Wm+`
  return log(1.0 + x);
`,J_e=Ct({opSnippet:Z_e}),eSe={kernelName:$h,backendName:"webgl",kernelFunc:J_e},tSe="return float(a >= 1.0 && b >= 1.0);",nSe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,aSe=Ra({opSnippet:tSe,packedOpSnippet:nSe,dtype:"bool"}),rSe={kernelName:Kf,backendName:"webgl",kernelFunc:aSe},sSe="return float(!(x >= 1.0));",iSe=Ct({opSnippet:sSe}),oSe={kernelName:Xf,backendName:"webgl",kernelFunc:iSe},lSe="return float(a >= 1.0 || b >= 1.0);",uSe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,cSe=Ra({opSnippet:lSe,packedOpSnippet:uSe,dtype:"bool"}),hSe={kernelName:Qf,backendName:"webgl",kernelFunc:cSe},dSe=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${l})`:r===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},pSe=class{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${l})`:r===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},fSe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a,c=Z().getBool("WEBGL_PACK_NORMALIZATION")?new pSe(r.shape,s,i,o,l):new dSe(r.shape,s,i,o,l);return n.runWebGLProgram(c,[r],r.dtype)},mSe={kernelName:Mh,backendName:"webgl",kernelFunc:fSe},gSe=class{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${a}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${a})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},ySe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:c,beta:u}=a,h=new gSe(r.shape,o,l,c,u);return n.runWebGLProgram(h,[r,s,i],r.dtype)},bSe={kernelName:Yf,backendName:"webgl",kernelFunc:ySe};function vSe(e,t,n,a){let r=N.sizeFromShape(t),s=N.sizeFromShape(e.shape)/r,i=_e({inputs:{x:e},attrs:{shape:[s,r]},backend:a}),o=Td(i,e.dtype,"max",a),l=_e({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),l}function Q5(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=r.shape.length,l=N.parseAxisParam(s,r.shape),c=l,u=O.getAxesPermutation(c,o),h=u!=null,d=n.shouldExecuteOnCPU([r]),p=r;if(h){if(d){let v=n.texData.get(p.dataId).values,x=new Array(o);for(let M=0;M<x.length;M++)x[M]=r.shape[u[M]];let w=cA(v,r.shape,r.dtype,u,x);p=n.makeTensorInfo(x,r.dtype);let k=n.texData.get(p.dataId);k.values=w}else p=l_(r,u,n);c=O.getInnerMostAxes(c.length,o)}O.assertAxesAreInnerMostDims("max",c,o);let[f,m]=O.computeOutAndReduceShapes(p.shape,c),g=f;i&&(g=O.expandShapeToKeepDim(f,l));let y;if(d){let v=n.texData.get(p.dataId).values,x=Ive(v,N.sizeFromShape(m),g,r.dtype);y=n.makeTensorInfo(g,r.dtype);let w=n.texData.get(y.dataId);w.values=x}else y=vSe(p,m,g,n);return h&&n.disposeIntermediateTensorInfo(p),y}var xSe={kernelName:Oh,backendName:"webgl",kernelFunc:Q5},wSe=dA+`
  return max(a, b);
`,_Se=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+kd+`
  return result;
`,SSe=Ra({opSnippet:wSe,packedOpSnippet:_Se,cpuKernelImpl:kve}),ISe={kernelName:Fh,backendName:"webgl",kernelFunc:SSe};function kSe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;Lm(r,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,c=1;N.assert(O.eitherStridesOrDilationsAreOne(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=O.computePool2DInfo(r.shape,s,i,c,o,l);if(u.filterWidth===1&&u.filterHeight===1&&N.arraysEqual(u.inShape,u.outShape))return Vr({inputs:{x:r},backend:n});let h=new Fy(u,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}var TSe={kernelName:Lh,backendName:"webgl",kernelFunc:kSe};function ESe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:c}=a,u=[1,1,1],h=O.computePool3DInfo(r.shape,s,i,u,o,c,l),d=new fA(h,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}var NSe={kernelName:Zf,backendName:"webgl",kernelFunc:ESe},CSe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=r-1-e.padInfo.top,o=s-1-e.padInfo.left,l=r*s-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},ASe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=o-1-e.padInfo.front,h=l-1-e.padInfo.top,d=c-1-e.padInfo.left,p=o*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function RSe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:l,pad:c,dimRoundingMode:u}=a,h=[1,1,1],d=O.computePool3DInfo(i.shape,o,l,h,c,u),p=new fA(d,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new ASe(d),g=n.runWebGLProgram(m,[r,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}var DSe={kernelName:yb,backendName:"webgl",kernelFunc:RSe};function $Se(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;Lm([s,i],"maxPoolGrad");let{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=a,d=O.computePool2DInfo(o.shape,l,c,1,u,h),p=!0,f=new Fy(d,"max",p),m=n.runWebGLProgram(f,[o],o.dtype),g=new CSe(d),y=n.runWebGLProgram(g,[r,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}var MSe={kernelName:gb,backendName:"webgl",kernelFunc:$Se};function OSe(e,t,n,a){let r=new Fy(n,"max",!1),s=a.runWebGLProgram(r,[e],"float32");r=new Fy(n,"max",!0,!0,t);let i=a.runWebGLProgram(r,[e],"float32");return[s,i]}var FSe={kernelName:bb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;N.assert(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);let c=[1,1];N.assert(O.eitherStridesOrDilationsAreOne(s,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);let u=O.computePool2DInfo(a.shape,r,s,c,i),[h,d]=OSe(a,o,u,l);return[h,d]}};function LSe(e,t,n,a){let r=N.sizeFromShape(t),s=N.sizeFromShape(e.shape)/r,i=_e({inputs:{x:e},attrs:{shape:[s,r]},backend:a}),o=Td(i,"float32","mean",a),l=_e({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),l}var zSe={kernelName:zh,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{keepDims:r,axis:s}=t,i=n,o=a.shape.length,l=N.parseAxisParam(s,a.shape),c=l,u=O.getAxesPermutation(c,o),h=u!=null,d=i.shouldExecuteOnCPU([a]),p=[],f=a;if(h){if(d){let x=i.texData.get(f.dataId).values,w=new Array(o);for(let S=0;S<w.length;S++)w[S]=a.shape[u[S]];let k=cA(x,a.shape,a.dtype,u,w);f=i.makeTensorInfo(w,a.dtype);let M=i.texData.get(f.dataId);M.values=k}else f=l_(a,u,i);p.push(f),c=O.getInnerMostAxes(c.length,o)}O.assertAxesAreInnerMostDims("sum",c,o);let[m,g]=O.computeOutAndReduceShapes(f.shape,c),y=m;r&&(y=O.expandShapeToKeepDim(m,l));let v=LSe(f,g,y,i);for(let x of p)i.disposeIntermediateTensorInfo(x);return v}};function PSe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=N.parseAxisParam(s,r.shape),c=l,u=O.getAxesPermutation(c,o),h=r;u!=null&&(h=er({inputs:{x:r},backend:n,attrs:{perm:u}}),c=O.getInnerMostAxes(c.length,r.shape.length)),O.assertAxesAreInnerMostDims("min",c,o);let[d,p]=O.computeOutAndReduceShapes(h.shape,c),f=N.sizeFromShape(p),m=_e({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),g=Td(m,m.dtype,"min",n),y;if(i){let v=O.expandShapeToKeepDim(d,l);y=_e({inputs:{x:g},backend:n,attrs:{shape:v}})}else y=_e({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(h),y}var VSe={kernelName:Ph,backendName:"webgl",kernelFunc:PSe},BSe=dA+`
  return min(a, b);
`,USe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+kd+`
  return result;
`,WSe=Ra({opSnippet:BSe,packedOpSnippet:USe,cpuKernelImpl:Tve}),jSe={kernelName:Vh,backendName:"webgl",kernelFunc:WSe},GSe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);let a=e.length,r=Zt(a),s=t.map(c=>c[0]).join(","),i=t.map((c,u)=>c[0]+e[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),l=n==="reflect"?0:1;if(a===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${s});
      ${r} end = ${r}(${i});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${a}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},HSe=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,f)=>p[0]+e[f]+p[1]);let a=e.length,r=Zt(a),s=t.map(p=>p[0]).join(","),i=t.map((p,f)=>p[0]+e[f]).join(","),o=Ya("rc",a),l=Ya("source",a),c=`${o[a-1]} < ${this.outputShape[a-1]}`,u=a===1?"source":`vec2(${l.slice(-2).join()})`,h=n==="reflect"?0:1,d="";if(a===1){let p=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;d=`
        ${r} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${u});
        ${o[a-1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${u});
        }
      `}else{let p=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;d=`
        ${r} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${u});
        ${o[a-1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${u});
        }
        rc = outputLoc;
        ${o[a-2]} += 1;
        if(${o[a-2]} < ${this.outputShape[a-2]}) {
          ${p}
          result[2] = getChannel(getX(${l.join()}), ${u});
          ${o[a-1]} += 1;
          if(${c}) {
            ${p}
            result[3] = getChannel(getX(${l.join()}), ${u});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${s});
      const ${r} end = ${r}(${i});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}},qSe=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{paddings:r,mode:s}=n,i=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new HSe(a.shape,r,s):new GSe(a.shape,r,s);return t.runWebGLProgram(i,[a],a.dtype)},KSe={kernelName:Bh,backendName:"webgl",kernelFunc:qSe},XSe=`if (b == 0.0) return NAN;
  return mod(a, b);`,QSe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+kd+`
  return result;
`,YSe=Ra({opSnippet:XSe,packedOpSnippet:QSe}),ZSe={kernelName:Uh,backendName:"webgl",kernelFunc:YSe},JSe=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},eIe=`
if (a == b) {
  return 1.0;
};
return a / b;`,tIe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Y5=Ra({opSnippet:eIe,packedOpSnippet:tIe,checkOutOfBounds:!0}),nIe={kernelName:bh,backendName:"webgl",kernelFunc:Y5},QM="return a - b;",Z5=Ra({opSnippet:QM,packedOpSnippet:QM,supportsComplex:!0,cpuKernelImpl:qve}),aIe={kernelName:pd,backendName:"webgl",kernelFunc:Z5};function J5(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=N.parseAxisParam([s],r.shape),o=Q5({inputs:{x:r},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=O.expandShapeToKeepDim(o.shape,i),c=_e({inputs:{x:o},backend:n,attrs:{shape:l}}),u=Z5({inputs:{a:r,b:c},backend:n}),h=q5({inputs:{x:u},backend:n}),d=u_({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=_e({inputs:{x:d},backend:n,attrs:{shape:l}}),f=Y5({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}var rIe={kernelName:hd,backendName:"webgl",kernelFunc:J5};function sIe(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a,l=o?r:J5({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new JSe(c,u,s),d=[[i]],p=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),p}var iIe={kernelName:Jf,backendName:"webgl",kernelFunc:sIe},oIe=Ls+`
  return -x;
`,lIe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function uIe(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){let s=n.texData.get(a.dataId),[i,o]=Nve(s.values,a.shape,a.dtype);return n.makeTensorInfo(o,a.dtype,i)}let r;return Z().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new bl(a.shape,lIe):r=new Ei(a.shape,oIe),n.runWebGLProgram(r,[a],a.dtype)}var cIe={kernelName:em,backendName:"webgl",kernelFunc:uIe},hIe=Hi.nonMaxSuppressionV3Impl;function dIe(e){O.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=a,c=n.readSync(r.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=hIe(c,u,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var pIe={kernelName:nm,backendName:"webgl",kernelFunc:dIe},fIe=Hi.nonMaxSuppressionV4Impl;function mIe(e){O.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=a,u=n.readSync(r.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:p}=fIe(u,h,i,o,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var gIe={kernelName:am,backendName:"webgl",kernelFunc:mIe},yIe=Hi.nonMaxSuppressionV5Impl;function bIe(e){O.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=a,u=n.readSync(r.dataId),h=n.readSync(s.dataId),d=i,p=o,f=l,m=c,{selectedIndices:g,selectedScores:y}=yIe(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var vIe={kernelName:rm,backendName:"webgl",kernelFunc:bIe},xIe=class{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${a}), float(${n}),
                      float(index == coords.y)));
      }
    `}},wIe=e=>{let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a,c=N.sizeFromShape(r.shape),u=new xIe(c,i,o,l),h=_e({inputs:{x:r},backend:n,attrs:{shape:[c]}}),d=n.runWebGLProgram(u,[h],s);n.disposeIntermediateTensorInfo(h);let p=[...r.shape,i],f=_e({inputs:{x:d},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(d),f},_Ie={kernelName:jh,backendName:"webgl",kernelFunc:wIe};function Z0(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="complex64"){let r=ov({inputs:{input:a},backend:n}),s=Z0({inputs:{x:r},backend:n}),i=c_({inputs:{input:a},backend:n}),o=Z0({inputs:{x:i},backend:n}),l=wu({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return lv({attrs:{shape:a.shape,dtype:a.dtype,value:a.dtype==="string"?"":0},backend:n})}var SIe={kernelName:Sm,backendName:"webgl",kernelFunc:Z0};function eW(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(a.dtype==="complex64"){let r=ov({inputs:{input:a},backend:n}),s=eW({inputs:{x:r},backend:n}),i=c_({inputs:{input:a},backend:n}),o=Z0({inputs:{x:i},backend:n}),l=wu({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return lv({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:n})}var IIe={kernelName:sm,backendName:"webgl",kernelFunc:eW};function kIe(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return Gk({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{N.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),N.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let h=Gk({inputs:{input:u},backend:n,attrs:{dim:r}});return o.push(h),h}),c=P5({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(u=>n.disposeIntermediateTensorInfo(u)),c}var TIe={kernelName:im,backendName:"webgl",kernelFunc:kIe},EIe=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,c)=>l[0]+e[c]+l[1]);let a=e.length,r=Zt(a),s=t.map(l=>l[0]).join(","),i=t.map((l,c)=>l[0]+e[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);if(a===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${s});
      ${r} end = ${r}(${i});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},NIe=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);let a=e.length,r=Zt(a),s=t.map(f=>f[0]).join(","),i=t.map((f,m)=>f[0]+e[m]).join(","),o=Ya("rc",a),l=Ya("source",a),c=`${o[a-1]} < ${this.outputShape[a-1]}`,u=a===1?"source":`vec2(${l.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${o[a-1]} += 1;
       if(${c}) {
      `,a===1?"":`}
       rc = outputLoc;
       ${o[a-2]} += 1;
       if(${o[a-2]} < ${this.outputShape[a-2]}) {`,a===1?"":`  ${o[a-1]} += 1;
         if(${c}) {`],d=a===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="";for(let f=0,m=a===1?2:4;f<m;f++)p+=`
        ${h[f]}
        if (${d}) {
          result[${f}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${f}] = getChannel(getX(${l.join()}), ${u});
        }
      `;p+=a===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${s});
      const ${r} end = ${r}(${i});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}},tW=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;if(N.sizeFromShape(r.shape)===0){let c=s.map((u,h)=>u[0]+r.shape[h]+u[1]);return lv({backend:n,attrs:{shape:c,value:i,dtype:r.dtype}})}let o=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NIe(r.shape,s,i):new EIe(r.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[r],r.dtype,l)},CIe={kernelName:Gh,backendName:"webgl",kernelFunc:tW},AIe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,RIe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+kd+`
  return result;
`,DIe=Ra({opSnippet:AIe,packedOpSnippet:RIe}),$Ie={kernelName:Hh,backendName:"webgl",kernelFunc:DIe};function MIe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=[],c=N.parseAxisParam(s,r.shape),u=c,h=O.getAxesPermutation(u,o),d=r;h!=null&&(d=er({inputs:{x:r},backend:n,attrs:{perm:h}}),u=O.getInnerMostAxes(u.length,o),l.push(d)),O.assertAxesAreInnerMostDims("prod",u,o);let p;if(n.shouldExecuteOnCPU([d])){let f=n.texData.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=Ave(d.shape,d.dtype,f,u);p=n.makeTensorInfo(g,y,m)}else{let[f,m]=O.computeOutAndReduceShapes(d.shape,u),g=N.sizeFromShape(m),y=_e({inputs:{x:d},backend:n,attrs:{shape:[-1,g]}}),v=n1(r.dtype),x=Td(y,v,"prod",n);p=_e({inputs:{x},backend:n,attrs:{shape:f}}),l.push(y),l.push(x)}if(i){l.push(p);let f=O.expandShapeToKeepDim(p.shape,c);p=_e({inputs:{x:p},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var OIe={kernelName:Kh,backendName:"webgl",kernelFunc:MIe};function FIe(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,l=r.map(y=>n.readSync(y.dataId)),c=r.map(y=>y.shape),u=n.readSync(s.dataId),h=n.readSync(i.dataId),[d,p,f]=Rve(l,c,u,s.shape,s.dtype,h,i.shape,o),m=d.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}var LIe={kernelName:Yw,backendName:"webgl",kernelFunc:FIe};function zIe(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[c,u]=Dve(i,a.shape,a.dtype,o,r.shape,l,s.shape),h=n.makeTensorInfo([c.length],"int32",c),d=n.makeTensorInfo([u.length],a.dtype,u);return[h,d]}var PIe={kernelName:Zw,backendName:"webgl",kernelFunc:zIe};function VIe(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=a,c=n.readSync(r.dataId),u=n.readSync(s.dataId),h=n.readSync(i.dataId),d=o.map(g=>n.readSync(g.dataId)),p=o.map(g=>g.shape),[f,m]=$ve(c,r.shape,u,s.shape,s.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,m)}var BIe={kernelName:Jw,backendName:"webgl",kernelFunc:VIe},nW=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=Mve(a,r,s,i);return t.makeTensorInfo([o.length],i,o)},UIe={kernelName:vb,backendName:"webgl",kernelFunc:nW},WIe="return 1.0 / x;",jIe=Ct({opSnippet:WIe}),GIe={kernelName:Xh,backendName:"webgl",kernelFunc:jIe},HIe=Ls+`
  return (x < 0.0) ? 0.0 : x;
`,qIe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,KIe=Ct({opSnippet:HIe,packedOpSnippet:qIe}),XIe={kernelName:Qh,backendName:"webgl",kernelFunc:KIe},QIe=Ls+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,YIe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ZIe=Ct({opSnippet:QIe,packedOpSnippet:YIe}),JIe={kernelName:Jh,backendName:"webgl",kernelFunc:ZIe},eke=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let c=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h;r?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/u[0]},
          ${c[1]/u[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},tke=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let c=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h;r?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/u[0]},
          ${c[1]/u[1]},
          ${c[1]/u[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function nke(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,c]=o,u=Z().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new tke(r.shape,l,c,s,i):new eke(r.shape,l,c,s,i);return n.runWebGLProgram(u,[r],"float32")}var ake={kernelName:Zh,backendName:"webgl",kernelFunc:nke},rke=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],c=o[0]/l[0],u=o[1]/l[1],h=1/c,d=1/u,p=Math.ceil(h)*2+2,f=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${u});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function ske(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new rke(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var ike={kernelName:um,backendName:"webgl",kernelFunc:ske},oke=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let c=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0",d;r?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/u[0]},
          ${c[1]/u[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},lke=class{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let c=[a&&t>1?i-1:i,a&&n>1?o-1:o],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0",d;r?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/u[0]},
          ${c[1]/u[1]},
          ${c[1]/u[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function uke(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,c]=o,u=Z().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new lke(r.shape,l,c,s,i):new oke(r.shape,l,c,s,i);return n.runWebGLProgram(u,[r],r.dtype)}var cke={kernelName:Yh,backendName:"webgl",kernelFunc:uke},hke=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],c=o[0]/l[0],u=o[1]/l[1],h=1/c,d=1/u,p=Math.ceil(h)*2+2,f=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${u});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function dke(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new hke(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var pke={kernelName:lm,backendName:"webgl",kernelFunc:dke},fke=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let a=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,r=e.map((i,o)=>a(o)).join(","),s=Zt(n);this.userCode=`
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}},mke=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let a=Ya("rc",n),r=`${a[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${a[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Zt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(a.slice())};
          if(${r}){
            result.g = ${l(a.slice())};
          }
          if(${s}) {
            result.b = ${c(a.slice())};
            if(${r}) {
              result.a = ${u(a.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(p){return h(p)}function l(p){return p[n-1]="("+p[n-1]+" + 1)",h(p)}function c(p){return p[n-2]="("+p[n-2]+" + 1)",h(p)}function u(p){return p[n-1]="("+p[n-1]+" + 1)",p[n-2]="("+p[n-2]+" + 1)",h(p)}function h(p){let f=e.map((y,v)=>d(v,p)),m=f.join(","),g=f.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${g}))`}function d(p,f){return t.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${f[p]} - 1`:`${f[p]}`}}};function gke(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=r.shape.length,o=N.parseAxisParam(s,r.shape);if(i===0)return Vr({inputs:{x:r},backend:n});let l=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mke(r.shape,o):new fke(r.shape,o);return n.runWebGLProgram(l,[r],r.dtype)}var yke={kernelName:ed,backendName:"webgl",kernelFunc:gke},bke=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],a=e[2];this.outputShape=e;let r="";typeof t=="number"?r=`float outputValue = ${t.toFixed(2)};`:r=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},vke={kernelName:Im,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,l=new bke(a.shape,s),[c,u]=O.getImageCenter(i,a.shape[1],a.shape[2]),h=[[c,u,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(l,[a],a.dtype,h)}},xke=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,wke=Ct({opSnippet:xke}),_ke={kernelName:td,backendName:"webgl",kernelFunc:wke},Ske="return inversesqrt(x);",Ike=Ct({opSnippet:Ske,cpuKernelImpl:Ove}),kke={kernelName:nd,backendName:"webgl",kernelFunc:Ike},mA=class{constructor(e,t,n,a,r,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let l=Zt(r.length),c=Zt(s.length),u="";n===1?u="i":n===2&&(u="i, j");let h=`getIndices(${u})`,d="";a===1?d="i":a===2&&(d="i, coords[1]");let p=`getUpdates(${d})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${r});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${g};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}},Tke=class{constructor(e,t,n,a,r,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let l=Zt(r.length),c=Zt(s.length),u="";n===1?u="i":n===2&&(u="i, j");let h=`getIndices(${u})`,d="";a===1?d="i":a===2&&(d="i, coords[1]");let p=`getUpdates(${d})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${r});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${g};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}};function Eke(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=O.calculateShapes(s,r,i),d=[h/c,c];if(h===0)return n.makeTensorInfo(i,r.dtype);let p=_e({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),f=_e({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g;Z().getBool("WEBGL_PACK")?g=new Tke(l,o,p.shape.length,f.shape.length,u,d):g=new mA(l,o,p.shape.length,f.shape.length,u,d);let y=n.runWebGLProgram(g,[f,p,m],f.dtype),v=_e({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),v}var Nke={kernelName:cm,backendName:"webgl",kernelFunc:Eke},Cke=class{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let r="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=Z().getNumber("WEBGL_VERSION")===2?r:s,o=a==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Ake(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=new Cke(r.shape[0],r.shape[1],s.shape[1],i),l=[[r.shape[1]]];return n.runWebGLProgram(o,[r,s],"int32",l)}var Rke={kernelName:dm,backendName:"webgl",kernelFunc:Ake},Dke=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let a,r;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)r="resRC",a="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let c=0;c<t.length;c++)l.push(`${i[c]}`),c<e&&o.push(`${i[c]}`);a=o.join(),r=l.join()}let s=Zt(n);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${a});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}};function $ke(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=new Dke(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(i,[a,r,s],us(r.dtype,s.dtype))}var Mke={kernelName:pm,backendName:"webgl",kernelFunc:$ke},Oke=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${O.SELU_SCALEALPHA};
  float scale = ${O.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Fke=Ct({opSnippet:Oke}),Lke={kernelName:ad,backendName:"webgl",kernelFunc:Fke},zke=Wm+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Pke=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Vke=Ct({opSnippet:zke,packedOpSnippet:Pke,cpuKernelImpl:Lve}),Bke={kernelName:od,backendName:"webgl",kernelFunc:Vke},Uke=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Wke=Ct({opSnippet:Uke}),jke={kernelName:id,backendName:"webgl",kernelFunc:Wke},Gke=Wm+`
  return sin(x);
`,Hke=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${kd}
  return result;
`,qke=Ct({opSnippet:Gke,packedOpSnippet:Hke}),Kke={kernelName:rd,backendName:"webgl",kernelFunc:qke},Xke=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Qke=Ct({opSnippet:Xke}),Yke={kernelName:sd,backendName:"webgl",kernelFunc:Qke},Zke=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Jke=Ct({opSnippet:Zke}),eTe={kernelName:ld,backendName:"webgl",kernelFunc:Jke},tTe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;N.assert(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((y,v)=>y*v),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<r.shape.length;++y)l.push([0,0]);let c=[],u=tW({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),h=O.getReshaped(u.shape,s,o,!1),d=O.getPermuted(h.length,s.length,!1),p=O.getReshapedPermuted(u.shape,s,o,!1),f=_e({inputs:{x:u},backend:n,attrs:{shape:h}}),m=er({inputs:{x:f},backend:n,attrs:{perm:d}}),g=_e({inputs:{x:m},backend:n,attrs:{shape:p}});return c.push(u),c.push(f),c.push(m),c.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},nTe={kernelName:mm,backendName:"webgl",kernelFunc:tTe};function aTe(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(a.dataId),l=n.readSync(r.dataId),c=n.readSync(s.dataId),u=n.readSync(i.dataId)[0],[h,d,p,f,m]=Pve(o,a.shape,a.dtype,l,r.dtype,c,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}var rTe={kernelName:xb,backendName:"webgl",kernelFunc:aTe};function sTe(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(r.dataId)),o=n.readSync(a.dataId),l=Array.from(n.readSync(s.dataId)),[c,u,h]=Vve(o,a.shape,a.dtype,i,l);return[n.makeTensorInfo(u,a.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}var iTe={kernelName:ym,backendName:"webgl",kernelFunc:sTe};function oTe(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[c,u]=I5(i,a.shape,a.dtype,o,l,!0);return n.makeTensorInfo(u,a.dtype,c)}var lTe={kernelName:wb,backendName:"webgl",kernelFunc:oTe};function uTe(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[c,u]=I5(i,a.shape,a.dtype,o,l);return n.makeTensorInfo(u,a.dtype,c)}var cTe={kernelName:_b,backendName:"webgl",kernelFunc:uTe};function hTe(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=O.calculateShapes(s,r,o),p=!1;if(s.dtype==="string"){let y=n.bufferSync(r),v=n.bufferSync(s),x=N.decodeString(n.readSync(i.dataId)[0]),w=Fve(y,v,o,d,u,c,l,h,x,p);return n.makeTensorInfo(o,w.dtype,w.values)}let f=new mA(c,l,r.shape.length,s.shape.length,h,[d,1],p),m=n.runWebGLProgram(f,[s,r,i],s.dtype),g=_e({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}var dTe={kernelName:bm,backendName:"webgl",kernelFunc:hTe};function pTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=N.parseAxisParam(i,r.shape)[0],l=O.prepareSplitSize(r,s,o),c=r.shape.length,u=new Array(c).fill(0),h=r.shape.slice();return l.map(d=>{let p=[...h];p[o]=d;let f=jm({inputs:{x:r},backend:n,attrs:{begin:u,size:p}});return u[o]+=d,f})}var fTe={kernelName:gm,backendName:"webgl",kernelFunc:pTe},YM="return sqrt(x);",mTe=Ct({opSnippet:YM,packedOpSnippet:YM,cpuKernelImpl:Bve}),gTe={kernelName:ud,backendName:"webgl",kernelFunc:mTe},yTe="return x * x;",bTe=Ct({opSnippet:yTe}),vTe={kernelName:Sb,backendName:"webgl",kernelFunc:bTe},ZM="return (a - b) * (a - b);",xTe=Ra({opSnippet:ZM,packedOpSnippet:ZM}),wTe={kernelName:dd,backendName:"webgl",kernelFunc:xTe};function _Te(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");let s=n.readSync(r.dataId),i=O.fromUint8ToStringArray(s),o=Uve(i,"string",a);return n.makeTensorInfo(r.shape,"string",o)}var STe={kernelName:Ib,backendName:"webgl",kernelFunc:_Te};function ITe({inputs:e,attrs:t,backend:n}){let{x:a}=e,r=Ls+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Ei(a.shape,r);return n.runWebGLProgram(s,[a],a.dtype)}var kTe={kernelName:fu,backendName:"webgl",kernelFunc:ITe},TTe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let a=n.length,r=Zt(n.length),s=Zt(n.length),i="";if(a===1)i="coords * strides + begin";else{let o=0;i=n.map((l,c)=>(o++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${o-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function ETe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:v,end:x,strides:w}=aa.sliceInfo(r.shape,s,i,o,l,c,u,h,d),k;if(m)k=_e({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||y){N.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let S=aa.computeOutShape(v,x,w),I=jm({inputs:{x:r},backend:n,attrs:{begin:v,size:S}});k=_e({inputs:{x:I},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(I)}else if(n.shouldExecuteOnCPU([r])){let S=n.readSync(r.dataId),I=ut(r.shape,r.dtype,S),E=Wve(p,I,w,v);k=n.makeTensorInfo(f,r.dtype,E.values)}else{let S=new TTe(v,w,p);k=n.runWebGLProgram(S,[r],r.dtype)}let M=_e({inputs:{x:k},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(k),M}var NTe={kernelName:vm,backendName:"webgl",kernelFunc:ETe};function CTe(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:c}=a,{data:u,dataSplits:h}=t,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=jve(d,p,r,s,i,o,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}var ATe={kernelName:kb,backendName:"webgl",kernelFunc:CTe};function RTe(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[c,u,h]=Gve(o,l,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var DTe={kernelName:Tb,backendName:"webgl",kernelFunc:RTe};function $Te(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=Hve(i,r);return n.makeTensorInfo(s.shape,"int32",o)}var MTe={kernelName:Eb,backendName:"webgl",kernelFunc:$Te},OTe="return tan(x);",FTe=Ct({opSnippet:OTe}),LTe={kernelName:fd,backendName:"webgl",kernelFunc:FTe},zTe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,PTe=Ct({opSnippet:zTe}),VTe={kernelName:md,backendName:"webgl",kernelFunc:PTe};function BTe(e){let{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=O.calculateShapes(i,s,r.shape),d=[h/c,c];if(h===0)return n.makeTensorInfo(r.shape,s.dtype);let p=_e({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=_e({inputs:{x:i},backend:n,attrs:{shape:[l,c]}}),m=_e({inputs:{x:r},backend:n,attrs:{shape:d}}),g=new mA(l,o,p.shape.length,f.shape.length,u,d,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),v=_e({inputs:{x:y},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),v}var UTe={kernelName:hm,backendName:"webgl",kernelFunc:BTe},WTe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let a=Zt(this.rank),r=jTe(e);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}};function jTe(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push(`imod(${n[r]}, ${e[r]})`);return a.join()}function aW(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if(r.dtype==="string"||r.shape.length>5){let o=n.readSync(r.dataId),l=r.dtype==="string"?o.map(h=>N.decodeString(h)):o,c=ut(r.shape,r.dtype,l),u=Kve(c,s);return n.makeTensorInfo(u.shape,u.dtype,u.values)}let i=new WTe(r.shape,s);return n.runWebGLProgram(i,[r],r.dtype)}var GTe={kernelName:pu,backendName:"webgl",kernelFunc:aW},HTe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},qTe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Gu(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function JM(e){let t=1;for(;t<e;)t*=2;return t}function KTe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a,o=Z().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Z().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,u=c[c.length-1];if(n.shouldExecuteOnCPU([r])||u<o||s>l){let E=n.readSync(r.dataId),[R,A]=Xve(E,c,r.dtype,s,i);return[n.makeTensorInfo(R.shape,R.dtype,R.values),n.makeTensorInfo(A.shape,A.dtype,A.values)]}if(s===0)return c[c.length-1]=0,[n.makeTensorInfo(c,r.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(u===1)return[r,lv({attrs:{shape:c,dtype:"int32",value:0},backend:n})];let h=n.texData.get(r.dataId),d=h!==null&&h.isPacked,p=d?n.unpackTensor(r):r,f=N.sizeFromShape(c)/u,m=_e({inputs:{x:p},attrs:{shape:[f,u]},backend:n});d&&Gu(n,p);let g=JM(s),y=JM(u),v=null,x=()=>v===null?[m,m]:[m,v],w=(E,R,A)=>{let _=x(),D=new HTe(A),j=[[u],[v===null?1:0],[Number.NEGATIVE_INFINITY],[E],[R]],q=v;v=n.runWebGLProgram(D,_,"int32",j),Gu(n,q)};for(let E=1;E<g;E*=2){let R=E*2;for(let A=E;A>=1;A/=2)w(R,A,[f,y])}for(let E=y;E>g;E/=2){let R=x(),A=new qTe([f,E/2]),_=[[u],[v===null?1:0],[g]],D=v;v=n.runWebGLProgram(A,R,"int32",_),Gu(n,D);let j=g/2,q=j*2;for(let B=j;B>=1;B/=2)w(q,B,v.shape)}let k=v;v=jm({inputs:{x:v},backend:n,attrs:{begin:0,size:[f,s]}}),Gu(n,k);let M=X5({inputs:{x:m,indices:v},backend:n,attrs:{axis:1,batchDims:1}});Gu(n,m);let S=c.slice(0,-1);S.push(s),k=v,v=_e({inputs:{x:v},attrs:{shape:S},backend:n}),Gu(n,k);let I=M;return M=_e({inputs:{x:M},attrs:{shape:S},backend:n}),Gu(n,I),[M,v]}var XTe={kernelName:xm,backendName:"webgl",kernelFunc:KTe},QTe=class{constructor(e,t,n,a,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i=n==="nearest"?1:2,o;switch(a){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function YTe(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:c}=a,[u,h,d,p]=r.shape,[f,m]=c??[h,d],g=[u,f,m,p],y=new QTe(h,d,i,o,l,g);return n.runWebGLProgram(y,[r,s],"float32")}var ZTe={kernelName:wm,backendName:"webgl",kernelFunc:YTe};function JTe(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;Lm(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=a.readSync(s.dataId),{outputValues:o,outputShape:l,indices:c}=Qve(i,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,o),a.makeTensorInfo([c.length],"int32",c)]}var e2e={kernelName:Nb,backendName:"webgl",kernelFunc:JTe};function t2e(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r,o=i.shape.length,l=r.shape[s],c=new Array(o-1),u=0;for(let m=0;m<o;m++)m!==s&&(c[u++]=i.shape[m]);let h=[],d=new Array(o).fill(0),p=i.shape.slice();p[s]=1;let f=new Array(l);for(let m=0;m<f.length;m++){d[s]=m;let g=jm({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),y=_e({inputs:{x:g},backend:n,attrs:{shape:c}});f[m]=y,h.push(g)}return h.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var n2e={kernelName:_m,backendName:"webgl",kernelFunc:t2e},a2e=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,a=e.batchSize,r=e.inSize,s=e.numSegments,i=s*Math.ceil(r/n);this.outputShape=[a,i];let o="0.0",l="sumValue",c=Math.floor(n/4)*4,u=n%4,h=`
        sumValue += dot(values, segFilter);
    `,d="";r%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let p="";r%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${u===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${l});
      }
    `}};function r2e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a,o=r.shape.length,l=[],c=0,u=O.getAxesPermutation([c],o),h=r;u!=null&&(h=er({inputs:{x:r},backend:n,attrs:{perm:u}}),l.push(h),c=O.getInnerMostAxes(1,o)[0]);let d=O.segment_util.computeOutShape(h.shape,c,i),p=N.sizeFromShape([h.shape[c]]),f=_e({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);let m=n1(r.dtype),g=(w,k,M,S,I)=>{let E=w.shape[0],R=w.shape[1],A=O.segment_util.segOpComputeOptimalWindowSize(R,I),_={windowSize:A,inSize:R,batchSize:E,numSegments:I},D=new a2e(_,k),j=n.compileAndRun(D,[w,M],S);if(l.push(j),j.shape[1]===I)return j;let q=nW({backend:n,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),B=aW({inputs:{x:q},backend:n,attrs:{reps:[R/A]}});return l.push(q),l.push(B),g(j,k,B,S,I)},y=g(f,"unsortedSegmentSum",s,m,i),v=_e({inputs:{x:y},backend:n,attrs:{shape:d}}),x=v;if(u!=null){l.push(v);let w=O.getUndoAxesPermutation(u);x=er({inputs:{x},backend:n,attrs:{perm:w}})}return l.forEach(w=>n.disposeIntermediateTensorInfo(w)),x}var s2e={kernelName:Cb,backendName:"webgl",kernelFunc:r2e},i2e=[Wxe,Gxe,Kxe,Yxe,Jxe,n0e,r0e,i0e,c0e,d0e,m0e,b0e,w0e,k0e,N0e,A0e,D0e,F0e,z0e,V0e,j0e,Y0e,J0e,awe,swe,hwe,pwe,ywe,Txe,xwe,kwe,Cwe,Owe,zwe,Vwe,Uwe,jwe,Kwe,Ywe,e1e,n1e,r1e,i1e,u1e,h1e,m1e,y1e,x1e,S1e,k1e,C1e,$1e,L1e,V1e,W1e,j1e,H1e,K1e,Q1e,Z1e,e_e,r_e,o_e,c_e,d_e,m_e,b_e,__e,T_e,kxe,N_e,Swe,R_e,M_e,L_e,Nxe,B_e,G_e,q_e,Y_e,eSe,rSe,oSe,hSe,mSe,bSe,xSe,ISe,TSe,NSe,DSe,MSe,FSe,zSe,VSe,jSe,KSe,ZSe,iIe,Rxe,cIe,pIe,gIe,vIe,owe,_Ie,IIe,TIe,CIe,$Ie,Axe,OIe,LIe,PIe,BIe,UIe,lwe,nIe,GIe,XIe,JIe,$xe,ake,ike,cke,pke,yke,vke,_ke,kke,Nke,Rke,Mke,Lke,Bke,jke,Kke,Yke,X0e,rIe,eTe,nTe,rTe,iTe,lTe,cTe,dTe,fTe,gTe,vTe,wTe,STe,kTe,NTe,ATe,DTe,MTe,aIe,Vxe,LTe,VTe,UTe,GTe,XTe,ZTe,Bxe,e2e,n2e,s2e,SIe];for(let e of i2e)Ab(e);var Mt;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(Mt||(Mt={}));var zy;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(zy||(zy={}));var rW;function o2e(e){rW=e.wasm.cwrap(Ic,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function l2e(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t;if(r.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=a,d=n.dataIdMap.get(r.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=0;if(i!=null){let I=n.dataIdMap.get(i.dataId);if(I.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${I.shape.length}.`);f=I.id}let m=o==null?0:n.dataIdMap.get(o.dataId).id,g=zy[u];if(g==null)throw new Error(`${u} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?r.shape[2]:r.shape[1],v=c?s.shape[1]:s.shape[2],x=km.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)),w=n.makeOutput([...x,y,v],r.dtype),k=n.dataIdMap.get(w.dataId).id,M=new Uint8Array(new Int32Array(r.shape).buffer),S=new Uint8Array(new Int32Array(s.shape).buffer);return rW(d,M,r.shape.length,p,S,s.shape.length,l,c,g,f,m,h||0,k),w}var u2e={kernelName:Ic,backendName:"wasm",setupFunc:o2e,kernelFunc:l2e};function Tt(e,t){let n;function a(s){n=s.wasm.cwrap(e,null,["number","number","number"])}function r(s){let{backend:i,inputs:{x:o}}=s,l=i.dataIdMap.get(o.dataId).id,c=i.makeOutput(o.shape,t||o.dtype),u=i.dataIdMap.get(c.dataId).id;return N.sizeFromShape(c.shape)===0||n(l,Mt[o.dtype],u),c}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:r}}var c2e=Tt(Sf),h2e=Tt(Zc),d2e=Tt(Jc);function jn(e,t,n){let a;function r(i){a=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:o,inputs:l}=i,{a:c,b:u}=l,h=o.dataIdMap.get(c.dataId).id,d=o.dataIdMap.get(u.dataId).id,p=n??c.dtype,f=O.assertAndGetBroadcastShape(c.shape,u.shape),m=o.makeOutput(f,p);if(N.sizeFromShape(f)===0)return m;let g=new Uint8Array(new Int32Array(c.shape).buffer),y=new Uint8Array(new Int32Array(u.shape).buffer),v=o.dataIdMap.get(m.dataId).id;return a(h,g,c.shape.length,d,y,u.shape.length,Mt[c.dtype],v),m}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:s}}var p2e=jn(hu),sW;function f2e(e){sW=e.wasm.cwrap(eh,null,["array","number","number","number"])}function m2e(e){let{inputs:t,backend:n}=e,a=n.makeOutput(t[0].shape,t[0].dtype);if(N.sizeFromShape(a.shape)===0)return a;let r=t.map(o=>n.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(r).buffer),i=n.dataIdMap.get(a.dataId).id;return sW(s,r.length,Mt[a.dtype],i),a}var g2e={kernelName:eh,backendName:"wasm",setupFunc:f2e,kernelFunc:m2e};function h_(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return Za(n.readSync(t.dataId),t.shape,t.dtype);let a=n.makeOutput(t.shape,t.dtype),r=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(a).set(r),a}var y2e={kernelName:Eh,backendName:"wasm",kernelFunc:h_},iW;function b2e(e){iW=e.wasm.cwrap(bo,null,["number","array","number","number","number","array","number"])}function Jl(e){let{inputs:t,backend:n,attrs:a}=e,[r,s]=x2e(t.x.shape,a.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=v2e(t.x.shape,a.perm),l={dataId:t.x.dataId,shape:r,dtype:t.x.dtype};if(i){let f=h_({inputs:t,backend:n});return f.shape=o,f}let c=n.makeOutput(o,l.dtype),u=n.dataIdMap.get(l.dataId).id,h=n.dataIdMap.get(c.dataId).id,d=new Uint8Array(new Int32Array(s).buffer),p=new Uint8Array(new Int32Array(l.shape).buffer);return iW(u,p,l.shape.length,Mt[l.dtype],h,d,s.length),c}function v2e(e,t){let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];return n}function x2e(e,t){let n=[],a=[];for(let r=0;r<e.length;++r)e[r]!==1&&n.push(e[r]),e[t[r]]!==1&&a.push(t[r]);for(let r=0;r<a.length;++r){let s=-1;for(let i=0;i<a.length;++i)a[i]>=r&&(s===-1||a[s]>a[i])&&(s=i);a[s]=r}return[n,a]}var w2e={kernelName:bo,backendName:"wasm",kernelFunc:Jl,setupFunc:b2e};function _u(e,t,n){let a=e.shape,r=e.shape.length,s=N.parseAxisParam(t,a),i=s,o=O.getAxesPermutation(i,r),l=null,c=!1;if(o!=null){let u=new Array(r);for(let d=0;d<u.length;d++)u[d]=a[o[d]];i=O.getInnerMostAxes(i.length,r),l=Jl({inputs:{x:e},attrs:{perm:o},backend:n});let h=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==h&&(c=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:c}}var oW;function _2e(e){oW=e.wasm.cwrap(If,null,["number, number, number"])}function S2e(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:u,originalAxes:h,inputWasTransposed:d}=_u(i,r,t);if(d){let v=t.dataIdMap.get(c.dataId).id;l=c,o=v}let p=l.shape.length;O.assertAxesAreInnerMostDims("all",u,p);let[f,m]=O.computeOutAndReduceShapes(l.shape,u),g=N.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(N.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(y.dataId).id;oW(o,g,v)}if(d&&t.disposeData(c.dataId),s){let v=O.expandShapeToKeepDim(y.shape,h);y.shape=v}return y}var I2e={kernelName:If,backendName:"wasm",setupFunc:_2e,kernelFunc:S2e},lW;function k2e(e){lW=e.wasm.cwrap(kf,null,["number, number, number"])}function T2e(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:u,originalAxes:h,inputWasTransposed:d}=_u(i,r,t);if(d){let v=t.dataIdMap.get(c.dataId).id;l=c,o=v}let p=l.shape.length;O.assertAxesAreInnerMostDims("any",u,p);let[f,m]=O.computeOutAndReduceShapes(l.shape,u),g=N.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(N.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(y.dataId).id;lW(o,g,v)}if(d&&t.disposeData(c.dataId),s){let v=O.expandShapeToKeepDim(y.shape,h);y.shape=v}return y}var E2e={kernelName:kf,backendName:"wasm",setupFunc:k2e,kernelFunc:T2e};function uW(e){let t;function n(r){t=r.wasm.cwrap(e,null,["number","number","number","number","number"])}function a(r){let{backend:s,inputs:i,attrs:o}=r,{axis:l}=o,{x:c}=i,u=s.dataIdMap.get(c.dataId).id,h=u,d=c,{transposed:p,axes:f,inputWasTransposed:m}=_u(c,l,s);if(m){let k=s.dataIdMap.get(p.dataId).id;k!==u&&(d=p,h=k)}let g=d.shape.slice(0,-1),y=s.makeOutput(g,"int32"),v=s.dataIdMap.get(y.dataId).id,x=N.sizeFromShape(y.shape),w=d.shape[f[0]];return t(h,Mt[d.dtype],x,w,v),m&&s.disposeData(p.dataId),y}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:a}}var N2e=uW(Tf),C2e=uW(Ef),A2e=Tt(th),R2e=Tt(nh),D2e=Tt(ah),$2e=jn(sh),M2e=Tt(rh),cW;function O2e(e){cW=e.wasm.cwrap(ih,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function F2e(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=n,u=O.computePool2DInfo(r.shape,i,o,1,l,c),h=u.filterHeight,d=u.filterWidth,p=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,g=u.padInfo.left,y=u.strideHeight,v=u.strideWidth,x=u.inChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);if(u.dilationWidth!==1||u.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${u.dilationHeight}, ${u.dilationWidth}].`);let w=a.makeOutput(u.outShape,"float32"),k=a.dataIdMap.get(w.dataId).id;return cW(s,r.shape[0],r.shape[1],r.shape[2],h,d,p,f,m,g,y,v,x,k),w}var L2e={kernelName:ih,backendName:"wasm",setupFunc:O2e,kernelFunc:F2e},hW;function z2e(e){hW=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function P2e(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=a,u=O.computePool3DInfo(r.shape,s,i,1,o,l,c),h=n.makeOutput(u.outShape,r.dtype);return hW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),h}var V2e={kernelName:Nf,backendName:"wasm",setupFunc:z2e,kernelFunc:P2e},dW;function B2e(e){dW=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function U2e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=a,u=O.computePool3DInfo(s.shape,i,o,1,l,c),h=n.makeOutput(s.shape,s.dtype);return dW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left,u.filterDepth,u.filterHeight,u.filterWidth),h}var W2e={kernelName:cb,backendName:"wasm",setupFunc:B2e,kernelFunc:U2e},pW;function j2e(e){pW=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function G2e(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l}=a,c=O.computePool2DInfo(s.shape,i,o,1,l),u=n.makeOutput(s.shape,s.dtype);return pW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(u.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left,c.filterHeight,c.filterWidth),u}var H2e={kernelName:ub,backendName:"wasm",setupFunc:j2e,kernelFunc:G2e};function mr(e){let{inputs:t,attrs:n}=e,{x:a}=t,{shape:r}=n,s=N.sizeFromShape(a.shape),i=N.inferFromImplicitShape(r,s);return N.assert(s===N.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${a.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:i,dtype:a.dtype}}var q2e={kernelName:om,backendName:"wasm",kernelFunc:mr},fW;function K2e(e){fW=e.wasm.cwrap(oh,null,["number","array","number","number","array","number","number","number","number"])}function X2e(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;if(r.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=r.shape.length,c=s.shape.length,u=i?r.shape[l-2]:r.shape[l-1],h=o?s.shape[c-1]:s.shape[c-2],d=i?r.shape[l-1]:r.shape[l-2],p=o?s.shape[c-2]:s.shape[c-1],f=r.shape.slice(0,-2),m=s.shape.slice(0,-2),g=N.sizeFromShape(f),y=N.sizeFromShape(m),v=km.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);N.assert(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,u,d]:[g,d,u],w=o?[y,p,h]:[y,h,p],k=mr({inputs:{x:r},backend:n,attrs:{shape:x}}),M=mr({inputs:{x:s},backend:n,attrs:{shape:w}}),S=n.dataIdMap.get(k.dataId).id,I=n.dataIdMap.get(M.dataId).id,E=i?k.shape[2]:k.shape[1],R=o?M.shape[1]:M.shape[2],A=Math.max(g,y),_=n.makeOutput([A,E,R],k.dtype),D=n.dataIdMap.get(_.dataId).id,j=new Uint8Array(new Int32Array(k.shape).buffer),q=new Uint8Array(new Int32Array(M.shape).buffer);return fW(S,j,k.shape.length,I,q,M.shape.length,i,o,D),n.disposeData(k.dataId),n.disposeData(M.dataId),_.shape=v,_}var Q2e={kernelName:oh,backendName:"wasm",setupFunc:K2e,kernelFunc:X2e};function Uc(e){let{inputs:{x:t},attrs:{begin:n,size:a},backend:r}=e,[s,i]=aa.parseSliceParams(t,n,a),o=aa.isSliceContinous(t.shape,s,i),l=r.readSync(t.dataId),c=r.makeOutput(i,t.dtype),u=N.computeStrides(t.shape),h=r.dataIdMap.get(c.dataId);if(o){let f=aa.computeFlatOffset(s,u);return t.dtype==="string"?h.stringBytes=l.slice(f,f+N.sizeFromShape(i)):r.typedArrayFromHeap(c).set(l.subarray(f,f+N.sizeFromShape(i))),c}if(t.dtype==="string"){let f=H0(l,s,i,t.shape,t.dtype);return h.stringBytes=f,c}let d=r.typedArrayFromHeap(c),p=t.shape.length;if(p===2)Y2e(l,u[0],d,s,i);else if(p===3)Z2e(l,u[0],u[1],d,s,i);else if(p===4)J2e(l,u[0],u[1],u[2],d,s,i);else{let f=H0(l,s,i,t.shape,t.dtype);d.set(f)}return c}function Y2e(e,t,n,a,r){let s=0,i=a[0],o=a[1],l=i+r[0];for(let c=i;c<l;c++){let u=c*t+o;n.set(e.subarray(u,u+r[1]),s),s+=r[1]}}function Z2e(e,t,n,a,r,s){let i=0,o=r[0],l=r[1],c=r[2],u=o+s[0],h=l+s[1];for(let d=o;d<u;d++)for(let p=l;p<h;p++){let f=d*t+p*n+c;a.set(e.subarray(f,f+s[2]),i),i+=s[2]}}function J2e(e,t,n,a,r,s,i){let o=0,l=s[0],c=s[1],u=s[2],h=l+i[0],d=c+i[1],p=u+i[2],f=s[3];for(let m=l;m<h;m++)for(let g=c;g<d;g++)for(let y=u;y<p;y++){let v=m*t+g*n+y*a+f;r.set(e.subarray(v,v+i[3]),o),o+=i[3]}}var eEe={kernelName:fm,backendName:"wasm",kernelFunc:Uc};function tEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a,o=s.reduce((y,v)=>y*v),l=O.getReshaped(r.shape,s,o),c=O.getPermuted(l.length,s.length),u=O.getReshapedPermuted(r.shape,s,o),h=O.getSliceBeginCoords(i,s.length),d=O.getSliceSize(u,i,s.length),p=mr({inputs:{x:r},backend:n,attrs:{shape:l}}),f=Jl({inputs:{x:p},backend:n,attrs:{perm:c}}),m=mr({inputs:{x:f},backend:n,attrs:{shape:u}}),g=Uc({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}var nEe={kernelName:Cf,backendName:"wasm",kernelFunc:tEe},mW;function aEe(e){mW=e.wasm.cwrap(Af,null,["number","number","boolean","number","number","number"])}function rEe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i}=a,o=s.shape.reduce((h,d)=>h*d,1)!==0,l=r.shape.length===1?[i]:[r.shape[0],i],c=t.makeOutput(l,s.dtype);function u(h){return t.dataIdMap.get(h.dataId).id}return mW(u(r),i,o,u(s),Mt[s.dtype],u(c)),c}var sEe={kernelName:Af,backendName:"wasm",setupFunc:aEe,kernelFunc:rEe},iEe=jn(Rf);function oEe(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.typedArrayFromHeap(a),i=n.typedArrayFromHeap(r),o=O.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var lEe={kernelName:hb,backendName:"wasm",kernelFunc:oEe};function Su(e){let{inputs:{x:t},attrs:{dtype:n},backend:a}=e,r=a.makeOutput(t.shape,n),s=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(r).set(s),r}var uEe={kernelName:lh,backendName:"wasm",kernelFunc:Su},cEe=Tt(uh),gW;function hEe(e){gW=e.wasm.cwrap(du,null,["number","number","number","number"])}function dEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,o=n.dataIdMap.get(r.dataId).id,l=n.makeOutput(r.shape,r.dtype),c=n.dataIdMap.get(l.dataId).id;return gW(o,s,i,c),l}var pEe={kernelName:du,backendName:"wasm",setupFunc:hEe,kernelFunc:dEe};function yW(e){let{inputs:t,backend:n}=e,a=N.parseAxisParam(e.attrs.axis,t[0].shape)[0],r=t.map(p=>p.shape);O.assertParamsConsistent(r,a);let s=O.computeOutShape(t.map(p=>p.shape),a),i=t.filter(p=>N.sizeFromShape(p.shape)>0);if(i.length===1)return h_({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(N.sizeFromShape(s)===0)return o;if(i[0].dtype==="string"){let p=i.map(x=>{let w=[-1,N.sizeFromShape(x.shape.slice(a))];return mr({inputs:{x},backend:n,attrs:{shape:w}})}),f=p.map(x=>({vals:n.readSync(x.dataId),shape:x.shape}));s=O.computeOutShape(p.map(x=>x.shape),1);let m=p[0].shape[0]===1,g=BC(f,s,t[0].dtype,m),y=O.computeOutShape(i.map(x=>x.shape),a);o.shape=y;let v=n.dataIdMap.get(o.dataId);return v.stringBytes=O.fromStringArrayToUint8(g),p.forEach(x=>n.disposeData(x.dataId)),o}let l=N.sizeFromShape(i[0].shape.slice(0,a)),c=0,u=i.map(p=>{let f=N.sizeFromShape(p.shape.slice(a));return c+=f,f}),h=i.map(p=>n.typedArrayFromHeap(p)),d=n.typedArrayFromHeap(o);for(let p=0;p<l;p++){let f=p*c;for(let m=0;m<h.length;m++){let g=u[m],y=p*g,v=h[m].subarray(y,y+g);d.set(v,f),f+=g}}return o}var fEe={kernelName:Df,backendName:"wasm",kernelFunc:yW},bW;function mEe(e){bW=e.wasm.cwrap(ch,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function gEe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:l,dilations:c,pad:u,dimRoundingMode:h,dataFormat:d}=n,p=O.convertConv2DDataFormat(d),f=O.computeConv2DInfo(r.shape,s.shape,l,c,u,h,!1,p),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,v=f.padInfo.right,x=f.padInfo.bottom,w=f.padInfo.left,k=f.dilationHeight,M=f.dilationWidth,S=f.strideHeight,I=f.strideWidth,E=f.inChannels,R=f.outChannels,A=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let _=a.makeOutput(f.outShape,"float32"),D=a.dataIdMap.get(_.dataId).id;return bW(i,r.shape[0],r.shape[1],r.shape[2],o,m,g,y,v,x,w,A,k,M,S,I,E,R,D),_}var yEe={kernelName:ch,backendName:"wasm",setupFunc:mEe,kernelFunc:gEe},vW;function bEe(e){vW=e.wasm.cwrap(hh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function vEe(e){let{backend:t,inputs:n,attrs:a}=e,{dy:r,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:c,inputShape:u}=a,h=1,d=O.convertConv2DDataFormat(l),p=O.computeConv2DInfo(u,s.shape,i,h,o,c,!1,d),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:y,inHeight:v,inWidth:x,outChannels:w,outHeight:k,outWidth:M,strideHeight:S,strideWidth:I}=p,E=m-1-p.padInfo.top,R=g-1-p.padInfo.left,A=p.dataFormat==="channelsLast",_=N.computeStrides(p.inShape),D=N.computeStrides(r.shape),[j,q,B]=N.computeStrides(s.shape),Q=_[0],H=A?_[1]:_[2],J=A?_[2]:1,ae=A?1:_[1],ne=D[0],ue=A?D[1]:D[2],le=A?D[2]:1,he=A?1:D[1],me=t.makeOutput(p.inShape,"float32"),Re=t.dataIdMap.get(me.dataId).id,Ne=t.dataIdMap.get(r.dataId).id,xe=t.dataIdMap.get(s.dataId).id;return vW(Ne,xe,f,m,g,v,x,y,k,M,w,S,I,E,R,j,q,B,Q,H,J,ae,ne,ue,le,he,Re),me}var xEe={kernelName:hh,backendName:"wasm",setupFunc:bEe,kernelFunc:vEe},xW;function wEe(e){xW=e.wasm.cwrap(dh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _Ee(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;if(r.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let c=O.computeConv3DInfo(r.shape,s.shape,i,l,o),u=n.makeOutput(c.outShape,r.dtype);return xW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),u}var SEe={kernelName:dh,backendName:"wasm",setupFunc:wEe,kernelFunc:_Ee},wW;function IEe(e){wW=e.wasm.cwrap($f,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function kEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a;if(r.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let c=O.computeConv3DInfo(r.shape,l,i,1,o),u=n.makeOutput(c.filterShape,s.dtype);return wW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),u}var TEe={kernelName:$f,backendName:"wasm",setupFunc:IEe,kernelFunc:kEe},_W;function EEe(e){_W=e.wasm.cwrap(Mf,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function NEe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a;if(r.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let c=O.computeConv3DInfo(l,s.shape,o,1,i),u=n.makeOutput(c.inShape,r.dtype);return _W(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(u.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),u}var CEe={kernelName:Mf,backendName:"wasm",setupFunc:EEe,kernelFunc:NEe},AEe=Tt(ph),REe=Tt(fh),Hk;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(Hk||(Hk={}));var SW;function DEe(e){SW=e.wasm.cwrap(Ff,null,["number","number","number","number","array","number","number","number","number","number"])}function $Ee(e){let{backend:t,inputs:n,attrs:a}=e,{method:r,extrapolationValue:s,cropSize:i}=a,{image:o,boxes:l,boxInd:c}=n,u=l.shape[0],[h,d]=i,p=[u,h,d,o.shape[3]],f=t.dataIdMap.get(o.dataId),m;o.dtype!=="float32"&&(m=Su({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));let g=f.id,y=t.dataIdMap.get(l.dataId).id,v=t.dataIdMap.get(c.dataId).id,x=t.makeOutput(p,"float32"),w=t.dataIdMap.get(x.dataId).id,k=new Uint8Array(new Int32Array(o.shape).buffer);return SW(g,y,v,u,k,h,d,Hk[r],s,w),m!=null&&t.disposeData(m.dataId),x}var MEe={kernelName:Ff,backendName:"wasm",setupFunc:DEe,kernelFunc:$Ee},IW;function OEe(e){IW=e.wasm.cwrap(Of,null,["number","number","number","number","number","number"])}function FEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,l=r.shape.length;N.assert(r.dtype==="float32"||r.dtype==="int32",()=>`cumprod does not support ${r.dtype} tensors in the WASM backend`);let c=O.getAxesPermutation([s],l),u=r;c!==null&&(u=Jl({inputs:{x:r},attrs:{perm:c},backend:n}));let h=O.getInnerMostAxes(1,l)[0];O.assertAxesAreInnerMostDims("cumprod",[h],l);let d=n.makeOutput(u.shape,u.dtype),p=u.shape[h],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(d.dataId).id;IW(f,i?1:0,o?1:0,p,m,Mt[r.dtype]);let g=d;if(c!==null){let y=O.getUndoAxesPermutation(c);g=Jl({inputs:{x:d},attrs:{perm:y},backend:n}),n.disposeData(u.dataId),n.disposeData(d.dataId)}return g}var LEe={kernelName:Of,backendName:"wasm",setupFunc:OEe,kernelFunc:FEe},kW;function zEe(e){kW=e.wasm.cwrap(mh,null,["number","number","number","number","number","number"])}function PEe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,l=r.shape.length;N.assert(r.dtype==="float32"||r.dtype==="int32",()=>`cumsum does not support ${r.dtype} tensors in the WASM backend`);let c=O.getAxesPermutation([s],l),u=r;c!==null&&(u=Jl({inputs:{x:r},attrs:{perm:c},backend:n}));let h=O.getInnerMostAxes(1,l)[0];O.assertAxesAreInnerMostDims("cumsum",[h],l);let d=n.makeOutput(u.shape,u.dtype),p=u.shape[h],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(d.dataId).id;kW(f,i?1:0,o?1:0,p,m,Mt[r.dtype]);let g=d;if(c!==null){let y=O.getUndoAxesPermutation(c);g=Jl({inputs:{x:d},attrs:{perm:y},backend:n}),n.disposeData(u.dataId),n.disposeData(d.dataId)}return g}var VEe={kernelName:mh,backendName:"wasm",setupFunc:zEe,kernelFunc:PEe},TW;function BEe(e){TW=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function UEe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i,binaryOutput:o}=a,l=s.shape.reduce((d,p)=>d*p,1)!==0,c=r.shape.length===1?[i]:[r.shape[0],i],u=t.makeOutput(c,s.dtype);function h(d){return t.dataIdMap.get(d.dataId).id}return TW(h(r),new Uint8Array(new Int32Array(r.shape).buffer),r.shape.length,i,l,h(s),Mt[s.dtype],o,h(u)),u}var WEe={kernelName:pb,backendName:"wasm",setupFunc:BEe,kernelFunc:UEe},EW;function jEe(e){EW=e.wasm.cwrap(Lf,null,["number","number","number","array","number","array","array","number","number"])}function GEe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{blockSize:s,dataFormat:i}=a,o=r.shape[0],l=i==="NHWC"?r.shape[1]:r.shape[2],c=i==="NHWC"?r.shape[2]:r.shape[3],u=i==="NHWC"?r.shape[3]:r.shape[1],h=l*s,d=c*s,p=u/(s*s),f=i==="NHWC"?[o,h,d,p]:[o,p,h,d],m=t.makeOutput(f,"float32"),g=t.dataIdMap.get(r.dataId).id,y=new Uint8Array(new Int32Array(N.computeStrides(r.shape)).buffer),v=new Uint8Array(new Int32Array(f).buffer),x=new Uint8Array(new Int32Array(N.computeStrides(f)).buffer),w=t.dataIdMap.get(m.dataId).id;return EW(g,s,i==="NHWC"?1:0,y,r.shape.length-1,v,x,f.length,w),m}var HEe={kernelName:Lf,backendName:"wasm",setupFunc:jEe,kernelFunc:GEe},NW;function qEe(e){NW=e.wasm.cwrap(gh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function KEe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:l,dilations:c,pad:u,dimRoundingMode:h}=n,d=c??[1,1],p=O.computeConv2DInfo(r.shape,s.shape,l,d,u,h,!0),f=p.filterHeight,m=p.filterWidth,g=p.padInfo.top,y=p.padInfo.right,v=p.padInfo.bottom,x=p.padInfo.left,w=p.dilationHeight,k=p.dilationWidth,M=p.strideHeight,S=p.strideWidth,I=p.inChannels,E=p.outChannels,R=p.padInfo.type==="SAME"?1:0;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let A=a.makeOutput(p.outShape,"float32"),_=a.dataIdMap.get(A.dataId).id;return NW(i,r.shape[0],r.shape[1],r.shape[2],o,f,m,g,y,v,x,R,w,k,M,S,I,E,_),A}var XEe={kernelName:gh,backendName:"wasm",setupFunc:qEe,kernelFunc:KEe},CW;function QEe(e){CW=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function YEe(e){let{inputs:t,backend:n}=e,{x:a}=t,r=N.sizeFromShape(a.shape),s=n.makeOutput([...a.shape,...a.shape],a.dtype);return CW(n.dataIdMap.get(a.dataId).id,Mt[a.dtype],r,n.dataIdMap.get(s.dataId).id),s}var ZEe={kernelName:fb,backendName:"wasm",setupFunc:QEe,kernelFunc:YEe},AW;function JEe(e){AW=e.wasm.cwrap(yh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function eNe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;if(r.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${r.dtype} and ${s.dtype}`);let c=O.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",l),u=n.makeOutput(c.outShape,r.dtype);return AW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,Mt[r.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),u}var tNe={kernelName:yh,backendName:"wasm",setupFunc:JEe,kernelFunc:eNe},RW;function nNe(e){RW=e.wasm.cwrap(Gp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function aNe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:l,dilations:c}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let u=O.computeDilation2DInfo(r.shape,s.shape,o,l,"NHWC",c),h=n.makeOutput(s.shape,s.dtype);return RW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,Mt[r.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),h}var rNe={kernelName:Gp,backendName:"wasm",setupFunc:nNe,kernelFunc:aNe},DW;function sNe(e){DW=e.wasm.cwrap(jp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function iNe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:l,dilations:c}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let u=O.computeDilation2DInfo(r.shape,s.shape,o,l,"NHWC",c),h=n.makeOutput(r.shape,r.dtype);return DW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,Mt[r.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),h}var oNe={kernelName:jp,backendName:"wasm",setupFunc:sNe,kernelFunc:iNe},lNe=Tt(vh),$W;function uNe(e){$W=e.wasm.cwrap(zf,null,["number","number","number"])}function cNe(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=n.makeOutput(r.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return $W(i(r),i(a),i(s)),s}var hNe={kernelName:zf,backendName:"wasm",setupFunc:uNe,kernelFunc:cNe},dNe=!1,pNe=jn(Pf,dNe,"bool"),fNe=Tt(xh),mNe=Tt(wh,"float32");function qk(e){let{inputs:t,attrs:n,backend:a}=e,{input:r}=t,{dim:s}=n,i=r.shape.length,o=r.shape.slice(),l=s;return s<0&&(N.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),mr({inputs:{x:r},backend:a,attrs:{shape:o}})}var gNe={kernelName:Vf,backendName:"wasm",kernelFunc:qk},yNe=Tt(_h,"float32");function MW(e){let{attrs:{shape:t,value:n},backend:a}=e,{attrs:{dtype:r}}=e;r=r||N.inferDtype(n);let s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}var bNe={kernelName:mb,backendName:"wasm",kernelFunc:MW},OW;function vNe(e){OW=e.wasm.cwrap(Bf,null,["number","number","number","number","number","number"])}function xNe(e){let{inputs:t,backend:n}=e,{image:a}=t,r=n.makeOutput(a.shape,a.dtype),s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,[o,l,c,u]=a.shape;return OW(s,o,l,c,u,i),r}var wNe={kernelName:Bf,backendName:"wasm",kernelFunc:xNe,setupFunc:vNe},_Ne=Tt(Sh),SNe=jn(Ih),FW;function INe(e){FW=e.wasm.cwrap(kh,null,["number","number","number","number","number","number","number"])}function kNe(e){let{backend:t,inputs:n,attrs:a}=e,{varianceEpsilon:r}=a,{x:s,mean:i,variance:o,offset:l,scale:c}=n,u=t.dataIdMap.get(s.dataId).id,h=t.dataIdMap.get(i.dataId).id,d=t.dataIdMap.get(o.dataId).id,p=l!=null?t.dataIdMap.get(l.dataId).id:0,f=c!=null?t.dataIdMap.get(c.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(N.sizeFromShape(s.shape)===0)return m;let g=t.dataIdMap.get(m.dataId).id;return FW(u,h,d,p,f,r,g),m}var TNe={kernelName:kh,backendName:"wasm",setupFunc:INe,kernelFunc:kNe},LW;function ENe(e){LW=e.wasm.cwrap(kc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function NNe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dilations:u,dataFormat:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=n,m=O.computeConv2DInfo(r.shape,s.shape,l,u,c,d),g=zy[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=a.dataIdMap.get(r.dataId).id,v=a.dataIdMap.get(s.dataId).id,x=m.outChannels,w=0;if(i!=null){let le=a.dataIdMap.get(i.dataId);if(le.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${le.shape.length}.`);if(le.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${le.shape}) does not match the number of output channels (${x})`);w=le.id}let k=m.filterHeight,M=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,E=m.padInfo.bottom,R=m.padInfo.left,A=m.dilationHeight,_=m.dilationWidth,D=m.strideHeight,j=m.strideWidth,q=m.inChannels,B=m.padInfo.type==="SAME"?1:0,Q=m.batchSize,H=m.inHeight,J=m.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let ae=a.makeOutput(m.outShape,"float32"),ne=a.dataIdMap.get(ae.dataId).id,ue=o==null?0:a.dataIdMap.get(o.dataId).id;return LW(y,Q,H,J,v,k,M,w,S,I,E,R,B,A,_,D,j,q,x,g,ue,f||0,ne),ae}var CNe={kernelName:kc,backendName:"wasm",setupFunc:ENe,kernelFunc:NNe},zW;function ANe(e){zW=e.wasm.cwrap(Tc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function RNe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dilations:u,dataFormat:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=n,m=O.computeConv2DInfo(r.shape,s.shape,l,u,c,d,!0),g=zy[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=a.dataIdMap.get(r.dataId).id,v=a.dataIdMap.get(s.dataId).id,x=m.outChannels,w=0;if(i!=null){let le=a.dataIdMap.get(i.dataId);if(le.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${le.shape.length}.`);if(le.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${le.shape}) does not match the number of output channels (${x})`);w=le.id}let k=m.filterHeight,M=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,E=m.padInfo.bottom,R=m.padInfo.left,A=m.dilationHeight,_=m.dilationWidth,D=m.strideHeight,j=m.strideWidth,q=m.inChannels,B=m.padInfo.type==="SAME"?1:0,Q=m.batchSize,H=m.inHeight,J=m.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let ae=a.makeOutput(m.outShape,"float32"),ne=a.dataIdMap.get(ae.dataId).id,ue=o==null?0:a.dataIdMap.get(o.dataId).id;return zW(y,Q,H,J,v,k,M,w,S,I,E,R,B,A,_,D,j,q,x,g,ue,f||0,ne),ae}var DNe={kernelName:Tc,backendName:"wasm",setupFunc:ANe,kernelFunc:RNe},PW;function $Ne(e){PW=e.wasm.cwrap(Wf,null,["number","number","number","number","number","number","array","number"])}function MNe(e){let{backend:t,inputs:n}=e,{params:a,indices:r}=n,[s,i,o,l]=JE.prepareAndValidate(a,r),c=t.makeOutput(s,a.dtype);if(i===0)return c;let u=r.shape,h=u[u.length-1],d=t.dataIdMap.get(a.dataId).id,p=t.dataIdMap.get(r.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(c.dataId).id;return PW(d,Mt[a.dtype],p,i,h,o,f,m),c}var ONe={kernelName:Wf,backendName:"wasm",setupFunc:$Ne,kernelFunc:MNe},VW;function FNe(e){VW=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function LNe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,indices:s}=n,{axis:i,batchDims:o}=a,l=N.parseAxisParam(i,r.shape)[0],c=t.readSync(s.dataId),u=r.shape[l];for(let S=0;S<c.length;++S){let I=c[S];N.assert(I<=u-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${u-1}]`)}let h=O.segment_util.collectGatherOpShapeInfo(r,s,l,o),d=mr({inputs:{x:r},attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]},backend:t}),p=N.sizeFromShape(s.shape),f=mr({inputs:{x:s},attrs:{shape:[h.batchSize,p/h.batchSize]},backend:t}),m=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],g=t.makeOutput(m,r.dtype);if(N.sizeFromShape(r.shape)===0)return g;let y=d.shape.length-1,v=t.dataIdMap.get(d.dataId).id,x=t.dataIdMap.get(f.dataId).id,w=t.dataIdMap.get(g.dataId).id,k=new Uint8Array(new Int32Array(N.computeStrides(d.shape)).buffer),M=new Uint8Array(new Int32Array(N.computeStrides(m)).buffer);return VW(v,Mt[r.dtype],k,y,x,h.batchSize,M,w),t.disposeData(d.dataId),t.disposeData(f.dataId),g.shape=h.outputShape,g}var zNe={kernelName:Uf,backendName:"wasm",setupFunc:FNe,kernelFunc:LNe},PNe=!1,VNe=jn(jf,PNe,"bool"),BNe=!1,UNe=jn(Th,BNe,"bool"),WNe=Tt(Nh,"bool"),jNe=Tt(Ch,"bool"),GNe=Tt(Ah,"bool"),BW;function HNe(e){BW=e.wasm.cwrap(Rh,null,["number","number","number","number"])}function qNe(e){let{inputs:{x:t},attrs:{alpha:n},backend:a}=e,r=a.dataIdMap.get(t.dataId).id,s=a.makeOutput(t.shape,"float32");if(N.sizeFromShape(t.shape)!==0){let i=a.dataIdMap.get(s.dataId).id;BW(r,Mt[t.dtype],n,i)}return s}var KNe={kernelName:Rh,backendName:"wasm",setupFunc:HNe,kernelFunc:qNe},XNe=!1,QNe=jn(Gf,XNe,"bool"),YNe=!1,ZNe=jn(Hf,YNe,"bool"),UW;function JNe(e){UW=e.wasm.cwrap(qf,null,["number","number","number","number"])}function eCe(e){let{attrs:t,backend:n}=e,{start:a,stop:r,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return UW(n.dataIdMap.get(o.dataId).id,a,r,i),o}var tCe={kernelName:qf,backendName:"wasm",setupFunc:JNe,kernelFunc:eCe},nCe=Tt(Dh),aCe=Tt($h),rCe=!1,sCe=jn(Kf,rCe,"bool"),iCe=Tt(Xf),oCe=!1,lCe=jn(Qf,oCe,"bool"),uCe=!1,cCe=jn(Bz,uCe,"bool"),WW;function hCe(e){WW=e.wasm.cwrap(Mh,null,["number","number","number","number","number","number","number"])}function dCe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a;if(r.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let c=n.makeOutput(r.shape,r.dtype);return WW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(c.dataId).id,r.shape[3],s,i,o,l),c}var pCe={kernelName:Mh,backendName:"wasm",setupFunc:hCe,kernelFunc:dCe},jW;function fCe(e){jW=e.wasm.cwrap(Yf,null,["number","number","number","number","number","number","number","number","number"])}function mCe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:c,beta:u}=a;if(r.dtype!=="float32"||s.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let h=n.makeOutput(r.shape,r.dtype);return jW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,i.shape[3],o,l,c,u),h}var gCe={kernelName:Yf,backendName:"wasm",setupFunc:fCe,kernelFunc:mCe},GW;function yCe(e){GW=e.wasm.cwrap(Oh,null,["number","number","number","number"])}function bCe(e){let{backend:t,inputs:n,attrs:a}=e,{reductionIndices:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:u,originalAxes:h,inputWasTransposed:d}=_u(i,r,t);if(d){let v=t.dataIdMap.get(c.dataId).id;l=c,o=v}let p=l.shape.length;O.assertAxesAreInnerMostDims("max",u,p);let[f,m]=O.computeOutAndReduceShapes(l.shape,u),g=N.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(N.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(y.dataId).id;GW(o,Mt[i.dtype],g,v)}if(d&&t.disposeData(c.dataId),s){let v=O.expandShapeToKeepDim(y.shape,h);y.shape=v}return y}var vCe={kernelName:Oh,backendName:"wasm",setupFunc:yCe,kernelFunc:bCe},xCe=jn(Fh),HW;function wCe(e){HW=e.wasm.cwrap(Lh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _Ce(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id;N.assert(r.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${r.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=n,u=O.computePool2DInfo(r.shape,i,o,1,l,c),h=u.filterHeight,d=u.filterWidth,p=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,g=u.padInfo.left,y=u.dilationHeight,v=u.dilationWidth,x=u.strideHeight,w=u.strideWidth,k=u.inChannels,M=u.outChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);let S=a.makeOutput(u.outShape,"float32"),I=a.dataIdMap.get(S.dataId).id;return HW(s,r.shape[0],r.shape[1],r.shape[2],h,d,p,f,m,g,y,v,x,w,k,M,I),S}var SCe={kernelName:Lh,backendName:"wasm",setupFunc:wCe,kernelFunc:_Ce},qW;function ICe(e){qW=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function kCe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=a,u=O.computePool3DInfo(r.shape,s,i,1,o,l,c),h=n.makeOutput(u.outShape,r.dtype);return qW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),h}var TCe={kernelName:Zf,backendName:"wasm",setupFunc:ICe,kernelFunc:kCe},KW;function ECe(e){KW=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function NCe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=a,u=O.computePool3DInfo(s.shape,i,o,1,l,c),h=n.makeOutput(s.shape,s.dtype);return KW(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),h}var CCe={kernelName:yb,backendName:"wasm",setupFunc:ECe,kernelFunc:NCe},XW;function ACe(e){XW=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function RCe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=a,u=O.computePool2DInfo(s.shape,i,o,1,l,c),h=n.makeOutput(s.shape,s.dtype);return XW(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),h}var DCe={kernelName:gb,backendName:"wasm",setupFunc:ACe,kernelFunc:RCe},QW;function $Ce(e){QW=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function MCe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=a;N.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let c=[1,1];N.assert(O.eitherStridesOrDilationsAreOne(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=O.computePool2DInfo(r.shape,s,i,[1,1],o),h=n.makeOutput(u.outShape,r.dtype),d=n.makeOutput(u.outShape,"int32");return QW(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(h.dataId).id,n.dataIdMap.get(d.dataId).id,Mt[r.dtype],l,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),[h,d]}var OCe={kernelName:bb,backendName:"wasm",setupFunc:$Ce,kernelFunc:MCe},YW;function FCe(e){YW=e.wasm.cwrap(zh,null,["number, number, number"])}function LCe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,c=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=_u(i,r,t),f=h;if(p){let w=t.dataIdMap.get(u.dataId).id;w!==o&&(c=u,l=w,f=O.getInnerMostAxes(f.length,c.shape.length))}O.assertAxesAreInnerMostDims("mean",f,c.shape.length);let[m,g]=O.computeOutAndReduceShapes(c.shape,f),y=N.sizeFromShape(g),v=c;c.dtype!=="float32"&&(v=Su({backend:t,inputs:{x:c},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(v.dataId).id);let x=t.makeOutput(m,"float32");if(N.sizeFromShape(c.shape)!==0){let w=t.dataIdMap.get(x.dataId).id;YW(l,y,w)}if(p&&t.disposeData(u.dataId),s){let w=O.expandShapeToKeepDim(x.shape,d);x.shape=w}return c.dtype!=="float32"&&t.disposeData(v.dataId),x}var zCe={kernelName:zh,backendName:"wasm",setupFunc:FCe,kernelFunc:LCe},ZW;function PCe(e){ZW=e.wasm.cwrap(Ph,null,["number","number","number","number"])}function VCe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,c=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=_u(i,r,t);if(p){let x=t.dataIdMap.get(u.dataId).id;x!==o&&(c=u,l=x)}let f=c.shape.length;O.assertAxesAreInnerMostDims("min",h,f);let[m,g]=O.computeOutAndReduceShapes(c.shape,h),y=N.sizeFromShape(g),v=t.makeOutput(m,c.dtype);if(N.sizeFromShape(c.shape)!==0){let x=t.dataIdMap.get(v.dataId).id;ZW(l,Mt[i.dtype],y,x)}if(p&&t.disposeData(u.dataId),s){let x=O.expandShapeToKeepDim(v.shape,d);v.shape=x}return v}var BCe={kernelName:Ph,backendName:"wasm",setupFunc:PCe,kernelFunc:VCe},UCe=jn(Vh),Kk;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(Kk||(Kk={}));var JW;function WCe(e){JW=e.wasm.cwrap(Bh,null,["number","array","number","number","array","array","number","number"])}function jCe(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,mode:r}}=e,s=a.map((f,m)=>f[0]+t.shape[m]+f[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),u=a.map(f=>f[0]),h=a.map(f=>f[1]),d=new Uint8Array(new Int32Array(u).buffer),p=new Uint8Array(new Int32Array(h).buffer);return JW(i,c,t.shape.length,Mt[t.dtype],d,p,Kk[r],l),o}var GCe={kernelName:Bh,backendName:"wasm",kernelFunc:jCe,setupFunc:WCe},ej;function HCe(e){ej=e.wasm.cwrap(hd,null,["number","number","number","number"])}function tj(e){let{backend:t,inputs:{logits:n},attrs:{dim:a}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[a],l=N.sizeFromShape(n.shape)/o;return N.sizeFromShape(s.shape)===0||ej(r,i,o,l),s}var qCe={kernelName:hd,backendName:"wasm",setupFunc:HCe,kernelFunc:tj},nj;function KCe(e){nj=e.wasm.cwrap(Jf,null,["number","number","number","number","number","number"])}function XCe(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;if(r.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);let l=o?r:tj({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),[c,u]=l.shape,h=n.makeOutput([c,s],"int32");return nj(n.dataIdMap.get(l.dataId).id,c,u,s,i,n.dataIdMap.get(h.dataId).id),o||n.disposeData(l.dataId),h}var QCe={kernelName:Jf,backendName:"wasm",setupFunc:KCe,kernelFunc:XCe},YCe=jn(Uh),ZCe=jn(Wh),JCe=Tt(em);function gA(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),a=n[0],r=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:a,selectedSize:r,pSelectedScores:s,pValidOutputs:i}}var aj;function eAe(e){aj=e.wasm.cwrap(nm,"number",["number","number","number","number","number"])}function tAe(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i}=a,{boxes:o,scores:l}=n,c=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(l.dataId).id,h=aj(c,u,s,r,i),{pSelectedIndices:d,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=gA(t,h);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",d)}var nAe={kernelName:nm,backendName:"wasm",setupFunc:eAe,kernelFunc:tAe},rj;function aAe(e){rj=e.wasm.cwrap(am,"number",["number","number","number","number","number","bool"])}function rAe(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=a,{boxes:l,scores:c}=n,u=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(c.dataId).id,d=rj(u,h,s,r,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=gA(t,d);t.wasm._free(m);let y=t.makeOutput([f],"int32",p),v=t.makeOutput([],"int32",g);return[y,v]}var sAe={kernelName:am,backendName:"wasm",setupFunc:aAe,kernelFunc:rAe},sj;function iAe(e){sj=e.wasm.cwrap(rm,"number",["number","number","number","number","number","number"])}function oAe(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=a,{boxes:l,scores:c}=n,u=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(c.dataId).id,d=sj(u,h,s,r,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=gA(t,d);t.wasm._free(g);let y=t.makeOutput([f],"int32",p),v=t.makeOutput([f],"float32",m);return[y,v]}var lAe={kernelName:rm,backendName:"wasm",setupFunc:iAe,kernelFunc:oAe},uAe=!1,cAe=jn(tm,uAe,"bool"),ij;function hAe(e){ij=e.wasm.cwrap(jh,null,["number","number","number","number","number"])}function dAe(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a,c=n.makeOutput([...r.shape,i],s),u=n.dataIdMap.get(c.dataId).id,h=n.dataIdMap.get(r.dataId).id;return ij(h,i,o,l,u),c}var pAe={kernelName:jh,backendName:"wasm",setupFunc:hAe,kernelFunc:dAe};function fAe(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(1),a}var mAe={kernelName:sm,backendName:"wasm",kernelFunc:fAe};function gAe(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return qk({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{N.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),N.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let h=qk({inputs:{input:u},backend:n,attrs:{dim:r}});return o.push(h),h}),c=yW({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(u=>n.disposeData(u.dataId)),c}var yAe={kernelName:im,backendName:"wasm",kernelFunc:gAe},oj;function bAe(e){oj=e.wasm.cwrap(Gh,null,["number","array","number","number","array","array","number","number"])}function vAe(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,constantValue:r}}=e,s=a.map((f,m)=>f[0]+t.shape[m]+f[1]);if(N.sizeFromShape(t.shape)===0)return MW({backend:n,attrs:{shape:s,value:r,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),u=a.map(f=>f[0]),h=a.map(f=>f[1]),d=new Uint8Array(new Int32Array(u).buffer),p=new Uint8Array(new Int32Array(h).buffer);return oj(i,c,t.shape.length,Mt[t.dtype],d,p,r,l),o}var lj={kernelName:Gh,backendName:"wasm",kernelFunc:vAe,setupFunc:bAe},xAe=jn(Hh),uj;function wAe(e){uj=e.wasm.cwrap(qh,null,["number","number","number"])}function _Ae(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,o=s,l=a,c=l;l.dtype!=="float32"&&(c=Su({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(c.dataId).id);let u=n.makeOutput(a.shape,"float32"),h=n.dataIdMap.get(u.dataId).id;return uj(o,i,h),l.dtype!=="float32"&&n.disposeData(c.dataId),u}var SAe={kernelName:qh,backendName:"wasm",setupFunc:wAe,kernelFunc:_Ae},cj;function IAe(e){cj=e.wasm.cwrap(Kh,null,["number","number","number","number"])}function kAe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,c=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=_u(i,r,t),f=h;if(p){let x=t.dataIdMap.get(u.dataId).id;x!==o&&(c=u,l=x,f=O.getInnerMostAxes(f.length,c.shape.length))}O.assertAxesAreInnerMostDims("prod",f,c.shape.length);let[m,g]=O.computeOutAndReduceShapes(c.shape,f),y=N.sizeFromShape(g),v=t.makeOutput(m,c.dtype);if(N.sizeFromShape(c.shape)!==0){let x=t.dataIdMap.get(v.dataId).id;cj(l,y,Mt[v.dtype],x)}if(p&&t.disposeData(u.dataId),s){let x=O.expandShapeToKeepDim(v.shape,d);v.shape=x}return v}var TAe={kernelName:Kh,backendName:"wasm",setupFunc:IAe,kernelFunc:kAe},EAe=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=jC(a,r,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},NAe={kernelName:vb,backendName:"wasm",kernelFunc:EAe},CAe=jn(bh),AAe=Tt(Xh),RAe=Tt(Qh),DAe=Tt(Jh),hj;function $Ae(e){hj=e.wasm.cwrap(Zh,null,["number","number","number","number","number","number","number","number","number","number"])}function MAe(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,c]=o,[u,h,d,p]=r.shape,f=[u,l,c,p],m=t.dataIdMap.get(r.dataId),g;m.dtype!=="float32"&&(g=Su({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let y=m.id,v=t.makeOutput(f,"float32");if(N.sizeFromShape(r.shape)===0)return v;let x=t.dataIdMap.get(v.dataId).id;return hj(y,u,h,d,p,l,c,s?1:0,i?1:0,x),g!=null&&t.disposeData(g.dataId),v}var OAe={kernelName:Zh,backendName:"wasm",setupFunc:$Ae,kernelFunc:MAe},dj;function FAe(e){dj=e.wasm.cwrap(um,null,["number","number","number","array","array","boolean"])}function LAe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=n.makeOutput(r.shape,"float32"),l=n.dataIdMap.get(r.dataId),c;return l.dtype!=="float32"&&(c=Su({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(c.dataId)),dj(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),c!=null&&n.disposeData(c.dataId),o}var zAe={kernelName:um,backendName:"wasm",setupFunc:FAe,kernelFunc:LAe},pj;function PAe(e){pj=e.wasm.cwrap(Yh,null,["number","number","number","number","number","number","number","number","number","number"])}function VAe(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,c]=o,[u,h,d,p]=r.shape,f=[u,l,c,p],m=t.makeOutput(f,"float32");if(N.sizeFromShape(r.shape)===0)return m;let g=t.dataIdMap.get(r.dataId),y;g.dtype!=="float32"&&(y=Su({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(y.dataId));let v=g.id,x=t.dataIdMap.get(m.dataId).id;return pj(v,u,h,d,p,l,c,s?1:0,i?1:0,x),y!=null&&t.disposeData(y.dataId),m}var BAe={kernelName:Yh,backendName:"wasm",setupFunc:PAe,kernelFunc:VAe},fj;function UAe(e){fj=e.wasm.cwrap(lm,null,["number","number","number","array","array","boolean"])}function WAe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=n.makeOutput(r.shape,"float32"),l=n.dataIdMap.get(r.dataId),c;return l.dtype!=="float32"&&(c=Su({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(c.dataId)),fj(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),c!=null&&n.disposeData(c.dataId),o}var jAe={kernelName:lm,backendName:"wasm",setupFunc:UAe,kernelFunc:WAe},mj;function GAe(e){mj=e.wasm.cwrap(ed,null,["number","array","number","array","number","number"])}function HAe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=N.parseAxisParam(s,r.shape);if(r.shape.length===0)return h_({inputs:{x:r},backend:n});let o=n.makeOutput(r.shape,r.dtype),l=n.dataIdMap.get(r.dataId).id,c=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(i).buffer),h=new Uint8Array(new Int32Array(r.shape).buffer);mj(l,u,i.length,h,r.shape.length,c);let d=mr({inputs:{x:o},attrs:{shape:r.shape},backend:n});return n.disposeData(o.dataId),d}var qAe={kernelName:ed,backendName:"wasm",kernelFunc:HAe,setupFunc:GAe},gj;function KAe(e){gj=e.wasm.cwrap(Im,null,["number","number","number","number","number","number","number","number","array","number","number"])}function XAe(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{radians:s,fillValue:i,center:o}=a,l=n.makeOutput(r.shape,r.dtype),c=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(l.dataId).id,[h,d,p,f]=r.shape,[m,g]=O.getImageCenter(o,d,p),y=i===0,v=255,x=typeof i=="number"?[i,i,i,y?0:v]:[...i,v],w=new Uint8Array(new Int32Array(x).buffer);return gj(c,h,d,p,f,s,m,g,w,x.length,u),l}var QAe={kernelName:Im,backendName:"wasm",kernelFunc:XAe,setupFunc:KAe},YAe=Tt(td),ZAe=Tt(nd),yj;function JAe(e){yj=e.wasm.cwrap(cm,null,["number","number","number","number","number","number","array","number","number"])}function eRe(e){let{backend:t,inputs:n,attrs:a}=e,{indices:r,updates:s}=n,{shape:i}=a,o=t.makeOutput(i,s.dtype);if(N.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=E1.calculateShapes(s,r,i),p=t.dataIdMap.get(r.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(h).buffer),g=t.dataIdMap.get(o.dataId).id;return yj(p,f,Mt[s.dtype],l,c,u,m,d,g),o}var tRe={kernelName:cm,backendName:"wasm",setupFunc:JAe,kernelFunc:eRe},bj;function nRe(e){bj=e.wasm.cwrap(dm,null,["number","number","number","number","number","number","bool","number"])}function aRe(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a;if(r.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(c){return n.dataIdMap.get(c.dataId).id}return bj(l(r),l(s),r.shape[0],r.shape[1],s.shape[1],Mt[r.dtype],i==="left",l(o)),o}var rRe={kernelName:dm,backendName:"wasm",setupFunc:nRe,kernelFunc:aRe},vj;function sRe(e){vj=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function iRe(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=n.dataIdMap.get(a.dataId).id,o=n.dataIdMap.get(r.dataId).id,l=n.dataIdMap.get(s.dataId).id,c=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(c.dataId).id,h=a.shape.length,d=r.shape.length,p=h===0||h>1||d===1?1:N.sizeFromShape(r.shape.slice(1));return vj(i,o,l,p,u),c}var oRe={kernelName:pm,backendName:"wasm",kernelFunc:iRe,setupFunc:sRe},lRe=Tt(ad),xj;function uRe(e){xj=e.wasm.cwrap(od,null,["number","number"])}function cRe(e){let{backend:t,inputs:{x:n}}=e,a=t.dataIdMap.get(n.dataId).id,r=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(r.dataId).id;return N.sizeFromShape(r.shape)===0||xj(a,s),r}var hRe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:uRe,kernelFunc:cRe},dRe=Tt(id),pRe=Tt(rd),fRe=Tt(sd),mRe=Tt(ld);function gRe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a,o=N.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<r.shape.length;++g)l.push([0,0]);let c=lj.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),u=O.getReshaped(c.shape,s,o,!1),h=O.getPermuted(u.length,s.length,!1),d=O.getReshapedPermuted(c.shape,s,o,!1),p=mr({inputs:{x:c},backend:n,attrs:{shape:u}}),f=Jl({inputs:{x:p},backend:n,attrs:{perm:h}}),m=mr({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeData(c.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}var yRe={kernelName:mm,backendName:"wasm",kernelFunc:gRe},wj;function bRe(e){wj=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function vRe(e){let{backend:t,inputs:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=n,o=a.shape[0],l=a.shape[1],c=t.readSync(s.dataId)[0],u=[o+c,l],h=t.dataIdMap.get(a.dataId).id,d=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(i.dataId).id,f=t.makeOutput(u,a.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(u.slice(0,1),r.dtype),y=t.dataIdMap.get(g.dataId).id,v=t.makeOutput([c],"bool"),x=t.dataIdMap.get(v.dataId).id,w=t.makeOutput([o],a.dtype),k=t.dataIdMap.get(w.dataId).id,M=t.makeOutput([4],"int32"),S=t.dataIdMap.get(M.dataId).id,I=wj(h,d,Mt[r.dtype],o,c,l,p,m,y,x,k,S),E=t.readSync(M.dataId),R;switch(E[0]){case 1:{R=O.getSparseFillEmptyRowsIndicesDenseShapeMismatch(E[1]);break}case 2:{R=O.getSparseFillEmptyRowsNegativeIndexErrorMessage(E[1],E[2]);break}case 3:R=O.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(E[1],E[2],E[3]);break;default:R=""}if(t.disposeData(M.dataId),R)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(v.dataId),t.disposeData(w.dataId),new Error(R);let A=f,_=g;return I!==u[0]&&(A=Uc({inputs:{x:f},attrs:{begin:0,size:[I,l]},backend:t}),_=Uc({inputs:{x:g},attrs:{begin:0,size:I},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[A,_,v,w]}var xRe={kernelName:xb,backendName:"wasm",setupFunc:bRe,kernelFunc:vRe},_j;function wRe(e){_j=e.wasm.cwrap(ym,null,["number","number","number","number","number","number","number"])}function _Re(e){let{backend:t,inputs:n}=e,{inputIndices:a,inputShape:r,newShape:s}=n;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(a.dataId).id,o=t.dataIdMap.get(r.dataId).id,l=t.dataIdMap.get(s.dataId).id,c=a.shape[0],u=N.sizeFromShape(s.shape),h=t.makeOutput([c,u],a.dtype),d=t.dataIdMap.get(h.dataId).id,p=t.makeOutput([u],s.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;_j(i,o,l,c,d,f,g);let y=t.readSync(m.dataId),v;switch(y[0]){case 0:{v=O.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break}case 1:{v=O.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break}case 2:v=O.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(t.readSync(r.dataId)),w=Array.from(t.readSync(p.dataId));v=O.getSparseReshapeInputOutputMultipleErrorMessage(x,w);break}case 4:{let x=Array.from(t.readSync(r.dataId)),w=Array.from(t.readSync(p.dataId));v=O.getSparseReshapeInputOutputMismatchErrorMessage(x,w);break}default:v=""}if(t.disposeData(m.dataId),v)throw t.disposeData(h.dataId),t.disposeData(p.dataId),new Error(v);return[h,p]}var SRe={kernelName:ym,backendName:"wasm",setupFunc:wRe,kernelFunc:_Re},Sj;function Ij(e){Sj=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function kj(e,t){let{backend:n,inputs:a}=e,{data:r,indices:s,segmentIds:i}=a,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],c=o>0?l+1:0;if(c<0)throw new Error(O.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let u=r.shape.slice();u[0]=c;let h=n.dataIdMap.get(r.dataId).id,d=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(u,r.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;Sj(h,Mt[r.dtype],r.shape[0],d,p,m,y,t,0);let v=n.readSync(g.dataId),x;switch(v[0]){case 0:{x=O.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{x=O.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:x=O.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v[1],v[2]);break;case 3:x=O.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v[1],v[2],v[3]);break;default:x=""}if(n.disposeData(g.dataId),x)throw n.disposeData(f.dataId),new Error(x);return f}function IRe(e){return kj(e,!0)}var kRe={kernelName:wb,backendName:"wasm",setupFunc:Ij,kernelFunc:IRe};function TRe(e){return kj(e,!1)}var ERe={kernelName:_b,backendName:"wasm",setupFunc:Ij,kernelFunc:TRe},Tj;function NRe(e){Tj=e.wasm.cwrap(bm,null,["number","number","number","number","number","number","number","number","array","number","number"])}function CRe(e){let{backend:t,inputs:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=n,{outputShape:o}=a,l=t.makeOutput(o,i.dtype);if(N.sizeFromShape(o)===0)return l;let{sliceRank:c,numUpdates:u,sliceSize:h,strides:d,outputSize:p}=O.calculateShapes(s,r,o),f=t.dataIdMap.get(r.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(d).buffer),v=t.dataIdMap.get(l.dataId).id;return Tj(f,m,s.shape.length,g,Mt[i.dtype],c,u,h,y,p,v),l}var ARe={kernelName:bm,backendName:"wasm",setupFunc:NRe,kernelFunc:CRe};function RRe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=n,o=N.parseAxisParam(i,r.shape)[0],l=O.prepareSplitSize(r,s,o),c=new Array(r.shape.length).fill(0),u=r.shape.slice();return l.map(h=>{let d=[...u];d[o]=h;let p=Uc({inputs:{x:r},attrs:{begin:c,size:d},backend:a});return c[o]+=h,p})}var DRe={kernelName:gm,backendName:"wasm",kernelFunc:RRe},$Re=Tt(ud),MRe=Tt(Sb),ORe=jn(dd),Ej;function FRe(e){Ej=e.wasm.cwrap(fu,null,["number","number","number","number"])}function LRe(e){let{backend:t,inputs:n,attrs:a}=e,{alpha:r}=a,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return Ej(i,r,Mt[s.dtype],l),o}var zRe={kernelName:fu,backendName:"wasm",setupFunc:FRe,kernelFunc:LRe},Nj;function PRe(e){Nj=e.wasm.cwrap(vm,null,["number","array","number","array","array","array","array","array","number","number"])}function VRe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{begin:s,end:i,strides:o,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:v,end:x,strides:w}=aa.sliceInfo(r.shape,s,i,o,l,c,u,h,d),k;if(m)k=mr({inputs:{x:r},backend:t,attrs:{shape:f}});else if(g||y){N.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let M=aa.computeOutShape(v,x,w),S=Uc({inputs:{x:r},backend:t,attrs:{begin:v,size:M}});k=mr({inputs:{x:S},backend:t,attrs:{shape:f}}),t.disposeData(S.dataId)}else{let M=t.makeOutput(p,"float32"),S=t.dataIdMap.get(r.dataId).id,I=new Uint8Array(new Int32Array(N.computeStrides(r.shape)).buffer),E=new Uint8Array(new Int32Array(v).buffer),R=new Uint8Array(new Int32Array(x).buffer),A=new Uint8Array(new Int32Array(w).buffer),_=new Uint8Array(new Int32Array(p).buffer),D=new Uint8Array(new Int32Array(N.computeStrides(p)).buffer),j=t.dataIdMap.get(M.dataId).id;Nj(S,I,r.shape.length,E,R,A,_,D,p.length,j),k=mr({inputs:{x:M},backend:t,attrs:{shape:f}}),t.disposeData(M.dataId)}return k}var BRe={kernelName:vm,backendName:"wasm",setupFunc:PRe,kernelFunc:VRe};function URe(e){let{backend:t,inputs:n,attrs:a}=e,{data:r,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:c,padWidth:u,preserveShortSequences:h}=a,d=t.readSync(r.dataId),p=t.readSync(s.dataId),[f,m]=HC(d,p,i,o,l,c,u,h),g=t.makeOutput([f.length],"string"),y=t.dataIdMap.get(g.dataId);y.stringBytes=f;let v=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(v).set(m),[g,v]}var WRe={kernelName:kb,backendName:"wasm",kernelFunc:URe};function jRe(e){let{backend:t,inputs:n,attrs:a}=e,{input:r,delimiter:s}=n,{skipEmpty:i}=a,o=t.readSync(r.dataId),l=t.readSync(s.dataId),[c,u,h]=qC(o,l[0],i),d=u.length,p=t.makeOutput([d,2],"int32");t.typedArrayFromHeap(p).set(c);let f=t.makeOutput([d],"string"),m=t.dataIdMap.get(f.dataId);m.stringBytes=u;let g=t.makeOutput([2],"int32");return t.typedArrayFromHeap(g).set(h),[p,f,g]}var GRe={kernelName:Tb,backendName:"wasm",kernelFunc:jRe};function HRe(e){let{backend:t,inputs:n,attrs:a}=e,{input:r}=n,{numBuckets:s}=a,i=t.readSync(r.dataId),o=KC(i,s),l=t.makeOutput(r.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}var qRe={kernelName:Eb,backendName:"wasm",kernelFunc:HRe},KRe=jn(pd),Cj;function XRe(e){Cj=e.wasm.cwrap(cd,null,["number","number","number","number"])}function QRe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,c=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=_u(i,r,t),f=h;if(p){let x=t.dataIdMap.get(u.dataId).id;x!==o&&(c=u,l=x,f=O.getInnerMostAxes(f.length,c.shape.length))}O.assertAxesAreInnerMostDims("sum",f,c.shape.length);let[m,g]=O.computeOutAndReduceShapes(c.shape,f),y=N.sizeFromShape(g),v=t.makeOutput(m,c.dtype);if(N.sizeFromShape(c.shape)!==0){let x=t.dataIdMap.get(v.dataId).id;Cj(l,y,Mt[v.dtype],x)}if(p&&t.disposeData(u.dataId),s){let x=O.expandShapeToKeepDim(v.shape,d);v.shape=x}return v}var YRe={kernelName:cd,backendName:"wasm",setupFunc:XRe,kernelFunc:QRe},ZRe=Tt(fd),JRe=Tt(md),Aj;function eDe(e){Aj=e.wasm.cwrap(hm,null,["number","number","number","number","number","number","array","number","number","number"])}function tDe(e){let{backend:t,inputs:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=n,o=t.makeOutput(r.shape,r.dtype);if(N.sizeFromShape(r.shape)===0)return o;let{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=E1.calculateShapes(i,s,r.shape),p=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(r.dataId).id,g=new Uint8Array(new Int32Array(h).buffer),y=t.dataIdMap.get(o.dataId).id;return Aj(p,f,Mt[i.dtype],l,c,u,g,d,y,m),o}var nDe={kernelName:hm,backendName:"wasm",setupFunc:eDe,kernelFunc:tDe},Rj;function aDe(e){Rj=e.wasm.cwrap(pu,null,["number","array","number","array","number","number"])}function rDe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,s=n.dataIdMap.get(r.dataId).id,{reps:i}=a,o=new Array(r.shape.length);for(let d=0;d<o.length;d++)o[d]=r.shape[d]*i[d];let l=new Uint8Array(new Int32Array(r.shape).buffer),c=new Uint8Array(new Int32Array(o).buffer),u=n.makeOutput(o,r.dtype),h=n.dataIdMap.get(u.dataId).id;return Rj(s,l,r.shape.length,c,o.length,Mt[u.dtype],h),u}var sDe={kernelName:pu,backendName:"wasm",setupFunc:aDe,kernelFunc:rDe},Dj;function iDe(e){Dj=e.wasm.cwrap(xm,null,["number","array","number","number","number","bool","number","number"])}var oDe=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{k:r,sorted:s}=n,i=t.dataIdMap.get(a.dataId).id,o=new Uint8Array(new Int32Array(a.shape).buffer),l=a.shape.slice();l[l.length-1]=r;let c=t.makeOutput(l,a.dtype),u=t.dataIdMap.get(c.dataId).id,h=t.makeOutput(l,"int32"),d=t.dataIdMap.get(h.dataId).id;return Dj(i,o,a.shape.length,Mt[a.dtype],r,s,u,d),[c,h]},lDe={kernelName:xm,backendName:"wasm",setupFunc:iDe,kernelFunc:oDe},$j;function uDe(e){$j=e.wasm.cwrap(wm,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function cDe(e){let{backend:t,inputs:n,attrs:a}=e,{image:r,transforms:s}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:c}=a,[u,h,d,p]=r.shape,[f,m]=c??[h,d],g=[u,f,m,p],y=new Uint8Array(new Int32Array(N.computeStrides(r.shape)).buffer),v=new Uint8Array(new Int32Array(N.computeStrides(g)).buffer),x=t.makeOutput(g,r.dtype),w=t.dataIdMap.get(x.dataId).id,k=t.dataIdMap.get(r.dataId).id,M=t.dataIdMap.get(s.dataId).id,S=i==="nearest"?1:2,I;switch(o){case"constant":I=1;break;case"reflect":I=2;break;case"wrap":I=3;break;case"nearest":I=4;break;default:I=1;break}return $j(k,M,s.shape[0]>1,u,f,m,p,d,h,y,r.shape.length-1,v,g.length-1,S,I,l,w),x}var hDe={kernelName:wm,backendName:"wasm",setupFunc:uDe,kernelFunc:cDe};function dDe(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=QC(a.readSync(s.dataId),r,s.shape,s.dtype);return[a.makeOutput(o,s.dtype,void 0,i),a.makeOutput([l.length],"int32",void 0,l)]}var pDe={kernelName:Nb,backendName:"wasm",kernelFunc:dDe};function fDe(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape[s],o=r.shape.length,l=new Array(o-1),c=0;for(let p=0;p<o;p++)p!==s&&(l[c++]=r.shape[p]);let u=new Array(i),h=new Array(o).fill(0),d=r.shape.slice();d[s]=1;for(let p=0;p<u.length;p++)h[s]=p,u[p]=Uc({inputs:{x:r},attrs:{begin:h,size:d},backend:n});return u.map(({dataId:p,dtype:f})=>({dataId:p,dtype:f,shape:l}))}var mDe={kernelName:_m,backendName:"wasm",kernelFunc:fDe};function gDe(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(0),a}var yDe={kernelName:Sm,backendName:"wasm",kernelFunc:gDe},bDe=[u2e,c2e,h2e,d2e,p2e,g2e,I2e,E2e,N2e,C2e,A2e,R2e,D2e,$2e,M2e,L2e,H2e,V2e,W2e,Q2e,nEe,sEe,iEe,lEe,uEe,cEe,pEe,fEe,yEe,xEe,SEe,TEe,CEe,AEe,REe,MEe,LEe,VEe,WEe,HEe,XEe,ZEe,tNe,rNe,oNe,lNe,hNe,pNe,fNe,mNe,gNe,yNe,bNe,wNe,_Ne,SNe,TNe,CNe,DNe,ONe,zNe,VNe,UNe,y2e,WNe,jNe,GNe,KNe,QNe,ZNe,tCe,aCe,nCe,sCe,iCe,lCe,cCe,pCe,gCe,vCe,xCe,SCe,TCe,CCe,DCe,OCe,zCe,BCe,UCe,GCe,QCe,YCe,ZCe,JCe,nAe,sAe,lAe,cAe,pAe,mAe,yAe,lj,xAe,SAe,TAe,NAe,CAe,AAe,RAe,DAe,q2e,OAe,zAe,BAe,jAe,qAe,QAe,YAe,ZAe,tRe,rRe,oRe,lRe,hRe,dRe,pRe,fRe,eEe,qCe,mRe,yRe,xRe,SRe,kRe,ERe,ARe,DRe,$Re,MRe,ORe,zRe,BRe,WRe,GRe,qRe,KRe,YRe,ZRe,JRe,nDe,sDe,lDe,hDe,w2e,pDe,mDe,yDe];for(let e of bDe)Ab(e);var Xk=Z();Xk.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});Xk.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(Xk.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var eO=cu(J7()),vDe=cu(eK()),tO=cu(tK()),nO=eO.default||eO,xDe=tO.default||tO,Mj=class extends ob{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(Oj),Qk=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Pw(this,xs())}write(e,t,n){let a={id:this.dataIdNextNumber++};return this.move(a,e,t,n,1),a}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=N.now();return e(),{kernelMs:N.now()-t}}move(e,t,n,a,r){let s=this.dataIdNextNumber++;if(a==="string"){let c=t;this.dataIdMap.set(e,{id:s,stringBytes:c,shape:n,dtype:a,memoryOffset:null,refCount:r});return}let i=N.sizeFromShape(n),o=i*N.bytesPerElement(a),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:a,refCount:r}),this.wasm.tfjs.registerTensor(s,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:a,dtype:r,shape:s,stringBytes:i}=this.dataIdMap.get(e);if(r==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||N.sizeFromShape(s);let o=N.bytesPerElement(r),l=this.wasm.HEAPU8.slice(a+t*o,a+n*o);return SDe(l.buffer,r)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,a){let r;if(n==null)r=this.write(a??null,e,t);else{let s=this.dataIdNextNumber++;r={id:s},this.dataIdMap.set(r,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=N.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let a=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(n),s=N.sizeFromShape(e);switch(t){case"float32":return new Float32Array(a,r,s);case"int32":return new Int32Array(a,r,s);case"bool":return new Uint8Array(a,r,s);default:throw new Error(`Unknown dtype ${t}`)}}};function wDe(e){return(t,n)=>(N.fetch(e,{credentials:"same-origin"}).then(a=>{a.ok||t.env.a(`failed to load wasm binary file at '${e}'`),a.arrayBuffer().then(r=>{WebAssembly.instantiate(r,t).then(s=>{n(s.instance,s.module)})})}),{})}function aO(e,t,n){if(J0!=null)return J0;let a="tfjs-backend-wasm.wasm";return e&&t?a="tfjs-backend-wasm-threaded-simd.wasm":e&&(a="tfjs-backend-wasm-simd.wasm"),Jg!=null&&Jg[a]!=null?Jg[a]:n+a}async function _De(){let[e,t]=await Promise.all([Z().getAsync("WASM_HAS_SIMD_SUPPORT"),Z().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,a)=>{let r={};r.locateFile=(o,l)=>{if(o.endsWith(".worker.js")){let c=vDe.wasmWorkerContents.replace(/\n/g,"\\n"),u=new Blob([c],{type:"application/javascript"});return URL.createObjectURL(u)}return o.endsWith(".wasm")?aO(e,t,Dg??l):l+o},yA&&(r.instantiateWasm=wDe(aO(e,t,Dg??"")));let s=!1;r.onAbort=()=>{s||ey||(ey=!0,a({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&J0==null?(r.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+nO.toString()],{type:"text/javascript"}),i=nO(r)):i=xDe(r),i.then(o=>{s=!0,ey=!1;let l=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",l,["number"]),dispose:o.cwrap("dispose",l,[])},n({wasm:o})}).catch(a)})}function SDe(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var IDe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],J0=null,Dg=null,Jg={},ey=!1,yA=!1;function kDe(e,t=!1){if(n4("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),ey)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");J0=e,yA=t}function TDe(e,t=!1){if(ey)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")Dg=e;else{Jg=e;let n=IDe.filter(a=>Jg[a]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}yA=t}var Oj=-1,Qk=-1;function EDe(e){Oj=e}function NDe(){if(Qk===-1)throw new Error("WASM backend not initialized.");return Qk}var CDe="4.22.0",ADe=2;a1("wasm",async()=>{let{wasm:e}=await _De();return new Mj(e)},ADe);var rO="4.22.0",RDe="4.22.0",DDe="4.22.0",$De="4.22.0",MDe="4.22.0",ODe={tfjs:rO,"tfjs-core":rO,"tfjs-converter":RDe,"tfjs-backend-cpu":DDe,"tfjs-backend-webgl":$De,"tfjs-backend-wasm":MDe},FDe={};k2(FDe,{AnchorPosition:()=>Yj,DrawBox:()=>eG,DrawBoxOptions:()=>Jj,DrawFaceLandmarks:()=>vG,DrawFaceLandmarksOptions:()=>bG,DrawTextField:()=>IA,DrawTextFieldOptions:()=>SA,drawContour:()=>el,drawDetections:()=>XDe,drawFaceExpressions:()=>l$e,drawFaceLandmarks:()=>c$e});function el(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:a,y:r},s)=>{let i=t[s];e.moveTo(i.x,i.y),e.lineTo(a,r)}),n){let a=t[t.length-1],r=t[0];if(!a||!r)return;e.moveTo(a.x,a.y),e.lineTo(r.x,r.y)}e.stroke()}var LDe={};k2(LDe,{computeReshapedDimensions:()=>Pj,getCenterPoint:()=>vA,isDimensions:()=>Zk,isEven:()=>Yk,isFloat:()=>zj,isTensor:()=>Gm,isTensor1D:()=>zDe,isTensor2D:()=>Lj,isTensor3D:()=>uv,isTensor4D:()=>xo,isValidNumber:()=>yc,isValidProbablitiy:()=>PDe,range:()=>of,round:()=>bA});var Np=class Fj{constructor(t,n){if(!yc(t)||!yc(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new Fj(1/this.width,1/this.height)}};function Gm(e,t){return e instanceof at&&e.shape.length===t}function zDe(e){return Gm(e,1)}function Lj(e){return Gm(e,2)}function uv(e){return Gm(e,3)}function xo(e){return Gm(e,4)}function zj(e){return e%1!==0}function Yk(e){return e%2===0}function bA(e,t=2){let n=10**t;return Math.floor(e*n)/n}function Zk(e){return e&&e.width&&e.height}function Pj({width:e,height:t},n){let a=n/Math.max(t,e);return new Np(Math.round(e*a),Math.round(t*a))}function vA(e){return e.reduce((t,n)=>t.add(n),new Kt(0,0)).div(new Kt(e.length,e.length))}function of(e,t,n){return Array(e).fill(0).map((a,r)=>t+r*n)}function yc(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function PDe(e){return yc(e)&&e>=0&&e<=1}var Kt=class Ju{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new Ju(this.x+t.x,this.y+t.y)}sub(t){return new Ju(this.x-t.x,this.y-t.y)}mul(t){return new Ju(this.x*t.x,this.y*t.y)}div(t){return new Ju(this.x/t.x,this.y/t.y)}abs(){return new Ju(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Ju(Math.floor(this.x),Math.floor(this.y))}},Wc=class Gs{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(yc)}static assertIsValidBox(t,n,a=!1){if(!Gs.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!a&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let a=t||{},r=[a.left,a.top,a.right,a.bottom].every(yc),s=[a.x,a.y,a.width,a.height].every(yc);if(!s&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(a)}`);let[i,o,l,c]=s?[a.x,a.y,a.width,a.height]:[a.left,a.top,a.right-a.left,a.bottom-a.top];Gs.assertIsValidBox({x:i,y:o,width:l,height:c},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=c}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Kt(this.left,this.top)}get topRight(){return new Kt(this.right,this.top)}get bottomLeft(){return new Kt(this.left,this.bottom)}get bottomRight(){return new Kt(this.right,this.bottom)}round(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new Gs({x:t,y:n,width:a,height:r})}floor(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new Gs({x:t,y:n,width:a,height:r})}toSquare(){let{x:t,y:n,width:a,height:r}=this,s=Math.abs(a-r);return a<r&&(t-=s/2,a+=s),r<a&&(n-=s/2,r+=s),new Gs({x:t,y:n,width:a,height:r})}rescale(t){let n=Zk(t)?t.width:t,a=Zk(t)?t.height:t;return new Gs({x:this.x*n,y:this.y*a,width:this.width*n,height:this.height*a})}pad(t,n){let[a,r,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new Gs({x:a,y:r,width:s,height:i})}clipAtImageBorders(t,n){let{x:a,y:r,right:s,bottom:i}=this,o=Math.max(a,0),l=Math.max(r,0),c=s-o,u=i-l,h=Math.min(c,t-o),d=Math.min(u,n-l);return new Gs({x:o,y:l,width:h,height:d}).floor()}shift(t,n){let{width:a,height:r}=this,s=this.x+t,i=this.y+n;return new Gs({x:s,y:i,width:a,height:r})}padAtBorders(t,n){let a=this.width+1,r=this.height+1,s=1,i=1,o=a,l=r,c=this.left,u=this.top,h=this.right,d=this.bottom;return h>n&&(o=-h+n+a,h=n),d>t&&(l=-d+t+r,d=t),c<1&&(l=2-c,c=1),u<1&&(l=2-u,u=1),{dy:i,edy:l,dx:s,edx:o,y:u,ey:d,x:c,ex:h,w:a,h:r}}calibrate(t){return new Gs({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},Vj=class extends Wc{constructor(e,t,n,a,r=!1){super({left:e,top:t,right:n,bottom:a},r)}},Bj=class Uj{constructor(t,n,a,r,s){this._imageDims=new Np(s.width,s.height),this._score=t,this._classScore=n,this._className=a,this._box=new Wc(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Wc(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new Uj(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},ti=class Wj extends Bj{constructor(t,n,a){super(t,t,"",n,a)}forSize(t,n){let{score:a,relativeBox:r,imageDims:s}=super.forSize(t,n);return new Wj(a,r,s)}};function VDe(e,t,n=!0){let a=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),r=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=a*r;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function BDe(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),a=t.reduce((o,l)=>l<o?l:o,1/0),r=n.reduce((o,l)=>l<o?l:o,1/0),s=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new Vj(a,r,s,i)}function UDe(e,t,n,a=!0){let r=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),s=[];for(;r.length>0;){let i=r.pop();s.push(i);let o=r,l=[];for(let c=0;c<o.length;c++){let u=o[c],h=e[i],d=e[u];l.push(VDe(h,d,a))}r=r.filter((c,u)=>l[u]<=n)}return s}function cv(e,t){return X(()=>{let[n,a,r]=t,s=Mr([...e.shape.slice(0,3),1],n,"float32"),i=Mr([...e.shape.slice(0,3),1],a,"float32"),o=Mr([...e.shape.slice(0,3),1],r,"float32"),l=Qt([s,i,o],3);return Ie(e,l)})}function WDe(e,t=!1){return X(()=>{let[n,a]=e.shape.slice(1);if(n===a)return e;let r=Math.abs(n-a),s=Math.round(r*(t?.5:1)),i=n>a?2:1,o=h=>{let d=e.shape.slice();return d[i]=h,Mr(d,0,"float32")},l=o(s),c=r-l.shape[i],u=[t&&c?o(c):null,e,l].filter(h=>!!h).map(h=>ye(h,"float32"));return Qt(u,i)})}function zS(e){return 1/(1+Math.exp(-e))}var jj=class extends Wc{constructor(e,t,n,a,r=!1){super({x:e,y:t,width:n,height:a},r)}},jDe=.5,GDe=.43,HDe=.45,ew=class{constructor(e,t,n=new Kt(0,0)){let{width:a,height:r}=t;this._imgDims=new Np(a,r),this._shift=n,this._positions=e.map(s=>s.mul(new Kt(a,r)).add(n))}get shift(){return new Kt(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new Kt(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Kt(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let r=e instanceof ti?e.box.floor():new Wc(e);return this.shiftBy(r.x,r.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:a}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(a)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,a]=e,r=u=>a.sub(u).magnitude(),s=(r(t)+r(n))/2,i=Math.floor(s/HDe),o=vA(e),l=Math.floor(Math.max(0,o.x-jDe*i)),c=Math.floor(Math.max(0,o.y-GDe*i));return new jj(l,c,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+c))}alignMinBbox(e){let t=BDe(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},Gj=class extends ew{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(vA)}};function tw(e){return e.detection instanceof ti}function Hj(e,t){return{...e,detection:t}}function qj(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function xA(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function Kj(e){let t="";if(!e&&xA())try{e=R7("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((a,r)=>{e.readFile(n,(s,i)=>s?r(s):a(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function Xj(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,a=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},r=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},s=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=Kj();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:a,createImageElement:r,createVideoElement:s,fetch:i,...o}}function Qj(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var ua;function qDe(){if(!ua)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return ua}function Jk(e){ua=e}function wA(){return Qj()?Jk(qj()):xA()?Jk(Xj()):null}function KDe(e){if(ua||wA(),!ua)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=ua.Canvas,Image:n=ua.Image}=e;ua.Canvas=t,ua.Image=n,ua.createCanvasElement=e.createCanvasElement||(()=>new t),ua.createImageElement=e.createImageElement||(()=>new n),ua.ImageData=e.ImageData||ua.ImageData,ua.Video=e.Video||ua.Video,ua.fetch=e.fetch||ua.fetch,ua.readFile=e.readFile||ua.readFile}var tr={getEnv:qDe,setEnv:Jk,initialize:wA,createBrowserEnv:qj,createFileSystem:Kj,createNodejsEnv:Xj,monkeyPatch:KDe,isBrowser:Qj,isNodejs:xA};wA();function _A(e){return!tr.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function eu(e){let{Canvas:t,CanvasRenderingContext2D:n}=tr.getEnv();if(e instanceof n)return e;let a=_A(e);if(!(a instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let r=a.getContext("2d",{willReadFrequently:!0});if(!r)throw new Error("resolveContext2d - canvas 2d context is null");return r}var Yj=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(Yj||{}),SA=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:a,fontSize:r,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=a||"rgba(255, 255, 255, 1)",this.fontSize=r||14,this.fontStyle=s||"Georgia",this.padding=i||4}},IA=class Zj{constructor(t,n,a={}){this.text=typeof t=="string"?[t]:t instanceof Zj?t.text:t,this.anchor=n,this.options=new SA(a)}measureWidth(t){let{padding:n}=this.options;return this.text.map(a=>t.measureText(a).width).reduce((a,r)=>a<r?r:a,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:a}=this.options,r=a==="BOTTOM_RIGHT"||a==="TOP_RIGHT",s=a==="BOTTOM_LEFT"||a==="BOTTOM_RIGHT",i=this.measureWidth(t),o=this.measureHeight(),l=r?this.anchor.x-i:this.anchor.x,c=s?this.anchor.y-o:this.anchor.y;if(n){let{width:u,height:h}=n,d=Math.max(Math.min(l,u-i),0),p=Math.max(Math.min(c,h-o),0);return{x:d,y:p}}return{x:l,y:c}}draw(t){let n=_A(t),a=eu(n),{backgroundColor:r,fontColor:s,fontSize:i,fontStyle:o,padding:l}=this.options;a.font=`${i}px ${o}`;let c=this.measureWidth(a),u=this.measureHeight();a.fillStyle=r;let h=this.getUpperLeft(a,n);a.fillRect(h.x,h.y,c,u),a.fillStyle=s,this.text.forEach((d,p)=>{let f=l+h.x,m=l+h.y+(p+1)*i;a.fillText(d,f,m)})}},Jj=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:a,drawLabelOptions:r}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=a;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new SA({...s,...r})}},eG=class{constructor(e,t={}){this.box=new Wc(e),this.options=new Jj(t)}draw(e){let t=eu(e),{boxColor:n,lineWidth:a}=this.options,{x:r,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=a,t.strokeRect(r,s,i,o);let{label:l}=this.options;l&&new IA([l],{x:r-a/2,y:s},this.options.drawLabelOptions).draw(e)}};function XDe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let a=n instanceof ti?n.score:tw(n)?n.detection.score:void 0,r=n instanceof ti?n.box:tw(n)?n.detection.box:new Wc(n),s=a?`${bA(a)}`:void 0;new eG(r,{label:s}).draw(e)})}function tG(e){let{Image:t,Video:n}=tr.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function QDe(e){return new Promise((t,n)=>{if(e instanceof tr.getEnv().Canvas||tG(e)){t(null);return}function a(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",r),s.currentTarget.removeEventListener("error",a),n(s))}function r(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",r),s.currentTarget.removeEventListener("error",a),t(s))}e.addEventListener("load",r),e.addEventListener("error",a)})}function YDe(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let a=new FileReader;a.onload=()=>{typeof a.result!="string"&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let r=tr.getEnv().createImageElement();r.onload=()=>t(r),r.onerror=n,r.src=a.result},a.onerror=n,a.readAsDataURL(e)})}function nG(e){let{Image:t,Video:n}=tr.getEnv();return e instanceof t?new Np(e.naturalWidth,e.naturalHeight):e instanceof n?new Np(e.videoWidth,e.videoHeight):new Np(e.width,e.height)}function nw({width:e,height:t}){let{createCanvasElement:n}=tr.getEnv(),a=n();return a.width=e,a.height=t,a}function aG(e,t){let{ImageData:n}=tr.getEnv();if(!(e instanceof n)&&!tG(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:a,height:r}=nG(e),s=nw({width:a,height:r});return e instanceof n?eu(s).putImageData(e,0,0):eu(s).drawImage(e,0,0,a,r),s}async function ZDe(e,t){let n=t||tr.getEnv().createCanvasElement(),[a,r,s]=e.shape.slice(xo(e)?1:0),i=X(()=>e.as3D(a,r,s).toInt());return await Xb.toPixels(i,n),i.dispose(),n}function sO(e){let{Image:t,Canvas:n,Video:a}=tr.getEnv();return e instanceof t||e instanceof n||e instanceof a}function JDe(e,t,n=!1){let{Image:a,Canvas:r}=tr.getEnv();if(!(e instanceof a||e instanceof r))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return nw({width:1,height:1});let s=nG(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,c=nw({width:t,height:t}),u=e instanceof r?e:aG(e),h=Math.abs(o-l)/2,d=n&&o<l?h:0,p=n&&l<o?h:0;return u.width>0&&u.height>0&&eu(c).drawImage(u,d,p,o,l),c}var aw=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,a)=>{if(uv(n)){this._imageTensors[a]=n,this._inputDimensions[a]=n.shape;return}if(xo(n)){let s=n.shape[0];if(s!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${s} passed, but not supported in input array`);this._imageTensors[a]=n,this._inputDimensions[a]=n.shape.slice(1);return}let r=n instanceof tr.getEnv().Canvas?n:aG(n);this._canvases[a]=r,this._inputDimensions[a]=[r.height,r.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return of(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return Pj({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,X(()=>{let n=of(this.batchSize,0,1).map(a=>{let r=this.getInput(a);if(r instanceof at){let s=xo(r)?r:pa(r);return s=WDe(s,t),(s.shape[1]!==e||s.shape[2]!==e)&&(s=Yr.resizeBilinear(s,[e,e],!1,!1)),s.as3D(e,e,3)}if(r instanceof tr.getEnv().Canvas)return Xb.fromPixels(JDe(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${a}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)});return Bn(n.map(a=>ye(a,"float32"))).as4D(this.batchSize,e,e,3)})}};async function nr(e){if(e instanceof aw)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=r=>Array.isArray(e)?` at input index ${r}:`:"",a=t.map(_A);return a.forEach((r,s)=>{if(!sO(r)&&!uv(r)&&!xo(r))throw typeof t[s]=="string"?new Error(`toNetInput -${n(s)} string passed, but could not resolve HTMLElement for element id ${t[s]}`):new Error(`toNetInput -${n(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(xo(r)){let i=r.shape[0];if(i!==1)throw new Error(`toNetInput -${n(s)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(a.map(r=>sO(r)&&QDe(r))),new aw(a,Array.isArray(e))}async function kA(e,t){let{Canvas:n}=tr.getEnv(),a=e;if(!(e instanceof n)){let s=await nr(e);if(s.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=s.getInput(0);a=i instanceof n?i:await ZDe(i)}let r=eu(a);return t.map(s=>s instanceof ti?s.forSize(a.width,a.height).box.floor():s).map(s=>s.clipAtImageBorders(a.width,a.height)).map(({x:s,y:i,width:o,height:l})=>{let c=nw({width:o,height:l});return o>0&&l>0&&eu(c).putImageData(r.getImageData(s,i,o,l),0,0),c})}async function TA(e,t){if(!uv(e)&&!xo(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(xo(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return X(()=>{let[n,a,r]=e.shape.slice(xo(e)?1:0);return t.map(s=>s instanceof ti?s.forSize(a,n).box:s).map(s=>s.clipAtImageBorders(a,n)).filter(s=>s.width>0&&s.height>0).map(({x:s,y:i,width:o,height:l})=>Rm(e.as3D(n,a,r),[i,s,0],[l,o,r]))})}async function rG(e,t){let{fetch:n}=tr.getEnv(),a=await n(e,t);if(!(a.status<400))throw new Error(`failed to fetch: (${a.status}) ${a.statusText}, from url: ${a.url}`);return a}async function sG(e){let t=await rG(e),n=await t.blob();if(!n.type.startsWith("image/"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return YDe(n)}async function e$e(e){return(await rG(e)).json()}function iG(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let a=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(a,"");let r=e.split("/").filter(o=>o),s=e.endsWith(".json")?r[r.length-1]:n,i=a+(e.endsWith(".json")?r.slice(0,r.length-1):r).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${s}`:`${i}/${s}`}}async function t$e(e,t){let{manifestUri:n,modelBaseUri:a}=iG(e,t),r=await e$e(n);return Ca.loadWeights(r,a)}var Iu=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:a}=this.traversePropertyPath(e);n[a].dispose(),n[a]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Ec)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Ec))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=Za(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await t$e(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=tr.getEnv(),{manifestUri:n,modelBaseUri:a}=iG(e,this.getDefaultModelName()),r=l=>Promise.all(l.map(c=>t(c).then(u=>typeof u=="string"?Buffer.from(u):u.buffer))),s=Ca.weightsLoaderFactory(r),i=JSON.parse((await t(n)).toString()),o=await s(i,a);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((r,s)=>{if(!r.nextObj.hasOwnProperty(s))throw new Error(`traversePropertyPath - object does not have property ${s}, for path ${e}`);return{obj:r.nextObj,objProp:s,nextObj:r.nextObj[s]}},{nextObj:this.params}),{obj:n,objProp:a}=t;if(!n||!a||!(n[a]instanceof at))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:a}}};function es(e,t,n){return X(()=>{let a=Am(e,t.depthwise_filter,t.pointwise_filter,n,"same");return a=re(a,t.bias),a})}function PS(e,t,n=!1){return X(()=>{let a=Bt(n?re(Ja(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):es(e,t.conv0,[2,2])),r=es(a,t.conv1,[1,1]),s=Bt(re(a,r)),i=es(s,t.conv2,[1,1]);return Bt(re(a,re(r,i)))})}function hx(e,t,n=!1,a=!0){return X(()=>{let r=Bt(n?re(Ja(e,t.conv0.filters,a?[2,2]:[1,1],"same"),t.conv0.bias):es(e,t.conv0,a?[2,2]:[1,1])),s=es(r,t.conv1,[1,1]),i=Bt(re(r,s)),o=es(i,t.conv2,[1,1]),l=Bt(re(r,re(s,o))),c=es(l,t.conv3,[1,1]);return Bt(re(r,re(s,re(o,c))))})}function ty(e,t,n="same",a=!1){return X(()=>{let r=re(Ja(e,t.filters,[1,1],n),t.bias);return a?Bt(r):r})}function ku(e,t){Object.keys(e).forEach(n=>{t.some(a=>a.originalPath===n)||e[n].dispose()})}function EA(e,t){return(n,a,r,s)=>{let i=ql(e(n*a*r*r),[r,r,n,a]),o=Ft(e(a));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function oG(e,t){return(n,a,r)=>{let s=Ai(e(n*a),[n,a]),i=Ft(e(a));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/bias`}),{weights:s,bias:i}}}var lG=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function NA(e,t){return(n,a,r)=>{let s=ql(e(9*n),[3,3,n,1]),i=ql(e(n*a),[1,1,n,a]),o=Ft(e(a));return t.push({paramPath:`${r}/depthwise_filter`},{paramPath:`${r}/pointwise_filter`},{paramPath:`${r}/bias`}),new lG(s,i,o)}}function CA(e){return t=>{let n=e(`${t}/depthwise_filter`,4),a=e(`${t}/pointwise_filter`,4),r=e(`${t}/bias`,1);return new lG(n,a,r)}}function Ed(e,t){return(n,a,r)=>{let s=e[n];if(!Gm(s,a))throw new Error(`expected weightMap[${n}] to be a Tensor${a}D, instead have ${s}`);return t.push({originalPath:n,paramPath:r||n}),s}}function Tu(e){let t=e;function n(r){let s=t.slice(0,r);return t=t.slice(r),s}function a(){return t}return{extractWeights:n,getRemainingWeights:a}}function uG(e,t){let n=EA(e,t),a=NA(e,t);function r(i,o,l,c=!1){let u=c?n(i,o,3,`${l}/conv0`):a(i,o,`${l}/conv0`),h=a(o,o,`${l}/conv1`),d=a(o,o,`${l}/conv2`);return{conv0:u,conv1:h,conv2:d}}function s(i,o,l,c=!1){let{conv0:u,conv1:h,conv2:d}=r(i,o,l,c),p=a(o,o,`${l}/conv3`);return{conv0:u,conv1:h,conv2:d,conv3:p}}return{extractDenseBlock3Params:r,extractDenseBlock4Params:s}}function n$e(e){let t=[],{extractWeights:n,getRemainingWeights:a}=Tu(e),{extractDenseBlock4Params:r}=uG(n,t),s=r(3,32,"dense0",!0),i=r(32,64,"dense1"),o=r(64,128,"dense2"),l=r(128,256,"dense3");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function cG(e){return t=>{let n=e(`${t}/filters`,4),a=e(`${t}/bias`,1);return{filters:n,bias:a}}}function hG(e,t){let n=Ed(e,t),a=cG(n),r=CA(n);function s(o,l=!1){let c=l?a(`${o}/conv0`):r(`${o}/conv0`),u=r(`${o}/conv1`),h=r(`${o}/conv2`);return{conv0:c,conv1:u,conv2:h}}function i(o,l=!1){let c=l?a(`${o}/conv0`):r(`${o}/conv0`),u=r(`${o}/conv1`),h=r(`${o}/conv2`),d=r(`${o}/conv3`);return{conv0:c,conv1:u,conv2:h,conv3:d}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function a$e(e){let t=[],{extractDenseBlock4Params:n}=hG(e,t),a={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return ku(e,t),{params:a,paramMappings:t}}var dG=class extends Iu{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return X(()=>{let n=ye(e.toBatchTensor(112,!0),"float32"),a=cv(n,[122.782,117.001,104.298]).div(255),r=hx(a,t.dense0,!0);return r=hx(r,t.dense1),r=hx(r,t.dense2),r=hx(r,t.dense3),r=Oo(r,[7,7],[2,2],"valid"),r})}async forward(e){return this.forwardInput(await nr(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return a$e(e)}extractParams(e){return n$e(e)}};function eT(e,t){return X(()=>re(ot(e,t.weights),t.bias))}function r$e(e,t,n){let a=[],{extractWeights:r,getRemainingWeights:s}=Tu(e),i=oG(r,a)(t,n,"fc");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:a,params:{fc:i}}}function s$e(e){let t=[],n=Ed(e,t);function a(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:a("fc")};return ku(e,t),{params:r,paramMappings:t}}function pG(e){let t={},n={};return Object.keys(e).forEach(a=>{let r=a.startsWith("fc")?n:t;r[a]=e[a]}),{featureExtractorMap:t,classifierMap:n}}var fG=class extends Iu{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return X(()=>{let n=e instanceof aw?this.faceFeatureExtractor.forwardInput(e):e;return eT(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return r$e(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=pG(e);return this.faceFeatureExtractor.loadFromWeightMap(t),s$e(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),a=n*t+n,r=e.slice(0,e.length-a),s=e.slice(e.length-a);return this.faceFeatureExtractor.extractWeights(r),this.extractClassifierParams(s)}},iO=["neutral","happy","sad","angry","fearful","disgusted","surprised"],AA=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);iO.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return iO.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},i$e=class extends fG{constructor(e=new dG){super("FaceExpressionNet",e)}forwardInput(e){return X(()=>bu(this.runNet(e)))}async forward(e){return this.forwardInput(await nr(e))}async predictExpressions(e){let t=await nr(e),n=await this.forwardInput(t),a=await Promise.all(Tn(n).map(async s=>{let i=s.dataSync();return s.dispose(),i}));n.dispose();let r=a.map(s=>new AA(s));return t.isBatchInput?r:r[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function o$e(e){return e.expressions instanceof AA}function mG(e,t){return{...e,expressions:t}}function l$e(e,t,n=.1,a){(Array.isArray(t)?t:[t]).forEach(r=>{let s=r instanceof AA?r:o$e(r)?r.expressions:void 0;if(!s)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=s.asSortedArray().filter(l=>l.probability>n),o=tw(r)?r.detection.box.bottomLeft:a||new Kt(0,0);new IA(i.map(l=>`${l.expression} (${bA(l.probability)})`),o).draw(e)})}function gG(e){return tw(e)&&e.landmarks instanceof ew&&e.unshiftedLandmarks instanceof ew&&e.alignedRect instanceof ti}function u$e(e){let t=l=>l*180/Math.PI,n=(l,c)=>Math.sqrt((l.x-c.x)**2+(l.y-c.y)**2),a={roll:void 0,pitch:void 0,yaw:void 0},r=(l,c,u)=>{let h=Math.floor(l.x-c.x),d=Math.floor(c.x-u.x);return h-d},s=(l,c)=>{let u=Math.hypot(c.x-l.x,c.y-l.y),h=c.y-l.y,d=Math.asin(h/u),p=t(d),f=Math.floor(90-p),m=c.x-l.x<0?-1:1;return f*m},i=(l,c,u)=>{let h=n(l,u),d=new Kt((l.x+u.x)/2,(l.y+u.y)/2),p=n(c,d),f=Math.atan(p/h),m=Math.floor(t(f)),g=d.y-c.y<0?-1:1;return m*g};if(!e||!e.positions||e.positions.length!==68)return a;let o=e.positions;return a.roll=s(o[27],o[66]),a.pitch=i(o[14],o[30],o[2]),a.yaw=r(o[14],o[33],o[2]),a}function yG(e,t){let{box:n}=e.detection,a=t.shiftBy(n.x,n.y),r=a.align(),{imageDims:s}=e.detection,i=new ti(e.detection.score,r.rescale(s.reverse()),s),o=u$e(t);return{...e,landmarks:a,unshiftedLandmarks:t,alignedRect:i,angle:o}}var bG=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:a,lineColor:r,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=a||1,this.pointSize=s||2,this.lineColor=r||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},vG=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new bG(t)}draw(e){let t=eu(e),{drawLines:n,drawPoints:a,lineWidth:r,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof Gj&&(t.strokeStyle=s,t.lineWidth=r,el(t,this.faceLandmarks.getJawOutline()),el(t,this.faceLandmarks.getLeftEyeBrow()),el(t,this.faceLandmarks.getRightEyeBrow()),el(t,this.faceLandmarks.getNose()),el(t,this.faceLandmarks.getLeftEye(),!0),el(t,this.faceLandmarks.getRightEye(),!0),el(t,this.faceLandmarks.getMouth(),!0)),a){t.strokeStyle=o,t.fillStyle=o;let l=c=>{t.beginPath(),t.arc(c.x,c.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(l)}}};function c$e(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let a=n instanceof ew?n:gG(n)?n.landmarks:void 0;if(!a)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new vG(a).draw(e)})}function h$e(e,t){let n=EA(e,t),a=NA(e,t);function r(i,o,l){let c=a(i,o,`${l}/separable_conv0`),u=a(o,o,`${l}/separable_conv1`),h=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:c,separable_conv1:u,expansion_conv:h}}function s(i,o){let l=a(i,i,`${o}/separable_conv0`),c=a(i,i,`${o}/separable_conv1`),u=a(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:c,separable_conv2:u}}return{extractConvParams:n,extractSeparableConvParams:a,extractReductionBlockParams:r,extractMainBlockParams:s}}function d$e(e,t){let n=[],{extractWeights:a,getRemainingWeights:r}=Tu(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=h$e(a,n),c=s(3,32,3,"entry_flow/conv_in"),u=o(32,64,"entry_flow/reduction_block_0"),h=o(64,128,"entry_flow/reduction_block_1"),d={conv_in:c,reduction_block_0:u,reduction_block_1:h},p={};of(t,0,1).forEach(y=>{p[`main_block_${y}`]=l(128,`middle_flow/main_block_${y}`)});let f=o(128,256,"exit_flow/reduction_block"),m=i(256,512,"exit_flow/separable_conv"),g={reduction_block:f,separable_conv:m};if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:n,params:{entry_flow:d,middle_flow:p,exit_flow:g}}}function p$e(e,t){let n=Ed(e,t),a=cG(n),r=CA(n);function s(o){let l=r(`${o}/separable_conv0`),c=r(`${o}/separable_conv1`),u=a(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:c,expansion_conv:u}}function i(o){let l=r(`${o}/separable_conv0`),c=r(`${o}/separable_conv1`),u=r(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:c,separable_conv2:u}}return{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}}function f$e(e,t){let n=[],{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}=p$e(e,n),o=a("entry_flow/conv_in"),l=s("entry_flow/reduction_block_0"),c=s("entry_flow/reduction_block_1"),u={conv_in:o,reduction_block_0:l,reduction_block_1:c},h={};of(t,0,1).forEach(m=>{h[`main_block_${m}`]=i(`middle_flow/main_block_${m}`)});let d=s("exit_flow/reduction_block"),p=r("exit_flow/separable_conv"),f={reduction_block:d,separable_conv:p};return ku(e,n),{params:{entry_flow:u,middle_flow:h,exit_flow:f},paramMappings:n}}function xG(e,t,n){return re(Ja(e,t.filters,n,"same"),t.bias)}function VS(e,t,n=!0){let a=n?Bt(e):e;return a=es(a,t.separable_conv0,[1,1]),a=es(Bt(a),t.separable_conv1,[1,1]),a=ca(a,[3,3],[2,2],"same"),a=re(a,xG(e,t.expansion_conv,[2,2])),a}function m$e(e,t){let n=es(Bt(e),t.separable_conv0,[1,1]);return n=es(Bt(n),t.separable_conv1,[1,1]),n=es(Bt(n),t.separable_conv2,[1,1]),n=re(n,e),n}var g$e=class extends Iu{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return X(()=>{let n=ye(e.toBatchTensor(112,!0),"float32"),a=cv(n,[122.782,117.001,104.298]).div(255),r=Bt(xG(a,t.entry_flow.conv_in,[2,2]));return r=VS(r,t.entry_flow.reduction_block_0,!1),r=VS(r,t.entry_flow.reduction_block_1),of(this._numMainBlocks,0,1).forEach(s=>{r=m$e(r,t.middle_flow[`main_block_${s}`])}),r=VS(r,t.exit_flow.reduction_block),r=Bt(es(r,t.exit_flow.separable_conv,[1,1])),r})}async forward(e){return this.forwardInput(await nr(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return f$e(e,this._numMainBlocks)}extractParams(e){return d$e(e,this._numMainBlocks)}};function y$e(e){let t=[],{extractWeights:n,getRemainingWeights:a}=Tu(e),r=oG(n,t),s=r(512,1,"fc/age"),i=r(512,2,"fc/gender");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function b$e(e){let t=[],n=Ed(e,t);function a(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:{age:a("fc/age"),gender:a("fc/gender")}};return ku(e,t),{params:r,paramMappings:t}}var v$e=(e=>(e.FEMALE="female",e.MALE="male",e))(v$e||{}),x$e=class extends Iu{constructor(e=new g$e(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return X(()=>{let n=e instanceof aw?this.faceFeatureExtractor.forwardInput(e):e,a=Oo(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),r=eT(a,t.fc.age).as1D(),s=eT(a,t.fc.gender);return{age:r,gender:s}})}forwardInput(e){return X(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:bu(n)}})}async forward(e){return this.forwardInput(await nr(e))}async predictAgeAndGender(e){let t=await nr(e),n=await this.forwardInput(t),a=Tn(n.age),r=Tn(n.gender),s=a.map((o,l)=>({ageTensor:o,genderTensor:r[l]})),i=await Promise.all(s.map(async({ageTensor:o,genderTensor:l})=>{let c=o.dataSync()[0],u=l.dataSync()[0],h=u>.5,d=h?"male":"female",p=h?u:1-u;return o.dispose(),l.dispose(),{age:c,gender:d,genderProbability:p}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return y$e(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=pG(e);return this.faceFeatureExtractor.loadFromWeightMap(t),b$e(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},wG=class extends fG{postProcess(e,t,n){let a=n.map(({width:s,height:i})=>{let o=t/Math.max(i,s);return{width:s*o,height:i*o}}),r=a.length;return X(()=>{let s=(c,u)=>Bn([Mr([68],c,"float32"),Mr([68],u,"float32")],1).as2D(1,136).as1D(),i=(c,u)=>{let{width:h,height:d}=a[c];return u(h,d)?Math.abs(h-d)/2:0},o=c=>i(c,(u,h)=>u<h),l=c=>i(c,(u,h)=>h<u);return e.mul(Mr([r,136],t,"float32")).sub(Bn(Array.from(Array(r),(c,u)=>s(o(u),l(u))))).div(Bn(Array.from(Array(r),(c,u)=>s(a[u].width,a[u].height))))})}forwardInput(e){return X(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,a])=>({height:n,width:a})))})}async forward(e){return this.forwardInput(await nr(e))}async detectLandmarks(e){let t=await nr(e),n=X(()=>Tn(this.forwardInput(t))),a=await Promise.all(n.map(async(r,s)=>{let i=Array.from(r.dataSync()),o=i.filter((c,u)=>Yk(u)),l=i.filter((c,u)=>!Yk(u));return new Gj(Array(68).fill(0).map((c,u)=>new Kt(o[u],l[u])),{height:t.getInputHeight(s),width:t.getInputWidth(s)})}));return n.forEach(r=>r.dispose()),t.isBatchInput?a:a[0]}getClassifierChannelsOut(){return 136}},w$e=class extends wG{constructor(e=new dG){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function _$e(e){let t=[],{extractDenseBlock3Params:n}=hG(e,t),a={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return ku(e,t),{params:a,paramMappings:t}}function S$e(e){let t=[],{extractWeights:n,getRemainingWeights:a}=Tu(e),{extractDenseBlock3Params:r}=uG(n,t),s=r(3,32,"dense0",!0),i=r(32,64,"dense1"),o=r(64,128,"dense2");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var I$e=class extends Iu{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return X(()=>{let n=ye(e.toBatchTensor(112,!0),"float32"),a=cv(n,[122.782,117.001,104.298]).div(255),r=PS(a,t.dense0,!0);return r=PS(r,t.dense1),r=PS(r,t.dense2),r=Oo(r,[14,14],[2,2],"valid"),r})}async forward(e){return this.forwardInput(await nr(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return _$e(e)}extractParams(e){return S$e(e)}},k$e=class extends wG{constructor(e=new I$e){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function T$e(e,t){return re(G(e,t.weights),t.biases)}function RA(e,t,n,a,r="same"){let{filters:s,bias:i}=t.conv,o=Ja(e,s,n,r);return o=re(o,i),o=T$e(o,t.scale),a?Bt(o):o}function E$e(e,t){return RA(e,t,[1,1],!0)}function _G(e,t){return RA(e,t,[1,1],!1)}function SG(e,t){return RA(e,t,[2,2],!0,"valid")}function N$e(e,t){function n(o,l,c){let u=e(o),h=u.length/(l*c*c);if(zj(h))throw new Error(`depth has to be an integer: ${h}, weights.length: ${u.length}, numFilters: ${l}, filterSize: ${c}`);return X(()=>lt(ql(u,[l,h,c,c]),[2,3,1,0]))}function a(o,l,c,u){let h=n(o,l,c),d=Ft(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/bias`}),{filters:h,bias:d}}function r(o,l){let c=Ft(e(o)),u=Ft(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:c,biases:u}}function s(o,l,c,u){let h=a(o,l,c,`${u}/conv`),d=r(l,`${u}/scale`);return{conv:h,scale:d}}function i(o,l,c,u,h=!1){let d=s((h?.5:1)*o,l,c,`${u}/conv1`),p=s(o,l,c,`${u}/conv2`);return{conv1:d,conv2:p}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function C$e(e){let{extractWeights:t,getRemainingWeights:n}=Tu(e),a=[],{extractConvLayerParams:r,extractResidualLayerParams:s}=N$e(t,a),i=r(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),c=s(9216,32,3,"conv32_3"),u=s(36864,64,3,"conv64_down",!0),h=s(36864,64,3,"conv64_1"),d=s(36864,64,3,"conv64_2"),p=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),v=s(589824,256,3,"conv256_1"),x=s(589824,256,3,"conv256_2"),w=s(589824,256,3,"conv256_down_out"),k=X(()=>lt(Ai(t(256*128),[128,256]),[1,0]));if(a.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:c,conv64_down:u,conv64_1:h,conv64_2:d,conv64_3:p,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:v,conv256_2:x,conv256_down_out:w,fc:k},paramMappings:a}}function A$e(e,t){let n=Ed(e,t);function a(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function r(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),c=a(i);return{conv:{filters:o,bias:l},scale:c}}function s(i){return{conv1:r(`${i}/conv1`),conv2:r(`${i}/conv2`)}}return{extractConvLayerParams:r,extractResidualLayerParams:s}}function R$e(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:a}=A$e(e,t),r=n("conv32_down"),s=a("conv32_1"),i=a("conv32_2"),o=a("conv32_3"),l=a("conv64_down"),c=a("conv64_1"),u=a("conv64_2"),h=a("conv64_3"),d=a("conv128_down"),p=a("conv128_1"),f=a("conv128_2"),m=a("conv256_down"),g=a("conv256_1"),y=a("conv256_2"),v=a("conv256_down_out"),{fc:x}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!Lj(x))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${x}`);let w={conv32_down:r,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:c,conv64_2:u,conv64_3:h,conv128_down:d,conv128_1:p,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:v,fc:x};return ku(e,t),{params:w,paramMappings:t}}function pi(e,t){let n=E$e(e,t.conv1);return n=_G(n,t.conv2),n=re(n,e),n=Bt(n),n}function dx(e,t){let n=SG(e,t.conv1);n=_G(n,t.conv2);let a=Oo(e,2,2,"valid"),r=_n(a.shape),s=a.shape[3]!==n.shape[3];if(a.shape[1]!==n.shape[1]||a.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=_n(i);n=Qt([n,o],1);let l=[...n.shape];l[2]=1;let c=_n(l);n=Qt([n,c],2)}return a=s?Qt([a,r],3):a,n=re(a,n),n=Bt(n),n}var D$e=class extends Iu{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return X(()=>{let n=ye(e.toBatchTensor(150,!0),"float32"),a=cv(n,[122.782,117.001,104.298]).div(255),r=SG(a,t.conv32_down);r=ca(r,3,2,"valid"),r=pi(r,t.conv32_1),r=pi(r,t.conv32_2),r=pi(r,t.conv32_3),r=dx(r,t.conv64_down),r=pi(r,t.conv64_1),r=pi(r,t.conv64_2),r=pi(r,t.conv64_3),r=dx(r,t.conv128_down),r=pi(r,t.conv128_1),r=pi(r,t.conv128_2),r=dx(r,t.conv256_down),r=pi(r,t.conv256_1),r=pi(r,t.conv256_2),r=dx(r,t.conv256_down_out);let s=r.mean([1,2]);return ot(s,t.fc)})}async forward(e){return this.forwardInput(await nr(e))}async computeFaceDescriptor(e){var t;if((t=e==null?void 0:e.shape)!=null&&t.some(s=>s<=0))return new Float32Array(128);let n=await nr(e),a=X(()=>Tn(this.forwardInput(n))),r=await Promise.all(a.map(s=>s.data()));return a.forEach(s=>s.dispose()),n.isBatchInput?r:r[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return R$e(e)}extractParams(e){return C$e(e)}};function IG(e,t){return{...e,descriptor:t}}function kG(e,t){return{...e,age:t}}function TG(e,t,n){return{...e,gender:t,genderProbability:n}}function $$e(e,t){function n(l,c){let u=ql(e(9*l),[3,3,l,1]),h=Ft(e(l)),d=Ft(e(l)),p=Ft(e(l)),f=Ft(e(l));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/batch_norm_scale`},{paramPath:`${c}/batch_norm_offset`},{paramPath:`${c}/batch_norm_mean`},{paramPath:`${c}/batch_norm_variance`}),{filters:u,batch_norm_scale:h,batch_norm_offset:d,batch_norm_mean:p,batch_norm_variance:f}}function a(l,c,u,h,d){let p=ql(e(l*c*u*u),[u,u,l,c]),f=Ft(e(c));return t.push({paramPath:`${h}/filters`},{paramPath:`${h}/${d?"batch_norm_offset":"bias"}`}),{filters:p,bias:f}}function r(l,c,u,h){let{filters:d,bias:p}=a(l,c,u,h,!0);return{filters:d,batch_norm_offset:p}}function s(l,c,u){let h=n(l,`${u}/depthwise_conv`),d=r(l,c,1,`${u}/pointwise_conv`);return{depthwise_conv:h,pointwise_conv:d}}function i(){let l=r(3,32,3,"mobilenetv1/conv_0"),c=s(32,64,"mobilenetv1/conv_1"),u=s(64,128,"mobilenetv1/conv_2"),h=s(128,128,"mobilenetv1/conv_3"),d=s(128,256,"mobilenetv1/conv_4"),p=s(256,256,"mobilenetv1/conv_5"),f=s(256,512,"mobilenetv1/conv_6"),m=s(512,512,"mobilenetv1/conv_7"),g=s(512,512,"mobilenetv1/conv_8"),y=s(512,512,"mobilenetv1/conv_9"),v=s(512,512,"mobilenetv1/conv_10"),x=s(512,512,"mobilenetv1/conv_11"),w=s(512,1024,"mobilenetv1/conv_12"),k=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:c,conv_2:u,conv_3:h,conv_4:d,conv_5:p,conv_6:f,conv_7:m,conv_8:g,conv_9:y,conv_10:v,conv_11:x,conv_12:w,conv_13:k}}function o(){let l=r(1024,256,1,"prediction_layer/conv_0"),c=r(256,512,3,"prediction_layer/conv_1"),u=r(512,128,1,"prediction_layer/conv_2"),h=r(128,256,3,"prediction_layer/conv_3"),d=r(256,128,1,"prediction_layer/conv_4"),p=r(128,256,3,"prediction_layer/conv_5"),f=r(256,64,1,"prediction_layer/conv_6"),m=r(64,128,3,"prediction_layer/conv_7"),g=a(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),y=a(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),v=a(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),x=a(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),w=a(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),k=a(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),M=a(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),S=a(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),I=a(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),E=a(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),R=a(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),A=a(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:c,conv_2:u,conv_3:h,conv_4:d,conv_5:p,conv_6:f,conv_7:m,box_predictor_0:{box_encoding_predictor:g,class_predictor:y},box_predictor_1:{box_encoding_predictor:v,class_predictor:x},box_predictor_2:{box_encoding_predictor:w,class_predictor:k},box_predictor_3:{box_encoding_predictor:M,class_predictor:S},box_predictor_4:{box_encoding_predictor:I,class_predictor:E},box_predictor_5:{box_encoding_predictor:R,class_predictor:A}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function M$e(e){let t=[],{extractWeights:n,getRemainingWeights:a}=Tu(e),{extractMobilenetV1Params:r,extractPredictionLayerParams:s}=$$e(n,t),i=r(),o=s(),l={extra_dim:T1(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function O$e(e,t){let n=Ed(e,t);function a(c,u,h){let d=n(`${c}/Conv2d_${u}_pointwise/weights`,4,`${h}/filters`),p=n(`${c}/Conv2d_${u}_pointwise/convolution_bn_offset`,1,`${h}/batch_norm_offset`);return{filters:d,batch_norm_offset:p}}function r(c){let u=`mobilenetv1/conv_${c}`,h=`MobilenetV1/Conv2d_${c}_depthwise`,d=`${u}/depthwise_conv`,p=`${u}/pointwise_conv`,f=n(`${h}/depthwise_weights`,4,`${d}/filters`),m=n(`${h}/BatchNorm/gamma`,1,`${d}/batch_norm_scale`),g=n(`${h}/BatchNorm/beta`,1,`${d}/batch_norm_offset`),y=n(`${h}/BatchNorm/moving_mean`,1,`${d}/batch_norm_mean`),v=n(`${h}/BatchNorm/moving_variance`,1,`${d}/batch_norm_variance`);return{depthwise_conv:{filters:f,batch_norm_scale:m,batch_norm_offset:g,batch_norm_mean:y,batch_norm_variance:v},pointwise_conv:a("MobilenetV1",c,p)}}function s(){return{conv_0:a("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:r(1),conv_2:r(2),conv_3:r(3),conv_4:r(4),conv_5:r(5),conv_6:r(6),conv_7:r(7),conv_8:r(8),conv_9:r(9),conv_10:r(10),conv_11:r(11),conv_12:r(12),conv_13:r(13)}}function i(c,u){let h=n(`${c}/weights`,4,`${u}/filters`),d=n(`${c}/biases`,1,`${u}/bias`);return{filters:h,bias:d}}function o(c){let u=i(`Prediction/BoxPredictor_${c}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${c}/box_encoding_predictor`),h=i(`Prediction/BoxPredictor_${c}/ClassPredictor`,`prediction_layer/box_predictor_${c}/class_predictor`);return{box_encoding_predictor:u,class_predictor:h}}function l(){return{conv_0:a("Prediction",0,"prediction_layer/conv_0"),conv_1:a("Prediction",1,"prediction_layer/conv_1"),conv_2:a("Prediction",2,"prediction_layer/conv_2"),conv_3:a("Prediction",3,"prediction_layer/conv_3"),conv_4:a("Prediction",4,"prediction_layer/conv_4"),conv_5:a("Prediction",5,"prediction_layer/conv_5"),conv_6:a("Prediction",6,"prediction_layer/conv_6"),conv_7:a("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function F$e(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:a}=O$e(e,t),r=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!uv(r))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${r}`);let s={mobilenetv1:n(),prediction_layer:a(),output_layer:{extra_dim:r}};return ku(e,t),{params:s,paramMappings:t}}function gi(e,t,n){return X(()=>{let a=Ja(e,t.filters,n,"same");return a=re(a,t.batch_norm_offset),Va(a,0,6)})}var L$e=.0010000000474974513;function z$e(e,t,n){return X(()=>{let a=yd(e,t.filters,n,"same");return a=gd(a,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,L$e),Va(a,0,6)})}function P$e(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function V$e(e,t){return X(()=>{let n,a=gi(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((r,s)=>{let i=s+1,o=P$e(i);a=z$e(a,r.depthwise_conv,o),a=gi(a,r.pointwise_conv,[1,1]),i===11&&(n=a)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:a,conv11:n}})}function B$e(e,t,n){let a=e.arraySync(),r=Math.min(a[t][0],a[t][2]),s=Math.min(a[t][1],a[t][3]),i=Math.max(a[t][0],a[t][2]),o=Math.max(a[t][1],a[t][3]),l=Math.min(a[n][0],a[n][2]),c=Math.min(a[n][1],a[n][3]),u=Math.max(a[n][0],a[n][2]),h=Math.max(a[n][1],a[n][3]),d=(i-r)*(o-s),p=(u-l)*(h-c);if(d<=0||p<=0)return 0;let f=Math.max(r,l),m=Math.max(s,c),g=Math.min(i,u),y=Math.min(o,h),v=Math.max(g-f,0)*Math.max(y-m,0);return v/(d+p-v)}function U$e(e,t,n,a,r){let s=e.shape[0],i=Math.min(n,s),o=t.map((u,h)=>({score:u,boxIndex:h})).filter(u=>u.score>r).sort((u,h)=>h.score-u.score),l=u=>u<=a?1:0,c=[];return o.forEach(u=>{if(c.length>=i)return;let h=u.score;for(let d=c.length-1;d>=0;--d){let p=B$e(e,u.boxIndex,c[d]);if(p!==0&&(u.score*=l(p),u.score<=r))break}h===u.score&&c.push(u.boxIndex)}),c}function W$e(e){let t=Tn(lt(e,[1,0])),n=[Ie(t[2],t[0]),Ie(t[3],t[1])],a=[re(t[0],Ce(n[0],2)),re(t[1],Ce(n[1],2))];return{sizes:n,centers:a}}function j$e(e,t){let{sizes:n,centers:a}=W$e(e),r=Tn(lt(t,[1,0])),s=Ce(G(Ba(Ce(r[2],5)),n[0]),2),i=re(G(Ce(r[0],10),n[0]),a[0]),o=Ce(G(Ba(Ce(r[3],5)),n[1]),2),l=re(G(Ce(r[1],10),n[1]),a[1]);return lt(Bn([Ie(i,s),Ie(l,o),re(i,s),re(l,o)]),[1,0])}function G$e(e,t,n){return X(()=>{let a=e.shape[0],r=j$e(K(Dr(n.extra_dim,[a,1,1]),[-1,4]),K(e,[-1,4]));r=K(r,[a,r.shape[0]/a,4]);let s=Rs(vt(t,[0,0,1],[-1,-1,-1])),i=vt(s,[0,0,0],[-1,-1,1]);i=K(i,[a,i.shape[1]]);let o=Tn(r),l=Tn(i);return{boxes:o,scores:l}})}function Hd(e,t){return X(()=>{let n=e.shape[0],a=K(ty(e,t.box_encoding_predictor),[n,-1,1,4]),r=K(ty(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:a,classPrediction:r}})}function H$e(e,t,n){return X(()=>{let a=gi(e,n.conv_0,[1,1]),r=gi(a,n.conv_1,[2,2]),s=gi(r,n.conv_2,[1,1]),i=gi(s,n.conv_3,[2,2]),o=gi(i,n.conv_4,[1,1]),l=gi(o,n.conv_5,[2,2]),c=gi(l,n.conv_6,[1,1]),u=gi(c,n.conv_7,[2,2]),h=Hd(t,n.box_predictor_0),d=Hd(e,n.box_predictor_1),p=Hd(r,n.box_predictor_2),f=Hd(i,n.box_predictor_3),m=Hd(l,n.box_predictor_4),g=Hd(u,n.box_predictor_5),y=Qt([h.boxPredictionEncoding,d.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),v=Qt([h.classPrediction,d.classPrediction,p.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1);return{boxPredictions:y,classPredictions:v}})}var d_=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},q$e=class extends Iu{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return X(()=>{let n=ye(e.toBatchTensor(512,!1),"float32"),a=Ie(Ce(n,127.5),1),r=V$e(a,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=H$e(r.out,r.conv11,t.prediction_layer);return G$e(s,i,t.output_layer)})}async forward(e){return this.forwardInput(await nr(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:a}=new d_(t),r=await nr(e),{boxes:s,scores:i}=this.forwardInput(r),o=s[0],l=i[0];for(let y=1;y<s.length;y++)s[y].dispose(),i[y].dispose();let c=Array.from(l.dataSync()),u=U$e(o,c,n,.5,a),h=r.getReshapedInputDimensions(0),d=r.inputSize,p=d/h.width,f=d/h.height,m=o.arraySync(),g=u.map(y=>{let[v,x]=[Math.max(0,m[y][0]),Math.min(1,m[y][2])].map(M=>M*f),[w,k]=[Math.max(0,m[y][1]),Math.min(1,m[y][3])].map(M=>M*p);return new ti(c[y],new jj(w,v,k-w,x-v),{height:r.getInputHeight(0),width:r.getInputWidth(0)})});return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return F$e(e)}extractParams(e){return M$e(e)}},K$e=.4,X$e=[new Kt(.738768,.874946),new Kt(2.42204,2.65704),new Kt(4.30971,7.04493),new Kt(10.246,4.59428),new Kt(12.6868,11.8741)],Q$e=[new Kt(1.603231,2.094468),new Kt(6.041143,7.080126),new Kt(2.882459,3.518061),new Kt(4.266906,5.178857),new Kt(9.041765,10.66308)],Y$e=[117.001,114.697,97.404],Z$e="tiny_yolov2_model",J$e="tiny_yolov2_separable_conv_model",px=e=>typeof e=="number";function eMe(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!px(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>px(t.x)&&px(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(px)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function DA(e){return X(()=>{let t=G(e,ze(.10000000149011612));return re(Bt(Ie(e,t)),t)})}function Ko(e,t){return X(()=>{let n=ri(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Ja(n,t.conv.filters,[1,1],"valid"),n=Ie(n,t.bn.sub),n=G(n,t.bn.truediv),n=re(n,t.conv.bias),DA(n)})}function Xo(e,t){return X(()=>{let n=ri(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Am(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=re(n,t.bias),DA(n)})}function tMe(e,t){let n=EA(e,t);function a(i,o){let l=Ft(e(i)),c=Ft(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:c}}function r(i,o,l){let c=n(i,o,3,`${l}/conv`),u=a(o,`${l}/bn`);return{conv:c,bn:u}}let s=NA(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}}function nMe(e,t,n,a){let{extractWeights:r,getRemainingWeights:s}=Tu(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:c}=tMe(r,i),u;if(t.withSeparableConvs){let[h,d,p,f,m,g,y,v,x]=a,w=t.isFirstLayerConv2d?o(h,d,3,"conv0"):c(h,d,"conv0"),k=c(d,p,"conv1"),M=c(p,f,"conv2"),S=c(f,m,"conv3"),I=c(m,g,"conv4"),E=c(g,y,"conv5"),R=v?c(y,v,"conv6"):void 0,A=x?c(v,x,"conv7"):void 0,_=o(x||v||y,5*n,1,"conv8");u={conv0:w,conv1:k,conv2:M,conv3:S,conv4:I,conv5:E,conv6:R,conv7:A,conv8:_}}else{let[h,d,p,f,m,g,y,v,x]=a,w=l(h,d,"conv0"),k=l(d,p,"conv1"),M=l(p,f,"conv2"),S=l(f,m,"conv3"),I=l(m,g,"conv4"),E=l(g,y,"conv5"),R=l(y,v,"conv6"),A=l(v,x,"conv7"),_=o(x,5*n,1,"conv8");u={conv0:w,conv1:k,conv2:M,conv3:S,conv4:I,conv5:E,conv6:R,conv7:A,conv8:_}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:u,paramMappings:i}}function aMe(e,t){let n=Ed(e,t);function a(o){let l=n(`${o}/sub`,1),c=n(`${o}/truediv`,1);return{sub:l,truediv:c}}function r(o){let l=n(`${o}/filters`,4),c=n(`${o}/bias`,1);return{filters:l,bias:c}}function s(o){let l=r(`${o}/conv`),c=a(`${o}/bn`);return{conv:l,bn:c}}let i=CA(n);return{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function rMe(e,t){let n=[],{extractConvParams:a,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}=aMe(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?a("conv0"):s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:o>7?s("conv6"):void 0,conv7:o>8?s("conv7"):void 0,conv8:a("conv8")}}else i={conv0:r("conv0"),conv1:r("conv1"),conv2:r("conv2"),conv3:r("conv3"),conv4:r("conv4"),conv5:r("conv5"),conv6:r("conv6"),conv7:r("conv7"),conv8:a("conv8")};return ku(e,n),{params:i,paramMappings:n}}var $A=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},EG=class NG extends Iu{constructor(t){super("TinyYolov2"),eMe(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let a=Ko(t,n.conv0);return a=ca(a,[2,2],[2,2],"same"),a=Ko(a,n.conv1),a=ca(a,[2,2],[2,2],"same"),a=Ko(a,n.conv2),a=ca(a,[2,2],[2,2],"same"),a=Ko(a,n.conv3),a=ca(a,[2,2],[2,2],"same"),a=Ko(a,n.conv4),a=ca(a,[2,2],[2,2],"same"),a=Ko(a,n.conv5),a=ca(a,[2,2],[1,1],"same"),a=Ko(a,n.conv6),a=Ko(a,n.conv7),ty(a,n.conv8,"valid",!1)}runMobilenet(t,n){let a=this.config.isFirstLayerConv2d?DA(ty(t,n.conv0,"valid",!1)):Xo(t,n.conv0);return a=ca(a,[2,2],[2,2],"same"),a=Xo(a,n.conv1),a=ca(a,[2,2],[2,2],"same"),a=Xo(a,n.conv2),a=ca(a,[2,2],[2,2],"same"),a=Xo(a,n.conv3),a=ca(a,[2,2],[2,2],"same"),a=Xo(a,n.conv4),a=ca(a,[2,2],[2,2],"same"),a=Xo(a,n.conv5),a=ca(a,[2,2],[1,1],"same"),a=n.conv6?Xo(a,n.conv6):a,a=n.conv7?Xo(a,n.conv7):a,ty(a,n.conv8,"valid",!1)}forwardInput(t,n){let{params:a}=this;if(!a)throw new Error("TinyYolov2 - load model before inference");return X(()=>{let r=ye(t.toBatchTensor(n,!1),"float32");return r=this.config.meanRgb?cv(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,a):this.runTinyYolov2(r,a)})}async forward(t,n){return this.forwardInput(await nr(t),n)}async detect(t,n={}){let{inputSize:a,scoreThreshold:r}=new $A(n),s=await nr(t),i=await this.forwardInput(s,a),o=X(()=>Tn(i)[0].expandDims()),l={width:s.getInputWidth(0),height:s.getInputHeight(0)},c=await this.extractBoxes(o,s.getReshapedInputDimensions(0),r);i.dispose(),o.dispose();let u=c.map(f=>f.box),h=c.map(f=>f.score),d=c.map(f=>f.classScore),p=c.map(f=>this.config.classes[f.label]);return UDe(u.map(f=>f.rescale(a)),h,this.config.iouThreshold,!0).map(f=>new Bj(h[f],d[f],p[f],u[f],l))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return rMe(t,this.config)}extractParams(t){let n=this.config.filterSizes||NG.DEFAULT_FILTER_SIZES,a=n?n.length:void 0;if(a!==7&&a!==8&&a!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${a} filterSizes in config`);return nMe(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,a){let{width:r,height:s}=n,i=Math.max(r,s),o=i/r,l=i/s,c=t.shape[1],u=this.config.anchors.length,[h,d,p]=X(()=>{let y=t.reshape([c,c,u,this.boxEncodingSize]),v=y.slice([0,0,0,0],[c,c,u,4]),x=y.slice([0,0,0,4],[c,c,u,1]),w=this.withClassScores?bu(y.slice([0,0,0,5],[c,c,u,this.config.classes.length]),3):ze(0);return[v,x,w]}),f=[],m=await d.array(),g=await h.array();for(let y=0;y<c;y++)for(let v=0;v<c;v++)for(let x=0;x<u;x++){let w=zS(m[y][v][x][0]);if(!a||w>a){let k=(v+zS(g[y][v][x][0]))/c*o,M=(y+zS(g[y][v][x][1]))/c*l,S=Math.exp(g[y][v][x][2])*this.config.anchors[x].x/c*o,I=Math.exp(g[y][v][x][3])*this.config.anchors[x].y/c*l,E=k-S/2,R=M-I/2,A={row:y,col:v,anchor:x},{classScore:_,label:D}=this.withClassScores?await this.extractPredictedClass(p,A):{classScore:1,label:0};f.push({box:new Vj(E,R,E+S,R+I),score:w,classScore:w*_,label:D,...A})}}return h.dispose(),d.dispose(),p.dispose(),f}async extractPredictedClass(t,n){let{row:a,col:r,anchor:s}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,l)=>i[a][r][s][l]).map((o,l)=>({classScore:o,label:l})).reduce((o,l)=>o.classScore>l.classScore?o:l)}};EG.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var CG=EG,sMe=class extends CG{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:K$e,classes:["face"],...e?{anchors:Q$e,meanRgb:Y$e}:{anchors:X$e,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new ti(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?J$e:Z$e}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},MA=class extends $A{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},hv=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function p_(e,t,n,a,r=({alignedRect:s})=>s){let s=e.map(l=>gG(l)?r(l):l.detection),i=a||(t instanceof at?await TA(t,s):await kA(t,s)),o=await n(i);return i.forEach(l=>l instanceof at&&l.dispose()),o}async function OA(e,t,n,a,r){return p_([e],t,async s=>n(s[0]),a,r)}var iMe=.4,oMe=[new Kt(1.603231,2.094468),new Kt(6.041143,7.080126),new Kt(2.882459,3.518061),new Kt(4.266906,5.178857),new Kt(9.041765,10.66308)],lMe=[117.001,114.697,97.404],uMe=class extends CG{constructor(){let e={withSeparableConvs:!0,iouThreshold:iMe,classes:["face"],anchors:oMe,meanRgb:lMe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new ti(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Or={ssdMobilenetv1:new q$e,tinyFaceDetector:new uMe,tinyYolov2:new sMe,faceLandmark68Net:new w$e,faceLandmark68TinyNet:new k$e,faceRecognitionNet:new D$e,faceExpressionNet:new i$e,ageGenderNet:new x$e},AG=class extends hv{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},FA=class extends AG{async run(){let e=await this.parentTask,t=await p_(e,this.input,async n=>Promise.all(n.map(a=>Or.faceExpressionNet.predictExpressions(a))),this.extractedFaces);return e.map((n,a)=>mG(n,t[a]))}withAgeAndGender(){return new VA(this,this.input)}},LA=class extends AG{async run(){let e=await this.parentTask;if(!e)return;let t=await OA(e,this.input,n=>Or.faceExpressionNet.predictExpressions(n),this.extractedFaces);return mG(e,t)}withAgeAndGender(){return new BA(this,this.input)}},zA=class extends FA{withAgeAndGender(){return new UA(this,this.input)}withFaceDescriptors(){return new jA(this,this.input)}},PA=class extends LA{withAgeAndGender(){return new WA(this,this.input)}withFaceDescriptor(){return new GA(this,this.input)}},RG=class extends hv{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},VA=class extends RG{async run(){let e=await this.parentTask,t=await p_(e,this.input,async n=>Promise.all(n.map(a=>Or.ageGenderNet.predictAgeAndGender(a))),this.extractedFaces);return e.map((n,a)=>{let{age:r,gender:s,genderProbability:i}=t[a];return kG(TG(n,s,i),r)})}withFaceExpressions(){return new FA(this,this.input)}},BA=class extends RG{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:a}=await OA(e,this.input,r=>Or.ageGenderNet.predictAgeAndGender(r),this.extractedFaces);return kG(TG(e,n,a),t)}withFaceExpressions(){return new LA(this,this.input)}},UA=class extends VA{withFaceExpressions(){return new zA(this,this.input)}withFaceDescriptors(){return new jA(this,this.input)}},WA=class extends BA{withFaceExpressions(){return new PA(this,this.input)}withFaceDescriptor(){return new GA(this,this.input)}},DG=class extends hv{constructor(e,t){super(),this.parentTask=e,this.input=t}},jA=class extends DG{async run(){let e=await this.parentTask;return(await p_(e,this.input,t=>Promise.all(t.map(n=>Or.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>IG(e[n],t))}withFaceExpressions(){return new zA(this,this.input)}withAgeAndGender(){return new UA(this,this.input)}},GA=class extends DG{async run(){let e=await this.parentTask;if(!e)return;let t=await OA(e,this.input,n=>Or.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return IG(e,t)}withFaceExpressions(){return new PA(this,this.input)}withAgeAndGender(){return new WA(this,this.input)}},$G=class extends hv{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Or.faceLandmark68TinyNet:Or.faceLandmark68Net}},cMe=class extends $G{async run(){let e=await this.parentTask,t=e.map(r=>r.detection),n=this.input instanceof at?await TA(this.input,t):await kA(this.input,t),a=await Promise.all(n.map(r=>this.landmarkNet.detectLandmarks(r)));return n.forEach(r=>r instanceof at&&r.dispose()),e.filter((r,s)=>a[s]).map((r,s)=>yG(r,a[s]))}withFaceExpressions(){return new zA(this,this.input)}withAgeAndGender(){return new UA(this,this.input)}withFaceDescriptors(){return new jA(this,this.input)}},hMe=class extends $G{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof at?await TA(this.input,[t]):await kA(this.input,[t]),a=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(r=>r instanceof at&&r.dispose()),yG(e,a)}withFaceExpressions(){return new PA(this,this.input)}withAgeAndGender(){return new WA(this,this.input)}withFaceDescriptor(){return new GA(this,this.input)}},MG=class extends hv{constructor(e,t=new d_){super(),this.input=e,this.options=t}},dMe=class extends MG{async run(){let{input:e,options:t}=this,n;if(t instanceof MA)n=Or.tinyFaceDetector.locateFaces(e,t);else if(t instanceof d_)n=Or.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof $A)n=Or.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(a=>Hj({},a)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new cMe(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new FA(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new VA(this.runAndExtendWithFaceDetections(),this.input)}},pMe=class extends MG{async run(){let e=await new dMe(this.input,this.options),t=e[0];return e.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?Hj({},t):void 0)})}withFaceLandmarks(e=!1){return new hMe(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new LA(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new BA(this.runAndExtendWithFaceDetection(),this.input)}};function OG(e,t=new d_){return new pMe(e,t)}function fMe(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),a=Array.from(t);return Math.sqrt(n.map((r,s)=>r-a[s]).reduce((r,s)=>r+s*s,0))}const BS="https://justadudewhohacks.github.io/face-api.js/models";let rw=!1;async function HA(){if(!rw)try{await Promise.all([Or.tinyFaceDetector.loadFromUri(BS),Or.faceLandmark68Net.loadFromUri(BS),Or.faceRecognitionNet.loadFromUri(BS)]),rw=!0,console.log("Face-API models loaded successfully")}catch(e){throw console.error("Failed to load Face-API models",e),e}}async function oO(e){const t=await sG(e),n=await OG(t,new MA).withFaceLandmarks().withFaceDescriptor();return n?n.descriptor:null}async function mMe(e,t){try{rw||await HA();const n=await oO(e);if(!n)return{isMatch:!1,score:0,message:"Could not detect face in registered photo."};const a=await oO(t);if(!a)return{isMatch:!1,score:0,message:"Could not detect your face. Please try again with better lighting."};const r=fMe(n,a),s=Math.max(0,Math.min(100,(1-r)*100)),i=r<.6;return{isMatch:i,score:s,message:i?"Face verification successful.":`Face does not match (Distance: ${r.toFixed(2)}).`}}catch(n){return console.error("Face-API Verification Error:",n),{isMatch:!1,score:0,message:"An error occurred during facial verification."}}}async function gMe(e){rw||await HA();const t=await sG(e);return!!await OG(t,new MA)}const yMe=()=>{};var lO={};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const FG=function(e){const t=[];let n=0;for(let a=0;a<e.length;a++){let r=e.charCodeAt(a);r<128?t[n++]=r:r<2048?(t[n++]=r>>6|192,t[n++]=r&63|128):(r&64512)===55296&&a+1<e.length&&(e.charCodeAt(a+1)&64512)===56320?(r=65536+((r&1023)<<10)+(e.charCodeAt(++a)&1023),t[n++]=r>>18|240,t[n++]=r>>12&63|128,t[n++]=r>>6&63|128,t[n++]=r&63|128):(t[n++]=r>>12|224,t[n++]=r>>6&63|128,t[n++]=r&63|128)}return t},bMe=function(e){const t=[];let n=0,a=0;for(;n<e.length;){const r=e[n++];if(r<128)t[a++]=String.fromCharCode(r);else if(r>191&&r<224){const s=e[n++];t[a++]=String.fromCharCode((r&31)<<6|s&63)}else if(r>239&&r<365){const s=e[n++],i=e[n++],o=e[n++],l=((r&7)<<18|(s&63)<<12|(i&63)<<6|o&63)-65536;t[a++]=String.fromCharCode(55296+(l>>10)),t[a++]=String.fromCharCode(56320+(l&1023))}else{const s=e[n++],i=e[n++];t[a++]=String.fromCharCode((r&15)<<12|(s&63)<<6|i&63)}}return t.join("")},LG={byteToCharMap_:null,charToByteMap_:null,byteToCharMapWebSafe_:null,charToByteMapWebSafe_:null,ENCODED_VALS_BASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",get ENCODED_VALS(){return this.ENCODED_VALS_BASE+"+/="},get ENCODED_VALS_WEBSAFE(){return this.ENCODED_VALS_BASE+"-_."},HAS_NATIVE_SUPPORT:typeof atob=="function",encodeByteArray(e,t){if(!Array.isArray(e))throw Error("encodeByteArray takes an array as a parameter");this.init_();const n=t?this.byteToCharMapWebSafe_:this.byteToCharMap_,a=[];for(let r=0;r<e.length;r+=3){const s=e[r],i=r+1<e.length,o=i?e[r+1]:0,l=r+2<e.length,c=l?e[r+2]:0,u=s>>2,h=(s&3)<<4|o>>4;let d=(o&15)<<2|c>>6,p=c&63;l||(p=64,i||(d=64)),a.push(n[u],n[h],n[d],n[p])}return a.join("")},encodeString(e,t){return this.HAS_NATIVE_SUPPORT&&!t?btoa(e):this.encodeByteArray(FG(e),t)},decodeString(e,t){return this.HAS_NATIVE_SUPPORT&&!t?atob(e):bMe(this.decodeStringToByteArray(e,t))},decodeStringToByteArray(e,t){this.init_();const n=t?this.charToByteMapWebSafe_:this.charToByteMap_,a=[];for(let r=0;r<e.length;){const s=n[e.charAt(r++)],o=r<e.length?n[e.charAt(r)]:0;++r;const c=r<e.length?n[e.charAt(r)]:64;++r;const h=r<e.length?n[e.charAt(r)]:64;if(++r,s==null||o==null||c==null||h==null)throw new vMe;const d=s<<2|o>>4;if(a.push(d),c!==64){const p=o<<4&240|c>>2;if(a.push(p),h!==64){const f=c<<6&192|h;a.push(f)}}}return a},init_(){if(!this.byteToCharMap_){this.byteToCharMap_={},this.charToByteMap_={},this.byteToCharMapWebSafe_={},this.charToByteMapWebSafe_={};for(let e=0;e<this.ENCODED_VALS.length;e++)this.byteToCharMap_[e]=this.ENCODED_VALS.charAt(e),this.charToByteMap_[this.byteToCharMap_[e]]=e,this.byteToCharMapWebSafe_[e]=this.ENCODED_VALS_WEBSAFE.charAt(e),this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]]=e,e>=this.ENCODED_VALS_BASE.length&&(this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)]=e,this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)]=e)}}};class vMe extends Error{constructor(){super(...arguments),this.name="DecodeBase64StringError"}}const xMe=function(e){const t=FG(e);return LG.encodeByteArray(t,!0)},sw=function(e){return xMe(e).replace(/\./g,"")},wMe=function(e){try{return LG.decodeString(e,!0)}catch(t){console.error("base64Decode failed: ",t)}return null};/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function _Me(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("Unable to locate global object.")}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const SMe=()=>_Me().__FIREBASE_DEFAULTS__,IMe=()=>{if(typeof process>"u"||typeof lO>"u")return;const e=lO.__FIREBASE_DEFAULTS__;if(e)return JSON.parse(e)},kMe=()=>{if(typeof document>"u")return;let e;try{e=document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)}catch{return}const t=e&&wMe(e[1]);return t&&JSON.parse(t)},qA=()=>{try{return yMe()||SMe()||IMe()||kMe()}catch(e){console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);return}},TMe=e=>{var t,n;return(n=(t=qA())==null?void 0:t.emulatorHosts)==null?void 0:n[e]},EMe=e=>{const t=TMe(e);if(!t)return;const n=t.lastIndexOf(":");if(n<=0||n+1===t.length)throw new Error(`Invalid host ${t} with no separate hostname and port!`);const a=parseInt(t.substring(n+1),10);return t[0]==="["?[t.substring(1,n-1),a]:[t.substring(0,n),a]},zG=()=>{var e;return(e=qA())==null?void 0:e.config};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class NMe{constructor(){this.reject=()=>{},this.resolve=()=>{},this.promise=new Promise((t,n)=>{this.resolve=t,this.reject=n})}wrapCallback(t){return(n,a)=>{n?this.reject(n):this.resolve(a),typeof t=="function"&&(this.promise.catch(()=>{}),t.length===1?t(n):t(n,a))}}}/**
 * @license
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function KA(e){try{return(e.startsWith("http://")||e.startsWith("https://")?new URL(e).hostname:e).endsWith(".cloudworkstations.dev")}catch{return!1}}async function CMe(e){return(await fetch(e,{credentials:"include"})).ok}/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function AMe(e,t){if(e.uid)throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');const n={alg:"none",type:"JWT"},a=t||"demo-project",r=e.iat||0,s=e.sub||e.user_id;if(!s)throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");const i={iss:`https://securetoken.google.com/${a}`,aud:a,iat:r,exp:r+3600,auth_time:r,sub:s,user_id:s,firebase:{sign_in_provider:"custom",identities:{}},...e};return[sw(JSON.stringify(n)),sw(JSON.stringify(i)),""].join(".")}const ny={};function RMe(){const e={prod:[],emulator:[]};for(const t of Object.keys(ny))ny[t]?e.emulator.push(t):e.prod.push(t);return e}function DMe(e){let t=document.getElementById(e),n=!1;return t||(t=document.createElement("div"),t.setAttribute("id",e),n=!0),{created:n,element:t}}let uO=!1;function $Me(e,t){if(typeof window>"u"||typeof document>"u"||!KA(window.location.host)||ny[e]===t||ny[e]||uO)return;ny[e]=t;function n(d){return`__firebase__banner__${d}`}const a="__firebase__banner",s=RMe().prod.length>0;function i(){const d=document.getElementById(a);d&&d.remove()}function o(d){d.style.display="flex",d.style.background="#7faaf0",d.style.position="fixed",d.style.bottom="5px",d.style.left="5px",d.style.padding=".5em",d.style.borderRadius="5px",d.style.alignItems="center"}function l(d,p){d.setAttribute("width","24"),d.setAttribute("id",p),d.setAttribute("height","24"),d.setAttribute("viewBox","0 0 24 24"),d.setAttribute("fill","none"),d.style.marginLeft="-6px"}function c(){const d=document.createElement("span");return d.style.cursor="pointer",d.style.marginLeft="16px",d.style.fontSize="24px",d.innerHTML=" &times;",d.onclick=()=>{uO=!0,i()},d}function u(d,p){d.setAttribute("id",p),d.innerText="Learn more",d.href="https://firebase.google.com/docs/studio/preview-apps#preview-backend",d.setAttribute("target","__blank"),d.style.paddingLeft="5px",d.style.textDecoration="underline"}function h(){const d=DMe(a),p=n("text"),f=document.getElementById(p)||document.createElement("span"),m=n("learnmore"),g=document.getElementById(m)||document.createElement("a"),y=n("preprendIcon"),v=document.getElementById(y)||document.createElementNS("http://www.w3.org/2000/svg","svg");if(d.created){const x=d.element;o(x),u(g,m);const w=c();l(v,y),x.append(v,f,g,w),document.body.appendChild(x)}s?(f.innerText="Preview backend disconnected.",v.innerHTML=`<g clip-path="url(#clip0_6013_33858)">
<path d="M4.8 17.6L12 5.6L19.2 17.6H4.8ZM6.91667 16.4H17.0833L12 7.93333L6.91667 16.4ZM12 15.6C12.1667 15.6 12.3056 15.5444 12.4167 15.4333C12.5389 15.3111 12.6 15.1667 12.6 15C12.6 14.8333 12.5389 14.6944 12.4167 14.5833C12.3056 14.4611 12.1667 14.4 12 14.4C11.8333 14.4 11.6889 14.4611 11.5667 14.5833C11.4556 14.6944 11.4 14.8333 11.4 15C11.4 15.1667 11.4556 15.3111 11.5667 15.4333C11.6889 15.5444 11.8333 15.6 12 15.6ZM11.4 13.6H12.6V10.4H11.4V13.6Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6013_33858">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`):(v.innerHTML=`<g clip-path="url(#clip0_6083_34804)">
<path d="M11.4 15.2H12.6V11.2H11.4V15.2ZM12 10C12.1667 10 12.3056 9.94444 12.4167 9.83333C12.5389 9.71111 12.6 9.56667 12.6 9.4C12.6 9.23333 12.5389 9.09444 12.4167 8.98333C12.3056 8.86111 12.1667 8.8 12 8.8C11.8333 8.8 11.6889 8.86111 11.5667 8.98333C11.4556 9.09444 11.4 9.23333 11.4 9.4C11.4 9.56667 11.4556 9.71111 11.5667 9.83333C11.6889 9.94444 11.8333 10 12 10ZM12 18.4C11.1222 18.4 10.2944 18.2333 9.51667 17.9C8.73889 17.5667 8.05556 17.1111 7.46667 16.5333C6.88889 15.9444 6.43333 15.2611 6.1 14.4833C5.76667 13.7056 5.6 12.8778 5.6 12C5.6 11.1111 5.76667 10.2833 6.1 9.51667C6.43333 8.73889 6.88889 8.06111 7.46667 7.48333C8.05556 6.89444 8.73889 6.43333 9.51667 6.1C10.2944 5.76667 11.1222 5.6 12 5.6C12.8889 5.6 13.7167 5.76667 14.4833 6.1C15.2611 6.43333 15.9389 6.89444 16.5167 7.48333C17.1056 8.06111 17.5667 8.73889 17.9 9.51667C18.2333 10.2833 18.4 11.1111 18.4 12C18.4 12.8778 18.2333 13.7056 17.9 14.4833C17.5667 15.2611 17.1056 15.9444 16.5167 16.5333C15.9389 17.1111 15.2611 17.5667 14.4833 17.9C13.7167 18.2333 12.8889 18.4 12 18.4ZM12 17.2C13.4444 17.2 14.6722 16.6944 15.6833 15.6833C16.6944 14.6722 17.2 13.4444 17.2 12C17.2 10.5556 16.6944 9.32778 15.6833 8.31667C14.6722 7.30555 13.4444 6.8 12 6.8C10.5556 6.8 9.32778 7.30555 8.31667 8.31667C7.30556 9.32778 6.8 10.5556 6.8 12C6.8 13.4444 7.30556 14.6722 8.31667 15.6833C9.32778 16.6944 10.5556 17.2 12 17.2Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6083_34804">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`,f.innerText="Preview backend running in this workspace."),f.setAttribute("id",p)}document.readyState==="loading"?window.addEventListener("DOMContentLoaded",h):h()}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function MMe(){return typeof navigator<"u"&&typeof navigator.userAgent=="string"?navigator.userAgent:""}function OMe(){var t;const e=(t=qA())==null?void 0:t.forceEnvironment;if(e==="node")return!0;if(e==="browser")return!1;try{return Object.prototype.toString.call(global.process)==="[object process]"}catch{return!1}}function FMe(){return!OMe()&&!!navigator.userAgent&&navigator.userAgent.includes("Safari")&&!navigator.userAgent.includes("Chrome")}function LMe(){try{return typeof indexedDB=="object"}catch{return!1}}function zMe(){return new Promise((e,t)=>{try{let n=!0;const a="validate-browser-context-for-indexeddb-analytics-module",r=self.indexedDB.open(a);r.onsuccess=()=>{r.result.close(),n||self.indexedDB.deleteDatabase(a),e(!0)},r.onupgradeneeded=()=>{n=!1},r.onerror=()=>{var s;t(((s=r.error)==null?void 0:s.message)||"")}}catch(n){t(n)}})}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const PMe="FirebaseError";class Hm extends Error{constructor(t,n,a){super(n),this.code=t,this.customData=a,this.name=PMe,Object.setPrototypeOf(this,Hm.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,PG.prototype.create)}}class PG{constructor(t,n,a){this.service=t,this.serviceName=n,this.errors=a}create(t,...n){const a=n[0]||{},r=`${this.service}/${t}`,s=this.errors[t],i=s?VMe(s,a):"Error",o=`${this.serviceName}: ${i} (${r}).`;return new Hm(r,o,a)}}function VMe(e,t){return e.replace(BMe,(n,a)=>{const r=t[a];return r!=null?String(r):`<${a}?>`})}const BMe=/\{\$([^}]+)}/g;function iw(e,t){if(e===t)return!0;const n=Object.keys(e),a=Object.keys(t);for(const r of n){if(!a.includes(r))return!1;const s=e[r],i=t[r];if(cO(s)&&cO(i)){if(!iw(s,i))return!1}else if(s!==i)return!1}for(const r of a)if(!n.includes(r))return!1;return!0}function cO(e){return e!==null&&typeof e=="object"}/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Vi(e){return e&&e._delegate?e._delegate:e}class Py{constructor(t,n,a){this.name=t,this.instanceFactory=n,this.type=a,this.multipleInstances=!1,this.serviceProps={},this.instantiationMode="LAZY",this.onInstanceCreated=null}setInstantiationMode(t){return this.instantiationMode=t,this}setMultipleInstances(t){return this.multipleInstances=t,this}setServiceProps(t){return this.serviceProps=t,this}setInstanceCreatedCallback(t){return this.onInstanceCreated=t,this}}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ec="[DEFAULT]";/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class UMe{constructor(t,n){this.name=t,this.container=n,this.component=null,this.instances=new Map,this.instancesDeferred=new Map,this.instancesOptions=new Map,this.onInitCallbacks=new Map}get(t){const n=this.normalizeInstanceIdentifier(t);if(!this.instancesDeferred.has(n)){const a=new NMe;if(this.instancesDeferred.set(n,a),this.isInitialized(n)||this.shouldAutoInitialize())try{const r=this.getOrInitializeService({instanceIdentifier:n});r&&a.resolve(r)}catch{}}return this.instancesDeferred.get(n).promise}getImmediate(t){const n=this.normalizeInstanceIdentifier(t==null?void 0:t.identifier),a=(t==null?void 0:t.optional)??!1;if(this.isInitialized(n)||this.shouldAutoInitialize())try{return this.getOrInitializeService({instanceIdentifier:n})}catch(r){if(a)return null;throw r}else{if(a)return null;throw Error(`Service ${this.name} is not available`)}}getComponent(){return this.component}setComponent(t){if(t.name!==this.name)throw Error(`Mismatching Component ${t.name} for Provider ${this.name}.`);if(this.component)throw Error(`Component for ${this.name} has already been provided`);if(this.component=t,!!this.shouldAutoInitialize()){if(jMe(t))try{this.getOrInitializeService({instanceIdentifier:ec})}catch{}for(const[n,a]of this.instancesDeferred.entries()){const r=this.normalizeInstanceIdentifier(n);try{const s=this.getOrInitializeService({instanceIdentifier:r});a.resolve(s)}catch{}}}}clearInstance(t=ec){this.instancesDeferred.delete(t),this.instancesOptions.delete(t),this.instances.delete(t)}async delete(){const t=Array.from(this.instances.values());await Promise.all([...t.filter(n=>"INTERNAL"in n).map(n=>n.INTERNAL.delete()),...t.filter(n=>"_delete"in n).map(n=>n._delete())])}isComponentSet(){return this.component!=null}isInitialized(t=ec){return this.instances.has(t)}getOptions(t=ec){return this.instancesOptions.get(t)||{}}initialize(t={}){const{options:n={}}=t,a=this.normalizeInstanceIdentifier(t.instanceIdentifier);if(this.isInitialized(a))throw Error(`${this.name}(${a}) has already been initialized`);if(!this.isComponentSet())throw Error(`Component ${this.name} has not been registered yet`);const r=this.getOrInitializeService({instanceIdentifier:a,options:n});for(const[s,i]of this.instancesDeferred.entries()){const o=this.normalizeInstanceIdentifier(s);a===o&&i.resolve(r)}return r}onInit(t,n){const a=this.normalizeInstanceIdentifier(n),r=this.onInitCallbacks.get(a)??new Set;r.add(t),this.onInitCallbacks.set(a,r);const s=this.instances.get(a);return s&&t(s,a),()=>{r.delete(t)}}invokeOnInitCallbacks(t,n){const a=this.onInitCallbacks.get(n);if(a)for(const r of a)try{r(t,n)}catch{}}getOrInitializeService({instanceIdentifier:t,options:n={}}){let a=this.instances.get(t);if(!a&&this.component&&(a=this.component.instanceFactory(this.container,{instanceIdentifier:WMe(t),options:n}),this.instances.set(t,a),this.instancesOptions.set(t,n),this.invokeOnInitCallbacks(a,t),this.component.onInstanceCreated))try{this.component.onInstanceCreated(this.container,t,a)}catch{}return a||null}normalizeInstanceIdentifier(t=ec){return this.component?this.component.multipleInstances?t:ec:t}shouldAutoInitialize(){return!!this.component&&this.component.instantiationMode!=="EXPLICIT"}}function WMe(e){return e===ec?void 0:e}function jMe(e){return e.instantiationMode==="EAGER"}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class GMe{constructor(t){this.name=t,this.providers=new Map}addComponent(t){const n=this.getProvider(t.name);if(n.isComponentSet())throw new Error(`Component ${t.name} has already been registered with ${this.name}`);n.setComponent(t)}addOrOverwriteComponent(t){this.getProvider(t.name).isComponentSet()&&this.providers.delete(t.name),this.addComponent(t)}getProvider(t){if(this.providers.has(t))return this.providers.get(t);const n=new UMe(t,this);return this.providers.set(t,n),n}getProviders(){return Array.from(this.providers.values())}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var Dt;(function(e){e[e.DEBUG=0]="DEBUG",e[e.VERBOSE=1]="VERBOSE",e[e.INFO=2]="INFO",e[e.WARN=3]="WARN",e[e.ERROR=4]="ERROR",e[e.SILENT=5]="SILENT"})(Dt||(Dt={}));const HMe={debug:Dt.DEBUG,verbose:Dt.VERBOSE,info:Dt.INFO,warn:Dt.WARN,error:Dt.ERROR,silent:Dt.SILENT},qMe=Dt.INFO,KMe={[Dt.DEBUG]:"log",[Dt.VERBOSE]:"log",[Dt.INFO]:"info",[Dt.WARN]:"warn",[Dt.ERROR]:"error"},XMe=(e,t,...n)=>{if(t<e.logLevel)return;const a=new Date().toISOString(),r=KMe[t];if(r)console[r](`[${a}]  ${e.name}:`,...n);else throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`)};class VG{constructor(t){this.name=t,this._logLevel=qMe,this._logHandler=XMe,this._userLogHandler=null}get logLevel(){return this._logLevel}set logLevel(t){if(!(t in Dt))throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``);this._logLevel=t}setLogLevel(t){this._logLevel=typeof t=="string"?HMe[t]:t}get logHandler(){return this._logHandler}set logHandler(t){if(typeof t!="function")throw new TypeError("Value assigned to `logHandler` must be a function");this._logHandler=t}get userLogHandler(){return this._userLogHandler}set userLogHandler(t){this._userLogHandler=t}debug(...t){this._userLogHandler&&this._userLogHandler(this,Dt.DEBUG,...t),this._logHandler(this,Dt.DEBUG,...t)}log(...t){this._userLogHandler&&this._userLogHandler(this,Dt.VERBOSE,...t),this._logHandler(this,Dt.VERBOSE,...t)}info(...t){this._userLogHandler&&this._userLogHandler(this,Dt.INFO,...t),this._logHandler(this,Dt.INFO,...t)}warn(...t){this._userLogHandler&&this._userLogHandler(this,Dt.WARN,...t),this._logHandler(this,Dt.WARN,...t)}error(...t){this._userLogHandler&&this._userLogHandler(this,Dt.ERROR,...t),this._logHandler(this,Dt.ERROR,...t)}}const QMe=(e,t)=>t.some(n=>e instanceof n);let hO,dO;function YMe(){return hO||(hO=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function ZMe(){return dO||(dO=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const BG=new WeakMap,tT=new WeakMap,UG=new WeakMap,US=new WeakMap,XA=new WeakMap;function JMe(e){const t=new Promise((n,a)=>{const r=()=>{e.removeEventListener("success",s),e.removeEventListener("error",i)},s=()=>{n(Dl(e.result)),r()},i=()=>{a(e.error),r()};e.addEventListener("success",s),e.addEventListener("error",i)});return t.then(n=>{n instanceof IDBCursor&&BG.set(n,e)}).catch(()=>{}),XA.set(t,e),t}function eOe(e){if(tT.has(e))return;const t=new Promise((n,a)=>{const r=()=>{e.removeEventListener("complete",s),e.removeEventListener("error",i),e.removeEventListener("abort",i)},s=()=>{n(),r()},i=()=>{a(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",s),e.addEventListener("error",i),e.addEventListener("abort",i)});tT.set(e,t)}let nT={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return tT.get(e);if(t==="objectStoreNames")return e.objectStoreNames||UG.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return Dl(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function tOe(e){nT=e(nT)}function nOe(e){return e===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(t,...n){const a=e.call(WS(this),t,...n);return UG.set(a,t.sort?t.sort():[t]),Dl(a)}:ZMe().includes(e)?function(...t){return e.apply(WS(this),t),Dl(BG.get(this))}:function(...t){return Dl(e.apply(WS(this),t))}}function aOe(e){return typeof e=="function"?nOe(e):(e instanceof IDBTransaction&&eOe(e),QMe(e,YMe())?new Proxy(e,nT):e)}function Dl(e){if(e instanceof IDBRequest)return JMe(e);if(US.has(e))return US.get(e);const t=aOe(e);return t!==e&&(US.set(e,t),XA.set(t,e)),t}const WS=e=>XA.get(e);function rOe(e,t,{blocked:n,upgrade:a,blocking:r,terminated:s}={}){const i=indexedDB.open(e,t),o=Dl(i);return a&&i.addEventListener("upgradeneeded",l=>{a(Dl(i.result),l.oldVersion,l.newVersion,Dl(i.transaction),l)}),n&&i.addEventListener("blocked",l=>n(l.oldVersion,l.newVersion,l)),o.then(l=>{s&&l.addEventListener("close",()=>s()),r&&l.addEventListener("versionchange",c=>r(c.oldVersion,c.newVersion,c))}).catch(()=>{}),o}const sOe=["get","getKey","getAll","getAllKeys","count"],iOe=["put","add","delete","clear"],jS=new Map;function pO(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(jS.get(t))return jS.get(t);const n=t.replace(/FromIndex$/,""),a=t!==n,r=iOe.includes(n);if(!(n in(a?IDBIndex:IDBObjectStore).prototype)||!(r||sOe.includes(n)))return;const s=async function(i,...o){const l=this.transaction(i,r?"readwrite":"readonly");let c=l.store;return a&&(c=c.index(o.shift())),(await Promise.all([c[n](...o),r&&l.done]))[0]};return jS.set(t,s),s}tOe(e=>({...e,get:(t,n,a)=>pO(t,n)||e.get(t,n,a),has:(t,n)=>!!pO(t,n)||e.has(t,n)}));/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class oOe{constructor(t){this.container=t}getPlatformInfoString(){return this.container.getProviders().map(n=>{if(lOe(n)){const a=n.getImmediate();return`${a.library}/${a.version}`}else return null}).filter(n=>n).join(" ")}}function lOe(e){const t=e.getComponent();return(t==null?void 0:t.type)==="VERSION"}const aT="@firebase/app",fO="0.14.6";/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Co=new VG("@firebase/app"),uOe="@firebase/app-compat",cOe="@firebase/analytics-compat",hOe="@firebase/analytics",dOe="@firebase/app-check-compat",pOe="@firebase/app-check",fOe="@firebase/auth",mOe="@firebase/auth-compat",gOe="@firebase/database",yOe="@firebase/data-connect",bOe="@firebase/database-compat",vOe="@firebase/functions",xOe="@firebase/functions-compat",wOe="@firebase/installations",_Oe="@firebase/installations-compat",SOe="@firebase/messaging",IOe="@firebase/messaging-compat",kOe="@firebase/performance",TOe="@firebase/performance-compat",EOe="@firebase/remote-config",NOe="@firebase/remote-config-compat",COe="@firebase/storage",AOe="@firebase/storage-compat",ROe="@firebase/firestore",DOe="@firebase/ai",$Oe="@firebase/firestore-compat",MOe="firebase",OOe="12.6.0";/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const rT="[DEFAULT]",FOe={[aT]:"fire-core",[uOe]:"fire-core-compat",[hOe]:"fire-analytics",[cOe]:"fire-analytics-compat",[pOe]:"fire-app-check",[dOe]:"fire-app-check-compat",[fOe]:"fire-auth",[mOe]:"fire-auth-compat",[gOe]:"fire-rtdb",[yOe]:"fire-data-connect",[bOe]:"fire-rtdb-compat",[vOe]:"fire-fn",[xOe]:"fire-fn-compat",[wOe]:"fire-iid",[_Oe]:"fire-iid-compat",[SOe]:"fire-fcm",[IOe]:"fire-fcm-compat",[kOe]:"fire-perf",[TOe]:"fire-perf-compat",[EOe]:"fire-rc",[NOe]:"fire-rc-compat",[COe]:"fire-gcs",[AOe]:"fire-gcs-compat",[ROe]:"fire-fst",[$Oe]:"fire-fst-compat",[DOe]:"fire-vertex","fire-js":"fire-js",[MOe]:"fire-js-all"};/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Vy=new Map,LOe=new Map,sT=new Map;function mO(e,t){try{e.container.addComponent(t)}catch(n){Co.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`,n)}}function ow(e){const t=e.name;if(sT.has(t))return Co.debug(`There were multiple attempts to register component ${t}.`),!1;sT.set(t,e);for(const n of Vy.values())mO(n,e);for(const n of LOe.values())mO(n,e);return!0}function zOe(e,t){const n=e.container.getProvider("heartbeat").getImmediate({optional:!0});return n&&n.triggerHeartbeat(),e.container.getProvider(t)}function POe(e){return e==null?!1:e.settings!==void 0}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const VOe={"no-app":"No Firebase App '{$appName}' has been created - call initializeApp() first","bad-app-name":"Illegal App name: '{$appName}'","duplicate-app":"Firebase App named '{$appName}' already exists with different options or config","app-deleted":"Firebase App named '{$appName}' already deleted","server-app-deleted":"Firebase Server App has been deleted","no-options":"Need to provide options, when not being deployed to hosting via source.","invalid-app-argument":"firebase.{$appName}() takes either no argument or a Firebase App instance.","invalid-log-argument":"First argument to `onLog` must be null or a function.","idb-open":"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.","idb-get":"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.","idb-set":"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.","idb-delete":"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.","finalization-registry-not-supported":"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.","invalid-server-app-environment":"FirebaseServerApp is not for use in browser environments."},$l=new PG("app","Firebase",VOe);/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class BOe{constructor(t,n,a){this._isDeleted=!1,this._options={...t},this._config={...n},this._name=n.name,this._automaticDataCollectionEnabled=n.automaticDataCollectionEnabled,this._container=a,this.container.addComponent(new Py("app",()=>this,"PUBLIC"))}get automaticDataCollectionEnabled(){return this.checkDestroyed(),this._automaticDataCollectionEnabled}set automaticDataCollectionEnabled(t){this.checkDestroyed(),this._automaticDataCollectionEnabled=t}get name(){return this.checkDestroyed(),this._name}get options(){return this.checkDestroyed(),this._options}get config(){return this.checkDestroyed(),this._config}get container(){return this._container}get isDeleted(){return this._isDeleted}set isDeleted(t){this._isDeleted=t}checkDestroyed(){if(this.isDeleted)throw $l.create("app-deleted",{appName:this._name})}}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const UOe=OOe;function WG(e,t={}){let n=e;typeof t!="object"&&(t={name:t});const a={name:rT,automaticDataCollectionEnabled:!0,...t},r=a.name;if(typeof r!="string"||!r)throw $l.create("bad-app-name",{appName:String(r)});if(n||(n=zG()),!n)throw $l.create("no-options");const s=Vy.get(r);if(s){if(iw(n,s.options)&&iw(a,s.config))return s;throw $l.create("duplicate-app",{appName:r})}const i=new GMe(r);for(const l of sT.values())i.addComponent(l);const o=new BOe(n,a,i);return Vy.set(r,o),o}function jG(e=rT){const t=Vy.get(e);if(!t&&e===rT&&zG())return WG();if(!t)throw $l.create("no-app",{appName:e});return t}function WOe(){return Array.from(Vy.values())}function Cp(e,t,n){let a=FOe[e]??e;n&&(a+=`-${n}`);const r=a.match(/\s|\//),s=t.match(/\s|\//);if(r||s){const i=[`Unable to register library "${a}" with version "${t}":`];r&&i.push(`library name "${a}" contains illegal characters (whitespace or "/")`),r&&s&&i.push("and"),s&&i.push(`version name "${t}" contains illegal characters (whitespace or "/")`),Co.warn(i.join(" "));return}ow(new Py(`${a}-version`,()=>({library:a,version:t}),"VERSION"))}/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const jOe="firebase-heartbeat-database",GOe=1,By="firebase-heartbeat-store";let GS=null;function GG(){return GS||(GS=rOe(jOe,GOe,{upgrade:(e,t)=>{switch(t){case 0:try{e.createObjectStore(By)}catch(n){console.warn(n)}}}}).catch(e=>{throw $l.create("idb-open",{originalErrorMessage:e.message})})),GS}async function HOe(e){try{const n=(await GG()).transaction(By),a=await n.objectStore(By).get(HG(e));return await n.done,a}catch(t){if(t instanceof Hm)Co.warn(t.message);else{const n=$l.create("idb-get",{originalErrorMessage:t==null?void 0:t.message});Co.warn(n.message)}}}async function gO(e,t){try{const a=(await GG()).transaction(By,"readwrite");await a.objectStore(By).put(t,HG(e)),await a.done}catch(n){if(n instanceof Hm)Co.warn(n.message);else{const a=$l.create("idb-set",{originalErrorMessage:n==null?void 0:n.message});Co.warn(a.message)}}}function HG(e){return`${e.name}!${e.options.appId}`}/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const qOe=1024,KOe=30;class XOe{constructor(t){this.container=t,this._heartbeatsCache=null;const n=this.container.getProvider("app").getImmediate();this._storage=new YOe(n),this._heartbeatsCachePromise=this._storage.read().then(a=>(this._heartbeatsCache=a,a))}async triggerHeartbeat(){var t,n;try{const r=this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),s=yO();if(((t=this._heartbeatsCache)==null?void 0:t.heartbeats)==null&&(this._heartbeatsCache=await this._heartbeatsCachePromise,((n=this._heartbeatsCache)==null?void 0:n.heartbeats)==null)||this._heartbeatsCache.lastSentHeartbeatDate===s||this._heartbeatsCache.heartbeats.some(i=>i.date===s))return;if(this._heartbeatsCache.heartbeats.push({date:s,agent:r}),this._heartbeatsCache.heartbeats.length>KOe){const i=ZOe(this._heartbeatsCache.heartbeats);this._heartbeatsCache.heartbeats.splice(i,1)}return this._storage.overwrite(this._heartbeatsCache)}catch(a){Co.warn(a)}}async getHeartbeatsHeader(){var t;try{if(this._heartbeatsCache===null&&await this._heartbeatsCachePromise,((t=this._heartbeatsCache)==null?void 0:t.heartbeats)==null||this._heartbeatsCache.heartbeats.length===0)return"";const n=yO(),{heartbeatsToSend:a,unsentEntries:r}=QOe(this._heartbeatsCache.heartbeats),s=sw(JSON.stringify({version:2,heartbeats:a}));return this._heartbeatsCache.lastSentHeartbeatDate=n,r.length>0?(this._heartbeatsCache.heartbeats=r,await this._storage.overwrite(this._heartbeatsCache)):(this._heartbeatsCache.heartbeats=[],this._storage.overwrite(this._heartbeatsCache)),s}catch(n){return Co.warn(n),""}}}function yO(){return new Date().toISOString().substring(0,10)}function QOe(e,t=qOe){const n=[];let a=e.slice();for(const r of e){const s=n.find(i=>i.agent===r.agent);if(s){if(s.dates.push(r.date),bO(n)>t){s.dates.pop();break}}else if(n.push({agent:r.agent,dates:[r.date]}),bO(n)>t){n.pop();break}a=a.slice(1)}return{heartbeatsToSend:n,unsentEntries:a}}class YOe{constructor(t){this.app=t,this._canUseIndexedDBPromise=this.runIndexedDBEnvironmentCheck()}async runIndexedDBEnvironmentCheck(){return LMe()?zMe().then(()=>!0).catch(()=>!1):!1}async read(){if(await this._canUseIndexedDBPromise){const n=await HOe(this.app);return n!=null&&n.heartbeats?n:{heartbeats:[]}}else return{heartbeats:[]}}async overwrite(t){if(await this._canUseIndexedDBPromise){const a=await this.read();return gO(this.app,{lastSentHeartbeatDate:t.lastSentHeartbeatDate??a.lastSentHeartbeatDate,heartbeats:t.heartbeats})}else return}async add(t){if(await this._canUseIndexedDBPromise){const a=await this.read();return gO(this.app,{lastSentHeartbeatDate:t.lastSentHeartbeatDate??a.lastSentHeartbeatDate,heartbeats:[...a.heartbeats,...t.heartbeats]})}else return}}function bO(e){return sw(JSON.stringify({version:2,heartbeats:e})).length}function ZOe(e){if(e.length===0)return-1;let t=0,n=e[0].date;for(let a=1;a<e.length;a++)e[a].date<n&&(n=e[a].date,t=a);return t}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function JOe(e){ow(new Py("platform-logger",t=>new oOe(t),"PRIVATE")),ow(new Py("heartbeat",t=>new XOe(t),"PRIVATE")),Cp(aT,fO,e),Cp(aT,fO,"esm2020"),Cp("fire-js","")}JOe("");var eFe="firebase",tFe="12.7.0";/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */Cp(eFe,tFe,"app");var vO=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/var Ml,qG;(function(){var e;/** @license

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/function t(S,I){function E(){}E.prototype=I.prototype,S.F=I.prototype,S.prototype=new E,S.prototype.constructor=S,S.D=function(R,A,_){for(var D=Array(arguments.length-2),j=2;j<arguments.length;j++)D[j-2]=arguments[j];return I.prototype[A].apply(R,D)}}function n(){this.blockSize=-1}function a(){this.blockSize=-1,this.blockSize=64,this.g=Array(4),this.C=Array(this.blockSize),this.o=this.h=0,this.u()}t(a,n),a.prototype.u=function(){this.g[0]=1732584193,this.g[1]=4023233417,this.g[2]=2562383102,this.g[3]=271733878,this.o=this.h=0};function r(S,I,E){E||(E=0);const R=Array(16);if(typeof I=="string")for(var A=0;A<16;++A)R[A]=I.charCodeAt(E++)|I.charCodeAt(E++)<<8|I.charCodeAt(E++)<<16|I.charCodeAt(E++)<<24;else for(A=0;A<16;++A)R[A]=I[E++]|I[E++]<<8|I[E++]<<16|I[E++]<<24;I=S.g[0],E=S.g[1],A=S.g[2];let _=S.g[3],D;D=I+(_^E&(A^_))+R[0]+3614090360&4294967295,I=E+(D<<7&4294967295|D>>>25),D=_+(A^I&(E^A))+R[1]+3905402710&4294967295,_=I+(D<<12&4294967295|D>>>20),D=A+(E^_&(I^E))+R[2]+606105819&4294967295,A=_+(D<<17&4294967295|D>>>15),D=E+(I^A&(_^I))+R[3]+3250441966&4294967295,E=A+(D<<22&4294967295|D>>>10),D=I+(_^E&(A^_))+R[4]+4118548399&4294967295,I=E+(D<<7&4294967295|D>>>25),D=_+(A^I&(E^A))+R[5]+1200080426&4294967295,_=I+(D<<12&4294967295|D>>>20),D=A+(E^_&(I^E))+R[6]+2821735955&4294967295,A=_+(D<<17&4294967295|D>>>15),D=E+(I^A&(_^I))+R[7]+4249261313&4294967295,E=A+(D<<22&4294967295|D>>>10),D=I+(_^E&(A^_))+R[8]+1770035416&4294967295,I=E+(D<<7&4294967295|D>>>25),D=_+(A^I&(E^A))+R[9]+2336552879&4294967295,_=I+(D<<12&4294967295|D>>>20),D=A+(E^_&(I^E))+R[10]+4294925233&4294967295,A=_+(D<<17&4294967295|D>>>15),D=E+(I^A&(_^I))+R[11]+2304563134&4294967295,E=A+(D<<22&4294967295|D>>>10),D=I+(_^E&(A^_))+R[12]+1804603682&4294967295,I=E+(D<<7&4294967295|D>>>25),D=_+(A^I&(E^A))+R[13]+4254626195&4294967295,_=I+(D<<12&4294967295|D>>>20),D=A+(E^_&(I^E))+R[14]+2792965006&4294967295,A=_+(D<<17&4294967295|D>>>15),D=E+(I^A&(_^I))+R[15]+1236535329&4294967295,E=A+(D<<22&4294967295|D>>>10),D=I+(A^_&(E^A))+R[1]+4129170786&4294967295,I=E+(D<<5&4294967295|D>>>27),D=_+(E^A&(I^E))+R[6]+3225465664&4294967295,_=I+(D<<9&4294967295|D>>>23),D=A+(I^E&(_^I))+R[11]+643717713&4294967295,A=_+(D<<14&4294967295|D>>>18),D=E+(_^I&(A^_))+R[0]+3921069994&4294967295,E=A+(D<<20&4294967295|D>>>12),D=I+(A^_&(E^A))+R[5]+3593408605&4294967295,I=E+(D<<5&4294967295|D>>>27),D=_+(E^A&(I^E))+R[10]+38016083&4294967295,_=I+(D<<9&4294967295|D>>>23),D=A+(I^E&(_^I))+R[15]+3634488961&4294967295,A=_+(D<<14&4294967295|D>>>18),D=E+(_^I&(A^_))+R[4]+3889429448&4294967295,E=A+(D<<20&4294967295|D>>>12),D=I+(A^_&(E^A))+R[9]+568446438&4294967295,I=E+(D<<5&4294967295|D>>>27),D=_+(E^A&(I^E))+R[14]+3275163606&4294967295,_=I+(D<<9&4294967295|D>>>23),D=A+(I^E&(_^I))+R[3]+4107603335&4294967295,A=_+(D<<14&4294967295|D>>>18),D=E+(_^I&(A^_))+R[8]+1163531501&4294967295,E=A+(D<<20&4294967295|D>>>12),D=I+(A^_&(E^A))+R[13]+2850285829&4294967295,I=E+(D<<5&4294967295|D>>>27),D=_+(E^A&(I^E))+R[2]+4243563512&4294967295,_=I+(D<<9&4294967295|D>>>23),D=A+(I^E&(_^I))+R[7]+1735328473&4294967295,A=_+(D<<14&4294967295|D>>>18),D=E+(_^I&(A^_))+R[12]+2368359562&4294967295,E=A+(D<<20&4294967295|D>>>12),D=I+(E^A^_)+R[5]+4294588738&4294967295,I=E+(D<<4&4294967295|D>>>28),D=_+(I^E^A)+R[8]+2272392833&4294967295,_=I+(D<<11&4294967295|D>>>21),D=A+(_^I^E)+R[11]+1839030562&4294967295,A=_+(D<<16&4294967295|D>>>16),D=E+(A^_^I)+R[14]+4259657740&4294967295,E=A+(D<<23&4294967295|D>>>9),D=I+(E^A^_)+R[1]+2763975236&4294967295,I=E+(D<<4&4294967295|D>>>28),D=_+(I^E^A)+R[4]+1272893353&4294967295,_=I+(D<<11&4294967295|D>>>21),D=A+(_^I^E)+R[7]+4139469664&4294967295,A=_+(D<<16&4294967295|D>>>16),D=E+(A^_^I)+R[10]+3200236656&4294967295,E=A+(D<<23&4294967295|D>>>9),D=I+(E^A^_)+R[13]+681279174&4294967295,I=E+(D<<4&4294967295|D>>>28),D=_+(I^E^A)+R[0]+3936430074&4294967295,_=I+(D<<11&4294967295|D>>>21),D=A+(_^I^E)+R[3]+3572445317&4294967295,A=_+(D<<16&4294967295|D>>>16),D=E+(A^_^I)+R[6]+76029189&4294967295,E=A+(D<<23&4294967295|D>>>9),D=I+(E^A^_)+R[9]+3654602809&4294967295,I=E+(D<<4&4294967295|D>>>28),D=_+(I^E^A)+R[12]+3873151461&4294967295,_=I+(D<<11&4294967295|D>>>21),D=A+(_^I^E)+R[15]+530742520&4294967295,A=_+(D<<16&4294967295|D>>>16),D=E+(A^_^I)+R[2]+3299628645&4294967295,E=A+(D<<23&4294967295|D>>>9),D=I+(A^(E|~_))+R[0]+4096336452&4294967295,I=E+(D<<6&4294967295|D>>>26),D=_+(E^(I|~A))+R[7]+1126891415&4294967295,_=I+(D<<10&4294967295|D>>>22),D=A+(I^(_|~E))+R[14]+2878612391&4294967295,A=_+(D<<15&4294967295|D>>>17),D=E+(_^(A|~I))+R[5]+4237533241&4294967295,E=A+(D<<21&4294967295|D>>>11),D=I+(A^(E|~_))+R[12]+1700485571&4294967295,I=E+(D<<6&4294967295|D>>>26),D=_+(E^(I|~A))+R[3]+2399980690&4294967295,_=I+(D<<10&4294967295|D>>>22),D=A+(I^(_|~E))+R[10]+4293915773&4294967295,A=_+(D<<15&4294967295|D>>>17),D=E+(_^(A|~I))+R[1]+2240044497&4294967295,E=A+(D<<21&4294967295|D>>>11),D=I+(A^(E|~_))+R[8]+1873313359&4294967295,I=E+(D<<6&4294967295|D>>>26),D=_+(E^(I|~A))+R[15]+4264355552&4294967295,_=I+(D<<10&4294967295|D>>>22),D=A+(I^(_|~E))+R[6]+2734768916&4294967295,A=_+(D<<15&4294967295|D>>>17),D=E+(_^(A|~I))+R[13]+1309151649&4294967295,E=A+(D<<21&4294967295|D>>>11),D=I+(A^(E|~_))+R[4]+4149444226&4294967295,I=E+(D<<6&4294967295|D>>>26),D=_+(E^(I|~A))+R[11]+3174756917&4294967295,_=I+(D<<10&4294967295|D>>>22),D=A+(I^(_|~E))+R[2]+718787259&4294967295,A=_+(D<<15&4294967295|D>>>17),D=E+(_^(A|~I))+R[9]+3951481745&4294967295,S.g[0]=S.g[0]+I&4294967295,S.g[1]=S.g[1]+(A+(D<<21&4294967295|D>>>11))&4294967295,S.g[2]=S.g[2]+A&4294967295,S.g[3]=S.g[3]+_&4294967295}a.prototype.v=function(S,I){I===void 0&&(I=S.length);const E=I-this.blockSize,R=this.C;let A=this.h,_=0;for(;_<I;){if(A==0)for(;_<=E;)r(this,S,_),_+=this.blockSize;if(typeof S=="string"){for(;_<I;)if(R[A++]=S.charCodeAt(_++),A==this.blockSize){r(this,R),A=0;break}}else for(;_<I;)if(R[A++]=S[_++],A==this.blockSize){r(this,R),A=0;break}}this.h=A,this.o+=I},a.prototype.A=function(){var S=Array((this.h<56?this.blockSize:this.blockSize*2)-this.h);S[0]=128;for(var I=1;I<S.length-8;++I)S[I]=0;I=this.o*8;for(var E=S.length-8;E<S.length;++E)S[E]=I&255,I/=256;for(this.v(S),S=Array(16),I=0,E=0;E<4;++E)for(let R=0;R<32;R+=8)S[I++]=this.g[E]>>>R&255;return S};function s(S,I){var E=o;return Object.prototype.hasOwnProperty.call(E,S)?E[S]:E[S]=I(S)}function i(S,I){this.h=I;const E=[];let R=!0;for(let A=S.length-1;A>=0;A--){const _=S[A]|0;R&&_==I||(E[A]=_,R=!1)}this.g=E}var o={};function l(S){return-128<=S&&S<128?s(S,function(I){return new i([I|0],I<0?-1:0)}):new i([S|0],S<0?-1:0)}function c(S){if(isNaN(S)||!isFinite(S))return h;if(S<0)return g(c(-S));const I=[];let E=1;for(let R=0;S>=E;R++)I[R]=S/E|0,E*=4294967296;return new i(I,0)}function u(S,I){if(S.length==0)throw Error("number format error: empty string");if(I=I||10,I<2||36<I)throw Error("radix out of range: "+I);if(S.charAt(0)=="-")return g(u(S.substring(1),I));if(S.indexOf("-")>=0)throw Error('number format error: interior "-" character');const E=c(Math.pow(I,8));let R=h;for(let _=0;_<S.length;_+=8){var A=Math.min(8,S.length-_);const D=parseInt(S.substring(_,_+A),I);A<8?(A=c(Math.pow(I,A)),R=R.j(A).add(c(D))):(R=R.j(E),R=R.add(c(D)))}return R}var h=l(0),d=l(1),p=l(16777216);e=i.prototype,e.m=function(){if(m(this))return-g(this).m();let S=0,I=1;for(let E=0;E<this.g.length;E++){const R=this.i(E);S+=(R>=0?R:4294967296+R)*I,I*=4294967296}return S},e.toString=function(S){if(S=S||10,S<2||36<S)throw Error("radix out of range: "+S);if(f(this))return"0";if(m(this))return"-"+g(this).toString(S);const I=c(Math.pow(S,6));var E=this;let R="";for(;;){const A=w(E,I).g;E=y(E,A.j(I));let _=((E.g.length>0?E.g[0]:E.h)>>>0).toString(S);if(E=A,f(E))return _+R;for(;_.length<6;)_="0"+_;R=_+R}},e.i=function(S){return S<0?0:S<this.g.length?this.g[S]:this.h};function f(S){if(S.h!=0)return!1;for(let I=0;I<S.g.length;I++)if(S.g[I]!=0)return!1;return!0}function m(S){return S.h==-1}e.l=function(S){return S=y(this,S),m(S)?-1:f(S)?0:1};function g(S){const I=S.g.length,E=[];for(let R=0;R<I;R++)E[R]=~S.g[R];return new i(E,~S.h).add(d)}e.abs=function(){return m(this)?g(this):this},e.add=function(S){const I=Math.max(this.g.length,S.g.length),E=[];let R=0;for(let A=0;A<=I;A++){let _=R+(this.i(A)&65535)+(S.i(A)&65535),D=(_>>>16)+(this.i(A)>>>16)+(S.i(A)>>>16);R=D>>>16,_&=65535,D&=65535,E[A]=D<<16|_}return new i(E,E[E.length-1]&-2147483648?-1:0)};function y(S,I){return S.add(g(I))}e.j=function(S){if(f(this)||f(S))return h;if(m(this))return m(S)?g(this).j(g(S)):g(g(this).j(S));if(m(S))return g(this.j(g(S)));if(this.l(p)<0&&S.l(p)<0)return c(this.m()*S.m());const I=this.g.length+S.g.length,E=[];for(var R=0;R<2*I;R++)E[R]=0;for(R=0;R<this.g.length;R++)for(let A=0;A<S.g.length;A++){const _=this.i(R)>>>16,D=this.i(R)&65535,j=S.i(A)>>>16,q=S.i(A)&65535;E[2*R+2*A]+=D*q,v(E,2*R+2*A),E[2*R+2*A+1]+=_*q,v(E,2*R+2*A+1),E[2*R+2*A+1]+=D*j,v(E,2*R+2*A+1),E[2*R+2*A+2]+=_*j,v(E,2*R+2*A+2)}for(S=0;S<I;S++)E[S]=E[2*S+1]<<16|E[2*S];for(S=I;S<2*I;S++)E[S]=0;return new i(E,0)};function v(S,I){for(;(S[I]&65535)!=S[I];)S[I+1]+=S[I]>>>16,S[I]&=65535,I++}function x(S,I){this.g=S,this.h=I}function w(S,I){if(f(I))throw Error("division by zero");if(f(S))return new x(h,h);if(m(S))return I=w(g(S),I),new x(g(I.g),g(I.h));if(m(I))return I=w(S,g(I)),new x(g(I.g),I.h);if(S.g.length>30){if(m(S)||m(I))throw Error("slowDivide_ only works with positive integers.");for(var E=d,R=I;R.l(S)<=0;)E=k(E),R=k(R);var A=M(E,1),_=M(R,1);for(R=M(R,2),E=M(E,2);!f(R);){var D=_.add(R);D.l(S)<=0&&(A=A.add(E),_=D),R=M(R,1),E=M(E,1)}return I=y(S,A.j(I)),new x(A,I)}for(A=h;S.l(I)>=0;){for(E=Math.max(1,Math.floor(S.m()/I.m())),R=Math.ceil(Math.log(E)/Math.LN2),R=R<=48?1:Math.pow(2,R-48),_=c(E),D=_.j(I);m(D)||D.l(S)>0;)E-=R,_=c(E),D=_.j(I);f(_)&&(_=d),A=A.add(_),S=y(S,D)}return new x(A,S)}e.B=function(S){return w(this,S).h},e.and=function(S){const I=Math.max(this.g.length,S.g.length),E=[];for(let R=0;R<I;R++)E[R]=this.i(R)&S.i(R);return new i(E,this.h&S.h)},e.or=function(S){const I=Math.max(this.g.length,S.g.length),E=[];for(let R=0;R<I;R++)E[R]=this.i(R)|S.i(R);return new i(E,this.h|S.h)},e.xor=function(S){const I=Math.max(this.g.length,S.g.length),E=[];for(let R=0;R<I;R++)E[R]=this.i(R)^S.i(R);return new i(E,this.h^S.h)};function k(S){const I=S.g.length+1,E=[];for(let R=0;R<I;R++)E[R]=S.i(R)<<1|S.i(R-1)>>>31;return new i(E,S.h)}function M(S,I){const E=I>>5;I%=32;const R=S.g.length-E,A=[];for(let _=0;_<R;_++)A[_]=I>0?S.i(_+E)>>>I|S.i(_+E+1)<<32-I:S.i(_+E);return new i(A,S.h)}a.prototype.digest=a.prototype.A,a.prototype.reset=a.prototype.u,a.prototype.update=a.prototype.v,qG=a,i.prototype.add=i.prototype.add,i.prototype.multiply=i.prototype.j,i.prototype.modulo=i.prototype.B,i.prototype.compare=i.prototype.l,i.prototype.toNumber=i.prototype.m,i.prototype.toString=i.prototype.toString,i.prototype.getBits=i.prototype.i,i.fromNumber=c,i.fromString=u,Ml=i}).apply(typeof vO<"u"?vO:typeof self<"u"?self:typeof window<"u"?window:{});var fx=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/var KG,$g,XG,Gx,iT,QG,YG,ZG;(function(){var e,t=Object.defineProperty;function n(b){b=[typeof globalThis=="object"&&globalThis,b,typeof window=="object"&&window,typeof self=="object"&&self,typeof fx=="object"&&fx];for(var T=0;T<b.length;++T){var $=b[T];if($&&$.Math==Math)return $}throw Error("Cannot find global object")}var a=n(this);function r(b,T){if(T)e:{var $=a;b=b.split(".");for(var L=0;L<b.length-1;L++){var te=b[L];if(!(te in $))break e;$=$[te]}b=b[b.length-1],L=$[b],T=T(L),T!=L&&T!=null&&t($,b,{configurable:!0,writable:!0,value:T})}}r("Symbol.dispose",function(b){return b||Symbol("Symbol.dispose")}),r("Array.prototype.values",function(b){return b||function(){return this[Symbol.iterator]()}}),r("Object.entries",function(b){return b||function(T){var $=[],L;for(L in T)Object.prototype.hasOwnProperty.call(T,L)&&$.push([L,T[L]]);return $}});/** @license

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/var s=s||{},i=this||self;function o(b){var T=typeof b;return T=="object"&&b!=null||T=="function"}function l(b,T,$){return b.call.apply(b.bind,arguments)}function c(b,T,$){return c=l,c.apply(null,arguments)}function u(b,T){var $=Array.prototype.slice.call(arguments,1);return function(){var L=$.slice();return L.push.apply(L,arguments),b.apply(this,L)}}function h(b,T){function $(){}$.prototype=T.prototype,b.Z=T.prototype,b.prototype=new $,b.prototype.constructor=b,b.Ob=function(L,te,se){for(var we=Array(arguments.length-2),yt=2;yt<arguments.length;yt++)we[yt-2]=arguments[yt];return T.prototype[te].apply(L,we)}}var d=typeof AsyncContext<"u"&&typeof AsyncContext.Snapshot=="function"?b=>b&&AsyncContext.Snapshot.wrap(b):b=>b;function p(b){const T=b.length;if(T>0){const $=Array(T);for(let L=0;L<T;L++)$[L]=b[L];return $}return[]}function f(b,T){for(let L=1;L<arguments.length;L++){const te=arguments[L];var $=typeof te;if($=$!="object"?$:te?Array.isArray(te)?"array":$:"null",$=="array"||$=="object"&&typeof te.length=="number"){$=b.length||0;const se=te.length||0;b.length=$+se;for(let we=0;we<se;we++)b[$+we]=te[we]}else b.push(te)}}class m{constructor(T,$){this.i=T,this.j=$,this.h=0,this.g=null}get(){let T;return this.h>0?(this.h--,T=this.g,this.g=T.next,T.next=null):T=this.i(),T}}function g(b){i.setTimeout(()=>{throw b},0)}function y(){var b=S;let T=null;return b.g&&(T=b.g,b.g=b.g.next,b.g||(b.h=null),T.next=null),T}class v{constructor(){this.h=this.g=null}add(T,$){const L=x.get();L.set(T,$),this.h?this.h.next=L:this.g=L,this.h=L}}var x=new m(()=>new w,b=>b.reset());class w{constructor(){this.next=this.g=this.h=null}set(T,$){this.h=T,this.g=$,this.next=null}reset(){this.next=this.g=this.h=null}}let k,M=!1,S=new v,I=()=>{const b=Promise.resolve(void 0);k=()=>{b.then(E)}};function E(){for(var b;b=y();){try{b.h.call(b.g)}catch($){g($)}var T=x;T.j(b),T.h<100&&(T.h++,b.next=T.g,T.g=b)}M=!1}function R(){this.u=this.u,this.C=this.C}R.prototype.u=!1,R.prototype.dispose=function(){this.u||(this.u=!0,this.N())},R.prototype[Symbol.dispose]=function(){this.dispose()},R.prototype.N=function(){if(this.C)for(;this.C.length;)this.C.shift()()};function A(b,T){this.type=b,this.g=this.target=T,this.defaultPrevented=!1}A.prototype.h=function(){this.defaultPrevented=!0};var _=function(){if(!i.addEventListener||!Object.defineProperty)return!1;var b=!1,T=Object.defineProperty({},"passive",{get:function(){b=!0}});try{const $=()=>{};i.addEventListener("test",$,T),i.removeEventListener("test",$,T)}catch{}return b}();function D(b){return/^[\s\xa0]*$/.test(b)}function j(b,T){A.call(this,b?b.type:""),this.relatedTarget=this.g=this.target=null,this.button=this.screenY=this.screenX=this.clientY=this.clientX=0,this.key="",this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1,this.state=null,this.pointerId=0,this.pointerType="",this.i=null,b&&this.init(b,T)}h(j,A),j.prototype.init=function(b,T){const $=this.type=b.type,L=b.changedTouches&&b.changedTouches.length?b.changedTouches[0]:null;this.target=b.target||b.srcElement,this.g=T,T=b.relatedTarget,T||($=="mouseover"?T=b.fromElement:$=="mouseout"&&(T=b.toElement)),this.relatedTarget=T,L?(this.clientX=L.clientX!==void 0?L.clientX:L.pageX,this.clientY=L.clientY!==void 0?L.clientY:L.pageY,this.screenX=L.screenX||0,this.screenY=L.screenY||0):(this.clientX=b.clientX!==void 0?b.clientX:b.pageX,this.clientY=b.clientY!==void 0?b.clientY:b.pageY,this.screenX=b.screenX||0,this.screenY=b.screenY||0),this.button=b.button,this.key=b.key||"",this.ctrlKey=b.ctrlKey,this.altKey=b.altKey,this.shiftKey=b.shiftKey,this.metaKey=b.metaKey,this.pointerId=b.pointerId||0,this.pointerType=b.pointerType,this.state=b.state,this.i=b,b.defaultPrevented&&j.Z.h.call(this)},j.prototype.h=function(){j.Z.h.call(this);const b=this.i;b.preventDefault?b.preventDefault():b.returnValue=!1};var q="closure_listenable_"+(Math.random()*1e6|0),B=0;function Q(b,T,$,L,te){this.listener=b,this.proxy=null,this.src=T,this.type=$,this.capture=!!L,this.ha=te,this.key=++B,this.da=this.fa=!1}function H(b){b.da=!0,b.listener=null,b.proxy=null,b.src=null,b.ha=null}function J(b,T,$){for(const L in b)T.call($,b[L],L,b)}function ae(b,T){for(const $ in b)T.call(void 0,b[$],$,b)}function ne(b){const T={};for(const $ in b)T[$]=b[$];return T}const ue="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function le(b,T){let $,L;for(let te=1;te<arguments.length;te++){L=arguments[te];for($ in L)b[$]=L[$];for(let se=0;se<ue.length;se++)$=ue[se],Object.prototype.hasOwnProperty.call(L,$)&&(b[$]=L[$])}}function he(b){this.src=b,this.g={},this.h=0}he.prototype.add=function(b,T,$,L,te){const se=b.toString();b=this.g[se],b||(b=this.g[se]=[],this.h++);const we=Re(b,T,L,te);return we>-1?(T=b[we],$||(T.fa=!1)):(T=new Q(T,this.src,se,!!L,te),T.fa=$,b.push(T)),T};function me(b,T){const $=T.type;if($ in b.g){var L=b.g[$],te=Array.prototype.indexOf.call(L,T,void 0),se;(se=te>=0)&&Array.prototype.splice.call(L,te,1),se&&(H(T),b.g[$].length==0&&(delete b.g[$],b.h--))}}function Re(b,T,$,L){for(let te=0;te<b.length;++te){const se=b[te];if(!se.da&&se.listener==T&&se.capture==!!$&&se.ha==L)return te}return-1}var Ne="closure_lm_"+(Math.random()*1e6|0),xe={};function Le(b,T,$,L,te){if(Array.isArray(T)){for(let se=0;se<T.length;se++)Le(b,T[se],$,L,te);return null}return $=Ot($),b&&b[q]?b.J(T,$,o(L)?!!L.capture:!1,te):Pe(b,T,$,!1,L,te)}function Pe(b,T,$,L,te,se){if(!T)throw Error("Invalid event type");const we=o(te)?!!te.capture:!!te;let yt=je(b);if(yt||(b[Ne]=yt=new he(b)),$=yt.add(T,$,L,we,se),$.proxy)return $;if(L=Xe(),$.proxy=L,L.src=b,L.listener=$,b.addEventListener)_||(te=we),te===void 0&&(te=!1),b.addEventListener(T.toString(),L,te);else if(b.attachEvent)b.attachEvent(st(T.toString()),L);else if(b.addListener&&b.removeListener)b.addListener(L);else throw Error("addEventListener and attachEvent are unavailable.");return $}function Xe(){function b($){return T.call(b.src,b.listener,$)}const T=bt;return b}function Ue(b,T,$,L,te){if(Array.isArray(T))for(var se=0;se<T.length;se++)Ue(b,T[se],$,L,te);else L=o(L)?!!L.capture:!!L,$=Ot($),b&&b[q]?(b=b.i,se=String(T).toString(),se in b.g&&(T=b.g[se],$=Re(T,$,L,te),$>-1&&(H(T[$]),Array.prototype.splice.call(T,$,1),T.length==0&&(delete b.g[se],b.h--)))):b&&(b=je(b))&&(T=b.g[T.toString()],b=-1,T&&(b=Re(T,$,L,te)),($=b>-1?T[b]:null)&&Et($))}function Et(b){if(typeof b!="number"&&b&&!b.da){var T=b.src;if(T&&T[q])me(T.i,b);else{var $=b.type,L=b.proxy;T.removeEventListener?T.removeEventListener($,L,b.capture):T.detachEvent?T.detachEvent(st($),L):T.addListener&&T.removeListener&&T.removeListener(L),($=je(T))?(me($,b),$.h==0&&($.src=null,T[Ne]=null)):H(b)}}}function st(b){return b in xe?xe[b]:xe[b]="on"+b}function bt(b,T){if(b.da)b=!0;else{T=new j(T,this);const $=b.listener,L=b.ha||b.src;b.fa&&Et(b),b=$.call(L,T)}return b}function je(b){return b=b[Ne],b instanceof he?b:null}var gt="__closure_events_fn_"+(Math.random()*1e9>>>0);function Ot(b){return typeof b=="function"?b:(b[gt]||(b[gt]=function(T){return b.handleEvent(T)}),b[gt])}function At(){R.call(this),this.i=new he(this),this.M=this,this.G=null}h(At,R),At.prototype[q]=!0,At.prototype.removeEventListener=function(b,T,$,L){Ue(this,b,T,$,L)};function pt(b,T){var $,L=b.G;if(L)for($=[];L;L=L.G)$.push(L);if(b=b.M,L=T.type||T,typeof T=="string")T=new A(T,b);else if(T instanceof A)T.target=T.target||b;else{var te=T;T=new A(L,b),le(T,te)}te=!0;let se,we;if($)for(we=$.length-1;we>=0;we--)se=T.g=$[we],te=Nn(se,L,!0,T)&&te;if(se=T.g=b,te=Nn(se,L,!0,T)&&te,te=Nn(se,L,!1,T)&&te,$)for(we=0;we<$.length;we++)se=T.g=$[we],te=Nn(se,L,!1,T)&&te}At.prototype.N=function(){if(At.Z.N.call(this),this.i){var b=this.i;for(const T in b.g){const $=b.g[T];for(let L=0;L<$.length;L++)H($[L]);delete b.g[T],b.h--}}this.G=null},At.prototype.J=function(b,T,$,L){return this.i.add(String(b),T,!1,$,L)},At.prototype.K=function(b,T,$,L){return this.i.add(String(b),T,!0,$,L)};function Nn(b,T,$,L){if(T=b.i.g[String(T)],!T)return!0;T=T.concat();let te=!0;for(let se=0;se<T.length;++se){const we=T[se];if(we&&!we.da&&we.capture==$){const yt=we.listener,la=we.ha||we.src;we.fa&&me(b.i,we),te=yt.call(la,L)!==!1&&te}}return te&&!L.defaultPrevented}function Cn(b,T){if(typeof b!="function")if(b&&typeof b.handleEvent=="function")b=c(b.handleEvent,b);else throw Error("Invalid listener argument");return Number(T)>2147483647?-1:i.setTimeout(b,T||0)}function ge(b){b.g=Cn(()=>{b.g=null,b.i&&(b.i=!1,ge(b))},b.l);const T=b.h;b.h=null,b.m.apply(null,T)}class Ze extends R{constructor(T,$){super(),this.m=T,this.l=$,this.h=null,this.i=!1,this.g=null}j(T){this.h=arguments,this.g?this.i=!0:ge(this)}N(){super.N(),this.g&&(i.clearTimeout(this.g),this.g=null,this.i=!1,this.h=null)}}function ht(b){R.call(this),this.h=b,this.g={}}h(ht,R);var kn=[];function vn(b){J(b.g,function(T,$){this.g.hasOwnProperty($)&&Et(T)},b),b.g={}}ht.prototype.N=function(){ht.Z.N.call(this),vn(this)},ht.prototype.handleEvent=function(){throw Error("EventHandler.handleEvent not implemented")};var Da=i.JSON.stringify,ii=i.JSON.parse,Cu=class{stringify(b){return i.JSON.stringify(b,void 0)}parse(b){return i.JSON.parse(b,void 0)}};function ps(){}function Bo(){}var Ga={OPEN:"a",hb:"b",ERROR:"c",tb:"d"};function fs(){A.call(this,"d")}h(fs,A);function An(){A.call(this,"c")}h(An,A);var ms={},Au=null;function Ki(){return Au=Au||new At}ms.Ia="serverreachability";function Ru(b){A.call(this,ms.Ia,b)}h(Ru,A);function or(b){const T=Ki();pt(T,new Ru(T))}ms.STAT_EVENT="statevent";function Xi(b,T){A.call(this,ms.STAT_EVENT,b),this.stat=T}h(Xi,A);function Gn(b){const T=Ki();pt(T,new Xi(T,b))}ms.Ja="timingevent";function oi(b,T){A.call(this,ms.Ja,b),this.size=T}h(oi,A);function Wr(b,T){if(typeof b!="function")throw Error("Fn must not be null and must be a function");return i.setTimeout(function(){b()},T)}function li(){this.g=!0}li.prototype.ua=function(){this.g=!1};function oe(b,T,$,L,te,se){b.info(function(){if(b.g)if(se){var we="",yt=se.split("&");for(let an=0;an<yt.length;an++){var la=yt[an].split("=");if(la.length>1){const Sa=la[0];la=la[1];const di=Sa.split("_");we=di.length>=2&&di[1]=="type"?we+(Sa+"="+la+"&"):we+(Sa+"=redacted&")}}}else we=null;else we=se;return"XMLHTTP REQ ("+L+") [attempt "+te+"]: "+T+`
`+$+`
`+we})}function ve(b,T,$,L,te,se,we){b.info(function(){return"XMLHTTP RESP ("+L+") [ attempt "+te+"]: "+T+`
`+$+`
`+se+" "+we})}function Oe(b,T,$,L){b.info(function(){return"XMLHTTP TEXT ("+T+"): "+Gt(b,$)+(L?" "+L:"")})}function ke(b,T){b.info(function(){return"TIMEOUT: "+T})}li.prototype.info=function(){};function Gt(b,T){if(!b.g)return T;if(!T)return null;try{const se=JSON.parse(T);if(se){for(b=0;b<se.length;b++)if(Array.isArray(se[b])){var $=se[b];if(!($.length<2)){var L=$[1];if(Array.isArray(L)&&!(L.length<1)){var te=L[0];if(te!="noop"&&te!="stop"&&te!="close")for(let we=1;we<L.length;we++)L[we]=""}}}}return Da(se)}catch{return T}}var Pt={NO_ERROR:0,cb:1,qb:2,pb:3,kb:4,ob:5,rb:6,Ga:7,TIMEOUT:8,ub:9},it={ib:"complete",Fb:"success",ERROR:"error",Ga:"abort",xb:"ready",yb:"readystatechange",TIMEOUT:"timeout",sb:"incrementaldata",wb:"progress",lb:"downloadprogress",Nb:"uploadprogress"},Je;function hn(){}h(hn,ps),hn.prototype.g=function(){return new XMLHttpRequest},Je=new hn;function oa(b){return encodeURIComponent(String(b))}function zs(b){var T=1;b=b.split(":");const $=[];for(;T>0&&b.length;)$.push(b.shift()),T--;return b.length&&$.push(b.join(":")),$}function jr(b,T,$,L){this.j=b,this.i=T,this.l=$,this.S=L||1,this.V=new ht(this),this.H=45e3,this.J=null,this.o=!1,this.u=this.B=this.A=this.M=this.F=this.T=this.D=null,this.G=[],this.g=null,this.C=0,this.m=this.v=null,this.X=-1,this.K=!1,this.P=0,this.O=null,this.W=this.L=this.U=this.R=!1,this.h=new Uo}function Uo(){this.i=null,this.g="",this.h=!1}var Du={},Hn={};function gs(b,T,$){b.M=1,b.A=Fu(Gr(T)),b.u=$,b.R=!0,$u(b,null)}function $u(b,T){b.F=Date.now(),Dd(b),b.B=Gr(b.A);var $=b.B,L=b.S;Array.isArray(L)||(L=[String(L)]),Pu($.i,"t",L),b.C=0,$=b.j.L,b.h=new Uo,b.g=UR(b.j,$?T:null,!b.u),b.P>0&&(b.O=new Ze(c(b.Y,b,b.g),b.P)),T=b.V,$=b.g,L=b.ba;var te="readystatechange";Array.isArray(te)||(te&&(kn[0]=te.toString()),te=kn);for(let se=0;se<te.length;se++){const we=Le($,te[se],L||T.handleEvent,!1,T.h||T);if(!we)break;T.g[we.key]=we}T=b.J?ne(b.J):{},b.u?(b.v||(b.v="POST"),T["Content-Type"]="application/x-www-form-urlencoded",b.g.ea(b.B,b.v,b.u,T)):(b.v="GET",b.g.ea(b.B,b.v,null,T)),or(),oe(b.i,b.v,b.B,b.l,b.S,b.u)}jr.prototype.ba=function(b){b=b.target;const T=this.O;T&&ur(b)==3?T.j():this.Y(b)},jr.prototype.Y=function(b){try{if(b==this.g)e:{const yt=ur(this.g),la=this.g.ya(),an=this.g.ca();if(!(yt<3)&&(yt!=3||this.g&&(this.h.h||this.g.la()||ag(this.g)))){this.K||yt!=4||la==7||(la==8||an<=0?or(3):or(2)),Qi(this);var T=this.g.ca();this.X=T;var $=A_(this);if(this.o=T==200,ve(this.i,this.v,this.B,this.l,this.S,yt,T),this.o){if(this.U&&!this.L){t:{if(this.g){var L,te=this.g;if((L=te.g?te.g.getResponseHeader("X-HTTP-Initial-Response"):null)&&!D(L)){var se=L;break t}}se=null}if(b=se)Oe(this.i,this.l,b,"Initial handshake response via X-HTTP-Initial-Response"),this.L=!0,$d(this,b);else{this.o=!1,this.m=3,Gn(12),Yi(this),Mu(this);break e}}if(this.R){b=!0;let Sa;for(;!this.K&&this.C<$.length;)if(Sa=R_(this,$),Sa==Hn){yt==4&&(this.m=4,Gn(14),b=!1),Oe(this.i,this.l,null,"[Incomplete Response]");break}else if(Sa==Du){this.m=4,Gn(15),Oe(this.i,this.l,$,"[Invalid Chunk]"),b=!1;break}else Oe(this.i,this.l,Sa,null),$d(this,Sa);if(Rd(this)&&this.C!=0&&(this.h.g=this.h.g.slice(this.C),this.C=0),yt!=4||$.length!=0||this.h.h||(this.m=1,Gn(16),b=!1),this.o=this.o&&b,!b)Oe(this.i,this.l,$,"[Invalid Chunked Response]"),Yi(this),Mu(this);else if($.length>0&&!this.W){this.W=!0;var we=this.j;we.g==this&&we.aa&&!we.P&&(we.j.info("Great, no buffering proxy detected. Bytes received: "+$.length),L_(we),we.P=!0,Gn(11))}}else Oe(this.i,this.l,$,null),$d(this,$);yt==4&&Yi(this),this.o&&!this.K&&(yt==4?zR(this.j,this):(this.o=!1,Dd(this)))}else A8(this.g),T==400&&$.indexOf("Unknown SID")>0?(this.m=3,Gn(12)):(this.m=0,Gn(13)),Yi(this),Mu(this)}}}catch{}finally{}};function A_(b){if(!Rd(b))return b.g.la();const T=ag(b.g);if(T==="")return"";let $="";const L=T.length,te=ur(b.g)==4;if(!b.h.i){if(typeof TextDecoder>"u")return Yi(b),Mu(b),"";b.h.i=new i.TextDecoder}for(let se=0;se<L;se++)b.h.h=!0,$+=b.h.i.decode(T[se],{stream:!(te&&se==L-1)});return T.length=0,b.h.g+=$,b.C=0,b.h.g}function Rd(b){return b.g?b.v=="GET"&&b.M!=2&&b.j.Aa:!1}function R_(b,T){var $=b.C,L=T.indexOf(`
`,$);return L==-1?Hn:($=Number(T.substring($,L)),isNaN($)?Du:(L+=1,L+$>T.length?Hn:(T=T.slice(L,L+$),b.C=L+$,T)))}jr.prototype.cancel=function(){this.K=!0,Yi(this)};function Dd(b){b.T=Date.now()+b.H,vv(b,b.H)}function vv(b,T){if(b.D!=null)throw Error("WatchDog timer not null");b.D=Wr(c(b.aa,b),T)}function Qi(b){b.D&&(i.clearTimeout(b.D),b.D=null)}jr.prototype.aa=function(){this.D=null;const b=Date.now();b-this.T>=0?(ke(this.i,this.B),this.M!=2&&(or(),Gn(17)),Yi(this),this.m=2,Mu(this)):vv(this,this.T-b)};function Mu(b){b.j.I==0||b.K||zR(b.j,b)}function Yi(b){Qi(b);var T=b.O;T&&typeof T.dispose=="function"&&T.dispose(),b.O=null,vn(b.V),b.g&&(T=b.g,b.g=null,T.abort(),T.dispose())}function $d(b,T){try{var $=b.j;if($.I!=0&&($.g==b||Zm($.h,b))){if(!b.L&&Zm($.h,b)&&$.I==3){try{var L=$.Ba.g.parse(T)}catch{L=null}if(Array.isArray(L)&&L.length==3){var te=L;if(te[0]==0){e:if(!$.v){if($.g)if($.g.F+3e3<b.F)Dv($),Av($);else break e;F_($),Gn(18)}}else $.xa=te[1],0<$.xa-$.K&&te[2]<37500&&$.F&&$.A==0&&!$.C&&($.C=Wr(c($.Va,$),6e3));wv($.h)<=1&&$.ta&&($.ta=void 0)}else Bu($,11)}else if((b.L||$.g==b)&&Dv($),!D(T))for(te=$.Ba.g.parse(T),T=0;T<te.length;T++){let an=te[T];const Sa=an[0];if(!(Sa<=$.K))if($.K=Sa,an=an[1],$.I==2)if(an[0]=="c"){$.M=an[1],$.ba=an[2];const di=an[3];di!=null&&($.ka=di,$.j.info("VER="+$.ka));const Uu=an[4];Uu!=null&&($.za=Uu,$.j.info("SVER="+$.za));const Go=an[5];Go!=null&&typeof Go=="number"&&Go>0&&(L=1.5*Go,$.O=L,$.j.info("backChannelRequestTimeoutMs_="+L)),L=$;const Ho=b.g;if(Ho){const Mv=Ho.g?Ho.g.getResponseHeader("X-Client-Wire-Protocol"):null;if(Mv){var se=L.h;se.g||Mv.indexOf("spdy")==-1&&Mv.indexOf("quic")==-1&&Mv.indexOf("h2")==-1||(se.j=se.l,se.g=new Set,se.h&&(ui(se,se.h),se.h=null))}if(L.G){const z_=Ho.g?Ho.g.getResponseHeader("X-HTTP-Session-Id"):null;z_&&(L.wa=z_,Jt(L.J,L.G,z_))}}$.I=3,$.l&&$.l.ra(),$.aa&&($.T=Date.now()-b.F,$.j.info("Handshake RTT: "+$.T+"ms")),L=$;var we=b;if(L.na=BR(L,L.L?L.ba:null,L.W),we.L){Od(L.h,we);var yt=we,la=L.O;la&&(yt.H=la),yt.D&&(Qi(yt),Dd(yt)),L.g=we}else FR(L);$.i.length>0&&Rv($)}else an[0]!="stop"&&an[0]!="close"||Bu($,7);else $.I==3&&(an[0]=="stop"||an[0]=="close"?an[0]=="stop"?Bu($,7):O_($):an[0]!="noop"&&$.l&&$.l.qa(an),$.A=0)}}or(4)}catch{}}var D_=class{constructor(b,T){this.g=b,this.map=T}};function Md(b){this.l=b||10,i.PerformanceNavigationTiming?(b=i.performance.getEntriesByType("navigation"),b=b.length>0&&(b[0].nextHopProtocol=="hq"||b[0].nextHopProtocol=="h2")):b=!!(i.chrome&&i.chrome.loadTimes&&i.chrome.loadTimes()&&i.chrome.loadTimes().wasFetchedViaSpdy),this.j=b?this.l:1,this.g=null,this.j>1&&(this.g=new Set),this.h=null,this.i=[]}function xv(b){return b.h?!0:b.g?b.g.size>=b.j:!1}function wv(b){return b.h?1:b.g?b.g.size:0}function Zm(b,T){return b.h?b.h==T:b.g?b.g.has(T):!1}function ui(b,T){b.g?b.g.add(T):b.h=T}function Od(b,T){b.h&&b.h==T?b.h=null:b.g&&b.g.has(T)&&b.g.delete(T)}Md.prototype.cancel=function(){if(this.i=_v(this),this.h)this.h.cancel(),this.h=null;else if(this.g&&this.g.size!==0){for(const b of this.g.values())b.cancel();this.g.clear()}};function _v(b){if(b.h!=null)return b.i.concat(b.h.G);if(b.g!=null&&b.g.size!==0){let T=b.i;for(const $ of b.g.values())T=T.concat($.G);return T}return p(b.i)}var Sv=RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");function $_(b,T){if(b){b=b.split("&");for(let $=0;$<b.length;$++){const L=b[$].indexOf("=");let te,se=null;L>=0?(te=b[$].substring(0,L),se=b[$].substring(L+1)):te=b[$],T(te,se?decodeURIComponent(se.replace(/\+/g," ")):"")}}}function ci(b){this.g=this.o=this.j="",this.u=null,this.m=this.h="",this.l=!1;let T;b instanceof ci?(this.l=b.l,Wo(this,b.j),this.o=b.o,this.g=b.g,Ou(this,b.u),this.h=b.h,Jm(this,Vu(b.i)),this.m=b.m):b&&(T=String(b).match(Sv))?(this.l=!1,Wo(this,T[1]||"",!0),this.o=Lu(T[2]||""),this.g=Lu(T[3]||"",!0),Ou(this,T[4]),this.h=Lu(T[5]||"",!0),Jm(this,T[6]||"",!0),this.m=Lu(T[7]||"")):(this.l=!1,this.i=new jo(null,this.l))}ci.prototype.toString=function(){const b=[];var T=this.j;T&&b.push(zu(T,Iv,!0),":");var $=this.g;return($||T=="file")&&(b.push("//"),(T=this.o)&&b.push(zu(T,Iv,!0),"@"),b.push(oa($).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),$=this.u,$!=null&&b.push(":",String($))),($=this.h)&&(this.g&&$.charAt(0)!="/"&&b.push("/"),b.push(zu($,$.charAt(0)=="/"?Fd:kv,!0))),($=this.i.toString())&&b.push("?",$),($=this.m)&&b.push("#",zu($,Ev)),b.join("")},ci.prototype.resolve=function(b){const T=Gr(this);let $=!!b.j;$?Wo(T,b.j):$=!!b.o,$?T.o=b.o:$=!!b.g,$?T.g=b.g:$=b.u!=null;var L=b.h;if($)Ou(T,b.u);else if($=!!b.h){if(L.charAt(0)!="/")if(this.g&&!this.h)L="/"+L;else{var te=T.h.lastIndexOf("/");te!=-1&&(L=T.h.slice(0,te+1)+L)}if(te=L,te==".."||te==".")L="";else if(te.indexOf("./")!=-1||te.indexOf("/.")!=-1){L=te.lastIndexOf("/",0)==0,te=te.split("/");const se=[];for(let we=0;we<te.length;){const yt=te[we++];yt=="."?L&&we==te.length&&se.push(""):yt==".."?((se.length>1||se.length==1&&se[0]!="")&&se.pop(),L&&we==te.length&&se.push("")):(se.push(yt),L=!0)}L=se.join("/")}else L=te}return $?T.h=L:$=b.i.toString()!=="",$?Jm(T,Vu(b.i)):$=!!b.m,$&&(T.m=b.m),T};function Gr(b){return new ci(b)}function Wo(b,T,$){b.j=$?Lu(T,!0):T,b.j&&(b.j=b.j.replace(/:$/,""))}function Ou(b,T){if(T){if(T=Number(T),isNaN(T)||T<0)throw Error("Bad port number "+T);b.u=T}else b.u=null}function Jm(b,T,$){T instanceof jo?(b.i=T,Nv(b.i,b.l)):($||(T=zu(T,Tv)),b.i=new jo(T,b.l))}function Jt(b,T,$){b.i.set(T,$)}function Fu(b){return Jt(b,"zx",Math.floor(Math.random()*2147483648).toString(36)+Math.abs(Math.floor(Math.random()*2147483648)^Date.now()).toString(36)),b}function Lu(b,T){return b?T?decodeURI(b.replace(/%25/g,"%2525")):decodeURIComponent(b):""}function zu(b,T,$){return typeof b=="string"?(b=encodeURI(b).replace(T,M_),$&&(b=b.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),b):null}function M_(b){return b=b.charCodeAt(0),"%"+(b>>4&15).toString(16)+(b&15).toString(16)}var Iv=/[#\/\?@]/g,kv=/[#\?:]/g,Fd=/[#\?]/g,Tv=/[#\?@]/g,Ev=/#/g;function jo(b,T){this.h=this.g=null,this.i=b||null,this.j=!!T}function Ps(b){b.g||(b.g=new Map,b.h=0,b.i&&$_(b.i,function(T,$){b.add(decodeURIComponent(T.replace(/\+/g," ")),$)}))}e=jo.prototype,e.add=function(b,T){Ps(this),this.i=null,b=Vs(this,b);let $=this.g.get(b);return $||this.g.set(b,$=[]),$.push(T),this.h+=1,this};function eg(b,T){Ps(b),T=Vs(b,T),b.g.has(T)&&(b.i=null,b.h-=b.g.get(T).length,b.g.delete(T))}function tg(b,T){return Ps(b),T=Vs(b,T),b.g.has(T)}e.forEach=function(b,T){Ps(this),this.g.forEach(function($,L){$.forEach(function(te){b.call(T,te,L,this)},this)},this)};function Ld(b,T){Ps(b);let $=[];if(typeof T=="string")tg(b,T)&&($=$.concat(b.g.get(Vs(b,T))));else for(b=Array.from(b.g.values()),T=0;T<b.length;T++)$=$.concat(b[T]);return $}e.set=function(b,T){return Ps(this),this.i=null,b=Vs(this,b),tg(this,b)&&(this.h-=this.g.get(b).length),this.g.set(b,[T]),this.h+=1,this},e.get=function(b,T){return b?(b=Ld(this,b),b.length>0?String(b[0]):T):T};function Pu(b,T,$){eg(b,T),$.length>0&&(b.i=null,b.g.set(Vs(b,T),p($)),b.h+=$.length)}e.toString=function(){if(this.i)return this.i;if(!this.g)return"";const b=[],T=Array.from(this.g.keys());for(let L=0;L<T.length;L++){var $=T[L];const te=oa($);$=Ld(this,$);for(let se=0;se<$.length;se++){let we=te;$[se]!==""&&(we+="="+oa($[se])),b.push(we)}}return this.i=b.join("&")};function Vu(b){const T=new jo;return T.i=b.i,b.g&&(T.g=new Map(b.g),T.h=b.h),T}function Vs(b,T){return T=String(T),b.j&&(T=T.toLowerCase()),T}function Nv(b,T){T&&!b.j&&(Ps(b),b.i=null,b.g.forEach(function($,L){const te=L.toLowerCase();L!=te&&(eg(this,L),Pu(this,te,$))},b)),b.j=T}function zd(b,T){const $=new li;if(i.Image){const L=new Image;L.onload=u(hi,$,"TestLoadImage: loaded",!0,T,L),L.onerror=u(hi,$,"TestLoadImage: error",!1,T,L),L.onabort=u(hi,$,"TestLoadImage: abort",!1,T,L),L.ontimeout=u(hi,$,"TestLoadImage: timeout",!1,T,L),i.setTimeout(function(){L.ontimeout&&L.ontimeout()},1e4),L.src=b}else T(!1)}function Pd(b,T){const $=new li,L=new AbortController,te=setTimeout(()=>{L.abort(),hi($,"TestPingServer: timeout",!1,T)},1e4);fetch(b,{signal:L.signal}).then(se=>{clearTimeout(te),se.ok?hi($,"TestPingServer: ok",!0,T):hi($,"TestPingServer: server error",!1,T)}).catch(()=>{clearTimeout(te),hi($,"TestPingServer: error",!1,T)})}function hi(b,T,$,L,te){try{te&&(te.onload=null,te.onerror=null,te.onabort=null,te.ontimeout=null),L($)}catch{}}function V(){this.g=new Cu}function ee(b){this.i=b.Sb||null,this.h=b.ab||!1}h(ee,ps),ee.prototype.g=function(){return new be(this.i,this.h)};function be(b,T){At.call(this),this.H=b,this.o=T,this.m=void 0,this.status=this.readyState=0,this.responseType=this.responseText=this.response=this.statusText="",this.onreadystatechange=null,this.A=new Headers,this.h=null,this.F="GET",this.D="",this.g=!1,this.B=this.j=this.l=null,this.v=new AbortController}h(be,At),e=be.prototype,e.open=function(b,T){if(this.readyState!=0)throw this.abort(),Error("Error reopening a connection");this.F=b,this.D=T,this.readyState=1,qe(this)},e.send=function(b){if(this.readyState!=1)throw this.abort(),Error("need to call open() first. ");if(this.v.signal.aborted)throw this.abort(),Error("Request was aborted.");this.g=!0;const T={headers:this.A,method:this.F,credentials:this.m,cache:void 0,signal:this.v.signal};b&&(T.body=b),(this.H||i).fetch(new Request(this.D,T)).then(this.Pa.bind(this),this.ga.bind(this))},e.abort=function(){this.response=this.responseText="",this.A=new Headers,this.status=0,this.v.abort(),this.j&&this.j.cancel("Request was aborted.").catch(()=>{}),this.readyState>=1&&this.g&&this.readyState!=4&&(this.g=!1,Ge(this)),this.readyState=0},e.Pa=function(b){if(this.g&&(this.l=b,this.h||(this.status=this.l.status,this.statusText=this.l.statusText,this.h=b.headers,this.readyState=2,qe(this)),this.g&&(this.readyState=3,qe(this),this.g)))if(this.responseType==="arraybuffer")b.arrayBuffer().then(this.Na.bind(this),this.ga.bind(this));else if(typeof i.ReadableStream<"u"&&"body"in b){if(this.j=b.body.getReader(),this.o){if(this.responseType)throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');this.response=[]}else this.response=this.responseText="",this.B=new TextDecoder;Be(this)}else b.text().then(this.Oa.bind(this),this.ga.bind(this))};function Be(b){b.j.read().then(b.Ma.bind(b)).catch(b.ga.bind(b))}e.Ma=function(b){if(this.g){if(this.o&&b.value)this.response.push(b.value);else if(!this.o){var T=b.value?b.value:new Uint8Array(0);(T=this.B.decode(T,{stream:!b.done}))&&(this.response=this.responseText+=T)}b.done?Ge(this):qe(this),this.readyState==3&&Be(this)}},e.Oa=function(b){this.g&&(this.response=this.responseText=b,Ge(this))},e.Na=function(b){this.g&&(this.response=b,Ge(this))},e.ga=function(){this.g&&Ge(this)};function Ge(b){b.readyState=4,b.l=null,b.j=null,b.B=null,qe(b)}e.setRequestHeader=function(b,T){this.A.append(b,T)},e.getResponseHeader=function(b){return this.h&&this.h.get(b.toLowerCase())||""},e.getAllResponseHeaders=function(){if(!this.h)return"";const b=[],T=this.h.entries();for(var $=T.next();!$.done;)$=$.value,b.push($[0]+": "+$[1]),$=T.next();return b.join(`\r
`)};function qe(b){b.onreadystatechange&&b.onreadystatechange.call(b)}Object.defineProperty(be.prototype,"withCredentials",{get:function(){return this.m==="include"},set:function(b){this.m=b?"include":"same-origin"}});function Ee(b){let T="";return J(b,function($,L){T+=L,T+=":",T+=$,T+=`\r
`}),T}function Fe(b,T,$){e:{for(L in $){var L=!1;break e}L=!0}L||($=Ee($),typeof b=="string"?$!=null&&oa($):Jt(b,T,$))}function Ye(b){At.call(this),this.headers=new Map,this.L=b||null,this.h=!1,this.g=null,this.D="",this.o=0,this.l="",this.j=this.B=this.v=this.A=!1,this.m=null,this.F="",this.H=!1}h(Ye,At);var lr=/^https?$/i,Bs=["POST","PUT"];e=Ye.prototype,e.Fa=function(b){this.H=b},e.ea=function(b,T,$,L){if(this.g)throw Error("[goog.net.XhrIo] Object is active with another request="+this.D+"; newUri="+b);T=T?T.toUpperCase():"GET",this.D=b,this.l="",this.o=0,this.A=!1,this.h=!0,this.g=this.L?this.L.g():Je.g(),this.g.onreadystatechange=d(c(this.Ca,this));try{this.B=!0,this.g.open(T,String(b),!0),this.B=!1}catch(se){ng(this,se);return}if(b=$||"",$=new Map(this.headers),L)if(Object.getPrototypeOf(L)===Object.prototype)for(var te in L)$.set(te,L[te]);else if(typeof L.keys=="function"&&typeof L.get=="function")for(const se of L.keys())$.set(se,L.get(se));else throw Error("Unknown input type for opt_headers: "+String(L));L=Array.from($.keys()).find(se=>se.toLowerCase()=="content-type"),te=i.FormData&&b instanceof i.FormData,!(Array.prototype.indexOf.call(Bs,T,void 0)>=0)||L||te||$.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");for(const[se,we]of $)this.g.setRequestHeader(se,we);this.F&&(this.g.responseType=this.F),"withCredentials"in this.g&&this.g.withCredentials!==this.H&&(this.g.withCredentials=this.H);try{this.m&&(clearTimeout(this.m),this.m=null),this.v=!0,this.g.send(b),this.v=!1}catch(se){ng(this,se)}};function ng(b,T){b.h=!1,b.g&&(b.j=!0,b.g.abort(),b.j=!1),b.l=T,b.o=5,Vd(b),_a(b)}function Vd(b){b.A||(b.A=!0,pt(b,"complete"),pt(b,"error"))}e.abort=function(b){this.g&&this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1,this.o=b||7,pt(this,"complete"),pt(this,"abort"),_a(this))},e.N=function(){this.g&&(this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1),_a(this,!0)),Ye.Z.N.call(this)},e.Ca=function(){this.u||(this.B||this.v||this.j?Cv(this):this.Xa())},e.Xa=function(){Cv(this)};function Cv(b){if(b.h&&typeof s<"u"){if(b.v&&ur(b)==4)setTimeout(b.Ca.bind(b),0);else if(pt(b,"readystatechange"),ur(b)==4){b.h=!1;try{const se=b.ca();e:switch(se){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var T=!0;break e;default:T=!1}var $;if(!($=T)){var L;if(L=se===0){let we=String(b.D).match(Sv)[1]||null;!we&&i.self&&i.self.location&&(we=i.self.location.protocol.slice(0,-1)),L=!lr.test(we?we.toLowerCase():"")}$=L}if($)pt(b,"complete"),pt(b,"success");else{b.o=6;try{var te=ur(b)>2?b.g.statusText:""}catch{te=""}b.l=te+" ["+b.ca()+"]",Vd(b)}}finally{_a(b)}}}}function _a(b,T){if(b.g){b.m&&(clearTimeout(b.m),b.m=null);const $=b.g;b.g=null,T||pt(b,"ready");try{$.onreadystatechange=null}catch{}}}e.isActive=function(){return!!this.g};function ur(b){return b.g?b.g.readyState:0}e.ca=function(){try{return ur(this)>2?this.g.status:-1}catch{return-1}},e.la=function(){try{return this.g?this.g.responseText:""}catch{return""}},e.La=function(b){if(this.g){var T=this.g.responseText;return b&&T.indexOf(b)==0&&(T=T.substring(b.length)),ii(T)}};function ag(b){try{if(!b.g)return null;if("response"in b.g)return b.g.response;switch(b.F){case"":case"text":return b.g.responseText;case"arraybuffer":if("mozResponseArrayBuffer"in b.g)return b.g.mozResponseArrayBuffer}return null}catch{return null}}function A8(b){const T={};b=(b.g&&ur(b)>=2&&b.g.getAllResponseHeaders()||"").split(`\r
`);for(let L=0;L<b.length;L++){if(D(b[L]))continue;var $=zs(b[L]);const te=$[0];if($=$[1],typeof $!="string")continue;$=$.trim();const se=T[te]||[];T[te]=se,se.push($)}ae(T,function(L){return L.join(", ")})}e.ya=function(){return this.o},e.Ha=function(){return typeof this.l=="string"?this.l:String(this.l)};function rg(b,T,$){return $&&$.internalChannelParams&&$.internalChannelParams[b]||T}function DR(b){this.za=0,this.i=[],this.j=new li,this.ba=this.na=this.J=this.W=this.g=this.wa=this.G=this.H=this.u=this.U=this.o=null,this.Ya=this.V=0,this.Sa=rg("failFast",!1,b),this.F=this.C=this.v=this.m=this.l=null,this.X=!0,this.xa=this.K=-1,this.Y=this.A=this.D=0,this.Qa=rg("baseRetryDelayMs",5e3,b),this.Za=rg("retryDelaySeedMs",1e4,b),this.Ta=rg("forwardChannelMaxRetries",2,b),this.va=rg("forwardChannelRequestTimeoutMs",2e4,b),this.ma=b&&b.xmlHttpFactory||void 0,this.Ua=b&&b.Rb||void 0,this.Aa=b&&b.useFetchStreams||!1,this.O=void 0,this.L=b&&b.supportsCrossDomainXhr||!1,this.M="",this.h=new Md(b&&b.concurrentRequestLimit),this.Ba=new V,this.S=b&&b.fastHandshake||!1,this.R=b&&b.encodeInitMessageHeaders||!1,this.S&&this.R&&(this.R=!1),this.Ra=b&&b.Pb||!1,b&&b.ua&&this.j.ua(),b&&b.forceLongPolling&&(this.X=!1),this.aa=!this.S&&this.X&&b&&b.detectBufferingProxy||!1,this.ia=void 0,b&&b.longPollingTimeout&&b.longPollingTimeout>0&&(this.ia=b.longPollingTimeout),this.ta=void 0,this.T=0,this.P=!1,this.ja=this.B=null}e=DR.prototype,e.ka=8,e.I=1,e.connect=function(b,T,$,L){Gn(0),this.W=b,this.H=T||{},$&&L!==void 0&&(this.H.OSID=$,this.H.OAID=L),this.F=this.X,this.J=BR(this,null,this.W),Rv(this)};function O_(b){if($R(b),b.I==3){var T=b.V++,$=Gr(b.J);if(Jt($,"SID",b.M),Jt($,"RID",T),Jt($,"TYPE","terminate"),sg(b,$),T=new jr(b,b.j,T),T.M=2,T.A=Fu(Gr($)),$=!1,i.navigator&&i.navigator.sendBeacon)try{$=i.navigator.sendBeacon(T.A.toString(),"")}catch{}!$&&i.Image&&(new Image().src=T.A,$=!0),$||(T.g=UR(T.j,null),T.g.ea(T.A)),T.F=Date.now(),Dd(T)}VR(b)}function Av(b){b.g&&(L_(b),b.g.cancel(),b.g=null)}function $R(b){Av(b),b.v&&(i.clearTimeout(b.v),b.v=null),Dv(b),b.h.cancel(),b.m&&(typeof b.m=="number"&&i.clearTimeout(b.m),b.m=null)}function Rv(b){if(!xv(b.h)&&!b.m){b.m=!0;var T=b.Ea;k||I(),M||(k(),M=!0),S.add(T,b),b.D=0}}function R8(b,T){return wv(b.h)>=b.h.j-(b.m?1:0)?!1:b.m?(b.i=T.G.concat(b.i),!0):b.I==1||b.I==2||b.D>=(b.Sa?0:b.Ta)?!1:(b.m=Wr(c(b.Ea,b,T),PR(b,b.D)),b.D++,!0)}e.Ea=function(b){if(this.m)if(this.m=null,this.I==1){if(!b){this.V=Math.floor(Math.random()*1e5),b=this.V++;const te=new jr(this,this.j,b);let se=this.o;if(this.U&&(se?(se=ne(se),le(se,this.U)):se=this.U),this.u!==null||this.R||(te.J=se,se=null),this.S)e:{for(var T=0,$=0;$<this.i.length;$++){t:{var L=this.i[$];if("__data__"in L.map&&(L=L.map.__data__,typeof L=="string")){L=L.length;break t}L=void 0}if(L===void 0)break;if(T+=L,T>4096){T=$;break e}if(T===4096||$===this.i.length-1){T=$+1;break e}}T=1e3}else T=1e3;T=OR(this,te,T),$=Gr(this.J),Jt($,"RID",b),Jt($,"CVER",22),this.G&&Jt($,"X-HTTP-Session-Id",this.G),sg(this,$),se&&(this.R?T="headers="+oa(Ee(se))+"&"+T:this.u&&Fe($,this.u,se)),ui(this.h,te),this.Ra&&Jt($,"TYPE","init"),this.S?(Jt($,"$req",T),Jt($,"SID","null"),te.U=!0,gs(te,$,null)):gs(te,$,T),this.I=2}}else this.I==3&&(b?MR(this,b):this.i.length==0||xv(this.h)||MR(this))};function MR(b,T){var $;T?$=T.l:$=b.V++;const L=Gr(b.J);Jt(L,"SID",b.M),Jt(L,"RID",$),Jt(L,"AID",b.K),sg(b,L),b.u&&b.o&&Fe(L,b.u,b.o),$=new jr(b,b.j,$,b.D+1),b.u===null&&($.J=b.o),T&&(b.i=T.G.concat(b.i)),T=OR(b,$,1e3),$.H=Math.round(b.va*.5)+Math.round(b.va*.5*Math.random()),ui(b.h,$),gs($,L,T)}function sg(b,T){b.H&&J(b.H,function($,L){Jt(T,L,$)}),b.l&&J({},function($,L){Jt(T,L,$)})}function OR(b,T,$){$=Math.min(b.i.length,$);const L=b.l?c(b.l.Ka,b.l,b):null;e:{var te=b.i;let yt=-1;for(;;){const la=["count="+$];yt==-1?$>0?(yt=te[0].g,la.push("ofs="+yt)):yt=0:la.push("ofs="+yt);let an=!0;for(let Sa=0;Sa<$;Sa++){var se=te[Sa].g;const di=te[Sa].map;if(se-=yt,se<0)yt=Math.max(0,te[Sa].g-100),an=!1;else try{se="req"+se+"_"||"";try{var we=di instanceof Map?di:Object.entries(di);for(const[Uu,Go]of we){let Ho=Go;o(Go)&&(Ho=Da(Go)),la.push(se+Uu+"="+encodeURIComponent(Ho))}}catch(Uu){throw la.push(se+"type="+encodeURIComponent("_badmap")),Uu}}catch{L&&L(di)}}if(an){we=la.join("&");break e}}we=void 0}return b=b.i.splice(0,$),T.G=b,we}function FR(b){if(!b.g&&!b.v){b.Y=1;var T=b.Da;k||I(),M||(k(),M=!0),S.add(T,b),b.A=0}}function F_(b){return b.g||b.v||b.A>=3?!1:(b.Y++,b.v=Wr(c(b.Da,b),PR(b,b.A)),b.A++,!0)}e.Da=function(){if(this.v=null,LR(this),this.aa&&!(this.P||this.g==null||this.T<=0)){var b=4*this.T;this.j.info("BP detection timer enabled: "+b),this.B=Wr(c(this.Wa,this),b)}},e.Wa=function(){this.B&&(this.B=null,this.j.info("BP detection timeout reached."),this.j.info("Buffering proxy detected and switch to long-polling!"),this.F=!1,this.P=!0,Gn(10),Av(this),LR(this))};function L_(b){b.B!=null&&(i.clearTimeout(b.B),b.B=null)}function LR(b){b.g=new jr(b,b.j,"rpc",b.Y),b.u===null&&(b.g.J=b.o),b.g.P=0;var T=Gr(b.na);Jt(T,"RID","rpc"),Jt(T,"SID",b.M),Jt(T,"AID",b.K),Jt(T,"CI",b.F?"0":"1"),!b.F&&b.ia&&Jt(T,"TO",b.ia),Jt(T,"TYPE","xmlhttp"),sg(b,T),b.u&&b.o&&Fe(T,b.u,b.o),b.O&&(b.g.H=b.O);var $=b.g;b=b.ba,$.M=1,$.A=Fu(Gr(T)),$.u=null,$.R=!0,$u($,b)}e.Va=function(){this.C!=null&&(this.C=null,Av(this),F_(this),Gn(19))};function Dv(b){b.C!=null&&(i.clearTimeout(b.C),b.C=null)}function zR(b,T){var $=null;if(b.g==T){Dv(b),L_(b),b.g=null;var L=2}else if(Zm(b.h,T))$=T.G,Od(b.h,T),L=1;else return;if(b.I!=0){if(T.o)if(L==1){$=T.u?T.u.length:0,T=Date.now()-T.F;var te=b.D;L=Ki(),pt(L,new oi(L,$)),Rv(b)}else FR(b);else if(te=T.m,te==3||te==0&&T.X>0||!(L==1&&R8(b,T)||L==2&&F_(b)))switch($&&$.length>0&&(T=b.h,T.i=T.i.concat($)),te){case 1:Bu(b,5);break;case 4:Bu(b,10);break;case 3:Bu(b,6);break;default:Bu(b,2)}}}function PR(b,T){let $=b.Qa+Math.floor(Math.random()*b.Za);return b.isActive()||($*=2),$*T}function Bu(b,T){if(b.j.info("Error code "+T),T==2){var $=c(b.bb,b),L=b.Ua;const te=!L;L=new ci(L||"//www.google.com/images/cleardot.gif"),i.location&&i.location.protocol=="http"||Wo(L,"https"),Fu(L),te?zd(L.toString(),$):Pd(L.toString(),$)}else Gn(2);b.I=0,b.l&&b.l.pa(T),VR(b),$R(b)}e.bb=function(b){b?(this.j.info("Successfully pinged google.com"),Gn(2)):(this.j.info("Failed to ping google.com"),Gn(1))};function VR(b){if(b.I=0,b.ja=[],b.l){const T=_v(b.h);(T.length!=0||b.i.length!=0)&&(f(b.ja,T),f(b.ja,b.i),b.h.i.length=0,p(b.i),b.i.length=0),b.l.oa()}}function BR(b,T,$){var L=$ instanceof ci?Gr($):new ci($);if(L.g!="")T&&(L.g=T+"."+L.g),Ou(L,L.u);else{var te=i.location;L=te.protocol,T=T?T+"."+te.hostname:te.hostname,te=+te.port;const se=new ci(null);L&&Wo(se,L),T&&(se.g=T),te&&Ou(se,te),$&&(se.h=$),L=se}return $=b.G,T=b.wa,$&&T&&Jt(L,$,T),Jt(L,"VER",b.ka),sg(b,L),L}function UR(b,T,$){if(T&&!b.L)throw Error("Can't create secondary domain capable XhrIo object.");return T=b.Aa&&!b.ma?new Ye(new ee({ab:$})):new Ye(b.ma),T.Fa(b.L),T}e.isActive=function(){return!!this.l&&this.l.isActive(this)};function WR(){}e=WR.prototype,e.ra=function(){},e.qa=function(){},e.pa=function(){},e.oa=function(){},e.isActive=function(){return!0},e.Ka=function(){};function $v(){}$v.prototype.g=function(b,T){return new Hr(b,T)};function Hr(b,T){At.call(this),this.g=new DR(T),this.l=b,this.h=T&&T.messageUrlParams||null,b=T&&T.messageHeaders||null,T&&T.clientProtocolHeaderRequired&&(b?b["X-Client-Protocol"]="webchannel":b={"X-Client-Protocol":"webchannel"}),this.g.o=b,b=T&&T.initMessageHeaders||null,T&&T.messageContentType&&(b?b["X-WebChannel-Content-Type"]=T.messageContentType:b={"X-WebChannel-Content-Type":T.messageContentType}),T&&T.sa&&(b?b["X-WebChannel-Client-Profile"]=T.sa:b={"X-WebChannel-Client-Profile":T.sa}),this.g.U=b,(b=T&&T.Qb)&&!D(b)&&(this.g.u=b),this.A=T&&T.supportsCrossDomainXhr||!1,this.v=T&&T.sendRawJson||!1,(T=T&&T.httpSessionIdParam)&&!D(T)&&(this.g.G=T,b=this.h,b!==null&&T in b&&(b=this.h,T in b&&delete b[T])),this.j=new Bd(this)}h(Hr,At),Hr.prototype.m=function(){this.g.l=this.j,this.A&&(this.g.L=!0),this.g.connect(this.l,this.h||void 0)},Hr.prototype.close=function(){O_(this.g)},Hr.prototype.o=function(b){var T=this.g;if(typeof b=="string"){var $={};$.__data__=b,b=$}else this.v&&($={},$.__data__=Da(b),b=$);T.i.push(new D_(T.Ya++,b)),T.I==3&&Rv(T)},Hr.prototype.N=function(){this.g.l=null,delete this.j,O_(this.g),delete this.g,Hr.Z.N.call(this)};function jR(b){fs.call(this),b.__headers__&&(this.headers=b.__headers__,this.statusCode=b.__status__,delete b.__headers__,delete b.__status__);var T=b.__sm__;if(T){e:{for(const $ in T){b=$;break e}b=void 0}(this.i=b)&&(b=this.i,T=T!==null&&b in T?T[b]:void 0),this.data=T}else this.data=b}h(jR,fs);function GR(){An.call(this),this.status=1}h(GR,An);function Bd(b){this.g=b}h(Bd,WR),Bd.prototype.ra=function(){pt(this.g,"a")},Bd.prototype.qa=function(b){pt(this.g,new jR(b))},Bd.prototype.pa=function(b){pt(this.g,new GR)},Bd.prototype.oa=function(){pt(this.g,"b")},$v.prototype.createWebChannel=$v.prototype.g,Hr.prototype.send=Hr.prototype.o,Hr.prototype.open=Hr.prototype.m,Hr.prototype.close=Hr.prototype.close,ZG=function(){return new $v},YG=function(){return Ki()},QG=ms,iT={jb:0,mb:1,nb:2,Hb:3,Mb:4,Jb:5,Kb:6,Ib:7,Gb:8,Lb:9,PROXY:10,NOPROXY:11,Eb:12,Ab:13,Bb:14,zb:15,Cb:16,Db:17,fb:18,eb:19,gb:20},Pt.NO_ERROR=0,Pt.TIMEOUT=8,Pt.HTTP_ERROR=6,Gx=Pt,it.COMPLETE="complete",XG=it,Bo.EventType=Ga,Ga.OPEN="a",Ga.CLOSE="b",Ga.ERROR="c",Ga.MESSAGE="d",At.prototype.listen=At.prototype.J,$g=Bo,Ye.prototype.listenOnce=Ye.prototype.K,Ye.prototype.getLastError=Ye.prototype.Ha,Ye.prototype.getLastErrorCode=Ye.prototype.ya,Ye.prototype.getStatus=Ye.prototype.ca,Ye.prototype.getResponseJson=Ye.prototype.La,Ye.prototype.getResponseText=Ye.prototype.la,Ye.prototype.send=Ye.prototype.ea,Ye.prototype.setWithCredentials=Ye.prototype.Fa,KG=Ye}).apply(typeof fx<"u"?fx:typeof self<"u"?self:typeof window<"u"?window:{});const xO="@firebase/firestore",wO="4.9.3";/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class qa{constructor(t){this.uid=t}isAuthenticated(){return this.uid!=null}toKey(){return this.isAuthenticated()?"uid:"+this.uid:"anonymous-user"}isEqual(t){return t.uid===this.uid}}qa.UNAUTHENTICATED=new qa(null),qa.GOOGLE_CREDENTIALS=new qa("google-credentials-uid"),qa.FIRST_PARTY=new qa("first-party-uid"),qa.MOCK_USER=new qa("mock-user");/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let qm="12.7.0";/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const jc=new VG("@firebase/firestore");function ep(){return jc.logLevel}function Ae(e,...t){if(jc.logLevel<=Dt.DEBUG){const n=t.map(QA);jc.debug(`Firestore (${qm}): ${e}`,...n)}}function Ao(e,...t){if(jc.logLevel<=Dt.ERROR){const n=t.map(QA);jc.error(`Firestore (${qm}): ${e}`,...n)}}function lf(e,...t){if(jc.logLevel<=Dt.WARN){const n=t.map(QA);jc.warn(`Firestore (${qm}): ${e}`,...n)}}function QA(e){if(typeof e=="string")return e;try{/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/return function(n){return JSON.stringify(n)}(e)}catch{return e}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function Ke(e,t,n){let a="Unexpected state";typeof t=="string"?a=t:n=t,JG(e,a,n)}function JG(e,t,n){let a=`FIRESTORE (${qm}) INTERNAL ASSERTION FAILED: ${t} (ID: ${e.toString(16)})`;if(n!==void 0)try{a+=" CONTEXT: "+JSON.stringify(n)}catch{a+=" CONTEXT: "+n}throw Ao(a),new Error(a)}function Wt(e,t,n,a){let r="Unexpected state";typeof n=="string"?r=n:a=n,e||JG(t,r,a)}function rt(e,t){return e}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ce={OK:"ok",CANCELLED:"cancelled",UNKNOWN:"unknown",INVALID_ARGUMENT:"invalid-argument",DEADLINE_EXCEEDED:"deadline-exceeded",NOT_FOUND:"not-found",ALREADY_EXISTS:"already-exists",PERMISSION_DENIED:"permission-denied",UNAUTHENTICATED:"unauthenticated",RESOURCE_EXHAUSTED:"resource-exhausted",FAILED_PRECONDITION:"failed-precondition",ABORTED:"aborted",OUT_OF_RANGE:"out-of-range",UNIMPLEMENTED:"unimplemented",INTERNAL:"internal",UNAVAILABLE:"unavailable",DATA_LOSS:"data-loss"};class Te extends Hm{constructor(t,n){super(t,n),this.code=t,this.message=n,this.toString=()=>`${this.name}: [code=${this.code}]: ${this.message}`}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class wo{constructor(){this.promise=new Promise((t,n)=>{this.resolve=t,this.reject=n})}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class eH{constructor(t,n){this.user=n,this.type="OAuth",this.headers=new Map,this.headers.set("Authorization",`Bearer ${t}`)}}class nFe{getToken(){return Promise.resolve(null)}invalidateToken(){}start(t,n){t.enqueueRetryable(()=>n(qa.UNAUTHENTICATED))}shutdown(){}}class aFe{constructor(t){this.token=t,this.changeListener=null}getToken(){return Promise.resolve(this.token)}invalidateToken(){}start(t,n){this.changeListener=n,t.enqueueRetryable(()=>n(this.token.user))}shutdown(){this.changeListener=null}}class rFe{constructor(t){this.t=t,this.currentUser=qa.UNAUTHENTICATED,this.i=0,this.forceRefresh=!1,this.auth=null}start(t,n){Wt(this.o===void 0,42304);let a=this.i;const r=l=>this.i!==a?(a=this.i,n(l)):Promise.resolve();let s=new wo;this.o=()=>{this.i++,this.currentUser=this.u(),s.resolve(),s=new wo,t.enqueueRetryable(()=>r(this.currentUser))};const i=()=>{const l=s;t.enqueueRetryable(async()=>{await l.promise,await r(this.currentUser)})},o=l=>{Ae("FirebaseAuthCredentialsProvider","Auth detected"),this.auth=l,this.o&&(this.auth.addAuthTokenListener(this.o),i())};this.t.onInit(l=>o(l)),setTimeout(()=>{if(!this.auth){const l=this.t.getImmediate({optional:!0});l?o(l):(Ae("FirebaseAuthCredentialsProvider","Auth not yet detected"),s.resolve(),s=new wo)}},0),i()}getToken(){const t=this.i,n=this.forceRefresh;return this.forceRefresh=!1,this.auth?this.auth.getToken(n).then(a=>this.i!==t?(Ae("FirebaseAuthCredentialsProvider","getToken aborted due to token change."),this.getToken()):a?(Wt(typeof a.accessToken=="string",31837,{l:a}),new eH(a.accessToken,this.currentUser)):null):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.auth&&this.o&&this.auth.removeAuthTokenListener(this.o),this.o=void 0}u(){const t=this.auth&&this.auth.getUid();return Wt(t===null||typeof t=="string",2055,{h:t}),new qa(t)}}class sFe{constructor(t,n,a){this.P=t,this.T=n,this.I=a,this.type="FirstParty",this.user=qa.FIRST_PARTY,this.A=new Map}R(){return this.I?this.I():null}get headers(){this.A.set("X-Goog-AuthUser",this.P);const t=this.R();return t&&this.A.set("Authorization",t),this.T&&this.A.set("X-Goog-Iam-Authorization-Token",this.T),this.A}}class iFe{constructor(t,n,a){this.P=t,this.T=n,this.I=a}getToken(){return Promise.resolve(new sFe(this.P,this.T,this.I))}start(t,n){t.enqueueRetryable(()=>n(qa.FIRST_PARTY))}shutdown(){}invalidateToken(){}}class _O{constructor(t){this.value=t,this.type="AppCheck",this.headers=new Map,t&&t.length>0&&this.headers.set("x-firebase-appcheck",this.value)}}class oFe{constructor(t,n){this.V=n,this.forceRefresh=!1,this.appCheck=null,this.m=null,this.p=null,POe(t)&&t.settings.appCheckToken&&(this.p=t.settings.appCheckToken)}start(t,n){Wt(this.o===void 0,3512);const a=s=>{s.error!=null&&Ae("FirebaseAppCheckTokenProvider",`Error getting App Check token; using placeholder token instead. Error: ${s.error.message}`);const i=s.token!==this.m;return this.m=s.token,Ae("FirebaseAppCheckTokenProvider",`Received ${i?"new":"existing"} token.`),i?n(s.token):Promise.resolve()};this.o=s=>{t.enqueueRetryable(()=>a(s))};const r=s=>{Ae("FirebaseAppCheckTokenProvider","AppCheck detected"),this.appCheck=s,this.o&&this.appCheck.addTokenListener(this.o)};this.V.onInit(s=>r(s)),setTimeout(()=>{if(!this.appCheck){const s=this.V.getImmediate({optional:!0});s?r(s):Ae("FirebaseAppCheckTokenProvider","AppCheck not yet detected")}},0)}getToken(){if(this.p)return Promise.resolve(new _O(this.p));const t=this.forceRefresh;return this.forceRefresh=!1,this.appCheck?this.appCheck.getToken(t).then(n=>n?(Wt(typeof n.token=="string",44558,{tokenResult:n}),this.m=n.token,new _O(n.token)):null):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.appCheck&&this.o&&this.appCheck.removeTokenListener(this.o),this.o=void 0}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function lFe(e){const t=typeof self<"u"&&(self.crypto||self.msCrypto),n=new Uint8Array(e);if(t&&typeof t.getRandomValues=="function")t.getRandomValues(n);else for(let a=0;a<e;a++)n[a]=Math.floor(256*Math.random());return n}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class YA{static newId(){const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",n=62*Math.floor(4.129032258064516);let a="";for(;a.length<20;){const r=lFe(40);for(let s=0;s<r.length;++s)a.length<20&&r[s]<n&&(a+=t.charAt(r[s]%62))}return a}}function St(e,t){return e<t?-1:e>t?1:0}function oT(e,t){const n=Math.min(e.length,t.length);for(let a=0;a<n;a++){const r=e.charAt(a),s=t.charAt(a);if(r!==s)return HS(r)===HS(s)?St(r,s):HS(r)?1:-1}return St(e.length,t.length)}const uFe=55296,cFe=57343;function HS(e){const t=e.charCodeAt(0);return t>=uFe&&t<=cFe}function uf(e,t,n){return e.length===t.length&&e.every((a,r)=>n(a,t[r]))}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const SO="__name__";class vi{constructor(t,n,a){n===void 0?n=0:n>t.length&&Ke(637,{offset:n,range:t.length}),a===void 0?a=t.length-n:a>t.length-n&&Ke(1746,{length:a,range:t.length-n}),this.segments=t,this.offset=n,this.len=a}get length(){return this.len}isEqual(t){return vi.comparator(this,t)===0}child(t){const n=this.segments.slice(this.offset,this.limit());return t instanceof vi?t.forEach(a=>{n.push(a)}):n.push(t),this.construct(n)}limit(){return this.offset+this.length}popFirst(t){return t=t===void 0?1:t,this.construct(this.segments,this.offset+t,this.length-t)}popLast(){return this.construct(this.segments,this.offset,this.length-1)}firstSegment(){return this.segments[this.offset]}lastSegment(){return this.get(this.length-1)}get(t){return this.segments[this.offset+t]}isEmpty(){return this.length===0}isPrefixOf(t){if(t.length<this.length)return!1;for(let n=0;n<this.length;n++)if(this.get(n)!==t.get(n))return!1;return!0}isImmediateParentOf(t){if(this.length+1!==t.length)return!1;for(let n=0;n<this.length;n++)if(this.get(n)!==t.get(n))return!1;return!0}forEach(t){for(let n=this.offset,a=this.limit();n<a;n++)t(this.segments[n])}toArray(){return this.segments.slice(this.offset,this.limit())}static comparator(t,n){const a=Math.min(t.length,n.length);for(let r=0;r<a;r++){const s=vi.compareSegments(t.get(r),n.get(r));if(s!==0)return s}return St(t.length,n.length)}static compareSegments(t,n){const a=vi.isNumericId(t),r=vi.isNumericId(n);return a&&!r?-1:!a&&r?1:a&&r?vi.extractNumericId(t).compare(vi.extractNumericId(n)):oT(t,n)}static isNumericId(t){return t.startsWith("__id")&&t.endsWith("__")}static extractNumericId(t){return Ml.fromString(t.substring(4,t.length-2))}}class un extends vi{construct(t,n,a){return new un(t,n,a)}canonicalString(){return this.toArray().join("/")}toString(){return this.canonicalString()}toUriEncodedString(){return this.toArray().map(encodeURIComponent).join("/")}static fromString(...t){const n=[];for(const a of t){if(a.indexOf("//")>=0)throw new Te(ce.INVALID_ARGUMENT,`Invalid segment (${a}). Paths must not contain // in them.`);n.push(...a.split("/").filter(r=>r.length>0))}return new un(n)}static emptyPath(){return new un([])}}const hFe=/^[_a-zA-Z][_a-zA-Z0-9]*$/;class La extends vi{construct(t,n,a){return new La(t,n,a)}static isValidIdentifier(t){return hFe.test(t)}canonicalString(){return this.toArray().map(t=>(t=t.replace(/\\/g,"\\\\").replace(/`/g,"\\`"),La.isValidIdentifier(t)||(t="`"+t+"`"),t)).join(".")}toString(){return this.canonicalString()}isKeyField(){return this.length===1&&this.get(0)===SO}static keyField(){return new La([SO])}static fromServerFormat(t){const n=[];let a="",r=0;const s=()=>{if(a.length===0)throw new Te(ce.INVALID_ARGUMENT,`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);n.push(a),a=""};let i=!1;for(;r<t.length;){const o=t[r];if(o==="\\"){if(r+1===t.length)throw new Te(ce.INVALID_ARGUMENT,"Path has trailing escape character: "+t);const l=t[r+1];if(l!=="\\"&&l!=="."&&l!=="`")throw new Te(ce.INVALID_ARGUMENT,"Path has invalid escape sequence: "+t);a+=l,r+=2}else o==="`"?(i=!i,r++):o!=="."||i?(a+=o,r++):(s(),r++)}if(s(),i)throw new Te(ce.INVALID_ARGUMENT,"Unterminated ` in path: "+t);return new La(n)}static emptyPath(){return new La([])}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Ve{constructor(t){this.path=t}static fromPath(t){return new Ve(un.fromString(t))}static fromName(t){return new Ve(un.fromString(t).popFirst(5))}static empty(){return new Ve(un.emptyPath())}get collectionGroup(){return this.path.popLast().lastSegment()}hasCollectionId(t){return this.path.length>=2&&this.path.get(this.path.length-2)===t}getCollectionGroup(){return this.path.get(this.path.length-2)}getCollectionPath(){return this.path.popLast()}isEqual(t){return t!==null&&un.comparator(this.path,t.path)===0}toString(){return this.path.toString()}static comparator(t,n){return un.comparator(t.path,n.path)}static isDocumentKey(t){return t.length%2==0}static fromSegments(t){return new Ve(new un(t.slice()))}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function tH(e,t,n){if(!n)throw new Te(ce.INVALID_ARGUMENT,`Function ${e}() cannot be called with an empty ${t}.`)}function dFe(e,t,n,a){if(t===!0&&a===!0)throw new Te(ce.INVALID_ARGUMENT,`${e} and ${n} cannot be used together.`)}function IO(e){if(!Ve.isDocumentKey(e))throw new Te(ce.INVALID_ARGUMENT,`Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`)}function kO(e){if(Ve.isDocumentKey(e))throw new Te(ce.INVALID_ARGUMENT,`Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`)}function nH(e){return typeof e=="object"&&e!==null&&(Object.getPrototypeOf(e)===Object.prototype||Object.getPrototypeOf(e)===null)}function f_(e){if(e===void 0)return"undefined";if(e===null)return"null";if(typeof e=="string")return e.length>20&&(e=`${e.substring(0,20)}...`),JSON.stringify(e);if(typeof e=="number"||typeof e=="boolean")return""+e;if(typeof e=="object"){if(e instanceof Array)return"an array";{const t=function(a){return a.constructor?a.constructor.name:null}(e);return t?`a custom ${t} object`:"an object"}}return typeof e=="function"?"a function":Ke(12329,{type:typeof e})}function tu(e,t){if("_delegate"in e&&(e=e._delegate),!(e instanceof t)){if(t.name===e.constructor.name)throw new Te(ce.INVALID_ARGUMENT,"Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");{const n=f_(e);throw new Te(ce.INVALID_ARGUMENT,`Expected type '${t.name}', but it was: ${n}`)}}return e}/**
 * @license
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function ta(e,t){const n={typeString:e};return t&&(n.value=t),n}function dv(e,t){if(!nH(e))throw new Te(ce.INVALID_ARGUMENT,"JSON must be an object");let n;for(const a in t)if(t[a]){const r=t[a].typeString,s="value"in t[a]?{value:t[a].value}:void 0;if(!(a in e)){n=`JSON missing required field: '${a}'`;break}const i=e[a];if(r&&typeof i!==r){n=`JSON field '${a}' must be a ${r}.`;break}if(s!==void 0&&i!==s.value){n=`Expected '${a}' field to equal '${s.value}'`;break}}if(n)throw new Te(ce.INVALID_ARGUMENT,n);return!0}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const TO=-62135596800,EO=1e6;class fn{static now(){return fn.fromMillis(Date.now())}static fromDate(t){return fn.fromMillis(t.getTime())}static fromMillis(t){const n=Math.floor(t/1e3),a=Math.floor((t-1e3*n)*EO);return new fn(n,a)}constructor(t,n){if(this.seconds=t,this.nanoseconds=n,n<0)throw new Te(ce.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+n);if(n>=1e9)throw new Te(ce.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+n);if(t<TO)throw new Te(ce.INVALID_ARGUMENT,"Timestamp seconds out of range: "+t);if(t>=253402300800)throw new Te(ce.INVALID_ARGUMENT,"Timestamp seconds out of range: "+t)}toDate(){return new Date(this.toMillis())}toMillis(){return 1e3*this.seconds+this.nanoseconds/EO}_compareTo(t){return this.seconds===t.seconds?St(this.nanoseconds,t.nanoseconds):St(this.seconds,t.seconds)}isEqual(t){return t.seconds===this.seconds&&t.nanoseconds===this.nanoseconds}toString(){return"Timestamp(seconds="+this.seconds+", nanoseconds="+this.nanoseconds+")"}toJSON(){return{type:fn._jsonSchemaVersion,seconds:this.seconds,nanoseconds:this.nanoseconds}}static fromJSON(t){if(dv(t,fn._jsonSchema))return new fn(t.seconds,t.nanoseconds)}valueOf(){const t=this.seconds-TO;return String(t).padStart(12,"0")+"."+String(this.nanoseconds).padStart(9,"0")}}fn._jsonSchemaVersion="firestore/timestamp/1.0",fn._jsonSchema={type:ta("string",fn._jsonSchemaVersion),seconds:ta("number"),nanoseconds:ta("number")};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class nt{static fromTimestamp(t){return new nt(t)}static min(){return new nt(new fn(0,0))}static max(){return new nt(new fn(253402300799,999999999))}constructor(t){this.timestamp=t}compareTo(t){return this.timestamp._compareTo(t.timestamp)}isEqual(t){return this.timestamp.isEqual(t.timestamp)}toMicroseconds(){return 1e6*this.timestamp.seconds+this.timestamp.nanoseconds/1e3}toString(){return"SnapshotVersion("+this.timestamp.toString()+")"}toTimestamp(){return this.timestamp}}/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Uy=-1;function pFe(e,t){const n=e.toTimestamp().seconds,a=e.toTimestamp().nanoseconds+1,r=nt.fromTimestamp(a===1e9?new fn(n+1,0):new fn(n,a));return new nu(r,Ve.empty(),t)}function fFe(e){return new nu(e.readTime,e.key,Uy)}class nu{constructor(t,n,a){this.readTime=t,this.documentKey=n,this.largestBatchId=a}static min(){return new nu(nt.min(),Ve.empty(),Uy)}static max(){return new nu(nt.max(),Ve.empty(),Uy)}}function mFe(e,t){let n=e.readTime.compareTo(t.readTime);return n!==0?n:(n=Ve.comparator(e.documentKey,t.documentKey),n!==0?n:St(e.largestBatchId,t.largestBatchId))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const gFe="The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";class yFe{constructor(){this.onCommittedListeners=[]}addOnCommittedListener(t){this.onCommittedListeners.push(t)}raiseOnCommittedEvent(){this.onCommittedListeners.forEach(t=>t())}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */async function Km(e){if(e.code!==ce.FAILED_PRECONDITION||e.message!==gFe)throw e;Ae("LocalStore","Unexpectedly lost primary lease")}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class fe{constructor(t){this.nextCallback=null,this.catchCallback=null,this.result=void 0,this.error=void 0,this.isDone=!1,this.callbackAttached=!1,t(n=>{this.isDone=!0,this.result=n,this.nextCallback&&this.nextCallback(n)},n=>{this.isDone=!0,this.error=n,this.catchCallback&&this.catchCallback(n)})}catch(t){return this.next(void 0,t)}next(t,n){return this.callbackAttached&&Ke(59440),this.callbackAttached=!0,this.isDone?this.error?this.wrapFailure(n,this.error):this.wrapSuccess(t,this.result):new fe((a,r)=>{this.nextCallback=s=>{this.wrapSuccess(t,s).next(a,r)},this.catchCallback=s=>{this.wrapFailure(n,s).next(a,r)}})}toPromise(){return new Promise((t,n)=>{this.next(t,n)})}wrapUserFunction(t){try{const n=t();return n instanceof fe?n:fe.resolve(n)}catch(n){return fe.reject(n)}}wrapSuccess(t,n){return t?this.wrapUserFunction(()=>t(n)):fe.resolve(n)}wrapFailure(t,n){return t?this.wrapUserFunction(()=>t(n)):fe.reject(n)}static resolve(t){return new fe((n,a)=>{n(t)})}static reject(t){return new fe((n,a)=>{a(t)})}static waitFor(t){return new fe((n,a)=>{let r=0,s=0,i=!1;t.forEach(o=>{++r,o.next(()=>{++s,i&&s===r&&n()},l=>a(l))}),i=!0,s===r&&n()})}static or(t){let n=fe.resolve(!1);for(const a of t)n=n.next(r=>r?fe.resolve(r):a());return n}static forEach(t,n){const a=[];return t.forEach((r,s)=>{a.push(n.call(this,r,s))}),this.waitFor(a)}static mapArray(t,n){return new fe((a,r)=>{const s=t.length,i=new Array(s);let o=0;for(let l=0;l<s;l++){const c=l;n(t[c]).next(u=>{i[c]=u,++o,o===s&&a(i)},u=>r(u))}})}static doWhile(t,n){return new fe((a,r)=>{const s=()=>{t()===!0?n().next(()=>{s()},r):a()};s()})}}function bFe(e){const t=e.match(/Android ([\d.]+)/i),n=t?t[1].split(".").slice(0,2).join("."):"-1";return Number(n)}function Xm(e){return e.name==="IndexedDbTransactionError"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class m_{constructor(t,n){this.previousValue=t,n&&(n.sequenceNumberHandler=a=>this.ae(a),this.ue=a=>n.writeSequenceNumber(a))}ae(t){return this.previousValue=Math.max(t,this.previousValue),this.previousValue}next(){const t=++this.previousValue;return this.ue&&this.ue(t),t}}m_.ce=-1;/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ZA=-1;function g_(e){return e==null}function lw(e){return e===0&&1/e==-1/0}function vFe(e){return typeof e=="number"&&Number.isInteger(e)&&!lw(e)&&e<=Number.MAX_SAFE_INTEGER&&e>=Number.MIN_SAFE_INTEGER}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const aH="";function xFe(e){let t="";for(let n=0;n<e.length;n++)t.length>0&&(t=NO(t)),t=wFe(e.get(n),t);return NO(t)}function wFe(e,t){let n=t;const a=e.length;for(let r=0;r<a;r++){const s=e.charAt(r);switch(s){case"\0":n+="";break;case aH:n+="";break;default:n+=s}}return n}function NO(e){return e+aH+""}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function CO(e){let t=0;for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t++;return t}function Eu(e,t){for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t(n,e[n])}function rH(e){for(const t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!1;return!0}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class En{constructor(t,n){this.comparator=t,this.root=n||Ma.EMPTY}insert(t,n){return new En(this.comparator,this.root.insert(t,n,this.comparator).copy(null,null,Ma.BLACK,null,null))}remove(t){return new En(this.comparator,this.root.remove(t,this.comparator).copy(null,null,Ma.BLACK,null,null))}get(t){let n=this.root;for(;!n.isEmpty();){const a=this.comparator(t,n.key);if(a===0)return n.value;a<0?n=n.left:a>0&&(n=n.right)}return null}indexOf(t){let n=0,a=this.root;for(;!a.isEmpty();){const r=this.comparator(t,a.key);if(r===0)return n+a.left.size;r<0?a=a.left:(n+=a.left.size+1,a=a.right)}return-1}isEmpty(){return this.root.isEmpty()}get size(){return this.root.size}minKey(){return this.root.minKey()}maxKey(){return this.root.maxKey()}inorderTraversal(t){return this.root.inorderTraversal(t)}forEach(t){this.inorderTraversal((n,a)=>(t(n,a),!1))}toString(){const t=[];return this.inorderTraversal((n,a)=>(t.push(`${n}:${a}`),!1)),`{${t.join(", ")}}`}reverseTraversal(t){return this.root.reverseTraversal(t)}getIterator(){return new mx(this.root,null,this.comparator,!1)}getIteratorFrom(t){return new mx(this.root,t,this.comparator,!1)}getReverseIterator(){return new mx(this.root,null,this.comparator,!0)}getReverseIteratorFrom(t){return new mx(this.root,t,this.comparator,!0)}}class mx{constructor(t,n,a,r){this.isReverse=r,this.nodeStack=[];let s=1;for(;!t.isEmpty();)if(s=n?a(t.key,n):1,n&&r&&(s*=-1),s<0)t=this.isReverse?t.left:t.right;else{if(s===0){this.nodeStack.push(t);break}this.nodeStack.push(t),t=this.isReverse?t.right:t.left}}getNext(){let t=this.nodeStack.pop();const n={key:t.key,value:t.value};if(this.isReverse)for(t=t.left;!t.isEmpty();)this.nodeStack.push(t),t=t.right;else for(t=t.right;!t.isEmpty();)this.nodeStack.push(t),t=t.left;return n}hasNext(){return this.nodeStack.length>0}peek(){if(this.nodeStack.length===0)return null;const t=this.nodeStack[this.nodeStack.length-1];return{key:t.key,value:t.value}}}class Ma{constructor(t,n,a,r,s){this.key=t,this.value=n,this.color=a??Ma.RED,this.left=r??Ma.EMPTY,this.right=s??Ma.EMPTY,this.size=this.left.size+1+this.right.size}copy(t,n,a,r,s){return new Ma(t??this.key,n??this.value,a??this.color,r??this.left,s??this.right)}isEmpty(){return!1}inorderTraversal(t){return this.left.inorderTraversal(t)||t(this.key,this.value)||this.right.inorderTraversal(t)}reverseTraversal(t){return this.right.reverseTraversal(t)||t(this.key,this.value)||this.left.reverseTraversal(t)}min(){return this.left.isEmpty()?this:this.left.min()}minKey(){return this.min().key}maxKey(){return this.right.isEmpty()?this.key:this.right.maxKey()}insert(t,n,a){let r=this;const s=a(t,r.key);return r=s<0?r.copy(null,null,null,r.left.insert(t,n,a),null):s===0?r.copy(null,n,null,null,null):r.copy(null,null,null,null,r.right.insert(t,n,a)),r.fixUp()}removeMin(){if(this.left.isEmpty())return Ma.EMPTY;let t=this;return t.left.isRed()||t.left.left.isRed()||(t=t.moveRedLeft()),t=t.copy(null,null,null,t.left.removeMin(),null),t.fixUp()}remove(t,n){let a,r=this;if(n(t,r.key)<0)r.left.isEmpty()||r.left.isRed()||r.left.left.isRed()||(r=r.moveRedLeft()),r=r.copy(null,null,null,r.left.remove(t,n),null);else{if(r.left.isRed()&&(r=r.rotateRight()),r.right.isEmpty()||r.right.isRed()||r.right.left.isRed()||(r=r.moveRedRight()),n(t,r.key)===0){if(r.right.isEmpty())return Ma.EMPTY;a=r.right.min(),r=r.copy(a.key,a.value,null,null,r.right.removeMin())}r=r.copy(null,null,null,null,r.right.remove(t,n))}return r.fixUp()}isRed(){return this.color}fixUp(){let t=this;return t.right.isRed()&&!t.left.isRed()&&(t=t.rotateLeft()),t.left.isRed()&&t.left.left.isRed()&&(t=t.rotateRight()),t.left.isRed()&&t.right.isRed()&&(t=t.colorFlip()),t}moveRedLeft(){let t=this.colorFlip();return t.right.left.isRed()&&(t=t.copy(null,null,null,null,t.right.rotateRight()),t=t.rotateLeft(),t=t.colorFlip()),t}moveRedRight(){let t=this.colorFlip();return t.left.left.isRed()&&(t=t.rotateRight(),t=t.colorFlip()),t}rotateLeft(){const t=this.copy(null,null,Ma.RED,null,this.right.left);return this.right.copy(null,null,this.color,t,null)}rotateRight(){const t=this.copy(null,null,Ma.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,t)}colorFlip(){const t=this.left.copy(null,null,!this.left.color,null,null),n=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,t,n)}checkMaxDepth(){const t=this.check();return Math.pow(2,t)<=this.size+1}check(){if(this.isRed()&&this.left.isRed())throw Ke(43730,{key:this.key,value:this.value});if(this.right.isRed())throw Ke(14113,{key:this.key,value:this.value});const t=this.left.check();if(t!==this.right.check())throw Ke(27949);return t+(this.isRed()?0:1)}}Ma.EMPTY=null,Ma.RED=!0,Ma.BLACK=!1;Ma.EMPTY=new class{constructor(){this.size=0}get key(){throw Ke(57766)}get value(){throw Ke(16141)}get color(){throw Ke(16727)}get left(){throw Ke(29726)}get right(){throw Ke(36894)}copy(t,n,a,r,s){return this}insert(t,n,a){return new Ma(t,n)}remove(t,n){return this}isEmpty(){return!0}inorderTraversal(t){return!1}reverseTraversal(t){return!1}minKey(){return null}maxKey(){return null}isRed(){return!1}checkMaxDepth(){return!0}check(){return 0}};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ya{constructor(t){this.comparator=t,this.data=new En(this.comparator)}has(t){return this.data.get(t)!==null}first(){return this.data.minKey()}last(){return this.data.maxKey()}get size(){return this.data.size}indexOf(t){return this.data.indexOf(t)}forEach(t){this.data.inorderTraversal((n,a)=>(t(n),!1))}forEachInRange(t,n){const a=this.data.getIteratorFrom(t[0]);for(;a.hasNext();){const r=a.getNext();if(this.comparator(r.key,t[1])>=0)return;n(r.key)}}forEachWhile(t,n){let a;for(a=n!==void 0?this.data.getIteratorFrom(n):this.data.getIterator();a.hasNext();)if(!t(a.getNext().key))return}firstAfterOrEqual(t){const n=this.data.getIteratorFrom(t);return n.hasNext()?n.getNext().key:null}getIterator(){return new AO(this.data.getIterator())}getIteratorFrom(t){return new AO(this.data.getIteratorFrom(t))}add(t){return this.copy(this.data.remove(t).insert(t,!0))}delete(t){return this.has(t)?this.copy(this.data.remove(t)):this}isEmpty(){return this.data.isEmpty()}unionWith(t){let n=this;return n.size<t.size&&(n=t,t=this),t.forEach(a=>{n=n.add(a)}),n}isEqual(t){if(!(t instanceof ya)||this.size!==t.size)return!1;const n=this.data.getIterator(),a=t.data.getIterator();for(;n.hasNext();){const r=n.getNext().key,s=a.getNext().key;if(this.comparator(r,s)!==0)return!1}return!0}toArray(){const t=[];return this.forEach(n=>{t.push(n)}),t}toString(){const t=[];return this.forEach(n=>t.push(n)),"SortedSet("+t.toString()+")"}copy(t){const n=new ya(this.comparator);return n.data=t,n}}class AO{constructor(t){this.iter=t}getNext(){return this.iter.getNext().key}hasNext(){return this.iter.hasNext()}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ts{constructor(t){this.fields=t,t.sort(La.comparator)}static empty(){return new ts([])}unionWith(t){let n=new ya(La.comparator);for(const a of this.fields)n=n.add(a);for(const a of t)n=n.add(a);return new ts(n.toArray())}covers(t){for(const n of this.fields)if(n.isPrefixOf(t))return!0;return!1}isEqual(t){return uf(this.fields,t.fields,(n,a)=>n.isEqual(a))}}/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class sH extends Error{constructor(){super(...arguments),this.name="Base64DecodeError"}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Ua{constructor(t){this.binaryString=t}static fromBase64String(t){const n=function(r){try{return atob(r)}catch(s){throw typeof DOMException<"u"&&s instanceof DOMException?new sH("Invalid base64 string: "+s):s}}(t);return new Ua(n)}static fromUint8Array(t){const n=function(r){let s="";for(let i=0;i<r.length;++i)s+=String.fromCharCode(r[i]);return s}(t);return new Ua(n)}[Symbol.iterator](){let t=0;return{next:()=>t<this.binaryString.length?{value:this.binaryString.charCodeAt(t++),done:!1}:{value:void 0,done:!0}}}toBase64(){return function(n){return btoa(n)}(this.binaryString)}toUint8Array(){return function(n){const a=new Uint8Array(n.length);for(let r=0;r<n.length;r++)a[r]=n.charCodeAt(r);return a}(this.binaryString)}approximateByteSize(){return 2*this.binaryString.length}compareTo(t){return St(this.binaryString,t.binaryString)}isEqual(t){return this.binaryString===t.binaryString}}Ua.EMPTY_BYTE_STRING=new Ua("");const _Fe=new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);function au(e){if(Wt(!!e,39018),typeof e=="string"){let t=0;const n=_Fe.exec(e);if(Wt(!!n,46558,{timestamp:e}),n[1]){let r=n[1];r=(r+"000000000").substr(0,9),t=Number(r)}const a=new Date(e);return{seconds:Math.floor(a.getTime()/1e3),nanos:t}}return{seconds:Fn(e.seconds),nanos:Fn(e.nanos)}}function Fn(e){return typeof e=="number"?e:typeof e=="string"?Number(e):0}function ru(e){return typeof e=="string"?Ua.fromBase64String(e):Ua.fromUint8Array(e)}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const iH="server_timestamp",oH="__type__",lH="__previous_value__",uH="__local_write_time__";function JA(e){var n,a;return((a=(((n=e==null?void 0:e.mapValue)==null?void 0:n.fields)||{})[oH])==null?void 0:a.stringValue)===iH}function y_(e){const t=e.mapValue.fields[lH];return JA(t)?y_(t):t}function Wy(e){const t=au(e.mapValue.fields[uH].timestampValue);return new fn(t.seconds,t.nanos)}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class SFe{constructor(t,n,a,r,s,i,o,l,c,u){this.databaseId=t,this.appId=n,this.persistenceKey=a,this.host=r,this.ssl=s,this.forceLongPolling=i,this.autoDetectLongPolling=o,this.longPollingOptions=l,this.useFetchStreams=c,this.isUsingEmulator=u}}const uw="(default)";class jy{constructor(t,n){this.projectId=t,this.database=n||uw}static empty(){return new jy("","")}get isDefaultDatabase(){return this.database===uw}isEqual(t){return t instanceof jy&&t.projectId===this.projectId&&t.database===this.database}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const cH="__type__",IFe="__max__",gx={mapValue:{}},hH="__vector__",cw="value";function su(e){return"nullValue"in e?0:"booleanValue"in e?1:"integerValue"in e||"doubleValue"in e?2:"timestampValue"in e?3:"stringValue"in e?5:"bytesValue"in e?6:"referenceValue"in e?7:"geoPointValue"in e?8:"arrayValue"in e?9:"mapValue"in e?JA(e)?4:TFe(e)?9007199254740991:kFe(e)?10:11:Ke(28295,{value:e})}function Bi(e,t){if(e===t)return!0;const n=su(e);if(n!==su(t))return!1;switch(n){case 0:case 9007199254740991:return!0;case 1:return e.booleanValue===t.booleanValue;case 4:return Wy(e).isEqual(Wy(t));case 3:return function(r,s){if(typeof r.timestampValue=="string"&&typeof s.timestampValue=="string"&&r.timestampValue.length===s.timestampValue.length)return r.timestampValue===s.timestampValue;const i=au(r.timestampValue),o=au(s.timestampValue);return i.seconds===o.seconds&&i.nanos===o.nanos}(e,t);case 5:return e.stringValue===t.stringValue;case 6:return function(r,s){return ru(r.bytesValue).isEqual(ru(s.bytesValue))}(e,t);case 7:return e.referenceValue===t.referenceValue;case 8:return function(r,s){return Fn(r.geoPointValue.latitude)===Fn(s.geoPointValue.latitude)&&Fn(r.geoPointValue.longitude)===Fn(s.geoPointValue.longitude)}(e,t);case 2:return function(r,s){if("integerValue"in r&&"integerValue"in s)return Fn(r.integerValue)===Fn(s.integerValue);if("doubleValue"in r&&"doubleValue"in s){const i=Fn(r.doubleValue),o=Fn(s.doubleValue);return i===o?lw(i)===lw(o):isNaN(i)&&isNaN(o)}return!1}(e,t);case 9:return uf(e.arrayValue.values||[],t.arrayValue.values||[],Bi);case 10:case 11:return function(r,s){const i=r.mapValue.fields||{},o=s.mapValue.fields||{};if(CO(i)!==CO(o))return!1;for(const l in i)if(i.hasOwnProperty(l)&&(o[l]===void 0||!Bi(i[l],o[l])))return!1;return!0}(e,t);default:return Ke(52216,{left:e})}}function Gy(e,t){return(e.values||[]).find(n=>Bi(n,t))!==void 0}function cf(e,t){if(e===t)return 0;const n=su(e),a=su(t);if(n!==a)return St(n,a);switch(n){case 0:case 9007199254740991:return 0;case 1:return St(e.booleanValue,t.booleanValue);case 2:return function(s,i){const o=Fn(s.integerValue||s.doubleValue),l=Fn(i.integerValue||i.doubleValue);return o<l?-1:o>l?1:o===l?0:isNaN(o)?isNaN(l)?0:-1:1}(e,t);case 3:return RO(e.timestampValue,t.timestampValue);case 4:return RO(Wy(e),Wy(t));case 5:return oT(e.stringValue,t.stringValue);case 6:return function(s,i){const o=ru(s),l=ru(i);return o.compareTo(l)}(e.bytesValue,t.bytesValue);case 7:return function(s,i){const o=s.split("/"),l=i.split("/");for(let c=0;c<o.length&&c<l.length;c++){const u=St(o[c],l[c]);if(u!==0)return u}return St(o.length,l.length)}(e.referenceValue,t.referenceValue);case 8:return function(s,i){const o=St(Fn(s.latitude),Fn(i.latitude));return o!==0?o:St(Fn(s.longitude),Fn(i.longitude))}(e.geoPointValue,t.geoPointValue);case 9:return DO(e.arrayValue,t.arrayValue);case 10:return function(s,i){var d,p,f,m;const o=s.fields||{},l=i.fields||{},c=(d=o[cw])==null?void 0:d.arrayValue,u=(p=l[cw])==null?void 0:p.arrayValue,h=St(((f=c==null?void 0:c.values)==null?void 0:f.length)||0,((m=u==null?void 0:u.values)==null?void 0:m.length)||0);return h!==0?h:DO(c,u)}(e.mapValue,t.mapValue);case 11:return function(s,i){if(s===gx.mapValue&&i===gx.mapValue)return 0;if(s===gx.mapValue)return 1;if(i===gx.mapValue)return-1;const o=s.fields||{},l=Object.keys(o),c=i.fields||{},u=Object.keys(c);l.sort(),u.sort();for(let h=0;h<l.length&&h<u.length;++h){const d=oT(l[h],u[h]);if(d!==0)return d;const p=cf(o[l[h]],c[u[h]]);if(p!==0)return p}return St(l.length,u.length)}(e.mapValue,t.mapValue);default:throw Ke(23264,{he:n})}}function RO(e,t){if(typeof e=="string"&&typeof t=="string"&&e.length===t.length)return St(e,t);const n=au(e),a=au(t),r=St(n.seconds,a.seconds);return r!==0?r:St(n.nanos,a.nanos)}function DO(e,t){const n=e.values||[],a=t.values||[];for(let r=0;r<n.length&&r<a.length;++r){const s=cf(n[r],a[r]);if(s)return s}return St(n.length,a.length)}function hf(e){return lT(e)}function lT(e){return"nullValue"in e?"null":"booleanValue"in e?""+e.booleanValue:"integerValue"in e?""+e.integerValue:"doubleValue"in e?""+e.doubleValue:"timestampValue"in e?function(n){const a=au(n);return`time(${a.seconds},${a.nanos})`}(e.timestampValue):"stringValue"in e?e.stringValue:"bytesValue"in e?function(n){return ru(n).toBase64()}(e.bytesValue):"referenceValue"in e?function(n){return Ve.fromName(n).toString()}(e.referenceValue):"geoPointValue"in e?function(n){return`geo(${n.latitude},${n.longitude})`}(e.geoPointValue):"arrayValue"in e?function(n){let a="[",r=!0;for(const s of n.values||[])r?r=!1:a+=",",a+=lT(s);return a+"]"}(e.arrayValue):"mapValue"in e?function(n){const a=Object.keys(n.fields||{}).sort();let r="{",s=!0;for(const i of a)s?s=!1:r+=",",r+=`${i}:${lT(n.fields[i])}`;return r+"}"}(e.mapValue):Ke(61005,{value:e})}function Hx(e){switch(su(e)){case 0:case 1:return 4;case 2:return 8;case 3:case 8:return 16;case 4:const t=y_(e);return t?16+Hx(t):16;case 5:return 2*e.stringValue.length;case 6:return ru(e.bytesValue).approximateByteSize();case 7:return e.referenceValue.length;case 9:return function(a){return(a.values||[]).reduce((r,s)=>r+Hx(s),0)}(e.arrayValue);case 10:case 11:return function(a){let r=0;return Eu(a.fields,(s,i)=>{r+=s.length+Hx(i)}),r}(e.mapValue);default:throw Ke(13486,{value:e})}}function $O(e,t){return{referenceValue:`projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}`}}function uT(e){return!!e&&"integerValue"in e}function eR(e){return!!e&&"arrayValue"in e}function MO(e){return!!e&&"nullValue"in e}function OO(e){return!!e&&"doubleValue"in e&&isNaN(Number(e.doubleValue))}function qx(e){return!!e&&"mapValue"in e}function kFe(e){var n,a;return((a=(((n=e==null?void 0:e.mapValue)==null?void 0:n.fields)||{})[cH])==null?void 0:a.stringValue)===hH}function ay(e){if(e.geoPointValue)return{geoPointValue:{...e.geoPointValue}};if(e.timestampValue&&typeof e.timestampValue=="object")return{timestampValue:{...e.timestampValue}};if(e.mapValue){const t={mapValue:{fields:{}}};return Eu(e.mapValue.fields,(n,a)=>t.mapValue.fields[n]=ay(a)),t}if(e.arrayValue){const t={arrayValue:{values:[]}};for(let n=0;n<(e.arrayValue.values||[]).length;++n)t.arrayValue.values[n]=ay(e.arrayValue.values[n]);return t}return{...e}}function TFe(e){return(((e.mapValue||{}).fields||{}).__type__||{}).stringValue===IFe}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Rr{constructor(t){this.value=t}static empty(){return new Rr({mapValue:{}})}field(t){if(t.isEmpty())return this.value;{let n=this.value;for(let a=0;a<t.length-1;++a)if(n=(n.mapValue.fields||{})[t.get(a)],!qx(n))return null;return n=(n.mapValue.fields||{})[t.lastSegment()],n||null}}set(t,n){this.getFieldsMap(t.popLast())[t.lastSegment()]=ay(n)}setAll(t){let n=La.emptyPath(),a={},r=[];t.forEach((i,o)=>{if(!n.isImmediateParentOf(o)){const l=this.getFieldsMap(n);this.applyChanges(l,a,r),a={},r=[],n=o.popLast()}i?a[o.lastSegment()]=ay(i):r.push(o.lastSegment())});const s=this.getFieldsMap(n);this.applyChanges(s,a,r)}delete(t){const n=this.field(t.popLast());qx(n)&&n.mapValue.fields&&delete n.mapValue.fields[t.lastSegment()]}isEqual(t){return Bi(this.value,t.value)}getFieldsMap(t){let n=this.value;n.mapValue.fields||(n.mapValue={fields:{}});for(let a=0;a<t.length;++a){let r=n.mapValue.fields[t.get(a)];qx(r)&&r.mapValue.fields||(r={mapValue:{fields:{}}},n.mapValue.fields[t.get(a)]=r),n=r}return n.mapValue.fields}applyChanges(t,n,a){Eu(n,(r,s)=>t[r]=s);for(const r of a)delete t[r]}clone(){return new Rr(ay(this.value))}}function dH(e){const t=[];return Eu(e.fields,(n,a)=>{const r=new La([n]);if(qx(a)){const s=dH(a.mapValue).fields;if(s.length===0)t.push(r);else for(const i of s)t.push(r.child(i))}else t.push(r)}),new ts(t)}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Xa{constructor(t,n,a,r,s,i,o){this.key=t,this.documentType=n,this.version=a,this.readTime=r,this.createTime=s,this.data=i,this.documentState=o}static newInvalidDocument(t){return new Xa(t,0,nt.min(),nt.min(),nt.min(),Rr.empty(),0)}static newFoundDocument(t,n,a,r){return new Xa(t,1,n,nt.min(),a,r,0)}static newNoDocument(t,n){return new Xa(t,2,n,nt.min(),nt.min(),Rr.empty(),0)}static newUnknownDocument(t,n){return new Xa(t,3,n,nt.min(),nt.min(),Rr.empty(),2)}convertToFoundDocument(t,n){return!this.createTime.isEqual(nt.min())||this.documentType!==2&&this.documentType!==0||(this.createTime=t),this.version=t,this.documentType=1,this.data=n,this.documentState=0,this}convertToNoDocument(t){return this.version=t,this.documentType=2,this.data=Rr.empty(),this.documentState=0,this}convertToUnknownDocument(t){return this.version=t,this.documentType=3,this.data=Rr.empty(),this.documentState=2,this}setHasCommittedMutations(){return this.documentState=2,this}setHasLocalMutations(){return this.documentState=1,this.version=nt.min(),this}setReadTime(t){return this.readTime=t,this}get hasLocalMutations(){return this.documentState===1}get hasCommittedMutations(){return this.documentState===2}get hasPendingWrites(){return this.hasLocalMutations||this.hasCommittedMutations}isValidDocument(){return this.documentType!==0}isFoundDocument(){return this.documentType===1}isNoDocument(){return this.documentType===2}isUnknownDocument(){return this.documentType===3}isEqual(t){return t instanceof Xa&&this.key.isEqual(t.key)&&this.version.isEqual(t.version)&&this.documentType===t.documentType&&this.documentState===t.documentState&&this.data.isEqual(t.data)}mutableCopy(){return new Xa(this.key,this.documentType,this.version,this.readTime,this.createTime,this.data.clone(),this.documentState)}toString(){return`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class hw{constructor(t,n){this.position=t,this.inclusive=n}}function FO(e,t,n){let a=0;for(let r=0;r<e.position.length;r++){const s=t[r],i=e.position[r];if(s.field.isKeyField()?a=Ve.comparator(Ve.fromName(i.referenceValue),n.key):a=cf(i,n.data.field(s.field)),s.dir==="desc"&&(a*=-1),a!==0)break}return a}function LO(e,t){if(e===null)return t===null;if(t===null||e.inclusive!==t.inclusive||e.position.length!==t.position.length)return!1;for(let n=0;n<e.position.length;n++)if(!Bi(e.position[n],t.position[n]))return!1;return!0}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Hy{constructor(t,n="asc"){this.field=t,this.dir=n}}function EFe(e,t){return e.dir===t.dir&&e.field.isEqual(t.field)}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class pH{}class Yn extends pH{constructor(t,n,a){super(),this.field=t,this.op=n,this.value=a}static create(t,n,a){return t.isKeyField()?n==="in"||n==="not-in"?this.createKeyFieldInFilter(t,n,a):new CFe(t,n,a):n==="array-contains"?new DFe(t,a):n==="in"?new $Fe(t,a):n==="not-in"?new MFe(t,a):n==="array-contains-any"?new OFe(t,a):new Yn(t,n,a)}static createKeyFieldInFilter(t,n,a){return n==="in"?new AFe(t,a):new RFe(t,a)}matches(t){const n=t.data.field(this.field);return this.op==="!="?n!==null&&n.nullValue===void 0&&this.matchesComparison(cf(n,this.value)):n!==null&&su(this.value)===su(n)&&this.matchesComparison(cf(n,this.value))}matchesComparison(t){switch(this.op){case"<":return t<0;case"<=":return t<=0;case"==":return t===0;case"!=":return t!==0;case">":return t>0;case">=":return t>=0;default:return Ke(47266,{operator:this.op})}}isInequality(){return["<","<=",">",">=","!=","not-in"].indexOf(this.op)>=0}getFlattenedFilters(){return[this]}getFilters(){return[this]}}class ni extends pH{constructor(t,n){super(),this.filters=t,this.op=n,this.Pe=null}static create(t,n){return new ni(t,n)}matches(t){return fH(this)?this.filters.find(n=>!n.matches(t))===void 0:this.filters.find(n=>n.matches(t))!==void 0}getFlattenedFilters(){return this.Pe!==null||(this.Pe=this.filters.reduce((t,n)=>t.concat(n.getFlattenedFilters()),[])),this.Pe}getFilters(){return Object.assign([],this.filters)}}function fH(e){return e.op==="and"}function mH(e){return NFe(e)&&fH(e)}function NFe(e){for(const t of e.filters)if(t instanceof ni)return!1;return!0}function cT(e){if(e instanceof Yn)return e.field.canonicalString()+e.op.toString()+hf(e.value);if(mH(e))return e.filters.map(t=>cT(t)).join(",");{const t=e.filters.map(n=>cT(n)).join(",");return`${e.op}(${t})`}}function gH(e,t){return e instanceof Yn?function(a,r){return r instanceof Yn&&a.op===r.op&&a.field.isEqual(r.field)&&Bi(a.value,r.value)}(e,t):e instanceof ni?function(a,r){return r instanceof ni&&a.op===r.op&&a.filters.length===r.filters.length?a.filters.reduce((s,i,o)=>s&&gH(i,r.filters[o]),!0):!1}(e,t):void Ke(19439)}function yH(e){return e instanceof Yn?function(n){return`${n.field.canonicalString()} ${n.op} ${hf(n.value)}`}(e):e instanceof ni?function(n){return n.op.toString()+" {"+n.getFilters().map(yH).join(" ,")+"}"}(e):"Filter"}class CFe extends Yn{constructor(t,n,a){super(t,n,a),this.key=Ve.fromName(a.referenceValue)}matches(t){const n=Ve.comparator(t.key,this.key);return this.matchesComparison(n)}}class AFe extends Yn{constructor(t,n){super(t,"in",n),this.keys=bH("in",n)}matches(t){return this.keys.some(n=>n.isEqual(t.key))}}class RFe extends Yn{constructor(t,n){super(t,"not-in",n),this.keys=bH("not-in",n)}matches(t){return!this.keys.some(n=>n.isEqual(t.key))}}function bH(e,t){var n;return(((n=t.arrayValue)==null?void 0:n.values)||[]).map(a=>Ve.fromName(a.referenceValue))}class DFe extends Yn{constructor(t,n){super(t,"array-contains",n)}matches(t){const n=t.data.field(this.field);return eR(n)&&Gy(n.arrayValue,this.value)}}class $Fe extends Yn{constructor(t,n){super(t,"in",n)}matches(t){const n=t.data.field(this.field);return n!==null&&Gy(this.value.arrayValue,n)}}class MFe extends Yn{constructor(t,n){super(t,"not-in",n)}matches(t){if(Gy(this.value.arrayValue,{nullValue:"NULL_VALUE"}))return!1;const n=t.data.field(this.field);return n!==null&&n.nullValue===void 0&&!Gy(this.value.arrayValue,n)}}class OFe extends Yn{constructor(t,n){super(t,"array-contains-any",n)}matches(t){const n=t.data.field(this.field);return!(!eR(n)||!n.arrayValue.values)&&n.arrayValue.values.some(a=>Gy(this.value.arrayValue,a))}}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class FFe{constructor(t,n=null,a=[],r=[],s=null,i=null,o=null){this.path=t,this.collectionGroup=n,this.orderBy=a,this.filters=r,this.limit=s,this.startAt=i,this.endAt=o,this.Te=null}}function zO(e,t=null,n=[],a=[],r=null,s=null,i=null){return new FFe(e,t,n,a,r,s,i)}function tR(e){const t=rt(e);if(t.Te===null){let n=t.path.canonicalString();t.collectionGroup!==null&&(n+="|cg:"+t.collectionGroup),n+="|f:",n+=t.filters.map(a=>cT(a)).join(","),n+="|ob:",n+=t.orderBy.map(a=>function(s){return s.field.canonicalString()+s.dir}(a)).join(","),g_(t.limit)||(n+="|l:",n+=t.limit),t.startAt&&(n+="|lb:",n+=t.startAt.inclusive?"b:":"a:",n+=t.startAt.position.map(a=>hf(a)).join(",")),t.endAt&&(n+="|ub:",n+=t.endAt.inclusive?"a:":"b:",n+=t.endAt.position.map(a=>hf(a)).join(",")),t.Te=n}return t.Te}function nR(e,t){if(e.limit!==t.limit||e.orderBy.length!==t.orderBy.length)return!1;for(let n=0;n<e.orderBy.length;n++)if(!EFe(e.orderBy[n],t.orderBy[n]))return!1;if(e.filters.length!==t.filters.length)return!1;for(let n=0;n<e.filters.length;n++)if(!gH(e.filters[n],t.filters[n]))return!1;return e.collectionGroup===t.collectionGroup&&!!e.path.isEqual(t.path)&&!!LO(e.startAt,t.startAt)&&LO(e.endAt,t.endAt)}function hT(e){return Ve.isDocumentKey(e.path)&&e.collectionGroup===null&&e.filters.length===0}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Qm{constructor(t,n=null,a=[],r=[],s=null,i="F",o=null,l=null){this.path=t,this.collectionGroup=n,this.explicitOrderBy=a,this.filters=r,this.limit=s,this.limitType=i,this.startAt=o,this.endAt=l,this.Ie=null,this.Ee=null,this.de=null,this.startAt,this.endAt}}function LFe(e,t,n,a,r,s,i,o){return new Qm(e,t,n,a,r,s,i,o)}function aR(e){return new Qm(e)}function PO(e){return e.filters.length===0&&e.limit===null&&e.startAt==null&&e.endAt==null&&(e.explicitOrderBy.length===0||e.explicitOrderBy.length===1&&e.explicitOrderBy[0].field.isKeyField())}function vH(e){return e.collectionGroup!==null}function ry(e){const t=rt(e);if(t.Ie===null){t.Ie=[];const n=new Set;for(const s of t.explicitOrderBy)t.Ie.push(s),n.add(s.field.canonicalString());const a=t.explicitOrderBy.length>0?t.explicitOrderBy[t.explicitOrderBy.length-1].dir:"asc";(function(i){let o=new ya(La.comparator);return i.filters.forEach(l=>{l.getFlattenedFilters().forEach(c=>{c.isInequality()&&(o=o.add(c.field))})}),o})(t).forEach(s=>{n.has(s.canonicalString())||s.isKeyField()||t.Ie.push(new Hy(s,a))}),n.has(La.keyField().canonicalString())||t.Ie.push(new Hy(La.keyField(),a))}return t.Ie}function Di(e){const t=rt(e);return t.Ee||(t.Ee=zFe(t,ry(e))),t.Ee}function zFe(e,t){if(e.limitType==="F")return zO(e.path,e.collectionGroup,t,e.filters,e.limit,e.startAt,e.endAt);{t=t.map(r=>{const s=r.dir==="desc"?"asc":"desc";return new Hy(r.field,s)});const n=e.endAt?new hw(e.endAt.position,e.endAt.inclusive):null,a=e.startAt?new hw(e.startAt.position,e.startAt.inclusive):null;return zO(e.path,e.collectionGroup,t,e.filters,e.limit,n,a)}}function dT(e,t){const n=e.filters.concat([t]);return new Qm(e.path,e.collectionGroup,e.explicitOrderBy.slice(),n,e.limit,e.limitType,e.startAt,e.endAt)}function pT(e,t,n){return new Qm(e.path,e.collectionGroup,e.explicitOrderBy.slice(),e.filters.slice(),t,n,e.startAt,e.endAt)}function b_(e,t){return nR(Di(e),Di(t))&&e.limitType===t.limitType}function xH(e){return`${tR(Di(e))}|lt:${e.limitType}`}function tp(e){return`Query(target=${function(n){let a=n.path.canonicalString();return n.collectionGroup!==null&&(a+=" collectionGroup="+n.collectionGroup),n.filters.length>0&&(a+=`, filters: [${n.filters.map(r=>yH(r)).join(", ")}]`),g_(n.limit)||(a+=", limit: "+n.limit),n.orderBy.length>0&&(a+=`, orderBy: [${n.orderBy.map(r=>function(i){return`${i.field.canonicalString()} (${i.dir})`}(r)).join(", ")}]`),n.startAt&&(a+=", startAt: ",a+=n.startAt.inclusive?"b:":"a:",a+=n.startAt.position.map(r=>hf(r)).join(",")),n.endAt&&(a+=", endAt: ",a+=n.endAt.inclusive?"a:":"b:",a+=n.endAt.position.map(r=>hf(r)).join(",")),`Target(${a})`}(Di(e))}; limitType=${e.limitType})`}function v_(e,t){return t.isFoundDocument()&&function(a,r){const s=r.key.path;return a.collectionGroup!==null?r.key.hasCollectionId(a.collectionGroup)&&a.path.isPrefixOf(s):Ve.isDocumentKey(a.path)?a.path.isEqual(s):a.path.isImmediateParentOf(s)}(e,t)&&function(a,r){for(const s of ry(a))if(!s.field.isKeyField()&&r.data.field(s.field)===null)return!1;return!0}(e,t)&&function(a,r){for(const s of a.filters)if(!s.matches(r))return!1;return!0}(e,t)&&function(a,r){return!(a.startAt&&!function(i,o,l){const c=FO(i,o,l);return i.inclusive?c<=0:c<0}(a.startAt,ry(a),r)||a.endAt&&!function(i,o,l){const c=FO(i,o,l);return i.inclusive?c>=0:c>0}(a.endAt,ry(a),r))}(e,t)}function PFe(e){return e.collectionGroup||(e.path.length%2==1?e.path.lastSegment():e.path.get(e.path.length-2))}function wH(e){return(t,n)=>{let a=!1;for(const r of ry(e)){const s=VFe(r,t,n);if(s!==0)return s;a=a||r.field.isKeyField()}return 0}}function VFe(e,t,n){const a=e.field.isKeyField()?Ve.comparator(t.key,n.key):function(s,i,o){const l=i.data.field(s),c=o.data.field(s);return l!==null&&c!==null?cf(l,c):Ke(42886)}(e.field,t,n);switch(e.dir){case"asc":return a;case"desc":return-1*a;default:return Ke(19790,{direction:e.dir})}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Nd{constructor(t,n){this.mapKeyFn=t,this.equalsFn=n,this.inner={},this.innerSize=0}get(t){const n=this.mapKeyFn(t),a=this.inner[n];if(a!==void 0){for(const[r,s]of a)if(this.equalsFn(r,t))return s}}has(t){return this.get(t)!==void 0}set(t,n){const a=this.mapKeyFn(t),r=this.inner[a];if(r===void 0)return this.inner[a]=[[t,n]],void this.innerSize++;for(let s=0;s<r.length;s++)if(this.equalsFn(r[s][0],t))return void(r[s]=[t,n]);r.push([t,n]),this.innerSize++}delete(t){const n=this.mapKeyFn(t),a=this.inner[n];if(a===void 0)return!1;for(let r=0;r<a.length;r++)if(this.equalsFn(a[r][0],t))return a.length===1?delete this.inner[n]:a.splice(r,1),this.innerSize--,!0;return!1}forEach(t){Eu(this.inner,(n,a)=>{for(const[r,s]of a)t(r,s)})}isEmpty(){return rH(this.inner)}size(){return this.innerSize}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const BFe=new En(Ve.comparator);function Ro(){return BFe}const _H=new En(Ve.comparator);function Mg(...e){let t=_H;for(const n of e)t=t.insert(n.key,n);return t}function SH(e){let t=_H;return e.forEach((n,a)=>t=t.insert(n,a.overlayedDocument)),t}function lc(){return sy()}function IH(){return sy()}function sy(){return new Nd(e=>e.toString(),(e,t)=>e.isEqual(t))}const UFe=new En(Ve.comparator),WFe=new ya(Ve.comparator);function It(...e){let t=WFe;for(const n of e)t=t.add(n);return t}const jFe=new ya(St);function GFe(){return jFe}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function rR(e,t){if(e.useProto3Json){if(isNaN(t))return{doubleValue:"NaN"};if(t===1/0)return{doubleValue:"Infinity"};if(t===-1/0)return{doubleValue:"-Infinity"}}return{doubleValue:lw(t)?"-0":t}}function kH(e){return{integerValue:""+e}}function HFe(e,t){return vFe(t)?kH(t):rR(e,t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class x_{constructor(){this._=void 0}}function qFe(e,t,n){return e instanceof dw?function(r,s){const i={fields:{[oH]:{stringValue:iH},[uH]:{timestampValue:{seconds:r.seconds,nanos:r.nanoseconds}}}};return s&&JA(s)&&(s=y_(s)),s&&(i.fields[lH]=s),{mapValue:i}}(n,t):e instanceof qy?EH(e,t):e instanceof Ky?NH(e,t):function(r,s){const i=TH(r,s),o=VO(i)+VO(r.Ae);return uT(i)&&uT(r.Ae)?kH(o):rR(r.serializer,o)}(e,t)}function KFe(e,t,n){return e instanceof qy?EH(e,t):e instanceof Ky?NH(e,t):n}function TH(e,t){return e instanceof pw?function(a){return uT(a)||function(s){return!!s&&"doubleValue"in s}(a)}(t)?t:{integerValue:0}:null}class dw extends x_{}class qy extends x_{constructor(t){super(),this.elements=t}}function EH(e,t){const n=CH(t);for(const a of e.elements)n.some(r=>Bi(r,a))||n.push(a);return{arrayValue:{values:n}}}class Ky extends x_{constructor(t){super(),this.elements=t}}function NH(e,t){let n=CH(t);for(const a of e.elements)n=n.filter(r=>!Bi(r,a));return{arrayValue:{values:n}}}class pw extends x_{constructor(t,n){super(),this.serializer=t,this.Ae=n}}function VO(e){return Fn(e.integerValue||e.doubleValue)}function CH(e){return eR(e)&&e.arrayValue.values?e.arrayValue.values.slice():[]}function XFe(e,t){return e.field.isEqual(t.field)&&function(a,r){return a instanceof qy&&r instanceof qy||a instanceof Ky&&r instanceof Ky?uf(a.elements,r.elements,Bi):a instanceof pw&&r instanceof pw?Bi(a.Ae,r.Ae):a instanceof dw&&r instanceof dw}(e.transform,t.transform)}class QFe{constructor(t,n){this.version=t,this.transformResults=n}}class Ds{constructor(t,n){this.updateTime=t,this.exists=n}static none(){return new Ds}static exists(t){return new Ds(void 0,t)}static updateTime(t){return new Ds(t)}get isNone(){return this.updateTime===void 0&&this.exists===void 0}isEqual(t){return this.exists===t.exists&&(this.updateTime?!!t.updateTime&&this.updateTime.isEqual(t.updateTime):!t.updateTime)}}function Kx(e,t){return e.updateTime!==void 0?t.isFoundDocument()&&t.version.isEqual(e.updateTime):e.exists===void 0||e.exists===t.isFoundDocument()}class w_{}function AH(e,t){if(!e.hasLocalMutations||t&&t.fields.length===0)return null;if(t===null)return e.isNoDocument()?new sR(e.key,Ds.none()):new pv(e.key,e.data,Ds.none());{const n=e.data,a=Rr.empty();let r=new ya(La.comparator);for(let s of t.fields)if(!r.has(s)){let i=n.field(s);i===null&&s.length>1&&(s=s.popLast(),i=n.field(s)),i===null?a.delete(s):a.set(s,i),r=r.add(s)}return new Nu(e.key,a,new ts(r.toArray()),Ds.none())}}function YFe(e,t,n){e instanceof pv?function(r,s,i){const o=r.value.clone(),l=UO(r.fieldTransforms,s,i.transformResults);o.setAll(l),s.convertToFoundDocument(i.version,o).setHasCommittedMutations()}(e,t,n):e instanceof Nu?function(r,s,i){if(!Kx(r.precondition,s))return void s.convertToUnknownDocument(i.version);const o=UO(r.fieldTransforms,s,i.transformResults),l=s.data;l.setAll(RH(r)),l.setAll(o),s.convertToFoundDocument(i.version,l).setHasCommittedMutations()}(e,t,n):function(r,s,i){s.convertToNoDocument(i.version).setHasCommittedMutations()}(0,t,n)}function iy(e,t,n,a){return e instanceof pv?function(s,i,o,l){if(!Kx(s.precondition,i))return o;const c=s.value.clone(),u=WO(s.fieldTransforms,l,i);return c.setAll(u),i.convertToFoundDocument(i.version,c).setHasLocalMutations(),null}(e,t,n,a):e instanceof Nu?function(s,i,o,l){if(!Kx(s.precondition,i))return o;const c=WO(s.fieldTransforms,l,i),u=i.data;return u.setAll(RH(s)),u.setAll(c),i.convertToFoundDocument(i.version,u).setHasLocalMutations(),o===null?null:o.unionWith(s.fieldMask.fields).unionWith(s.fieldTransforms.map(h=>h.field))}(e,t,n,a):function(s,i,o){return Kx(s.precondition,i)?(i.convertToNoDocument(i.version).setHasLocalMutations(),null):o}(e,t,n)}function ZFe(e,t){let n=null;for(const a of e.fieldTransforms){const r=t.data.field(a.field),s=TH(a.transform,r||null);s!=null&&(n===null&&(n=Rr.empty()),n.set(a.field,s))}return n||null}function BO(e,t){return e.type===t.type&&!!e.key.isEqual(t.key)&&!!e.precondition.isEqual(t.precondition)&&!!function(a,r){return a===void 0&&r===void 0||!(!a||!r)&&uf(a,r,(s,i)=>XFe(s,i))}(e.fieldTransforms,t.fieldTransforms)&&(e.type===0?e.value.isEqual(t.value):e.type!==1||e.data.isEqual(t.data)&&e.fieldMask.isEqual(t.fieldMask))}class pv extends w_{constructor(t,n,a,r=[]){super(),this.key=t,this.value=n,this.precondition=a,this.fieldTransforms=r,this.type=0}getFieldMask(){return null}}class Nu extends w_{constructor(t,n,a,r,s=[]){super(),this.key=t,this.data=n,this.fieldMask=a,this.precondition=r,this.fieldTransforms=s,this.type=1}getFieldMask(){return this.fieldMask}}function RH(e){const t=new Map;return e.fieldMask.fields.forEach(n=>{if(!n.isEmpty()){const a=e.data.field(n);t.set(n,a)}}),t}function UO(e,t,n){const a=new Map;Wt(e.length===n.length,32656,{Re:n.length,Ve:e.length});for(let r=0;r<n.length;r++){const s=e[r],i=s.transform,o=t.data.field(s.field);a.set(s.field,KFe(i,o,n[r]))}return a}function WO(e,t,n){const a=new Map;for(const r of e){const s=r.transform,i=n.data.field(r.field);a.set(r.field,qFe(s,i,t))}return a}class sR extends w_{constructor(t,n){super(),this.key=t,this.precondition=n,this.type=2,this.fieldTransforms=[]}getFieldMask(){return null}}class JFe extends w_{constructor(t,n){super(),this.key=t,this.precondition=n,this.type=3,this.fieldTransforms=[]}getFieldMask(){return null}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class e3e{constructor(t,n,a,r){this.batchId=t,this.localWriteTime=n,this.baseMutations=a,this.mutations=r}applyToRemoteDocument(t,n){const a=n.mutationResults;for(let r=0;r<this.mutations.length;r++){const s=this.mutations[r];s.key.isEqual(t.key)&&YFe(s,t,a[r])}}applyToLocalView(t,n){for(const a of this.baseMutations)a.key.isEqual(t.key)&&(n=iy(a,t,n,this.localWriteTime));for(const a of this.mutations)a.key.isEqual(t.key)&&(n=iy(a,t,n,this.localWriteTime));return n}applyToLocalDocumentSet(t,n){const a=IH();return this.mutations.forEach(r=>{const s=t.get(r.key),i=s.overlayedDocument;let o=this.applyToLocalView(i,s.mutatedFields);o=n.has(r.key)?null:o;const l=AH(i,o);l!==null&&a.set(r.key,l),i.isValidDocument()||i.convertToNoDocument(nt.min())}),a}keys(){return this.mutations.reduce((t,n)=>t.add(n.key),It())}isEqual(t){return this.batchId===t.batchId&&uf(this.mutations,t.mutations,(n,a)=>BO(n,a))&&uf(this.baseMutations,t.baseMutations,(n,a)=>BO(n,a))}}class iR{constructor(t,n,a,r){this.batch=t,this.commitVersion=n,this.mutationResults=a,this.docVersions=r}static from(t,n,a){Wt(t.mutations.length===a.length,58842,{me:t.mutations.length,fe:a.length});let r=function(){return UFe}();const s=t.mutations;for(let i=0;i<s.length;i++)r=r.insert(s[i].key,a[i].version);return new iR(t,n,a,r)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class t3e{constructor(t,n){this.largestBatchId=t,this.mutation=n}getKey(){return this.mutation.key}isEqual(t){return t!==null&&this.mutation===t.mutation}toString(){return`Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class n3e{constructor(t,n){this.count=t,this.unchangedNames=n}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var qn,Rt;function a3e(e){switch(e){case ce.OK:return Ke(64938);case ce.CANCELLED:case ce.UNKNOWN:case ce.DEADLINE_EXCEEDED:case ce.RESOURCE_EXHAUSTED:case ce.INTERNAL:case ce.UNAVAILABLE:case ce.UNAUTHENTICATED:return!1;case ce.INVALID_ARGUMENT:case ce.NOT_FOUND:case ce.ALREADY_EXISTS:case ce.PERMISSION_DENIED:case ce.FAILED_PRECONDITION:case ce.ABORTED:case ce.OUT_OF_RANGE:case ce.UNIMPLEMENTED:case ce.DATA_LOSS:return!0;default:return Ke(15467,{code:e})}}function DH(e){if(e===void 0)return Ao("GRPC error has no .code"),ce.UNKNOWN;switch(e){case qn.OK:return ce.OK;case qn.CANCELLED:return ce.CANCELLED;case qn.UNKNOWN:return ce.UNKNOWN;case qn.DEADLINE_EXCEEDED:return ce.DEADLINE_EXCEEDED;case qn.RESOURCE_EXHAUSTED:return ce.RESOURCE_EXHAUSTED;case qn.INTERNAL:return ce.INTERNAL;case qn.UNAVAILABLE:return ce.UNAVAILABLE;case qn.UNAUTHENTICATED:return ce.UNAUTHENTICATED;case qn.INVALID_ARGUMENT:return ce.INVALID_ARGUMENT;case qn.NOT_FOUND:return ce.NOT_FOUND;case qn.ALREADY_EXISTS:return ce.ALREADY_EXISTS;case qn.PERMISSION_DENIED:return ce.PERMISSION_DENIED;case qn.FAILED_PRECONDITION:return ce.FAILED_PRECONDITION;case qn.ABORTED:return ce.ABORTED;case qn.OUT_OF_RANGE:return ce.OUT_OF_RANGE;case qn.UNIMPLEMENTED:return ce.UNIMPLEMENTED;case qn.DATA_LOSS:return ce.DATA_LOSS;default:return Ke(39323,{code:e})}}(Rt=qn||(qn={}))[Rt.OK=0]="OK",Rt[Rt.CANCELLED=1]="CANCELLED",Rt[Rt.UNKNOWN=2]="UNKNOWN",Rt[Rt.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",Rt[Rt.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",Rt[Rt.NOT_FOUND=5]="NOT_FOUND",Rt[Rt.ALREADY_EXISTS=6]="ALREADY_EXISTS",Rt[Rt.PERMISSION_DENIED=7]="PERMISSION_DENIED",Rt[Rt.UNAUTHENTICATED=16]="UNAUTHENTICATED",Rt[Rt.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",Rt[Rt.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",Rt[Rt.ABORTED=10]="ABORTED",Rt[Rt.OUT_OF_RANGE=11]="OUT_OF_RANGE",Rt[Rt.UNIMPLEMENTED=12]="UNIMPLEMENTED",Rt[Rt.INTERNAL=13]="INTERNAL",Rt[Rt.UNAVAILABLE=14]="UNAVAILABLE",Rt[Rt.DATA_LOSS=15]="DATA_LOSS";/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function r3e(){return new TextEncoder}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const s3e=new Ml([4294967295,4294967295],0);function jO(e){const t=r3e().encode(e),n=new qG;return n.update(t),new Uint8Array(n.digest())}function GO(e){const t=new DataView(e.buffer),n=t.getUint32(0,!0),a=t.getUint32(4,!0),r=t.getUint32(8,!0),s=t.getUint32(12,!0);return[new Ml([n,a],0),new Ml([r,s],0)]}class oR{constructor(t,n,a){if(this.bitmap=t,this.padding=n,this.hashCount=a,n<0||n>=8)throw new Og(`Invalid padding: ${n}`);if(a<0)throw new Og(`Invalid hash count: ${a}`);if(t.length>0&&this.hashCount===0)throw new Og(`Invalid hash count: ${a}`);if(t.length===0&&n!==0)throw new Og(`Invalid padding when bitmap length is 0: ${n}`);this.ge=8*t.length-n,this.pe=Ml.fromNumber(this.ge)}ye(t,n,a){let r=t.add(n.multiply(Ml.fromNumber(a)));return r.compare(s3e)===1&&(r=new Ml([r.getBits(0),r.getBits(1)],0)),r.modulo(this.pe).toNumber()}we(t){return!!(this.bitmap[Math.floor(t/8)]&1<<t%8)}mightContain(t){if(this.ge===0)return!1;const n=jO(t),[a,r]=GO(n);for(let s=0;s<this.hashCount;s++){const i=this.ye(a,r,s);if(!this.we(i))return!1}return!0}static create(t,n,a){const r=t%8==0?0:8-t%8,s=new Uint8Array(Math.ceil(t/8)),i=new oR(s,r,n);return a.forEach(o=>i.insert(o)),i}insert(t){if(this.ge===0)return;const n=jO(t),[a,r]=GO(n);for(let s=0;s<this.hashCount;s++){const i=this.ye(a,r,s);this.Se(i)}}Se(t){const n=Math.floor(t/8),a=t%8;this.bitmap[n]|=1<<a}}class Og extends Error{constructor(){super(...arguments),this.name="BloomFilterError"}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class __{constructor(t,n,a,r,s){this.snapshotVersion=t,this.targetChanges=n,this.targetMismatches=a,this.documentUpdates=r,this.resolvedLimboDocuments=s}static createSynthesizedRemoteEventForCurrentChange(t,n,a){const r=new Map;return r.set(t,fv.createSynthesizedTargetChangeForCurrentChange(t,n,a)),new __(nt.min(),r,new En(St),Ro(),It())}}class fv{constructor(t,n,a,r,s){this.resumeToken=t,this.current=n,this.addedDocuments=a,this.modifiedDocuments=r,this.removedDocuments=s}static createSynthesizedTargetChangeForCurrentChange(t,n,a){return new fv(a,n,It(),It(),It())}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Xx{constructor(t,n,a,r){this.be=t,this.removedTargetIds=n,this.key=a,this.De=r}}class $H{constructor(t,n){this.targetId=t,this.Ce=n}}class MH{constructor(t,n,a=Ua.EMPTY_BYTE_STRING,r=null){this.state=t,this.targetIds=n,this.resumeToken=a,this.cause=r}}class HO{constructor(){this.ve=0,this.Fe=qO(),this.Me=Ua.EMPTY_BYTE_STRING,this.xe=!1,this.Oe=!0}get current(){return this.xe}get resumeToken(){return this.Me}get Ne(){return this.ve!==0}get Be(){return this.Oe}Le(t){t.approximateByteSize()>0&&(this.Oe=!0,this.Me=t)}ke(){let t=It(),n=It(),a=It();return this.Fe.forEach((r,s)=>{switch(s){case 0:t=t.add(r);break;case 2:n=n.add(r);break;case 1:a=a.add(r);break;default:Ke(38017,{changeType:s})}}),new fv(this.Me,this.xe,t,n,a)}qe(){this.Oe=!1,this.Fe=qO()}Qe(t,n){this.Oe=!0,this.Fe=this.Fe.insert(t,n)}$e(t){this.Oe=!0,this.Fe=this.Fe.remove(t)}Ue(){this.ve+=1}Ke(){this.ve-=1,Wt(this.ve>=0,3241,{ve:this.ve})}We(){this.Oe=!0,this.xe=!0}}class i3e{constructor(t){this.Ge=t,this.ze=new Map,this.je=Ro(),this.Je=yx(),this.He=yx(),this.Ye=new En(St)}Ze(t){for(const n of t.be)t.De&&t.De.isFoundDocument()?this.Xe(n,t.De):this.et(n,t.key,t.De);for(const n of t.removedTargetIds)this.et(n,t.key,t.De)}tt(t){this.forEachTarget(t,n=>{const a=this.nt(n);switch(t.state){case 0:this.rt(n)&&a.Le(t.resumeToken);break;case 1:a.Ke(),a.Ne||a.qe(),a.Le(t.resumeToken);break;case 2:a.Ke(),a.Ne||this.removeTarget(n);break;case 3:this.rt(n)&&(a.We(),a.Le(t.resumeToken));break;case 4:this.rt(n)&&(this.it(n),a.Le(t.resumeToken));break;default:Ke(56790,{state:t.state})}})}forEachTarget(t,n){t.targetIds.length>0?t.targetIds.forEach(n):this.ze.forEach((a,r)=>{this.rt(r)&&n(r)})}st(t){const n=t.targetId,a=t.Ce.count,r=this.ot(n);if(r){const s=r.target;if(hT(s))if(a===0){const i=new Ve(s.path);this.et(n,i,Xa.newNoDocument(i,nt.min()))}else Wt(a===1,20013,{expectedCount:a});else{const i=this._t(n);if(i!==a){const o=this.ut(t),l=o?this.ct(o,t,i):1;if(l!==0){this.it(n);const c=l===2?"TargetPurposeExistenceFilterMismatchBloom":"TargetPurposeExistenceFilterMismatch";this.Ye=this.Ye.insert(n,c)}}}}}ut(t){const n=t.Ce.unchangedNames;if(!n||!n.bits)return null;const{bits:{bitmap:a="",padding:r=0},hashCount:s=0}=n;let i,o;try{i=ru(a).toUint8Array()}catch(l){if(l instanceof sH)return lf("Decoding the base64 bloom filter in existence filter failed ("+l.message+"); ignoring the bloom filter and falling back to full re-query."),null;throw l}try{o=new oR(i,r,s)}catch(l){return lf(l instanceof Og?"BloomFilter error: ":"Applying bloom filter failed: ",l),null}return o.ge===0?null:o}ct(t,n,a){return n.Ce.count===a-this.Pt(t,n.targetId)?0:2}Pt(t,n){const a=this.Ge.getRemoteKeysForTarget(n);let r=0;return a.forEach(s=>{const i=this.Ge.ht(),o=`projects/${i.projectId}/databases/${i.database}/documents/${s.path.canonicalString()}`;t.mightContain(o)||(this.et(n,s,null),r++)}),r}Tt(t){const n=new Map;this.ze.forEach((s,i)=>{const o=this.ot(i);if(o){if(s.current&&hT(o.target)){const l=new Ve(o.target.path);this.It(l).has(i)||this.Et(i,l)||this.et(i,l,Xa.newNoDocument(l,t))}s.Be&&(n.set(i,s.ke()),s.qe())}});let a=It();this.He.forEach((s,i)=>{let o=!0;i.forEachWhile(l=>{const c=this.ot(l);return!c||c.purpose==="TargetPurposeLimboResolution"||(o=!1,!1)}),o&&(a=a.add(s))}),this.je.forEach((s,i)=>i.setReadTime(t));const r=new __(t,n,this.Ye,this.je,a);return this.je=Ro(),this.Je=yx(),this.He=yx(),this.Ye=new En(St),r}Xe(t,n){if(!this.rt(t))return;const a=this.Et(t,n.key)?2:0;this.nt(t).Qe(n.key,a),this.je=this.je.insert(n.key,n),this.Je=this.Je.insert(n.key,this.It(n.key).add(t)),this.He=this.He.insert(n.key,this.dt(n.key).add(t))}et(t,n,a){if(!this.rt(t))return;const r=this.nt(t);this.Et(t,n)?r.Qe(n,1):r.$e(n),this.He=this.He.insert(n,this.dt(n).delete(t)),this.He=this.He.insert(n,this.dt(n).add(t)),a&&(this.je=this.je.insert(n,a))}removeTarget(t){this.ze.delete(t)}_t(t){const n=this.nt(t).ke();return this.Ge.getRemoteKeysForTarget(t).size+n.addedDocuments.size-n.removedDocuments.size}Ue(t){this.nt(t).Ue()}nt(t){let n=this.ze.get(t);return n||(n=new HO,this.ze.set(t,n)),n}dt(t){let n=this.He.get(t);return n||(n=new ya(St),this.He=this.He.insert(t,n)),n}It(t){let n=this.Je.get(t);return n||(n=new ya(St),this.Je=this.Je.insert(t,n)),n}rt(t){const n=this.ot(t)!==null;return n||Ae("WatchChangeAggregator","Detected inactive target",t),n}ot(t){const n=this.ze.get(t);return n&&n.Ne?null:this.Ge.At(t)}it(t){this.ze.set(t,new HO),this.Ge.getRemoteKeysForTarget(t).forEach(n=>{this.et(t,n,null)})}Et(t,n){return this.Ge.getRemoteKeysForTarget(t).has(n)}}function yx(){return new En(Ve.comparator)}function qO(){return new En(Ve.comparator)}const o3e={asc:"ASCENDING",desc:"DESCENDING"},l3e={"<":"LESS_THAN","<=":"LESS_THAN_OR_EQUAL",">":"GREATER_THAN",">=":"GREATER_THAN_OR_EQUAL","==":"EQUAL","!=":"NOT_EQUAL","array-contains":"ARRAY_CONTAINS",in:"IN","not-in":"NOT_IN","array-contains-any":"ARRAY_CONTAINS_ANY"},u3e={and:"AND",or:"OR"};class c3e{constructor(t,n){this.databaseId=t,this.useProto3Json=n}}function fT(e,t){return e.useProto3Json||g_(t)?t:{value:t}}function fw(e,t){return e.useProto3Json?`${new Date(1e3*t.seconds).toISOString().replace(/\.\d*/,"").replace("Z","")}.${("000000000"+t.nanoseconds).slice(-9)}Z`:{seconds:""+t.seconds,nanos:t.nanoseconds}}function OH(e,t){return e.useProto3Json?t.toBase64():t.toUint8Array()}function h3e(e,t){return fw(e,t.toTimestamp())}function $i(e){return Wt(!!e,49232),nt.fromTimestamp(function(n){const a=au(n);return new fn(a.seconds,a.nanos)}(e))}function lR(e,t){return mT(e,t).canonicalString()}function mT(e,t){const n=function(r){return new un(["projects",r.projectId,"databases",r.database])}(e).child("documents");return t===void 0?n:n.child(t)}function FH(e){const t=un.fromString(e);return Wt(BH(t),10190,{key:t.toString()}),t}function gT(e,t){return lR(e.databaseId,t.path)}function qS(e,t){const n=FH(t);if(n.get(1)!==e.databaseId.projectId)throw new Te(ce.INVALID_ARGUMENT,"Tried to deserialize key from different project: "+n.get(1)+" vs "+e.databaseId.projectId);if(n.get(3)!==e.databaseId.database)throw new Te(ce.INVALID_ARGUMENT,"Tried to deserialize key from different database: "+n.get(3)+" vs "+e.databaseId.database);return new Ve(zH(n))}function LH(e,t){return lR(e.databaseId,t)}function d3e(e){const t=FH(e);return t.length===4?un.emptyPath():zH(t)}function yT(e){return new un(["projects",e.databaseId.projectId,"databases",e.databaseId.database]).canonicalString()}function zH(e){return Wt(e.length>4&&e.get(4)==="documents",29091,{key:e.toString()}),e.popFirst(5)}function KO(e,t,n){return{name:gT(e,t),fields:n.value.mapValue.fields}}function p3e(e,t){let n;if("targetChange"in t){t.targetChange;const a=function(c){return c==="NO_CHANGE"?0:c==="ADD"?1:c==="REMOVE"?2:c==="CURRENT"?3:c==="RESET"?4:Ke(39313,{state:c})}(t.targetChange.targetChangeType||"NO_CHANGE"),r=t.targetChange.targetIds||[],s=function(c,u){return c.useProto3Json?(Wt(u===void 0||typeof u=="string",58123),Ua.fromBase64String(u||"")):(Wt(u===void 0||u instanceof Buffer||u instanceof Uint8Array,16193),Ua.fromUint8Array(u||new Uint8Array))}(e,t.targetChange.resumeToken),i=t.targetChange.cause,o=i&&function(c){const u=c.code===void 0?ce.UNKNOWN:DH(c.code);return new Te(u,c.message||"")}(i);n=new MH(a,r,s,o||null)}else if("documentChange"in t){t.documentChange;const a=t.documentChange;a.document,a.document.name,a.document.updateTime;const r=qS(e,a.document.name),s=$i(a.document.updateTime),i=a.document.createTime?$i(a.document.createTime):nt.min(),o=new Rr({mapValue:{fields:a.document.fields}}),l=Xa.newFoundDocument(r,s,i,o),c=a.targetIds||[],u=a.removedTargetIds||[];n=new Xx(c,u,l.key,l)}else if("documentDelete"in t){t.documentDelete;const a=t.documentDelete;a.document;const r=qS(e,a.document),s=a.readTime?$i(a.readTime):nt.min(),i=Xa.newNoDocument(r,s),o=a.removedTargetIds||[];n=new Xx([],o,i.key,i)}else if("documentRemove"in t){t.documentRemove;const a=t.documentRemove;a.document;const r=qS(e,a.document),s=a.removedTargetIds||[];n=new Xx([],s,r,null)}else{if(!("filter"in t))return Ke(11601,{Rt:t});{t.filter;const a=t.filter;a.targetId;const{count:r=0,unchangedNames:s}=a,i=new n3e(r,s),o=a.targetId;n=new $H(o,i)}}return n}function f3e(e,t){let n;if(t instanceof pv)n={update:KO(e,t.key,t.value)};else if(t instanceof sR)n={delete:gT(e,t.key)};else if(t instanceof Nu)n={update:KO(e,t.key,t.data),updateMask:S3e(t.fieldMask)};else{if(!(t instanceof JFe))return Ke(16599,{Vt:t.type});n={verify:gT(e,t.key)}}return t.fieldTransforms.length>0&&(n.updateTransforms=t.fieldTransforms.map(a=>function(s,i){const o=i.transform;if(o instanceof dw)return{fieldPath:i.field.canonicalString(),setToServerValue:"REQUEST_TIME"};if(o instanceof qy)return{fieldPath:i.field.canonicalString(),appendMissingElements:{values:o.elements}};if(o instanceof Ky)return{fieldPath:i.field.canonicalString(),removeAllFromArray:{values:o.elements}};if(o instanceof pw)return{fieldPath:i.field.canonicalString(),increment:o.Ae};throw Ke(20930,{transform:i.transform})}(0,a))),t.precondition.isNone||(n.currentDocument=function(r,s){return s.updateTime!==void 0?{updateTime:h3e(r,s.updateTime)}:s.exists!==void 0?{exists:s.exists}:Ke(27497)}(e,t.precondition)),n}function m3e(e,t){return e&&e.length>0?(Wt(t!==void 0,14353),e.map(n=>function(r,s){let i=r.updateTime?$i(r.updateTime):$i(s);return i.isEqual(nt.min())&&(i=$i(s)),new QFe(i,r.transformResults||[])}(n,t))):[]}function g3e(e,t){return{documents:[LH(e,t.path)]}}function y3e(e,t){const n={structuredQuery:{}},a=t.path;let r;t.collectionGroup!==null?(r=a,n.structuredQuery.from=[{collectionId:t.collectionGroup,allDescendants:!0}]):(r=a.popLast(),n.structuredQuery.from=[{collectionId:a.lastSegment()}]),n.parent=LH(e,r);const s=function(c){if(c.length!==0)return VH(ni.create(c,"and"))}(t.filters);s&&(n.structuredQuery.where=s);const i=function(c){if(c.length!==0)return c.map(u=>function(d){return{field:np(d.field),direction:x3e(d.dir)}}(u))}(t.orderBy);i&&(n.structuredQuery.orderBy=i);const o=fT(e,t.limit);return o!==null&&(n.structuredQuery.limit=o),t.startAt&&(n.structuredQuery.startAt=function(c){return{before:c.inclusive,values:c.position}}(t.startAt)),t.endAt&&(n.structuredQuery.endAt=function(c){return{before:!c.inclusive,values:c.position}}(t.endAt)),{ft:n,parent:r}}function b3e(e){let t=d3e(e.parent);const n=e.structuredQuery,a=n.from?n.from.length:0;let r=null;if(a>0){Wt(a===1,65062);const u=n.from[0];u.allDescendants?r=u.collectionId:t=t.child(u.collectionId)}let s=[];n.where&&(s=function(h){const d=PH(h);return d instanceof ni&&mH(d)?d.getFilters():[d]}(n.where));let i=[];n.orderBy&&(i=function(h){return h.map(d=>function(f){return new Hy(ap(f.field),function(g){switch(g){case"ASCENDING":return"asc";case"DESCENDING":return"desc";default:return}}(f.direction))}(d))}(n.orderBy));let o=null;n.limit&&(o=function(h){let d;return d=typeof h=="object"?h.value:h,g_(d)?null:d}(n.limit));let l=null;n.startAt&&(l=function(h){const d=!!h.before,p=h.values||[];return new hw(p,d)}(n.startAt));let c=null;return n.endAt&&(c=function(h){const d=!h.before,p=h.values||[];return new hw(p,d)}(n.endAt)),LFe(t,r,i,s,o,"F",l,c)}function v3e(e,t){const n=function(r){switch(r){case"TargetPurposeListen":return null;case"TargetPurposeExistenceFilterMismatch":return"existence-filter-mismatch";case"TargetPurposeExistenceFilterMismatchBloom":return"existence-filter-mismatch-bloom";case"TargetPurposeLimboResolution":return"limbo-document";default:return Ke(28987,{purpose:r})}}(t.purpose);return n==null?null:{"goog-listen-tags":n}}function PH(e){return e.unaryFilter!==void 0?function(n){switch(n.unaryFilter.op){case"IS_NAN":const a=ap(n.unaryFilter.field);return Yn.create(a,"==",{doubleValue:NaN});case"IS_NULL":const r=ap(n.unaryFilter.field);return Yn.create(r,"==",{nullValue:"NULL_VALUE"});case"IS_NOT_NAN":const s=ap(n.unaryFilter.field);return Yn.create(s,"!=",{doubleValue:NaN});case"IS_NOT_NULL":const i=ap(n.unaryFilter.field);return Yn.create(i,"!=",{nullValue:"NULL_VALUE"});case"OPERATOR_UNSPECIFIED":return Ke(61313);default:return Ke(60726)}}(e):e.fieldFilter!==void 0?function(n){return Yn.create(ap(n.fieldFilter.field),function(r){switch(r){case"EQUAL":return"==";case"NOT_EQUAL":return"!=";case"GREATER_THAN":return">";case"GREATER_THAN_OR_EQUAL":return">=";case"LESS_THAN":return"<";case"LESS_THAN_OR_EQUAL":return"<=";case"ARRAY_CONTAINS":return"array-contains";case"IN":return"in";case"NOT_IN":return"not-in";case"ARRAY_CONTAINS_ANY":return"array-contains-any";case"OPERATOR_UNSPECIFIED":return Ke(58110);default:return Ke(50506)}}(n.fieldFilter.op),n.fieldFilter.value)}(e):e.compositeFilter!==void 0?function(n){return ni.create(n.compositeFilter.filters.map(a=>PH(a)),function(r){switch(r){case"AND":return"and";case"OR":return"or";default:return Ke(1026)}}(n.compositeFilter.op))}(e):Ke(30097,{filter:e})}function x3e(e){return o3e[e]}function w3e(e){return l3e[e]}function _3e(e){return u3e[e]}function np(e){return{fieldPath:e.canonicalString()}}function ap(e){return La.fromServerFormat(e.fieldPath)}function VH(e){return e instanceof Yn?function(n){if(n.op==="=="){if(OO(n.value))return{unaryFilter:{field:np(n.field),op:"IS_NAN"}};if(MO(n.value))return{unaryFilter:{field:np(n.field),op:"IS_NULL"}}}else if(n.op==="!="){if(OO(n.value))return{unaryFilter:{field:np(n.field),op:"IS_NOT_NAN"}};if(MO(n.value))return{unaryFilter:{field:np(n.field),op:"IS_NOT_NULL"}}}return{fieldFilter:{field:np(n.field),op:w3e(n.op),value:n.value}}}(e):e instanceof ni?function(n){const a=n.getFilters().map(r=>VH(r));return a.length===1?a[0]:{compositeFilter:{op:_3e(n.op),filters:a}}}(e):Ke(54877,{filter:e})}function S3e(e){const t=[];return e.fields.forEach(n=>t.push(n.canonicalString())),{fieldPaths:t}}function BH(e){return e.length>=4&&e.get(0)==="projects"&&e.get(2)==="databases"}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class vl{constructor(t,n,a,r,s=nt.min(),i=nt.min(),o=Ua.EMPTY_BYTE_STRING,l=null){this.target=t,this.targetId=n,this.purpose=a,this.sequenceNumber=r,this.snapshotVersion=s,this.lastLimboFreeSnapshotVersion=i,this.resumeToken=o,this.expectedCount=l}withSequenceNumber(t){return new vl(this.target,this.targetId,this.purpose,t,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,this.expectedCount)}withResumeToken(t,n){return new vl(this.target,this.targetId,this.purpose,this.sequenceNumber,n,this.lastLimboFreeSnapshotVersion,t,null)}withExpectedCount(t){return new vl(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,t)}withLastLimboFreeSnapshotVersion(t){return new vl(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,t,this.resumeToken,this.expectedCount)}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class I3e{constructor(t){this.yt=t}}function k3e(e){const t=b3e({parent:e.parent,structuredQuery:e.structuredQuery});return e.limitType==="LAST"?pT(t,t.limit,"L"):t}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class T3e{constructor(){this.Cn=new E3e}addToCollectionParentIndex(t,n){return this.Cn.add(n),fe.resolve()}getCollectionParents(t,n){return fe.resolve(this.Cn.getEntries(n))}addFieldIndex(t,n){return fe.resolve()}deleteFieldIndex(t,n){return fe.resolve()}deleteAllFieldIndexes(t){return fe.resolve()}createTargetIndexes(t,n){return fe.resolve()}getDocumentsMatchingTarget(t,n){return fe.resolve(null)}getIndexType(t,n){return fe.resolve(0)}getFieldIndexes(t,n){return fe.resolve([])}getNextCollectionGroupToUpdate(t){return fe.resolve(null)}getMinOffset(t,n){return fe.resolve(nu.min())}getMinOffsetFromCollectionGroup(t,n){return fe.resolve(nu.min())}updateCollectionGroup(t,n,a){return fe.resolve()}updateIndexEntries(t,n){return fe.resolve()}}class E3e{constructor(){this.index={}}add(t){const n=t.lastSegment(),a=t.popLast(),r=this.index[n]||new ya(un.comparator),s=!r.has(a);return this.index[n]=r.add(a),s}has(t){const n=t.lastSegment(),a=t.popLast(),r=this.index[n];return r&&r.has(a)}getEntries(t){return(this.index[t]||new ya(un.comparator)).toArray()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const XO={didRun:!1,sequenceNumbersCollected:0,targetsRemoved:0,documentsRemoved:0},UH=41943040;class Cr{static withCacheSize(t){return new Cr(t,Cr.DEFAULT_COLLECTION_PERCENTILE,Cr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)}constructor(t,n,a){this.cacheSizeCollectionThreshold=t,this.percentileToCollect=n,this.maximumSequenceNumbersToCollect=a}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */Cr.DEFAULT_COLLECTION_PERCENTILE=10,Cr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT=1e3,Cr.DEFAULT=new Cr(UH,Cr.DEFAULT_COLLECTION_PERCENTILE,Cr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT),Cr.DISABLED=new Cr(-1,0,0);/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class df{constructor(t){this.ar=t}next(){return this.ar+=2,this.ar}static ur(){return new df(0)}static cr(){return new df(-1)}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const QO="LruGarbageCollector",N3e=1048576;function YO([e,t],[n,a]){const r=St(e,n);return r===0?St(t,a):r}class C3e{constructor(t){this.Ir=t,this.buffer=new ya(YO),this.Er=0}dr(){return++this.Er}Ar(t){const n=[t,this.dr()];if(this.buffer.size<this.Ir)this.buffer=this.buffer.add(n);else{const a=this.buffer.last();YO(n,a)<0&&(this.buffer=this.buffer.delete(a).add(n))}}get maxValue(){return this.buffer.last()[0]}}class A3e{constructor(t,n,a){this.garbageCollector=t,this.asyncQueue=n,this.localStore=a,this.Rr=null}start(){this.garbageCollector.params.cacheSizeCollectionThreshold!==-1&&this.Vr(6e4)}stop(){this.Rr&&(this.Rr.cancel(),this.Rr=null)}get started(){return this.Rr!==null}Vr(t){Ae(QO,`Garbage collection scheduled in ${t}ms`),this.Rr=this.asyncQueue.enqueueAfterDelay("lru_garbage_collection",t,async()=>{this.Rr=null;try{await this.localStore.collectGarbage(this.garbageCollector)}catch(n){Xm(n)?Ae(QO,"Ignoring IndexedDB error during garbage collection: ",n):await Km(n)}await this.Vr(3e5)})}}class R3e{constructor(t,n){this.mr=t,this.params=n}calculateTargetCount(t,n){return this.mr.gr(t).next(a=>Math.floor(n/100*a))}nthSequenceNumber(t,n){if(n===0)return fe.resolve(m_.ce);const a=new C3e(n);return this.mr.forEachTarget(t,r=>a.Ar(r.sequenceNumber)).next(()=>this.mr.pr(t,r=>a.Ar(r))).next(()=>a.maxValue)}removeTargets(t,n,a){return this.mr.removeTargets(t,n,a)}removeOrphanedDocuments(t,n){return this.mr.removeOrphanedDocuments(t,n)}collect(t,n){return this.params.cacheSizeCollectionThreshold===-1?(Ae("LruGarbageCollector","Garbage collection skipped; disabled"),fe.resolve(XO)):this.getCacheSize(t).next(a=>a<this.params.cacheSizeCollectionThreshold?(Ae("LruGarbageCollector",`Garbage collection skipped; Cache size ${a} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`),XO):this.yr(t,n))}getCacheSize(t){return this.mr.getCacheSize(t)}yr(t,n){let a,r,s,i,o,l,c;const u=Date.now();return this.calculateTargetCount(t,this.params.percentileToCollect).next(h=>(h>this.params.maximumSequenceNumbersToCollect?(Ae("LruGarbageCollector",`Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${h}`),r=this.params.maximumSequenceNumbersToCollect):r=h,i=Date.now(),this.nthSequenceNumber(t,r))).next(h=>(a=h,o=Date.now(),this.removeTargets(t,a,n))).next(h=>(s=h,l=Date.now(),this.removeOrphanedDocuments(t,a))).next(h=>(c=Date.now(),ep()<=Dt.DEBUG&&Ae("LruGarbageCollector",`LRU Garbage Collection
	Counted targets in ${i-u}ms
	Determined least recently used ${r} in `+(o-i)+`ms
	Removed ${s} targets in `+(l-o)+`ms
	Removed ${h} documents in `+(c-l)+`ms
Total Duration: ${c-u}ms`),fe.resolve({didRun:!0,sequenceNumbersCollected:r,targetsRemoved:s,documentsRemoved:h})))}}function D3e(e,t){return new R3e(e,t)}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class $3e{constructor(){this.changes=new Nd(t=>t.toString(),(t,n)=>t.isEqual(n)),this.changesApplied=!1}addEntry(t){this.assertNotApplied(),this.changes.set(t.key,t)}removeEntry(t,n){this.assertNotApplied(),this.changes.set(t,Xa.newInvalidDocument(t).setReadTime(n))}getEntry(t,n){this.assertNotApplied();const a=this.changes.get(n);return a!==void 0?fe.resolve(a):this.getFromCache(t,n)}getEntries(t,n){return this.getAllFromCache(t,n)}apply(t){return this.assertNotApplied(),this.changesApplied=!0,this.applyChanges(t)}assertNotApplied(){}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class M3e{constructor(t,n){this.overlayedDocument=t,this.mutatedFields=n}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class O3e{constructor(t,n,a,r){this.remoteDocumentCache=t,this.mutationQueue=n,this.documentOverlayCache=a,this.indexManager=r}getDocument(t,n){let a=null;return this.documentOverlayCache.getOverlay(t,n).next(r=>(a=r,this.remoteDocumentCache.getEntry(t,n))).next(r=>(a!==null&&iy(a.mutation,r,ts.empty(),fn.now()),r))}getDocuments(t,n){return this.remoteDocumentCache.getEntries(t,n).next(a=>this.getLocalViewOfDocuments(t,a,It()).next(()=>a))}getLocalViewOfDocuments(t,n,a=It()){const r=lc();return this.populateOverlays(t,r,n).next(()=>this.computeViews(t,n,r,a).next(s=>{let i=Mg();return s.forEach((o,l)=>{i=i.insert(o,l.overlayedDocument)}),i}))}getOverlayedDocuments(t,n){const a=lc();return this.populateOverlays(t,a,n).next(()=>this.computeViews(t,n,a,It()))}populateOverlays(t,n,a){const r=[];return a.forEach(s=>{n.has(s)||r.push(s)}),this.documentOverlayCache.getOverlays(t,r).next(s=>{s.forEach((i,o)=>{n.set(i,o)})})}computeViews(t,n,a,r){let s=Ro();const i=sy(),o=function(){return sy()}();return n.forEach((l,c)=>{const u=a.get(c.key);r.has(c.key)&&(u===void 0||u.mutation instanceof Nu)?s=s.insert(c.key,c):u!==void 0?(i.set(c.key,u.mutation.getFieldMask()),iy(u.mutation,c,u.mutation.getFieldMask(),fn.now())):i.set(c.key,ts.empty())}),this.recalculateAndSaveOverlays(t,s).next(l=>(l.forEach((c,u)=>i.set(c,u)),n.forEach((c,u)=>o.set(c,new M3e(u,i.get(c)??null))),o))}recalculateAndSaveOverlays(t,n){const a=sy();let r=new En((i,o)=>i-o),s=It();return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t,n).next(i=>{for(const o of i)o.keys().forEach(l=>{const c=n.get(l);if(c===null)return;let u=a.get(l)||ts.empty();u=o.applyToLocalView(c,u),a.set(l,u);const h=(r.get(o.batchId)||It()).add(l);r=r.insert(o.batchId,h)})}).next(()=>{const i=[],o=r.getReverseIterator();for(;o.hasNext();){const l=o.getNext(),c=l.key,u=l.value,h=IH();u.forEach(d=>{if(!s.has(d)){const p=AH(n.get(d),a.get(d));p!==null&&h.set(d,p),s=s.add(d)}}),i.push(this.documentOverlayCache.saveOverlays(t,c,h))}return fe.waitFor(i)}).next(()=>a)}recalculateAndSaveOverlaysForDocumentKeys(t,n){return this.remoteDocumentCache.getEntries(t,n).next(a=>this.recalculateAndSaveOverlays(t,a))}getDocumentsMatchingQuery(t,n,a,r){return function(i){return Ve.isDocumentKey(i.path)&&i.collectionGroup===null&&i.filters.length===0}(n)?this.getDocumentsMatchingDocumentQuery(t,n.path):vH(n)?this.getDocumentsMatchingCollectionGroupQuery(t,n,a,r):this.getDocumentsMatchingCollectionQuery(t,n,a,r)}getNextDocuments(t,n,a,r){return this.remoteDocumentCache.getAllFromCollectionGroup(t,n,a,r).next(s=>{const i=r-s.size>0?this.documentOverlayCache.getOverlaysForCollectionGroup(t,n,a.largestBatchId,r-s.size):fe.resolve(lc());let o=Uy,l=s;return i.next(c=>fe.forEach(c,(u,h)=>(o<h.largestBatchId&&(o=h.largestBatchId),s.get(u)?fe.resolve():this.remoteDocumentCache.getEntry(t,u).next(d=>{l=l.insert(u,d)}))).next(()=>this.populateOverlays(t,c,s)).next(()=>this.computeViews(t,l,c,It())).next(u=>({batchId:o,changes:SH(u)})))})}getDocumentsMatchingDocumentQuery(t,n){return this.getDocument(t,new Ve(n)).next(a=>{let r=Mg();return a.isFoundDocument()&&(r=r.insert(a.key,a)),r})}getDocumentsMatchingCollectionGroupQuery(t,n,a,r){const s=n.collectionGroup;let i=Mg();return this.indexManager.getCollectionParents(t,s).next(o=>fe.forEach(o,l=>{const c=function(h,d){return new Qm(d,null,h.explicitOrderBy.slice(),h.filters.slice(),h.limit,h.limitType,h.startAt,h.endAt)}(n,l.child(s));return this.getDocumentsMatchingCollectionQuery(t,c,a,r).next(u=>{u.forEach((h,d)=>{i=i.insert(h,d)})})}).next(()=>i))}getDocumentsMatchingCollectionQuery(t,n,a,r){let s;return this.documentOverlayCache.getOverlaysForCollection(t,n.path,a.largestBatchId).next(i=>(s=i,this.remoteDocumentCache.getDocumentsMatchingQuery(t,n,a,s,r))).next(i=>{s.forEach((l,c)=>{const u=c.getKey();i.get(u)===null&&(i=i.insert(u,Xa.newInvalidDocument(u)))});let o=Mg();return i.forEach((l,c)=>{const u=s.get(l);u!==void 0&&iy(u.mutation,c,ts.empty(),fn.now()),v_(n,c)&&(o=o.insert(l,c))}),o})}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class F3e{constructor(t){this.serializer=t,this.Lr=new Map,this.kr=new Map}getBundleMetadata(t,n){return fe.resolve(this.Lr.get(n))}saveBundleMetadata(t,n){return this.Lr.set(n.id,function(r){return{id:r.id,version:r.version,createTime:$i(r.createTime)}}(n)),fe.resolve()}getNamedQuery(t,n){return fe.resolve(this.kr.get(n))}saveNamedQuery(t,n){return this.kr.set(n.name,function(r){return{name:r.name,query:k3e(r.bundledQuery),readTime:$i(r.readTime)}}(n)),fe.resolve()}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class L3e{constructor(){this.overlays=new En(Ve.comparator),this.qr=new Map}getOverlay(t,n){return fe.resolve(this.overlays.get(n))}getOverlays(t,n){const a=lc();return fe.forEach(n,r=>this.getOverlay(t,r).next(s=>{s!==null&&a.set(r,s)})).next(()=>a)}saveOverlays(t,n,a){return a.forEach((r,s)=>{this.St(t,n,s)}),fe.resolve()}removeOverlaysForBatchId(t,n,a){const r=this.qr.get(a);return r!==void 0&&(r.forEach(s=>this.overlays=this.overlays.remove(s)),this.qr.delete(a)),fe.resolve()}getOverlaysForCollection(t,n,a){const r=lc(),s=n.length+1,i=new Ve(n.child("")),o=this.overlays.getIteratorFrom(i);for(;o.hasNext();){const l=o.getNext().value,c=l.getKey();if(!n.isPrefixOf(c.path))break;c.path.length===s&&l.largestBatchId>a&&r.set(l.getKey(),l)}return fe.resolve(r)}getOverlaysForCollectionGroup(t,n,a,r){let s=new En((c,u)=>c-u);const i=this.overlays.getIterator();for(;i.hasNext();){const c=i.getNext().value;if(c.getKey().getCollectionGroup()===n&&c.largestBatchId>a){let u=s.get(c.largestBatchId);u===null&&(u=lc(),s=s.insert(c.largestBatchId,u)),u.set(c.getKey(),c)}}const o=lc(),l=s.getIterator();for(;l.hasNext()&&(l.getNext().value.forEach((c,u)=>o.set(c,u)),!(o.size()>=r)););return fe.resolve(o)}St(t,n,a){const r=this.overlays.get(a.key);if(r!==null){const i=this.qr.get(r.largestBatchId).delete(a.key);this.qr.set(r.largestBatchId,i)}this.overlays=this.overlays.insert(a.key,new t3e(n,a));let s=this.qr.get(n);s===void 0&&(s=It(),this.qr.set(n,s)),this.qr.set(n,s.add(a.key))}}/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class z3e{constructor(){this.sessionToken=Ua.EMPTY_BYTE_STRING}getSessionToken(t){return fe.resolve(this.sessionToken)}setSessionToken(t,n){return this.sessionToken=n,fe.resolve()}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class uR{constructor(){this.Qr=new ya(Ia.$r),this.Ur=new ya(Ia.Kr)}isEmpty(){return this.Qr.isEmpty()}addReference(t,n){const a=new Ia(t,n);this.Qr=this.Qr.add(a),this.Ur=this.Ur.add(a)}Wr(t,n){t.forEach(a=>this.addReference(a,n))}removeReference(t,n){this.Gr(new Ia(t,n))}zr(t,n){t.forEach(a=>this.removeReference(a,n))}jr(t){const n=new Ve(new un([])),a=new Ia(n,t),r=new Ia(n,t+1),s=[];return this.Ur.forEachInRange([a,r],i=>{this.Gr(i),s.push(i.key)}),s}Jr(){this.Qr.forEach(t=>this.Gr(t))}Gr(t){this.Qr=this.Qr.delete(t),this.Ur=this.Ur.delete(t)}Hr(t){const n=new Ve(new un([])),a=new Ia(n,t),r=new Ia(n,t+1);let s=It();return this.Ur.forEachInRange([a,r],i=>{s=s.add(i.key)}),s}containsKey(t){const n=new Ia(t,0),a=this.Qr.firstAfterOrEqual(n);return a!==null&&t.isEqual(a.key)}}class Ia{constructor(t,n){this.key=t,this.Yr=n}static $r(t,n){return Ve.comparator(t.key,n.key)||St(t.Yr,n.Yr)}static Kr(t,n){return St(t.Yr,n.Yr)||Ve.comparator(t.key,n.key)}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class P3e{constructor(t,n){this.indexManager=t,this.referenceDelegate=n,this.mutationQueue=[],this.tr=1,this.Zr=new ya(Ia.$r)}checkEmpty(t){return fe.resolve(this.mutationQueue.length===0)}addMutationBatch(t,n,a,r){const s=this.tr;this.tr++,this.mutationQueue.length>0&&this.mutationQueue[this.mutationQueue.length-1];const i=new e3e(s,n,a,r);this.mutationQueue.push(i);for(const o of r)this.Zr=this.Zr.add(new Ia(o.key,s)),this.indexManager.addToCollectionParentIndex(t,o.key.path.popLast());return fe.resolve(i)}lookupMutationBatch(t,n){return fe.resolve(this.Xr(n))}getNextMutationBatchAfterBatchId(t,n){const a=n+1,r=this.ei(a),s=r<0?0:r;return fe.resolve(this.mutationQueue.length>s?this.mutationQueue[s]:null)}getHighestUnacknowledgedBatchId(){return fe.resolve(this.mutationQueue.length===0?ZA:this.tr-1)}getAllMutationBatches(t){return fe.resolve(this.mutationQueue.slice())}getAllMutationBatchesAffectingDocumentKey(t,n){const a=new Ia(n,0),r=new Ia(n,Number.POSITIVE_INFINITY),s=[];return this.Zr.forEachInRange([a,r],i=>{const o=this.Xr(i.Yr);s.push(o)}),fe.resolve(s)}getAllMutationBatchesAffectingDocumentKeys(t,n){let a=new ya(St);return n.forEach(r=>{const s=new Ia(r,0),i=new Ia(r,Number.POSITIVE_INFINITY);this.Zr.forEachInRange([s,i],o=>{a=a.add(o.Yr)})}),fe.resolve(this.ti(a))}getAllMutationBatchesAffectingQuery(t,n){const a=n.path,r=a.length+1;let s=a;Ve.isDocumentKey(s)||(s=s.child(""));const i=new Ia(new Ve(s),0);let o=new ya(St);return this.Zr.forEachWhile(l=>{const c=l.key.path;return!!a.isPrefixOf(c)&&(c.length===r&&(o=o.add(l.Yr)),!0)},i),fe.resolve(this.ti(o))}ti(t){const n=[];return t.forEach(a=>{const r=this.Xr(a);r!==null&&n.push(r)}),n}removeMutationBatch(t,n){Wt(this.ni(n.batchId,"removed")===0,55003),this.mutationQueue.shift();let a=this.Zr;return fe.forEach(n.mutations,r=>{const s=new Ia(r.key,n.batchId);return a=a.delete(s),this.referenceDelegate.markPotentiallyOrphaned(t,r.key)}).next(()=>{this.Zr=a})}ir(t){}containsKey(t,n){const a=new Ia(n,0),r=this.Zr.firstAfterOrEqual(a);return fe.resolve(n.isEqual(r&&r.key))}performConsistencyCheck(t){return this.mutationQueue.length,fe.resolve()}ni(t,n){return this.ei(t)}ei(t){return this.mutationQueue.length===0?0:t-this.mutationQueue[0].batchId}Xr(t){const n=this.ei(t);return n<0||n>=this.mutationQueue.length?null:this.mutationQueue[n]}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class V3e{constructor(t){this.ri=t,this.docs=function(){return new En(Ve.comparator)}(),this.size=0}setIndexManager(t){this.indexManager=t}addEntry(t,n){const a=n.key,r=this.docs.get(a),s=r?r.size:0,i=this.ri(n);return this.docs=this.docs.insert(a,{document:n.mutableCopy(),size:i}),this.size+=i-s,this.indexManager.addToCollectionParentIndex(t,a.path.popLast())}removeEntry(t){const n=this.docs.get(t);n&&(this.docs=this.docs.remove(t),this.size-=n.size)}getEntry(t,n){const a=this.docs.get(n);return fe.resolve(a?a.document.mutableCopy():Xa.newInvalidDocument(n))}getEntries(t,n){let a=Ro();return n.forEach(r=>{const s=this.docs.get(r);a=a.insert(r,s?s.document.mutableCopy():Xa.newInvalidDocument(r))}),fe.resolve(a)}getDocumentsMatchingQuery(t,n,a,r){let s=Ro();const i=n.path,o=new Ve(i.child("__id-9223372036854775808__")),l=this.docs.getIteratorFrom(o);for(;l.hasNext();){const{key:c,value:{document:u}}=l.getNext();if(!i.isPrefixOf(c.path))break;c.path.length>i.length+1||mFe(fFe(u),a)<=0||(r.has(u.key)||v_(n,u))&&(s=s.insert(u.key,u.mutableCopy()))}return fe.resolve(s)}getAllFromCollectionGroup(t,n,a,r){Ke(9500)}ii(t,n){return fe.forEach(this.docs,a=>n(a))}newChangeBuffer(t){return new B3e(this)}getSize(t){return fe.resolve(this.size)}}class B3e extends $3e{constructor(t){super(),this.Nr=t}applyChanges(t){const n=[];return this.changes.forEach((a,r)=>{r.isValidDocument()?n.push(this.Nr.addEntry(t,r)):this.Nr.removeEntry(a)}),fe.waitFor(n)}getFromCache(t,n){return this.Nr.getEntry(t,n)}getAllFromCache(t,n){return this.Nr.getEntries(t,n)}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class U3e{constructor(t){this.persistence=t,this.si=new Nd(n=>tR(n),nR),this.lastRemoteSnapshotVersion=nt.min(),this.highestTargetId=0,this.oi=0,this._i=new uR,this.targetCount=0,this.ai=df.ur()}forEachTarget(t,n){return this.si.forEach((a,r)=>n(r)),fe.resolve()}getLastRemoteSnapshotVersion(t){return fe.resolve(this.lastRemoteSnapshotVersion)}getHighestSequenceNumber(t){return fe.resolve(this.oi)}allocateTargetId(t){return this.highestTargetId=this.ai.next(),fe.resolve(this.highestTargetId)}setTargetsMetadata(t,n,a){return a&&(this.lastRemoteSnapshotVersion=a),n>this.oi&&(this.oi=n),fe.resolve()}Pr(t){this.si.set(t.target,t);const n=t.targetId;n>this.highestTargetId&&(this.ai=new df(n),this.highestTargetId=n),t.sequenceNumber>this.oi&&(this.oi=t.sequenceNumber)}addTargetData(t,n){return this.Pr(n),this.targetCount+=1,fe.resolve()}updateTargetData(t,n){return this.Pr(n),fe.resolve()}removeTargetData(t,n){return this.si.delete(n.target),this._i.jr(n.targetId),this.targetCount-=1,fe.resolve()}removeTargets(t,n,a){let r=0;const s=[];return this.si.forEach((i,o)=>{o.sequenceNumber<=n&&a.get(o.targetId)===null&&(this.si.delete(i),s.push(this.removeMatchingKeysForTargetId(t,o.targetId)),r++)}),fe.waitFor(s).next(()=>r)}getTargetCount(t){return fe.resolve(this.targetCount)}getTargetData(t,n){const a=this.si.get(n)||null;return fe.resolve(a)}addMatchingKeys(t,n,a){return this._i.Wr(n,a),fe.resolve()}removeMatchingKeys(t,n,a){this._i.zr(n,a);const r=this.persistence.referenceDelegate,s=[];return r&&n.forEach(i=>{s.push(r.markPotentiallyOrphaned(t,i))}),fe.waitFor(s)}removeMatchingKeysForTargetId(t,n){return this._i.jr(n),fe.resolve()}getMatchingKeysForTargetId(t,n){const a=this._i.Hr(n);return fe.resolve(a)}containsKey(t,n){return fe.resolve(this._i.containsKey(n))}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class WH{constructor(t,n){this.ui={},this.overlays={},this.ci=new m_(0),this.li=!1,this.li=!0,this.hi=new z3e,this.referenceDelegate=t(this),this.Pi=new U3e(this),this.indexManager=new T3e,this.remoteDocumentCache=function(r){return new V3e(r)}(a=>this.referenceDelegate.Ti(a)),this.serializer=new I3e(n),this.Ii=new F3e(this.serializer)}start(){return Promise.resolve()}shutdown(){return this.li=!1,Promise.resolve()}get started(){return this.li}setDatabaseDeletedListener(){}setNetworkEnabled(){}getIndexManager(t){return this.indexManager}getDocumentOverlayCache(t){let n=this.overlays[t.toKey()];return n||(n=new L3e,this.overlays[t.toKey()]=n),n}getMutationQueue(t,n){let a=this.ui[t.toKey()];return a||(a=new P3e(n,this.referenceDelegate),this.ui[t.toKey()]=a),a}getGlobalsCache(){return this.hi}getTargetCache(){return this.Pi}getRemoteDocumentCache(){return this.remoteDocumentCache}getBundleCache(){return this.Ii}runTransaction(t,n,a){Ae("MemoryPersistence","Starting transaction:",t);const r=new W3e(this.ci.next());return this.referenceDelegate.Ei(),a(r).next(s=>this.referenceDelegate.di(r).next(()=>s)).toPromise().then(s=>(r.raiseOnCommittedEvent(),s))}Ai(t,n){return fe.or(Object.values(this.ui).map(a=>()=>a.containsKey(t,n)))}}class W3e extends yFe{constructor(t){super(),this.currentSequenceNumber=t}}class cR{constructor(t){this.persistence=t,this.Ri=new uR,this.Vi=null}static mi(t){return new cR(t)}get fi(){if(this.Vi)return this.Vi;throw Ke(60996)}addReference(t,n,a){return this.Ri.addReference(a,n),this.fi.delete(a.toString()),fe.resolve()}removeReference(t,n,a){return this.Ri.removeReference(a,n),this.fi.add(a.toString()),fe.resolve()}markPotentiallyOrphaned(t,n){return this.fi.add(n.toString()),fe.resolve()}removeTarget(t,n){this.Ri.jr(n.targetId).forEach(r=>this.fi.add(r.toString()));const a=this.persistence.getTargetCache();return a.getMatchingKeysForTargetId(t,n.targetId).next(r=>{r.forEach(s=>this.fi.add(s.toString()))}).next(()=>a.removeTargetData(t,n))}Ei(){this.Vi=new Set}di(t){const n=this.persistence.getRemoteDocumentCache().newChangeBuffer();return fe.forEach(this.fi,a=>{const r=Ve.fromPath(a);return this.gi(t,r).next(s=>{s||n.removeEntry(r,nt.min())})}).next(()=>(this.Vi=null,n.apply(t)))}updateLimboDocument(t,n){return this.gi(t,n).next(a=>{a?this.fi.delete(n.toString()):this.fi.add(n.toString())})}Ti(t){return 0}gi(t,n){return fe.or([()=>fe.resolve(this.Ri.containsKey(n)),()=>this.persistence.getTargetCache().containsKey(t,n),()=>this.persistence.Ai(t,n)])}}class mw{constructor(t,n){this.persistence=t,this.pi=new Nd(a=>xFe(a.path),(a,r)=>a.isEqual(r)),this.garbageCollector=D3e(this,n)}static mi(t,n){return new mw(t,n)}Ei(){}di(t){return fe.resolve()}forEachTarget(t,n){return this.persistence.getTargetCache().forEachTarget(t,n)}gr(t){const n=this.wr(t);return this.persistence.getTargetCache().getTargetCount(t).next(a=>n.next(r=>a+r))}wr(t){let n=0;return this.pr(t,a=>{n++}).next(()=>n)}pr(t,n){return fe.forEach(this.pi,(a,r)=>this.br(t,a,r).next(s=>s?fe.resolve():n(r)))}removeTargets(t,n,a){return this.persistence.getTargetCache().removeTargets(t,n,a)}removeOrphanedDocuments(t,n){let a=0;const r=this.persistence.getRemoteDocumentCache(),s=r.newChangeBuffer();return r.ii(t,i=>this.br(t,i,n).next(o=>{o||(a++,s.removeEntry(i,nt.min()))})).next(()=>s.apply(t)).next(()=>a)}markPotentiallyOrphaned(t,n){return this.pi.set(n,t.currentSequenceNumber),fe.resolve()}removeTarget(t,n){const a=n.withSequenceNumber(t.currentSequenceNumber);return this.persistence.getTargetCache().updateTargetData(t,a)}addReference(t,n,a){return this.pi.set(a,t.currentSequenceNumber),fe.resolve()}removeReference(t,n,a){return this.pi.set(a,t.currentSequenceNumber),fe.resolve()}updateLimboDocument(t,n){return this.pi.set(n,t.currentSequenceNumber),fe.resolve()}Ti(t){let n=t.key.toString().length;return t.isFoundDocument()&&(n+=Hx(t.data.value)),n}br(t,n,a){return fe.or([()=>this.persistence.Ai(t,n),()=>this.persistence.getTargetCache().containsKey(t,n),()=>{const r=this.pi.get(n);return fe.resolve(r!==void 0&&r>a)}])}getCacheSize(t){return this.persistence.getRemoteDocumentCache().getSize(t)}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class hR{constructor(t,n,a,r){this.targetId=t,this.fromCache=n,this.Es=a,this.ds=r}static As(t,n){let a=It(),r=It();for(const s of n.docChanges)switch(s.type){case 0:a=a.add(s.doc.key);break;case 1:r=r.add(s.doc.key)}return new hR(t,n.fromCache,a,r)}}/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class j3e{constructor(){this._documentReadCount=0}get documentReadCount(){return this._documentReadCount}incrementDocumentReadCount(t){this._documentReadCount+=t}}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class G3e{constructor(){this.Rs=!1,this.Vs=!1,this.fs=100,this.gs=function(){return FMe()?8:bFe(MMe())>0?6:4}()}initialize(t,n){this.ps=t,this.indexManager=n,this.Rs=!0}getDocumentsMatchingQuery(t,n,a,r){const s={result:null};return this.ys(t,n).next(i=>{s.result=i}).next(()=>{if(!s.result)return this.ws(t,n,r,a).next(i=>{s.result=i})}).next(()=>{if(s.result)return;const i=new j3e;return this.Ss(t,n,i).next(o=>{if(s.result=o,this.Vs)return this.bs(t,n,i,o.size)})}).next(()=>s.result)}bs(t,n,a,r){return a.documentReadCount<this.fs?(ep()<=Dt.DEBUG&&Ae("QueryEngine","SDK will not create cache indexes for query:",tp(n),"since it only creates cache indexes for collection contains","more than or equal to",this.fs,"documents"),fe.resolve()):(ep()<=Dt.DEBUG&&Ae("QueryEngine","Query:",tp(n),"scans",a.documentReadCount,"local documents and returns",r,"documents as results."),a.documentReadCount>this.gs*r?(ep()<=Dt.DEBUG&&Ae("QueryEngine","The SDK decides to create cache indexes for query:",tp(n),"as using cache indexes may help improve performance."),this.indexManager.createTargetIndexes(t,Di(n))):fe.resolve())}ys(t,n){if(PO(n))return fe.resolve(null);let a=Di(n);return this.indexManager.getIndexType(t,a).next(r=>r===0?null:(n.limit!==null&&r===1&&(n=pT(n,null,"F"),a=Di(n)),this.indexManager.getDocumentsMatchingTarget(t,a).next(s=>{const i=It(...s);return this.ps.getDocuments(t,i).next(o=>this.indexManager.getMinOffset(t,a).next(l=>{const c=this.Ds(n,o);return this.Cs(n,c,i,l.readTime)?this.ys(t,pT(n,null,"F")):this.vs(t,c,n,l)}))})))}ws(t,n,a,r){return PO(n)||r.isEqual(nt.min())?fe.resolve(null):this.ps.getDocuments(t,a).next(s=>{const i=this.Ds(n,s);return this.Cs(n,i,a,r)?fe.resolve(null):(ep()<=Dt.DEBUG&&Ae("QueryEngine","Re-using previous result from %s to execute query: %s",r.toString(),tp(n)),this.vs(t,i,n,pFe(r,Uy)).next(o=>o))})}Ds(t,n){let a=new ya(wH(t));return n.forEach((r,s)=>{v_(t,s)&&(a=a.add(s))}),a}Cs(t,n,a,r){if(t.limit===null)return!1;if(a.size!==n.size)return!0;const s=t.limitType==="F"?n.last():n.first();return!!s&&(s.hasPendingWrites||s.version.compareTo(r)>0)}Ss(t,n,a){return ep()<=Dt.DEBUG&&Ae("QueryEngine","Using full collection scan to execute query:",tp(n)),this.ps.getDocumentsMatchingQuery(t,n,nu.min(),a)}vs(t,n,a,r){return this.ps.getDocumentsMatchingQuery(t,a,r).next(s=>(n.forEach(i=>{s=s.insert(i.key,i)}),s))}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const dR="LocalStore",H3e=3e8;class q3e{constructor(t,n,a,r){this.persistence=t,this.Fs=n,this.serializer=r,this.Ms=new En(St),this.xs=new Nd(s=>tR(s),nR),this.Os=new Map,this.Ns=t.getRemoteDocumentCache(),this.Pi=t.getTargetCache(),this.Ii=t.getBundleCache(),this.Bs(a)}Bs(t){this.documentOverlayCache=this.persistence.getDocumentOverlayCache(t),this.indexManager=this.persistence.getIndexManager(t),this.mutationQueue=this.persistence.getMutationQueue(t,this.indexManager),this.localDocuments=new O3e(this.Ns,this.mutationQueue,this.documentOverlayCache,this.indexManager),this.Ns.setIndexManager(this.indexManager),this.Fs.initialize(this.localDocuments,this.indexManager)}collectGarbage(t){return this.persistence.runTransaction("Collect garbage","readwrite-primary",n=>t.collect(n,this.Ms))}}function K3e(e,t,n,a){return new q3e(e,t,n,a)}async function jH(e,t){const n=rt(e);return await n.persistence.runTransaction("Handle user change","readonly",a=>{let r;return n.mutationQueue.getAllMutationBatches(a).next(s=>(r=s,n.Bs(t),n.mutationQueue.getAllMutationBatches(a))).next(s=>{const i=[],o=[];let l=It();for(const c of r){i.push(c.batchId);for(const u of c.mutations)l=l.add(u.key)}for(const c of s){o.push(c.batchId);for(const u of c.mutations)l=l.add(u.key)}return n.localDocuments.getDocuments(a,l).next(c=>({Ls:c,removedBatchIds:i,addedBatchIds:o}))})})}function X3e(e,t){const n=rt(e);return n.persistence.runTransaction("Acknowledge batch","readwrite-primary",a=>{const r=t.batch.keys(),s=n.Ns.newChangeBuffer({trackRemovals:!0});return function(o,l,c,u){const h=c.batch,d=h.keys();let p=fe.resolve();return d.forEach(f=>{p=p.next(()=>u.getEntry(l,f)).next(m=>{const g=c.docVersions.get(f);Wt(g!==null,48541),m.version.compareTo(g)<0&&(h.applyToRemoteDocument(m,c),m.isValidDocument()&&(m.setReadTime(c.commitVersion),u.addEntry(m)))})}),p.next(()=>o.mutationQueue.removeMutationBatch(l,h))}(n,a,t,s).next(()=>s.apply(a)).next(()=>n.mutationQueue.performConsistencyCheck(a)).next(()=>n.documentOverlayCache.removeOverlaysForBatchId(a,r,t.batch.batchId)).next(()=>n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(a,function(o){let l=It();for(let c=0;c<o.mutationResults.length;++c)o.mutationResults[c].transformResults.length>0&&(l=l.add(o.batch.mutations[c].key));return l}(t))).next(()=>n.localDocuments.getDocuments(a,r))})}function GH(e){const t=rt(e);return t.persistence.runTransaction("Get last remote snapshot version","readonly",n=>t.Pi.getLastRemoteSnapshotVersion(n))}function Q3e(e,t){const n=rt(e),a=t.snapshotVersion;let r=n.Ms;return n.persistence.runTransaction("Apply remote event","readwrite-primary",s=>{const i=n.Ns.newChangeBuffer({trackRemovals:!0});r=n.Ms;const o=[];t.targetChanges.forEach((u,h)=>{const d=r.get(h);if(!d)return;o.push(n.Pi.removeMatchingKeys(s,u.removedDocuments,h).next(()=>n.Pi.addMatchingKeys(s,u.addedDocuments,h)));let p=d.withSequenceNumber(s.currentSequenceNumber);t.targetMismatches.get(h)!==null?p=p.withResumeToken(Ua.EMPTY_BYTE_STRING,nt.min()).withLastLimboFreeSnapshotVersion(nt.min()):u.resumeToken.approximateByteSize()>0&&(p=p.withResumeToken(u.resumeToken,a)),r=r.insert(h,p),function(m,g,y){return m.resumeToken.approximateByteSize()===0||g.snapshotVersion.toMicroseconds()-m.snapshotVersion.toMicroseconds()>=H3e?!0:y.addedDocuments.size+y.modifiedDocuments.size+y.removedDocuments.size>0}(d,p,u)&&o.push(n.Pi.updateTargetData(s,p))});let l=Ro(),c=It();if(t.documentUpdates.forEach(u=>{t.resolvedLimboDocuments.has(u)&&o.push(n.persistence.referenceDelegate.updateLimboDocument(s,u))}),o.push(Y3e(s,i,t.documentUpdates).next(u=>{l=u.ks,c=u.qs})),!a.isEqual(nt.min())){const u=n.Pi.getLastRemoteSnapshotVersion(s).next(h=>n.Pi.setTargetsMetadata(s,s.currentSequenceNumber,a));o.push(u)}return fe.waitFor(o).next(()=>i.apply(s)).next(()=>n.localDocuments.getLocalViewOfDocuments(s,l,c)).next(()=>l)}).then(s=>(n.Ms=r,s))}function Y3e(e,t,n){let a=It(),r=It();return n.forEach(s=>a=a.add(s)),t.getEntries(e,a).next(s=>{let i=Ro();return n.forEach((o,l)=>{const c=s.get(o);l.isFoundDocument()!==c.isFoundDocument()&&(r=r.add(o)),l.isNoDocument()&&l.version.isEqual(nt.min())?(t.removeEntry(o,l.readTime),i=i.insert(o,l)):!c.isValidDocument()||l.version.compareTo(c.version)>0||l.version.compareTo(c.version)===0&&c.hasPendingWrites?(t.addEntry(l),i=i.insert(o,l)):Ae(dR,"Ignoring outdated watch update for ",o,". Current version:",c.version," Watch version:",l.version)}),{ks:i,qs:r}})}function Z3e(e,t){const n=rt(e);return n.persistence.runTransaction("Get next mutation batch","readonly",a=>(t===void 0&&(t=ZA),n.mutationQueue.getNextMutationBatchAfterBatchId(a,t)))}function J3e(e,t){const n=rt(e);return n.persistence.runTransaction("Allocate target","readwrite",a=>{let r;return n.Pi.getTargetData(a,t).next(s=>s?(r=s,fe.resolve(r)):n.Pi.allocateTargetId(a).next(i=>(r=new vl(t,i,"TargetPurposeListen",a.currentSequenceNumber),n.Pi.addTargetData(a,r).next(()=>r))))}).then(a=>{const r=n.Ms.get(a.targetId);return(r===null||a.snapshotVersion.compareTo(r.snapshotVersion)>0)&&(n.Ms=n.Ms.insert(a.targetId,a),n.xs.set(t,a.targetId)),a})}async function bT(e,t,n){const a=rt(e),r=a.Ms.get(t),s=n?"readwrite":"readwrite-primary";try{n||await a.persistence.runTransaction("Release target",s,i=>a.persistence.referenceDelegate.removeTarget(i,r))}catch(i){if(!Xm(i))throw i;Ae(dR,`Failed to update sequence numbers for target ${t}: ${i}`)}a.Ms=a.Ms.remove(t),a.xs.delete(r.target)}function ZO(e,t,n){const a=rt(e);let r=nt.min(),s=It();return a.persistence.runTransaction("Execute query","readwrite",i=>function(l,c,u){const h=rt(l),d=h.xs.get(u);return d!==void 0?fe.resolve(h.Ms.get(d)):h.Pi.getTargetData(c,u)}(a,i,Di(t)).next(o=>{if(o)return r=o.lastLimboFreeSnapshotVersion,a.Pi.getMatchingKeysForTargetId(i,o.targetId).next(l=>{s=l})}).next(()=>a.Fs.getDocumentsMatchingQuery(i,t,n?r:nt.min(),n?s:It())).next(o=>(eLe(a,PFe(t),o),{documents:o,Qs:s})))}function eLe(e,t,n){let a=e.Os.get(t)||nt.min();n.forEach((r,s)=>{s.readTime.compareTo(a)>0&&(a=s.readTime)}),e.Os.set(t,a)}class JO{constructor(){this.activeTargetIds=GFe()}zs(t){this.activeTargetIds=this.activeTargetIds.add(t)}js(t){this.activeTargetIds=this.activeTargetIds.delete(t)}Gs(){const t={activeTargetIds:this.activeTargetIds.toArray(),updateTimeMs:Date.now()};return JSON.stringify(t)}}class tLe{constructor(){this.Mo=new JO,this.xo={},this.onlineStateHandler=null,this.sequenceNumberHandler=null}addPendingMutation(t){}updateMutationState(t,n,a){}addLocalQueryTarget(t,n=!0){return n&&this.Mo.zs(t),this.xo[t]||"not-current"}updateQueryState(t,n,a){this.xo[t]=n}removeLocalQueryTarget(t){this.Mo.js(t)}isLocalQueryTarget(t){return this.Mo.activeTargetIds.has(t)}clearQueryState(t){delete this.xo[t]}getAllActiveQueryTargets(){return this.Mo.activeTargetIds}isActiveQueryTarget(t){return this.Mo.activeTargetIds.has(t)}start(){return this.Mo=new JO,Promise.resolve()}handleUserChange(t,n,a){}setOnlineState(t){}shutdown(){}writeSequenceNumber(t){}notifyBundleLoaded(t){}}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class nLe{Oo(t){}shutdown(){}}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const eF="ConnectivityMonitor";class tF{constructor(){this.No=()=>this.Bo(),this.Lo=()=>this.ko(),this.qo=[],this.Qo()}Oo(t){this.qo.push(t)}shutdown(){window.removeEventListener("online",this.No),window.removeEventListener("offline",this.Lo)}Qo(){window.addEventListener("online",this.No),window.addEventListener("offline",this.Lo)}Bo(){Ae(eF,"Network connectivity changed: AVAILABLE");for(const t of this.qo)t(0)}ko(){Ae(eF,"Network connectivity changed: UNAVAILABLE");for(const t of this.qo)t(1)}static v(){return typeof window<"u"&&window.addEventListener!==void 0&&window.removeEventListener!==void 0}}/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let bx=null;function vT(){return bx===null?bx=function(){return 268435456+Math.round(2147483648*Math.random())}():bx++,"0x"+bx.toString(16)}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const KS="RestConnection",aLe={BatchGetDocuments:"batchGet",Commit:"commit",RunQuery:"runQuery",RunAggregationQuery:"runAggregationQuery"};class rLe{get $o(){return!1}constructor(t){this.databaseInfo=t,this.databaseId=t.databaseId;const n=t.ssl?"https":"http",a=encodeURIComponent(this.databaseId.projectId),r=encodeURIComponent(this.databaseId.database);this.Uo=n+"://"+t.host,this.Ko=`projects/${a}/databases/${r}`,this.Wo=this.databaseId.database===uw?`project_id=${a}`:`project_id=${a}&database_id=${r}`}Go(t,n,a,r,s){const i=vT(),o=this.zo(t,n.toUriEncodedString());Ae(KS,`Sending RPC '${t}' ${i}:`,o,a);const l={"google-cloud-resource-prefix":this.Ko,"x-goog-request-params":this.Wo};this.jo(l,r,s);const{host:c}=new URL(o),u=KA(c);return this.Jo(t,o,l,a,u).then(h=>(Ae(KS,`Received RPC '${t}' ${i}: `,h),h),h=>{throw lf(KS,`RPC '${t}' ${i} failed with error: `,h,"url: ",o,"request:",a),h})}Ho(t,n,a,r,s,i){return this.Go(t,n,a,r,s)}jo(t,n,a){t["X-Goog-Api-Client"]=function(){return"gl-js/ fire/"+qm}(),t["Content-Type"]="text/plain",this.databaseInfo.appId&&(t["X-Firebase-GMPID"]=this.databaseInfo.appId),n&&n.headers.forEach((r,s)=>t[s]=r),a&&a.headers.forEach((r,s)=>t[s]=r)}zo(t,n){const a=aLe[t];return`${this.Uo}/v1/${n}:${a}`}terminate(){}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class sLe{constructor(t){this.Yo=t.Yo,this.Zo=t.Zo}Xo(t){this.e_=t}t_(t){this.n_=t}r_(t){this.i_=t}onMessage(t){this.s_=t}close(){this.Zo()}send(t){this.Yo(t)}o_(){this.e_()}__(){this.n_()}a_(t){this.i_(t)}u_(t){this.s_(t)}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Ha="WebChannelConnection";class iLe extends rLe{constructor(t){super(t),this.c_=[],this.forceLongPolling=t.forceLongPolling,this.autoDetectLongPolling=t.autoDetectLongPolling,this.useFetchStreams=t.useFetchStreams,this.longPollingOptions=t.longPollingOptions}Jo(t,n,a,r,s){const i=vT();return new Promise((o,l)=>{const c=new KG;c.setWithCredentials(!0),c.listenOnce(XG.COMPLETE,()=>{try{switch(c.getLastErrorCode()){case Gx.NO_ERROR:const h=c.getResponseJson();Ae(Ha,`XHR for RPC '${t}' ${i} received:`,JSON.stringify(h)),o(h);break;case Gx.TIMEOUT:Ae(Ha,`RPC '${t}' ${i} timed out`),l(new Te(ce.DEADLINE_EXCEEDED,"Request time out"));break;case Gx.HTTP_ERROR:const d=c.getStatus();if(Ae(Ha,`RPC '${t}' ${i} failed with status:`,d,"response text:",c.getResponseText()),d>0){let p=c.getResponseJson();Array.isArray(p)&&(p=p[0]);const f=p==null?void 0:p.error;if(f&&f.status&&f.message){const m=function(y){const v=y.toLowerCase().replace(/_/g,"-");return Object.values(ce).indexOf(v)>=0?v:ce.UNKNOWN}(f.status);l(new Te(m,f.message))}else l(new Te(ce.UNKNOWN,"Server responded with status "+c.getStatus()))}else l(new Te(ce.UNAVAILABLE,"Connection failed."));break;default:Ke(9055,{l_:t,streamId:i,h_:c.getLastErrorCode(),P_:c.getLastError()})}}finally{Ae(Ha,`RPC '${t}' ${i} completed.`)}});const u=JSON.stringify(r);Ae(Ha,`RPC '${t}' ${i} sending request:`,r),c.send(n,"POST",u,a,15)})}T_(t,n,a){const r=vT(),s=[this.Uo,"/","google.firestore.v1.Firestore","/",t,"/channel"],i=ZG(),o=YG(),l={httpSessionIdParam:"gsessionid",initMessageHeaders:{},messageUrlParams:{database:`projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`},sendRawJson:!0,supportsCrossDomainXhr:!0,internalChannelParams:{forwardChannelRequestTimeoutMs:6e5},forceLongPolling:this.forceLongPolling,detectBufferingProxy:this.autoDetectLongPolling},c=this.longPollingOptions.timeoutSeconds;c!==void 0&&(l.longPollingTimeout=Math.round(1e3*c)),this.useFetchStreams&&(l.useFetchStreams=!0),this.jo(l.initMessageHeaders,n,a),l.encodeInitMessageHeaders=!0;const u=s.join("");Ae(Ha,`Creating RPC '${t}' stream ${r}: ${u}`,l);const h=i.createWebChannel(u,l);this.I_(h);let d=!1,p=!1;const f=new sLe({Yo:g=>{p?Ae(Ha,`Not sending because RPC '${t}' stream ${r} is closed:`,g):(d||(Ae(Ha,`Opening RPC '${t}' stream ${r} transport.`),h.open(),d=!0),Ae(Ha,`RPC '${t}' stream ${r} sending:`,g),h.send(g))},Zo:()=>h.close()}),m=(g,y,v)=>{g.listen(y,x=>{try{v(x)}catch(w){setTimeout(()=>{throw w},0)}})};return m(h,$g.EventType.OPEN,()=>{p||(Ae(Ha,`RPC '${t}' stream ${r} transport opened.`),f.o_())}),m(h,$g.EventType.CLOSE,()=>{p||(p=!0,Ae(Ha,`RPC '${t}' stream ${r} transport closed`),f.a_(),this.E_(h))}),m(h,$g.EventType.ERROR,g=>{p||(p=!0,lf(Ha,`RPC '${t}' stream ${r} transport errored. Name:`,g.name,"Message:",g.message),f.a_(new Te(ce.UNAVAILABLE,"The operation could not be completed")))}),m(h,$g.EventType.MESSAGE,g=>{var y;if(!p){const v=g.data[0];Wt(!!v,16349);const x=v,w=(x==null?void 0:x.error)||((y=x[0])==null?void 0:y.error);if(w){Ae(Ha,`RPC '${t}' stream ${r} received error:`,w);const k=w.status;let M=function(E){const R=qn[E];if(R!==void 0)return DH(R)}(k),S=w.message;M===void 0&&(M=ce.INTERNAL,S="Unknown error status: "+k+" with message "+w.message),p=!0,f.a_(new Te(M,S)),h.close()}else Ae(Ha,`RPC '${t}' stream ${r} received:`,v),f.u_(v)}}),m(o,QG.STAT_EVENT,g=>{g.stat===iT.PROXY?Ae(Ha,`RPC '${t}' stream ${r} detected buffering proxy`):g.stat===iT.NOPROXY&&Ae(Ha,`RPC '${t}' stream ${r} detected no buffering proxy`)}),setTimeout(()=>{f.__()},0),f}terminate(){this.c_.forEach(t=>t.close()),this.c_=[]}I_(t){this.c_.push(t)}E_(t){this.c_=this.c_.filter(n=>n===t)}}function XS(){return typeof document<"u"?document:null}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function S_(e){return new c3e(e,!0)}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class HH{constructor(t,n,a=1e3,r=1.5,s=6e4){this.Mi=t,this.timerId=n,this.d_=a,this.A_=r,this.R_=s,this.V_=0,this.m_=null,this.f_=Date.now(),this.reset()}reset(){this.V_=0}g_(){this.V_=this.R_}p_(t){this.cancel();const n=Math.floor(this.V_+this.y_()),a=Math.max(0,Date.now()-this.f_),r=Math.max(0,n-a);r>0&&Ae("ExponentialBackoff",`Backing off for ${r} ms (base delay: ${this.V_} ms, delay with jitter: ${n} ms, last attempt: ${a} ms ago)`),this.m_=this.Mi.enqueueAfterDelay(this.timerId,r,()=>(this.f_=Date.now(),t())),this.V_*=this.A_,this.V_<this.d_&&(this.V_=this.d_),this.V_>this.R_&&(this.V_=this.R_)}w_(){this.m_!==null&&(this.m_.skipDelay(),this.m_=null)}cancel(){this.m_!==null&&(this.m_.cancel(),this.m_=null)}y_(){return(Math.random()-.5)*this.V_}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const nF="PersistentStream";class qH{constructor(t,n,a,r,s,i,o,l){this.Mi=t,this.S_=a,this.b_=r,this.connection=s,this.authCredentialsProvider=i,this.appCheckCredentialsProvider=o,this.listener=l,this.state=0,this.D_=0,this.C_=null,this.v_=null,this.stream=null,this.F_=0,this.M_=new HH(t,n)}x_(){return this.state===1||this.state===5||this.O_()}O_(){return this.state===2||this.state===3}start(){this.F_=0,this.state!==4?this.auth():this.N_()}async stop(){this.x_()&&await this.close(0)}B_(){this.state=0,this.M_.reset()}L_(){this.O_()&&this.C_===null&&(this.C_=this.Mi.enqueueAfterDelay(this.S_,6e4,()=>this.k_()))}q_(t){this.Q_(),this.stream.send(t)}async k_(){if(this.O_())return this.close(0)}Q_(){this.C_&&(this.C_.cancel(),this.C_=null)}U_(){this.v_&&(this.v_.cancel(),this.v_=null)}async close(t,n){this.Q_(),this.U_(),this.M_.cancel(),this.D_++,t!==4?this.M_.reset():n&&n.code===ce.RESOURCE_EXHAUSTED?(Ao(n.toString()),Ao("Using maximum backoff delay to prevent overloading the backend."),this.M_.g_()):n&&n.code===ce.UNAUTHENTICATED&&this.state!==3&&(this.authCredentialsProvider.invalidateToken(),this.appCheckCredentialsProvider.invalidateToken()),this.stream!==null&&(this.K_(),this.stream.close(),this.stream=null),this.state=t,await this.listener.r_(n)}K_(){}auth(){this.state=1;const t=this.W_(this.D_),n=this.D_;Promise.all([this.authCredentialsProvider.getToken(),this.appCheckCredentialsProvider.getToken()]).then(([a,r])=>{this.D_===n&&this.G_(a,r)},a=>{t(()=>{const r=new Te(ce.UNKNOWN,"Fetching auth token failed: "+a.message);return this.z_(r)})})}G_(t,n){const a=this.W_(this.D_);this.stream=this.j_(t,n),this.stream.Xo(()=>{a(()=>this.listener.Xo())}),this.stream.t_(()=>{a(()=>(this.state=2,this.v_=this.Mi.enqueueAfterDelay(this.b_,1e4,()=>(this.O_()&&(this.state=3),Promise.resolve())),this.listener.t_()))}),this.stream.r_(r=>{a(()=>this.z_(r))}),this.stream.onMessage(r=>{a(()=>++this.F_==1?this.J_(r):this.onNext(r))})}N_(){this.state=5,this.M_.p_(async()=>{this.state=0,this.start()})}z_(t){return Ae(nF,`close with error: ${t}`),this.stream=null,this.close(4,t)}W_(t){return n=>{this.Mi.enqueueAndForget(()=>this.D_===t?n():(Ae(nF,"stream callback skipped by getCloseGuardedDispatcher."),Promise.resolve()))}}}class oLe extends qH{constructor(t,n,a,r,s,i){super(t,"listen_stream_connection_backoff","listen_stream_idle","health_check_timeout",n,a,r,i),this.serializer=s}j_(t,n){return this.connection.T_("Listen",t,n)}J_(t){return this.onNext(t)}onNext(t){this.M_.reset();const n=p3e(this.serializer,t),a=function(s){if(!("targetChange"in s))return nt.min();const i=s.targetChange;return i.targetIds&&i.targetIds.length?nt.min():i.readTime?$i(i.readTime):nt.min()}(t);return this.listener.H_(n,a)}Y_(t){const n={};n.database=yT(this.serializer),n.addTarget=function(s,i){let o;const l=i.target;if(o=hT(l)?{documents:g3e(s,l)}:{query:y3e(s,l).ft},o.targetId=i.targetId,i.resumeToken.approximateByteSize()>0){o.resumeToken=OH(s,i.resumeToken);const c=fT(s,i.expectedCount);c!==null&&(o.expectedCount=c)}else if(i.snapshotVersion.compareTo(nt.min())>0){o.readTime=fw(s,i.snapshotVersion.toTimestamp());const c=fT(s,i.expectedCount);c!==null&&(o.expectedCount=c)}return o}(this.serializer,t);const a=v3e(this.serializer,t);a&&(n.labels=a),this.q_(n)}Z_(t){const n={};n.database=yT(this.serializer),n.removeTarget=t,this.q_(n)}}class lLe extends qH{constructor(t,n,a,r,s,i){super(t,"write_stream_connection_backoff","write_stream_idle","health_check_timeout",n,a,r,i),this.serializer=s}get X_(){return this.F_>0}start(){this.lastStreamToken=void 0,super.start()}K_(){this.X_&&this.ea([])}j_(t,n){return this.connection.T_("Write",t,n)}J_(t){return Wt(!!t.streamToken,31322),this.lastStreamToken=t.streamToken,Wt(!t.writeResults||t.writeResults.length===0,55816),this.listener.ta()}onNext(t){Wt(!!t.streamToken,12678),this.lastStreamToken=t.streamToken,this.M_.reset();const n=m3e(t.writeResults,t.commitTime),a=$i(t.commitTime);return this.listener.na(a,n)}ra(){const t={};t.database=yT(this.serializer),this.q_(t)}ea(t){const n={streamToken:this.lastStreamToken,writes:t.map(a=>f3e(this.serializer,a))};this.q_(n)}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class uLe{}class cLe extends uLe{constructor(t,n,a,r){super(),this.authCredentials=t,this.appCheckCredentials=n,this.connection=a,this.serializer=r,this.ia=!1}sa(){if(this.ia)throw new Te(ce.FAILED_PRECONDITION,"The client has already been terminated.")}Go(t,n,a,r){return this.sa(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then(([s,i])=>this.connection.Go(t,mT(n,a),r,s,i)).catch(s=>{throw s.name==="FirebaseError"?(s.code===ce.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),s):new Te(ce.UNKNOWN,s.toString())})}Ho(t,n,a,r,s){return this.sa(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then(([i,o])=>this.connection.Ho(t,mT(n,a),r,i,o,s)).catch(i=>{throw i.name==="FirebaseError"?(i.code===ce.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),i):new Te(ce.UNKNOWN,i.toString())})}terminate(){this.ia=!0,this.connection.terminate()}}class hLe{constructor(t,n){this.asyncQueue=t,this.onlineStateHandler=n,this.state="Unknown",this.oa=0,this._a=null,this.aa=!0}ua(){this.oa===0&&(this.ca("Unknown"),this._a=this.asyncQueue.enqueueAfterDelay("online_state_timeout",1e4,()=>(this._a=null,this.la("Backend didn't respond within 10 seconds."),this.ca("Offline"),Promise.resolve())))}ha(t){this.state==="Online"?this.ca("Unknown"):(this.oa++,this.oa>=1&&(this.Pa(),this.la(`Connection failed 1 times. Most recent error: ${t.toString()}`),this.ca("Offline")))}set(t){this.Pa(),this.oa=0,t==="Online"&&(this.aa=!1),this.ca(t)}ca(t){t!==this.state&&(this.state=t,this.onlineStateHandler(t))}la(t){const n=`Could not reach Cloud Firestore backend. ${t}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;this.aa?(Ao(n),this.aa=!1):Ae("OnlineStateTracker",n)}Pa(){this._a!==null&&(this._a.cancel(),this._a=null)}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const Gc="RemoteStore";class dLe{constructor(t,n,a,r,s){this.localStore=t,this.datastore=n,this.asyncQueue=a,this.remoteSyncer={},this.Ta=[],this.Ia=new Map,this.Ea=new Set,this.da=[],this.Aa=s,this.Aa.Oo(i=>{a.enqueueAndForget(async()=>{Cd(this)&&(Ae(Gc,"Restarting streams for network reachability change."),await async function(l){const c=rt(l);c.Ea.add(4),await mv(c),c.Ra.set("Unknown"),c.Ea.delete(4),await I_(c)}(this))})}),this.Ra=new hLe(a,r)}}async function I_(e){if(Cd(e))for(const t of e.da)await t(!0)}async function mv(e){for(const t of e.da)await t(!1)}function KH(e,t){const n=rt(e);n.Ia.has(t.targetId)||(n.Ia.set(t.targetId,t),gR(n)?mR(n):Ym(n).O_()&&fR(n,t))}function pR(e,t){const n=rt(e),a=Ym(n);n.Ia.delete(t),a.O_()&&XH(n,t),n.Ia.size===0&&(a.O_()?a.L_():Cd(n)&&n.Ra.set("Unknown"))}function fR(e,t){if(e.Va.Ue(t.targetId),t.resumeToken.approximateByteSize()>0||t.snapshotVersion.compareTo(nt.min())>0){const n=e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size;t=t.withExpectedCount(n)}Ym(e).Y_(t)}function XH(e,t){e.Va.Ue(t),Ym(e).Z_(t)}function mR(e){e.Va=new i3e({getRemoteKeysForTarget:t=>e.remoteSyncer.getRemoteKeysForTarget(t),At:t=>e.Ia.get(t)||null,ht:()=>e.datastore.serializer.databaseId}),Ym(e).start(),e.Ra.ua()}function gR(e){return Cd(e)&&!Ym(e).x_()&&e.Ia.size>0}function Cd(e){return rt(e).Ea.size===0}function QH(e){e.Va=void 0}async function pLe(e){e.Ra.set("Online")}async function fLe(e){e.Ia.forEach((t,n)=>{fR(e,t)})}async function mLe(e,t){QH(e),gR(e)?(e.Ra.ha(t),mR(e)):e.Ra.set("Unknown")}async function gLe(e,t,n){if(e.Ra.set("Online"),t instanceof MH&&t.state===2&&t.cause)try{await async function(r,s){const i=s.cause;for(const o of s.targetIds)r.Ia.has(o)&&(await r.remoteSyncer.rejectListen(o,i),r.Ia.delete(o),r.Va.removeTarget(o))}(e,t)}catch(a){Ae(Gc,"Failed to remove targets %s: %s ",t.targetIds.join(","),a),await gw(e,a)}else if(t instanceof Xx?e.Va.Ze(t):t instanceof $H?e.Va.st(t):e.Va.tt(t),!n.isEqual(nt.min()))try{const a=await GH(e.localStore);n.compareTo(a)>=0&&await function(s,i){const o=s.Va.Tt(i);return o.targetChanges.forEach((l,c)=>{if(l.resumeToken.approximateByteSize()>0){const u=s.Ia.get(c);u&&s.Ia.set(c,u.withResumeToken(l.resumeToken,i))}}),o.targetMismatches.forEach((l,c)=>{const u=s.Ia.get(l);if(!u)return;s.Ia.set(l,u.withResumeToken(Ua.EMPTY_BYTE_STRING,u.snapshotVersion)),XH(s,l);const h=new vl(u.target,l,c,u.sequenceNumber);fR(s,h)}),s.remoteSyncer.applyRemoteEvent(o)}(e,n)}catch(a){Ae(Gc,"Failed to raise snapshot:",a),await gw(e,a)}}async function gw(e,t,n){if(!Xm(t))throw t;e.Ea.add(1),await mv(e),e.Ra.set("Offline"),n||(n=()=>GH(e.localStore)),e.asyncQueue.enqueueRetryable(async()=>{Ae(Gc,"Retrying IndexedDB access"),await n(),e.Ea.delete(1),await I_(e)})}function YH(e,t){return t().catch(n=>gw(e,n,t))}async function k_(e){const t=rt(e),n=iu(t);let a=t.Ta.length>0?t.Ta[t.Ta.length-1].batchId:ZA;for(;yLe(t);)try{const r=await Z3e(t.localStore,a);if(r===null){t.Ta.length===0&&n.L_();break}a=r.batchId,bLe(t,r)}catch(r){await gw(t,r)}ZH(t)&&JH(t)}function yLe(e){return Cd(e)&&e.Ta.length<10}function bLe(e,t){e.Ta.push(t);const n=iu(e);n.O_()&&n.X_&&n.ea(t.mutations)}function ZH(e){return Cd(e)&&!iu(e).x_()&&e.Ta.length>0}function JH(e){iu(e).start()}async function vLe(e){iu(e).ra()}async function xLe(e){const t=iu(e);for(const n of e.Ta)t.ea(n.mutations)}async function wLe(e,t,n){const a=e.Ta.shift(),r=iR.from(a,t,n);await YH(e,()=>e.remoteSyncer.applySuccessfulWrite(r)),await k_(e)}async function _Le(e,t){t&&iu(e).X_&&await async function(a,r){if(function(i){return a3e(i)&&i!==ce.ABORTED}(r.code)){const s=a.Ta.shift();iu(a).B_(),await YH(a,()=>a.remoteSyncer.rejectFailedWrite(s.batchId,r)),await k_(a)}}(e,t),ZH(e)&&JH(e)}async function aF(e,t){const n=rt(e);n.asyncQueue.verifyOperationInProgress(),Ae(Gc,"RemoteStore received new credentials");const a=Cd(n);n.Ea.add(3),await mv(n),a&&n.Ra.set("Unknown"),await n.remoteSyncer.handleCredentialChange(t),n.Ea.delete(3),await I_(n)}async function SLe(e,t){const n=rt(e);t?(n.Ea.delete(2),await I_(n)):t||(n.Ea.add(2),await mv(n),n.Ra.set("Unknown"))}function Ym(e){return e.ma||(e.ma=function(n,a,r){const s=rt(n);return s.sa(),new oLe(a,s.connection,s.authCredentials,s.appCheckCredentials,s.serializer,r)}(e.datastore,e.asyncQueue,{Xo:pLe.bind(null,e),t_:fLe.bind(null,e),r_:mLe.bind(null,e),H_:gLe.bind(null,e)}),e.da.push(async t=>{t?(e.ma.B_(),gR(e)?mR(e):e.Ra.set("Unknown")):(await e.ma.stop(),QH(e))})),e.ma}function iu(e){return e.fa||(e.fa=function(n,a,r){const s=rt(n);return s.sa(),new lLe(a,s.connection,s.authCredentials,s.appCheckCredentials,s.serializer,r)}(e.datastore,e.asyncQueue,{Xo:()=>Promise.resolve(),t_:vLe.bind(null,e),r_:_Le.bind(null,e),ta:xLe.bind(null,e),na:wLe.bind(null,e)}),e.da.push(async t=>{t?(e.fa.B_(),await k_(e)):(await e.fa.stop(),e.Ta.length>0&&(Ae(Gc,`Stopping write stream with ${e.Ta.length} pending writes`),e.Ta=[]))})),e.fa}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class yR{constructor(t,n,a,r,s){this.asyncQueue=t,this.timerId=n,this.targetTimeMs=a,this.op=r,this.removalCallback=s,this.deferred=new wo,this.then=this.deferred.promise.then.bind(this.deferred.promise),this.deferred.promise.catch(i=>{})}get promise(){return this.deferred.promise}static createAndSchedule(t,n,a,r,s){const i=Date.now()+a,o=new yR(t,n,i,r,s);return o.start(a),o}start(t){this.timerHandle=setTimeout(()=>this.handleDelayElapsed(),t)}skipDelay(){return this.handleDelayElapsed()}cancel(t){this.timerHandle!==null&&(this.clearTimeout(),this.deferred.reject(new Te(ce.CANCELLED,"Operation cancelled"+(t?": "+t:""))))}handleDelayElapsed(){this.asyncQueue.enqueueAndForget(()=>this.timerHandle!==null?(this.clearTimeout(),this.op().then(t=>this.deferred.resolve(t))):Promise.resolve())}clearTimeout(){this.timerHandle!==null&&(this.removalCallback(this),clearTimeout(this.timerHandle),this.timerHandle=null)}}function bR(e,t){if(Ao("AsyncQueue",`${t}: ${e}`),Xm(e))return new Te(ce.UNAVAILABLE,`${t}: ${e}`);throw e}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Ap{static emptySet(t){return new Ap(t.comparator)}constructor(t){this.comparator=t?(n,a)=>t(n,a)||Ve.comparator(n.key,a.key):(n,a)=>Ve.comparator(n.key,a.key),this.keyedMap=Mg(),this.sortedSet=new En(this.comparator)}has(t){return this.keyedMap.get(t)!=null}get(t){return this.keyedMap.get(t)}first(){return this.sortedSet.minKey()}last(){return this.sortedSet.maxKey()}isEmpty(){return this.sortedSet.isEmpty()}indexOf(t){const n=this.keyedMap.get(t);return n?this.sortedSet.indexOf(n):-1}get size(){return this.sortedSet.size}forEach(t){this.sortedSet.inorderTraversal((n,a)=>(t(n),!1))}add(t){const n=this.delete(t.key);return n.copy(n.keyedMap.insert(t.key,t),n.sortedSet.insert(t,null))}delete(t){const n=this.get(t);return n?this.copy(this.keyedMap.remove(t),this.sortedSet.remove(n)):this}isEqual(t){if(!(t instanceof Ap)||this.size!==t.size)return!1;const n=this.sortedSet.getIterator(),a=t.sortedSet.getIterator();for(;n.hasNext();){const r=n.getNext().key,s=a.getNext().key;if(!r.isEqual(s))return!1}return!0}toString(){const t=[];return this.forEach(n=>{t.push(n.toString())}),t.length===0?"DocumentSet ()":`DocumentSet (
  `+t.join(`  
`)+`
)`}copy(t,n){const a=new Ap;return a.comparator=this.comparator,a.keyedMap=t,a.sortedSet=n,a}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class rF{constructor(){this.ga=new En(Ve.comparator)}track(t){const n=t.doc.key,a=this.ga.get(n);a?t.type!==0&&a.type===3?this.ga=this.ga.insert(n,t):t.type===3&&a.type!==1?this.ga=this.ga.insert(n,{type:a.type,doc:t.doc}):t.type===2&&a.type===2?this.ga=this.ga.insert(n,{type:2,doc:t.doc}):t.type===2&&a.type===0?this.ga=this.ga.insert(n,{type:0,doc:t.doc}):t.type===1&&a.type===0?this.ga=this.ga.remove(n):t.type===1&&a.type===2?this.ga=this.ga.insert(n,{type:1,doc:a.doc}):t.type===0&&a.type===1?this.ga=this.ga.insert(n,{type:2,doc:t.doc}):Ke(63341,{Rt:t,pa:a}):this.ga=this.ga.insert(n,t)}ya(){const t=[];return this.ga.inorderTraversal((n,a)=>{t.push(a)}),t}}class pf{constructor(t,n,a,r,s,i,o,l,c){this.query=t,this.docs=n,this.oldDocs=a,this.docChanges=r,this.mutatedKeys=s,this.fromCache=i,this.syncStateChanged=o,this.excludesMetadataChanges=l,this.hasCachedResults=c}static fromInitialDocuments(t,n,a,r,s){const i=[];return n.forEach(o=>{i.push({type:0,doc:o})}),new pf(t,n,Ap.emptySet(n),i,a,r,!0,!1,s)}get hasPendingWrites(){return!this.mutatedKeys.isEmpty()}isEqual(t){if(!(this.fromCache===t.fromCache&&this.hasCachedResults===t.hasCachedResults&&this.syncStateChanged===t.syncStateChanged&&this.mutatedKeys.isEqual(t.mutatedKeys)&&b_(this.query,t.query)&&this.docs.isEqual(t.docs)&&this.oldDocs.isEqual(t.oldDocs)))return!1;const n=this.docChanges,a=t.docChanges;if(n.length!==a.length)return!1;for(let r=0;r<n.length;r++)if(n[r].type!==a[r].type||!n[r].doc.isEqual(a[r].doc))return!1;return!0}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ILe{constructor(){this.wa=void 0,this.Sa=[]}ba(){return this.Sa.some(t=>t.Da())}}class kLe{constructor(){this.queries=sF(),this.onlineState="Unknown",this.Ca=new Set}terminate(){(function(n,a){const r=rt(n),s=r.queries;r.queries=sF(),s.forEach((i,o)=>{for(const l of o.Sa)l.onError(a)})})(this,new Te(ce.ABORTED,"Firestore shutting down"))}}function sF(){return new Nd(e=>xH(e),b_)}async function e8(e,t){const n=rt(e);let a=3;const r=t.query;let s=n.queries.get(r);s?!s.ba()&&t.Da()&&(a=2):(s=new ILe,a=t.Da()?0:1);try{switch(a){case 0:s.wa=await n.onListen(r,!0);break;case 1:s.wa=await n.onListen(r,!1);break;case 2:await n.onFirstRemoteStoreListen(r)}}catch(i){const o=bR(i,`Initialization of query '${tp(t.query)}' failed`);return void t.onError(o)}n.queries.set(r,s),s.Sa.push(t),t.va(n.onlineState),s.wa&&t.Fa(s.wa)&&vR(n)}async function t8(e,t){const n=rt(e),a=t.query;let r=3;const s=n.queries.get(a);if(s){const i=s.Sa.indexOf(t);i>=0&&(s.Sa.splice(i,1),s.Sa.length===0?r=t.Da()?0:1:!s.ba()&&t.Da()&&(r=2))}switch(r){case 0:return n.queries.delete(a),n.onUnlisten(a,!0);case 1:return n.queries.delete(a),n.onUnlisten(a,!1);case 2:return n.onLastRemoteStoreUnlisten(a);default:return}}function TLe(e,t){const n=rt(e);let a=!1;for(const r of t){const s=r.query,i=n.queries.get(s);if(i){for(const o of i.Sa)o.Fa(r)&&(a=!0);i.wa=r}}a&&vR(n)}function ELe(e,t,n){const a=rt(e),r=a.queries.get(t);if(r)for(const s of r.Sa)s.onError(n);a.queries.delete(t)}function vR(e){e.Ca.forEach(t=>{t.next()})}var xT,iF;(iF=xT||(xT={})).Ma="default",iF.Cache="cache";class n8{constructor(t,n,a){this.query=t,this.xa=n,this.Oa=!1,this.Na=null,this.onlineState="Unknown",this.options=a||{}}Fa(t){if(!this.options.includeMetadataChanges){const a=[];for(const r of t.docChanges)r.type!==3&&a.push(r);t=new pf(t.query,t.docs,t.oldDocs,a,t.mutatedKeys,t.fromCache,t.syncStateChanged,!0,t.hasCachedResults)}let n=!1;return this.Oa?this.Ba(t)&&(this.xa.next(t),n=!0):this.La(t,this.onlineState)&&(this.ka(t),n=!0),this.Na=t,n}onError(t){this.xa.error(t)}va(t){this.onlineState=t;let n=!1;return this.Na&&!this.Oa&&this.La(this.Na,t)&&(this.ka(this.Na),n=!0),n}La(t,n){if(!t.fromCache||!this.Da())return!0;const a=n!=="Offline";return(!this.options.qa||!a)&&(!t.docs.isEmpty()||t.hasCachedResults||n==="Offline")}Ba(t){if(t.docChanges.length>0)return!0;const n=this.Na&&this.Na.hasPendingWrites!==t.hasPendingWrites;return!(!t.syncStateChanged&&!n)&&this.options.includeMetadataChanges===!0}ka(t){t=pf.fromInitialDocuments(t.query,t.docs,t.mutatedKeys,t.fromCache,t.hasCachedResults),this.Oa=!0,this.xa.next(t)}Da(){return this.options.source!==xT.Cache}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class a8{constructor(t){this.key=t}}class r8{constructor(t){this.key=t}}class NLe{constructor(t,n){this.query=t,this.Ya=n,this.Za=null,this.hasCachedResults=!1,this.current=!1,this.Xa=It(),this.mutatedKeys=It(),this.eu=wH(t),this.tu=new Ap(this.eu)}get nu(){return this.Ya}ru(t,n){const a=n?n.iu:new rF,r=n?n.tu:this.tu;let s=n?n.mutatedKeys:this.mutatedKeys,i=r,o=!1;const l=this.query.limitType==="F"&&r.size===this.query.limit?r.last():null,c=this.query.limitType==="L"&&r.size===this.query.limit?r.first():null;if(t.inorderTraversal((u,h)=>{const d=r.get(u),p=v_(this.query,h)?h:null,f=!!d&&this.mutatedKeys.has(d.key),m=!!p&&(p.hasLocalMutations||this.mutatedKeys.has(p.key)&&p.hasCommittedMutations);let g=!1;d&&p?d.data.isEqual(p.data)?f!==m&&(a.track({type:3,doc:p}),g=!0):this.su(d,p)||(a.track({type:2,doc:p}),g=!0,(l&&this.eu(p,l)>0||c&&this.eu(p,c)<0)&&(o=!0)):!d&&p?(a.track({type:0,doc:p}),g=!0):d&&!p&&(a.track({type:1,doc:d}),g=!0,(l||c)&&(o=!0)),g&&(p?(i=i.add(p),s=m?s.add(u):s.delete(u)):(i=i.delete(u),s=s.delete(u)))}),this.query.limit!==null)for(;i.size>this.query.limit;){const u=this.query.limitType==="F"?i.last():i.first();i=i.delete(u.key),s=s.delete(u.key),a.track({type:1,doc:u})}return{tu:i,iu:a,Cs:o,mutatedKeys:s}}su(t,n){return t.hasLocalMutations&&n.hasCommittedMutations&&!n.hasLocalMutations}applyChanges(t,n,a,r){const s=this.tu;this.tu=t.tu,this.mutatedKeys=t.mutatedKeys;const i=t.iu.ya();i.sort((u,h)=>function(p,f){const m=g=>{switch(g){case 0:return 1;case 2:case 3:return 2;case 1:return 0;default:return Ke(20277,{Rt:g})}};return m(p)-m(f)}(u.type,h.type)||this.eu(u.doc,h.doc)),this.ou(a),r=r??!1;const o=n&&!r?this._u():[],l=this.Xa.size===0&&this.current&&!r?1:0,c=l!==this.Za;return this.Za=l,i.length!==0||c?{snapshot:new pf(this.query,t.tu,s,i,t.mutatedKeys,l===0,c,!1,!!a&&a.resumeToken.approximateByteSize()>0),au:o}:{au:o}}va(t){return this.current&&t==="Offline"?(this.current=!1,this.applyChanges({tu:this.tu,iu:new rF,mutatedKeys:this.mutatedKeys,Cs:!1},!1)):{au:[]}}uu(t){return!this.Ya.has(t)&&!!this.tu.has(t)&&!this.tu.get(t).hasLocalMutations}ou(t){t&&(t.addedDocuments.forEach(n=>this.Ya=this.Ya.add(n)),t.modifiedDocuments.forEach(n=>{}),t.removedDocuments.forEach(n=>this.Ya=this.Ya.delete(n)),this.current=t.current)}_u(){if(!this.current)return[];const t=this.Xa;this.Xa=It(),this.tu.forEach(a=>{this.uu(a.key)&&(this.Xa=this.Xa.add(a.key))});const n=[];return t.forEach(a=>{this.Xa.has(a)||n.push(new r8(a))}),this.Xa.forEach(a=>{t.has(a)||n.push(new a8(a))}),n}cu(t){this.Ya=t.Qs,this.Xa=It();const n=this.ru(t.documents);return this.applyChanges(n,!0)}lu(){return pf.fromInitialDocuments(this.query,this.tu,this.mutatedKeys,this.Za===0,this.hasCachedResults)}}const xR="SyncEngine";class CLe{constructor(t,n,a){this.query=t,this.targetId=n,this.view=a}}class ALe{constructor(t){this.key=t,this.hu=!1}}class RLe{constructor(t,n,a,r,s,i){this.localStore=t,this.remoteStore=n,this.eventManager=a,this.sharedClientState=r,this.currentUser=s,this.maxConcurrentLimboResolutions=i,this.Pu={},this.Tu=new Nd(o=>xH(o),b_),this.Iu=new Map,this.Eu=new Set,this.du=new En(Ve.comparator),this.Au=new Map,this.Ru=new uR,this.Vu={},this.mu=new Map,this.fu=df.cr(),this.onlineState="Unknown",this.gu=void 0}get isPrimaryClient(){return this.gu===!0}}async function DLe(e,t,n=!0){const a=c8(e);let r;const s=a.Tu.get(t);return s?(a.sharedClientState.addLocalQueryTarget(s.targetId),r=s.view.lu()):r=await s8(a,t,n,!0),r}async function $Le(e,t){const n=c8(e);await s8(n,t,!0,!1)}async function s8(e,t,n,a){const r=await J3e(e.localStore,Di(t)),s=r.targetId,i=e.sharedClientState.addLocalQueryTarget(s,n);let o;return a&&(o=await MLe(e,t,s,i==="current",r.resumeToken)),e.isPrimaryClient&&n&&KH(e.remoteStore,r),o}async function MLe(e,t,n,a,r){e.pu=(h,d,p)=>async function(m,g,y,v){let x=g.view.ru(y);x.Cs&&(x=await ZO(m.localStore,g.query,!1).then(({documents:S})=>g.view.ru(S,x)));const w=v&&v.targetChanges.get(g.targetId),k=v&&v.targetMismatches.get(g.targetId)!=null,M=g.view.applyChanges(x,m.isPrimaryClient,w,k);return lF(m,g.targetId,M.au),M.snapshot}(e,h,d,p);const s=await ZO(e.localStore,t,!0),i=new NLe(t,s.Qs),o=i.ru(s.documents),l=fv.createSynthesizedTargetChangeForCurrentChange(n,a&&e.onlineState!=="Offline",r),c=i.applyChanges(o,e.isPrimaryClient,l);lF(e,n,c.au);const u=new CLe(t,n,i);return e.Tu.set(t,u),e.Iu.has(n)?e.Iu.get(n).push(t):e.Iu.set(n,[t]),c.snapshot}async function OLe(e,t,n){const a=rt(e),r=a.Tu.get(t),s=a.Iu.get(r.targetId);if(s.length>1)return a.Iu.set(r.targetId,s.filter(i=>!b_(i,t))),void a.Tu.delete(t);a.isPrimaryClient?(a.sharedClientState.removeLocalQueryTarget(r.targetId),a.sharedClientState.isActiveQueryTarget(r.targetId)||await bT(a.localStore,r.targetId,!1).then(()=>{a.sharedClientState.clearQueryState(r.targetId),n&&pR(a.remoteStore,r.targetId),wT(a,r.targetId)}).catch(Km)):(wT(a,r.targetId),await bT(a.localStore,r.targetId,!0))}async function FLe(e,t){const n=rt(e),a=n.Tu.get(t),r=n.Iu.get(a.targetId);n.isPrimaryClient&&r.length===1&&(n.sharedClientState.removeLocalQueryTarget(a.targetId),pR(n.remoteStore,a.targetId))}async function LLe(e,t,n){const a=jLe(e);try{const r=await function(i,o){const l=rt(i),c=fn.now(),u=o.reduce((p,f)=>p.add(f.key),It());let h,d;return l.persistence.runTransaction("Locally write mutations","readwrite",p=>{let f=Ro(),m=It();return l.Ns.getEntries(p,u).next(g=>{f=g,f.forEach((y,v)=>{v.isValidDocument()||(m=m.add(y))})}).next(()=>l.localDocuments.getOverlayedDocuments(p,f)).next(g=>{h=g;const y=[];for(const v of o){const x=ZFe(v,h.get(v.key).overlayedDocument);x!=null&&y.push(new Nu(v.key,x,dH(x.value.mapValue),Ds.exists(!0)))}return l.mutationQueue.addMutationBatch(p,c,y,o)}).next(g=>{d=g;const y=g.applyToLocalDocumentSet(h,m);return l.documentOverlayCache.saveOverlays(p,g.batchId,y)})}).then(()=>({batchId:d.batchId,changes:SH(h)}))}(a.localStore,t);a.sharedClientState.addPendingMutation(r.batchId),function(i,o,l){let c=i.Vu[i.currentUser.toKey()];c||(c=new En(St)),c=c.insert(o,l),i.Vu[i.currentUser.toKey()]=c}(a,r.batchId,n),await gv(a,r.changes),await k_(a.remoteStore)}catch(r){const s=bR(r,"Failed to persist write");n.reject(s)}}async function i8(e,t){const n=rt(e);try{const a=await Q3e(n.localStore,t);t.targetChanges.forEach((r,s)=>{const i=n.Au.get(s);i&&(Wt(r.addedDocuments.size+r.modifiedDocuments.size+r.removedDocuments.size<=1,22616),r.addedDocuments.size>0?i.hu=!0:r.modifiedDocuments.size>0?Wt(i.hu,14607):r.removedDocuments.size>0&&(Wt(i.hu,42227),i.hu=!1))}),await gv(n,a,t)}catch(a){await Km(a)}}function oF(e,t,n){const a=rt(e);if(a.isPrimaryClient&&n===0||!a.isPrimaryClient&&n===1){const r=[];a.Tu.forEach((s,i)=>{const o=i.view.va(t);o.snapshot&&r.push(o.snapshot)}),function(i,o){const l=rt(i);l.onlineState=o;let c=!1;l.queries.forEach((u,h)=>{for(const d of h.Sa)d.va(o)&&(c=!0)}),c&&vR(l)}(a.eventManager,t),r.length&&a.Pu.H_(r),a.onlineState=t,a.isPrimaryClient&&a.sharedClientState.setOnlineState(t)}}async function zLe(e,t,n){const a=rt(e);a.sharedClientState.updateQueryState(t,"rejected",n);const r=a.Au.get(t),s=r&&r.key;if(s){let i=new En(Ve.comparator);i=i.insert(s,Xa.newNoDocument(s,nt.min()));const o=It().add(s),l=new __(nt.min(),new Map,new En(St),i,o);await i8(a,l),a.du=a.du.remove(s),a.Au.delete(t),wR(a)}else await bT(a.localStore,t,!1).then(()=>wT(a,t,n)).catch(Km)}async function PLe(e,t){const n=rt(e),a=t.batch.batchId;try{const r=await X3e(n.localStore,t);l8(n,a,null),o8(n,a),n.sharedClientState.updateMutationState(a,"acknowledged"),await gv(n,r)}catch(r){await Km(r)}}async function VLe(e,t,n){const a=rt(e);try{const r=await function(i,o){const l=rt(i);return l.persistence.runTransaction("Reject batch","readwrite-primary",c=>{let u;return l.mutationQueue.lookupMutationBatch(c,o).next(h=>(Wt(h!==null,37113),u=h.keys(),l.mutationQueue.removeMutationBatch(c,h))).next(()=>l.mutationQueue.performConsistencyCheck(c)).next(()=>l.documentOverlayCache.removeOverlaysForBatchId(c,u,o)).next(()=>l.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(c,u)).next(()=>l.localDocuments.getDocuments(c,u))})}(a.localStore,t);l8(a,t,n),o8(a,t),a.sharedClientState.updateMutationState(t,"rejected",n),await gv(a,r)}catch(r){await Km(r)}}function o8(e,t){(e.mu.get(t)||[]).forEach(n=>{n.resolve()}),e.mu.delete(t)}function l8(e,t,n){const a=rt(e);let r=a.Vu[a.currentUser.toKey()];if(r){const s=r.get(t);s&&(n?s.reject(n):s.resolve(),r=r.remove(t)),a.Vu[a.currentUser.toKey()]=r}}function wT(e,t,n=null){e.sharedClientState.removeLocalQueryTarget(t);for(const a of e.Iu.get(t))e.Tu.delete(a),n&&e.Pu.yu(a,n);e.Iu.delete(t),e.isPrimaryClient&&e.Ru.jr(t).forEach(a=>{e.Ru.containsKey(a)||u8(e,a)})}function u8(e,t){e.Eu.delete(t.path.canonicalString());const n=e.du.get(t);n!==null&&(pR(e.remoteStore,n),e.du=e.du.remove(t),e.Au.delete(n),wR(e))}function lF(e,t,n){for(const a of n)a instanceof a8?(e.Ru.addReference(a.key,t),BLe(e,a)):a instanceof r8?(Ae(xR,"Document no longer in limbo: "+a.key),e.Ru.removeReference(a.key,t),e.Ru.containsKey(a.key)||u8(e,a.key)):Ke(19791,{wu:a})}function BLe(e,t){const n=t.key,a=n.path.canonicalString();e.du.get(n)||e.Eu.has(a)||(Ae(xR,"New document in limbo: "+n),e.Eu.add(a),wR(e))}function wR(e){for(;e.Eu.size>0&&e.du.size<e.maxConcurrentLimboResolutions;){const t=e.Eu.values().next().value;e.Eu.delete(t);const n=new Ve(un.fromString(t)),a=e.fu.next();e.Au.set(a,new ALe(n)),e.du=e.du.insert(n,a),KH(e.remoteStore,new vl(Di(aR(n.path)),a,"TargetPurposeLimboResolution",m_.ce))}}async function gv(e,t,n){const a=rt(e),r=[],s=[],i=[];a.Tu.isEmpty()||(a.Tu.forEach((o,l)=>{i.push(a.pu(l,t,n).then(c=>{var u;if((c||n)&&a.isPrimaryClient){const h=c?!c.fromCache:(u=n==null?void 0:n.targetChanges.get(l.targetId))==null?void 0:u.current;a.sharedClientState.updateQueryState(l.targetId,h?"current":"not-current")}if(c){r.push(c);const h=hR.As(l.targetId,c);s.push(h)}}))}),await Promise.all(i),a.Pu.H_(r),await async function(l,c){const u=rt(l);try{await u.persistence.runTransaction("notifyLocalViewChanges","readwrite",h=>fe.forEach(c,d=>fe.forEach(d.Es,p=>u.persistence.referenceDelegate.addReference(h,d.targetId,p)).next(()=>fe.forEach(d.ds,p=>u.persistence.referenceDelegate.removeReference(h,d.targetId,p)))))}catch(h){if(!Xm(h))throw h;Ae(dR,"Failed to update sequence numbers: "+h)}for(const h of c){const d=h.targetId;if(!h.fromCache){const p=u.Ms.get(d),f=p.snapshotVersion,m=p.withLastLimboFreeSnapshotVersion(f);u.Ms=u.Ms.insert(d,m)}}}(a.localStore,s))}async function ULe(e,t){const n=rt(e);if(!n.currentUser.isEqual(t)){Ae(xR,"User change. New user:",t.toKey());const a=await jH(n.localStore,t);n.currentUser=t,function(s,i){s.mu.forEach(o=>{o.forEach(l=>{l.reject(new Te(ce.CANCELLED,i))})}),s.mu.clear()}(n,"'waitForPendingWrites' promise is rejected due to a user change."),n.sharedClientState.handleUserChange(t,a.removedBatchIds,a.addedBatchIds),await gv(n,a.Ls)}}function WLe(e,t){const n=rt(e),a=n.Au.get(t);if(a&&a.hu)return It().add(a.key);{let r=It();const s=n.Iu.get(t);if(!s)return r;for(const i of s){const o=n.Tu.get(i);r=r.unionWith(o.view.nu)}return r}}function c8(e){const t=rt(e);return t.remoteStore.remoteSyncer.applyRemoteEvent=i8.bind(null,t),t.remoteStore.remoteSyncer.getRemoteKeysForTarget=WLe.bind(null,t),t.remoteStore.remoteSyncer.rejectListen=zLe.bind(null,t),t.Pu.H_=TLe.bind(null,t.eventManager),t.Pu.yu=ELe.bind(null,t.eventManager),t}function jLe(e){const t=rt(e);return t.remoteStore.remoteSyncer.applySuccessfulWrite=PLe.bind(null,t),t.remoteStore.remoteSyncer.rejectFailedWrite=VLe.bind(null,t),t}class yw{constructor(){this.kind="memory",this.synchronizeTabs=!1}async initialize(t){this.serializer=S_(t.databaseInfo.databaseId),this.sharedClientState=this.Du(t),this.persistence=this.Cu(t),await this.persistence.start(),this.localStore=this.vu(t),this.gcScheduler=this.Fu(t,this.localStore),this.indexBackfillerScheduler=this.Mu(t,this.localStore)}Fu(t,n){return null}Mu(t,n){return null}vu(t){return K3e(this.persistence,new G3e,t.initialUser,this.serializer)}Cu(t){return new WH(cR.mi,this.serializer)}Du(t){return new tLe}async terminate(){var t,n;(t=this.gcScheduler)==null||t.stop(),(n=this.indexBackfillerScheduler)==null||n.stop(),this.sharedClientState.shutdown(),await this.persistence.shutdown()}}yw.provider={build:()=>new yw};class GLe extends yw{constructor(t){super(),this.cacheSizeBytes=t}Fu(t,n){Wt(this.persistence.referenceDelegate instanceof mw,46915);const a=this.persistence.referenceDelegate.garbageCollector;return new A3e(a,t.asyncQueue,n)}Cu(t){const n=this.cacheSizeBytes!==void 0?Cr.withCacheSize(this.cacheSizeBytes):Cr.DEFAULT;return new WH(a=>mw.mi(a,n),this.serializer)}}class _T{async initialize(t,n){this.localStore||(this.localStore=t.localStore,this.sharedClientState=t.sharedClientState,this.datastore=this.createDatastore(n),this.remoteStore=this.createRemoteStore(n),this.eventManager=this.createEventManager(n),this.syncEngine=this.createSyncEngine(n,!t.synchronizeTabs),this.sharedClientState.onlineStateHandler=a=>oF(this.syncEngine,a,1),this.remoteStore.remoteSyncer.handleCredentialChange=ULe.bind(null,this.syncEngine),await SLe(this.remoteStore,this.syncEngine.isPrimaryClient))}createEventManager(t){return function(){return new kLe}()}createDatastore(t){const n=S_(t.databaseInfo.databaseId),a=function(s){return new iLe(s)}(t.databaseInfo);return function(s,i,o,l){return new cLe(s,i,o,l)}(t.authCredentials,t.appCheckCredentials,a,n)}createRemoteStore(t){return function(a,r,s,i,o){return new dLe(a,r,s,i,o)}(this.localStore,this.datastore,t.asyncQueue,n=>oF(this.syncEngine,n,0),function(){return tF.v()?new tF:new nLe}())}createSyncEngine(t,n){return function(r,s,i,o,l,c,u){const h=new RLe(r,s,i,o,l,c);return u&&(h.gu=!0),h}(this.localStore,this.remoteStore,this.eventManager,this.sharedClientState,t.initialUser,t.maxConcurrentLimboResolutions,n)}async terminate(){var t,n;await async function(r){const s=rt(r);Ae(Gc,"RemoteStore shutting down."),s.Ea.add(5),await mv(s),s.Aa.shutdown(),s.Ra.set("Unknown")}(this.remoteStore),(t=this.datastore)==null||t.terminate(),(n=this.eventManager)==null||n.terminate()}}_T.provider={build:()=>new _T};/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *//**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class h8{constructor(t){this.observer=t,this.muted=!1}next(t){this.muted||this.observer.next&&this.Ou(this.observer.next,t)}error(t){this.muted||(this.observer.error?this.Ou(this.observer.error,t):Ao("Uncaught Error in snapshot listener:",t.toString()))}Nu(){this.muted=!0}Ou(t,n){setTimeout(()=>{this.muted||t(n)},0)}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const ou="FirestoreClient";class HLe{constructor(t,n,a,r,s){this.authCredentials=t,this.appCheckCredentials=n,this.asyncQueue=a,this.databaseInfo=r,this.user=qa.UNAUTHENTICATED,this.clientId=YA.newId(),this.authCredentialListener=()=>Promise.resolve(),this.appCheckCredentialListener=()=>Promise.resolve(),this._uninitializedComponentsProvider=s,this.authCredentials.start(a,async i=>{Ae(ou,"Received user=",i.uid),await this.authCredentialListener(i),this.user=i}),this.appCheckCredentials.start(a,i=>(Ae(ou,"Received new app check token=",i),this.appCheckCredentialListener(i,this.user)))}get configuration(){return{asyncQueue:this.asyncQueue,databaseInfo:this.databaseInfo,clientId:this.clientId,authCredentials:this.authCredentials,appCheckCredentials:this.appCheckCredentials,initialUser:this.user,maxConcurrentLimboResolutions:100}}setCredentialChangeListener(t){this.authCredentialListener=t}setAppCheckTokenChangeListener(t){this.appCheckCredentialListener=t}terminate(){this.asyncQueue.enterRestrictedMode();const t=new wo;return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async()=>{try{this._onlineComponents&&await this._onlineComponents.terminate(),this._offlineComponents&&await this._offlineComponents.terminate(),this.authCredentials.shutdown(),this.appCheckCredentials.shutdown(),t.resolve()}catch(n){const a=bR(n,"Failed to shutdown persistence");t.reject(a)}}),t.promise}}async function QS(e,t){e.asyncQueue.verifyOperationInProgress(),Ae(ou,"Initializing OfflineComponentProvider");const n=e.configuration;await t.initialize(n);let a=n.initialUser;e.setCredentialChangeListener(async r=>{a.isEqual(r)||(await jH(t.localStore,r),a=r)}),t.persistence.setDatabaseDeletedListener(()=>e.terminate()),e._offlineComponents=t}async function uF(e,t){e.asyncQueue.verifyOperationInProgress();const n=await qLe(e);Ae(ou,"Initializing OnlineComponentProvider"),await t.initialize(n,e.configuration),e.setCredentialChangeListener(a=>aF(t.remoteStore,a)),e.setAppCheckTokenChangeListener((a,r)=>aF(t.remoteStore,r)),e._onlineComponents=t}async function qLe(e){if(!e._offlineComponents)if(e._uninitializedComponentsProvider){Ae(ou,"Using user provided OfflineComponentProvider");try{await QS(e,e._uninitializedComponentsProvider._offline)}catch(t){const n=t;if(!function(r){return r.name==="FirebaseError"?r.code===ce.FAILED_PRECONDITION||r.code===ce.UNIMPLEMENTED:!(typeof DOMException<"u"&&r instanceof DOMException)||r.code===22||r.code===20||r.code===11}(n))throw n;lf("Error using user provided cache. Falling back to memory cache: "+n),await QS(e,new yw)}}else Ae(ou,"Using default OfflineComponentProvider"),await QS(e,new GLe(void 0));return e._offlineComponents}async function d8(e){return e._onlineComponents||(e._uninitializedComponentsProvider?(Ae(ou,"Using user provided OnlineComponentProvider"),await uF(e,e._uninitializedComponentsProvider._online)):(Ae(ou,"Using default OnlineComponentProvider"),await uF(e,new _T))),e._onlineComponents}function KLe(e){return d8(e).then(t=>t.syncEngine)}async function p8(e){const t=await d8(e),n=t.eventManager;return n.onListen=DLe.bind(null,t.syncEngine),n.onUnlisten=OLe.bind(null,t.syncEngine),n.onFirstRemoteStoreListen=$Le.bind(null,t.syncEngine),n.onLastRemoteStoreUnlisten=FLe.bind(null,t.syncEngine),n}function XLe(e,t,n={}){const a=new wo;return e.asyncQueue.enqueueAndForget(async()=>function(s,i,o,l,c){const u=new h8({next:d=>{u.Nu(),i.enqueueAndForget(()=>t8(s,h));const p=d.docs.has(o);!p&&d.fromCache?c.reject(new Te(ce.UNAVAILABLE,"Failed to get document because the client is offline.")):p&&d.fromCache&&l&&l.source==="server"?c.reject(new Te(ce.UNAVAILABLE,'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')):c.resolve(d)},error:d=>c.reject(d)}),h=new n8(aR(o.path),u,{includeMetadataChanges:!0,qa:!0});return e8(s,h)}(await p8(e),e.asyncQueue,t,n,a)),a.promise}function QLe(e,t,n={}){const a=new wo;return e.asyncQueue.enqueueAndForget(async()=>function(s,i,o,l,c){const u=new h8({next:d=>{u.Nu(),i.enqueueAndForget(()=>t8(s,h)),d.fromCache&&l.source==="server"?c.reject(new Te(ce.UNAVAILABLE,'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')):c.resolve(d)},error:d=>c.reject(d)}),h=new n8(o,u,{includeMetadataChanges:!0,qa:!0});return e8(s,h)}(await p8(e),e.asyncQueue,t,n,a)),a.promise}/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function f8(e){const t={};return e.timeoutSeconds!==void 0&&(t.timeoutSeconds=e.timeoutSeconds),t}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const cF=new Map;/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const m8="firestore.googleapis.com",hF=!0;class dF{constructor(t){if(t.host===void 0){if(t.ssl!==void 0)throw new Te(ce.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");this.host=m8,this.ssl=hF}else this.host=t.host,this.ssl=t.ssl??hF;if(this.isUsingEmulator=t.emulatorOptions!==void 0,this.credentials=t.credentials,this.ignoreUndefinedProperties=!!t.ignoreUndefinedProperties,this.localCache=t.localCache,t.cacheSizeBytes===void 0)this.cacheSizeBytes=UH;else{if(t.cacheSizeBytes!==-1&&t.cacheSizeBytes<N3e)throw new Te(ce.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");this.cacheSizeBytes=t.cacheSizeBytes}dFe("experimentalForceLongPolling",t.experimentalForceLongPolling,"experimentalAutoDetectLongPolling",t.experimentalAutoDetectLongPolling),this.experimentalForceLongPolling=!!t.experimentalForceLongPolling,this.experimentalForceLongPolling?this.experimentalAutoDetectLongPolling=!1:t.experimentalAutoDetectLongPolling===void 0?this.experimentalAutoDetectLongPolling=!0:this.experimentalAutoDetectLongPolling=!!t.experimentalAutoDetectLongPolling,this.experimentalLongPollingOptions=f8(t.experimentalLongPollingOptions??{}),function(a){if(a.timeoutSeconds!==void 0){if(isNaN(a.timeoutSeconds))throw new Te(ce.INVALID_ARGUMENT,`invalid long polling timeout: ${a.timeoutSeconds} (must not be NaN)`);if(a.timeoutSeconds<5)throw new Te(ce.INVALID_ARGUMENT,`invalid long polling timeout: ${a.timeoutSeconds} (minimum allowed value is 5)`);if(a.timeoutSeconds>30)throw new Te(ce.INVALID_ARGUMENT,`invalid long polling timeout: ${a.timeoutSeconds} (maximum allowed value is 30)`)}}(this.experimentalLongPollingOptions),this.useFetchStreams=!!t.useFetchStreams}isEqual(t){return this.host===t.host&&this.ssl===t.ssl&&this.credentials===t.credentials&&this.cacheSizeBytes===t.cacheSizeBytes&&this.experimentalForceLongPolling===t.experimentalForceLongPolling&&this.experimentalAutoDetectLongPolling===t.experimentalAutoDetectLongPolling&&function(a,r){return a.timeoutSeconds===r.timeoutSeconds}(this.experimentalLongPollingOptions,t.experimentalLongPollingOptions)&&this.ignoreUndefinedProperties===t.ignoreUndefinedProperties&&this.useFetchStreams===t.useFetchStreams}}class T_{constructor(t,n,a,r){this._authCredentials=t,this._appCheckCredentials=n,this._databaseId=a,this._app=r,this.type="firestore-lite",this._persistenceKey="(lite)",this._settings=new dF({}),this._settingsFrozen=!1,this._emulatorOptions={},this._terminateTask="notTerminated"}get app(){if(!this._app)throw new Te(ce.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is not available");return this._app}get _initialized(){return this._settingsFrozen}get _terminated(){return this._terminateTask!=="notTerminated"}_setSettings(t){if(this._settingsFrozen)throw new Te(ce.FAILED_PRECONDITION,"Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");this._settings=new dF(t),this._emulatorOptions=t.emulatorOptions||{},t.credentials!==void 0&&(this._authCredentials=function(a){if(!a)return new nFe;switch(a.type){case"firstParty":return new iFe(a.sessionIndex||"0",a.iamToken||null,a.authTokenFactory||null);case"provider":return a.client;default:throw new Te(ce.INVALID_ARGUMENT,"makeAuthCredentialsProvider failed due to invalid credential type")}}(t.credentials))}_getSettings(){return this._settings}_getEmulatorOptions(){return this._emulatorOptions}_freezeSettings(){return this._settingsFrozen=!0,this._settings}_delete(){return this._terminateTask==="notTerminated"&&(this._terminateTask=this._terminate()),this._terminateTask}async _restart(){this._terminateTask==="notTerminated"?await this._terminate():this._terminateTask="notTerminated"}toJSON(){return{app:this._app,databaseId:this._databaseId,settings:this._settings}}_terminate(){return function(n){const a=cF.get(n);a&&(Ae("ComponentProvider","Removing Datastore"),cF.delete(n),a.terminate())}(this),Promise.resolve()}}function YLe(e,t,n,a={}){var c;e=tu(e,T_);const r=KA(t),s=e._getSettings(),i={...s,emulatorOptions:e._getEmulatorOptions()},o=`${t}:${n}`;r&&(CMe(`https://${o}`),$Me("Firestore",!0)),s.host!==m8&&s.host!==o&&lf("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used.");const l={...s,host:o,ssl:r,emulatorOptions:a};if(!iw(l,i)&&(e._setSettings(l),a.mockUserToken)){let u,h;if(typeof a.mockUserToken=="string")u=a.mockUserToken,h=qa.MOCK_USER;else{u=AMe(a.mockUserToken,(c=e._app)==null?void 0:c.options.projectId);const d=a.mockUserToken.sub||a.mockUserToken.user_id;if(!d)throw new Te(ce.INVALID_ARGUMENT,"mockUserToken must contain 'sub' or 'user_id' field!");h=new qa(d)}e._authCredentials=new aFe(new eH(u,h))}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Ad{constructor(t,n,a){this.converter=n,this._query=a,this.type="query",this.firestore=t}withConverter(t){return new Ad(this.firestore,t,this._query)}}class na{constructor(t,n,a){this.converter=n,this._key=a,this.type="document",this.firestore=t}get _path(){return this._key.path}get id(){return this._key.path.lastSegment()}get path(){return this._key.path.canonicalString()}get parent(){return new Ol(this.firestore,this.converter,this._key.path.popLast())}withConverter(t){return new na(this.firestore,t,this._key)}toJSON(){return{type:na._jsonSchemaVersion,referencePath:this._key.toString()}}static fromJSON(t,n,a){if(dv(n,na._jsonSchema))return new na(t,a||null,new Ve(un.fromString(n.referencePath)))}}na._jsonSchemaVersion="firestore/documentReference/1.0",na._jsonSchema={type:ta("string",na._jsonSchemaVersion),referencePath:ta("string")};class Ol extends Ad{constructor(t,n,a){super(t,n,aR(a)),this._path=a,this.type="collection"}get id(){return this._query.path.lastSegment()}get path(){return this._query.path.canonicalString()}get parent(){const t=this._path.popLast();return t.isEmpty()?null:new na(this.firestore,null,new Ve(t))}withConverter(t){return new Ol(this.firestore,t,this._path)}}function vx(e,t,...n){if(e=Vi(e),tH("collection","path",t),e instanceof T_){const a=un.fromString(t,...n);return kO(a),new Ol(e,null,a)}{if(!(e instanceof na||e instanceof Ol))throw new Te(ce.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const a=e._path.child(un.fromString(t,...n));return kO(a),new Ol(e.firestore,null,a)}}function qd(e,t,...n){if(e=Vi(e),arguments.length===1&&(t=YA.newId()),tH("doc","path",t),e instanceof T_){const a=un.fromString(t,...n);return IO(a),new na(e,null,new Ve(a))}{if(!(e instanceof na||e instanceof Ol))throw new Te(ce.INVALID_ARGUMENT,"Expected first argument to doc() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const a=e._path.child(un.fromString(t,...n));return IO(a),new na(e.firestore,e instanceof Ol?e.converter:null,new Ve(a))}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const pF="AsyncQueue";class fF{constructor(t=Promise.resolve()){this.Xu=[],this.ec=!1,this.tc=[],this.nc=null,this.rc=!1,this.sc=!1,this.oc=[],this.M_=new HH(this,"async_queue_retry"),this._c=()=>{const a=XS();a&&Ae(pF,"Visibility state changed to "+a.visibilityState),this.M_.w_()},this.ac=t;const n=XS();n&&typeof n.addEventListener=="function"&&n.addEventListener("visibilitychange",this._c)}get isShuttingDown(){return this.ec}enqueueAndForget(t){this.enqueue(t)}enqueueAndForgetEvenWhileRestricted(t){this.uc(),this.cc(t)}enterRestrictedMode(t){if(!this.ec){this.ec=!0,this.sc=t||!1;const n=XS();n&&typeof n.removeEventListener=="function"&&n.removeEventListener("visibilitychange",this._c)}}enqueue(t){if(this.uc(),this.ec)return new Promise(()=>{});const n=new wo;return this.cc(()=>this.ec&&this.sc?Promise.resolve():(t().then(n.resolve,n.reject),n.promise)).then(()=>n.promise)}enqueueRetryable(t){this.enqueueAndForget(()=>(this.Xu.push(t),this.lc()))}async lc(){if(this.Xu.length!==0){try{await this.Xu[0](),this.Xu.shift(),this.M_.reset()}catch(t){if(!Xm(t))throw t;Ae(pF,"Operation failed with retryable error: "+t)}this.Xu.length>0&&this.M_.p_(()=>this.lc())}}cc(t){const n=this.ac.then(()=>(this.rc=!0,t().catch(a=>{throw this.nc=a,this.rc=!1,Ao("INTERNAL UNHANDLED ERROR: ",mF(a)),a}).then(a=>(this.rc=!1,a))));return this.ac=n,n}enqueueAfterDelay(t,n,a){this.uc(),this.oc.indexOf(t)>-1&&(n=0);const r=yR.createAndSchedule(this,t,n,a,s=>this.hc(s));return this.tc.push(r),r}uc(){this.nc&&Ke(47125,{Pc:mF(this.nc)})}verifyOperationInProgress(){}async Tc(){let t;do t=this.ac,await t;while(t!==this.ac)}Ic(t){for(const n of this.tc)if(n.timerId===t)return!0;return!1}Ec(t){return this.Tc().then(()=>{this.tc.sort((n,a)=>n.targetTimeMs-a.targetTimeMs);for(const n of this.tc)if(n.skipDelay(),t!=="all"&&n.timerId===t)break;return this.Tc()})}dc(t){this.oc.push(t)}hc(t){const n=this.tc.indexOf(t);this.tc.splice(n,1)}}function mF(e){let t=e.message||"";return e.stack&&(t=e.stack.includes(e.message)?e.stack:e.message+`
`+e.stack),t}class yv extends T_{constructor(t,n,a,r){super(t,n,a,r),this.type="firestore",this._queue=new fF,this._persistenceKey=(r==null?void 0:r.name)||"[DEFAULT]"}async _terminate(){if(this._firestoreClient){const t=this._firestoreClient.terminate();this._queue=new fF(t),this._firestoreClient=void 0,await t}}}function ZLe(e,t){const n=typeof e=="object"?e:jG(),a=typeof e=="string"?e:uw,r=zOe(n,"firestore").getImmediate({identifier:a});if(!r._initialized){const s=EMe("firestore");s&&YLe(r,...s)}return r}function E_(e){if(e._terminated)throw new Te(ce.FAILED_PRECONDITION,"The client has already been terminated.");return e._firestoreClient||JLe(e),e._firestoreClient}function JLe(e){var a,r,s;const t=e._freezeSettings(),n=function(o,l,c,u){return new SFe(o,l,c,u.host,u.ssl,u.experimentalForceLongPolling,u.experimentalAutoDetectLongPolling,f8(u.experimentalLongPollingOptions),u.useFetchStreams,u.isUsingEmulator)}(e._databaseId,((a=e._app)==null?void 0:a.options.appId)||"",e._persistenceKey,t);e._componentsProvider||(r=t.localCache)!=null&&r._offlineComponentProvider&&((s=t.localCache)!=null&&s._onlineComponentProvider)&&(e._componentsProvider={_offline:t.localCache._offlineComponentProvider,_online:t.localCache._onlineComponentProvider}),e._firestoreClient=new HLe(e._authCredentials,e._appCheckCredentials,e._queue,n,e._componentsProvider&&function(o){const l=o==null?void 0:o._online.build();return{_offline:o==null?void 0:o._offline.build(l),_online:l}}(e._componentsProvider))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Ns{constructor(t){this._byteString=t}static fromBase64String(t){try{return new Ns(Ua.fromBase64String(t))}catch(n){throw new Te(ce.INVALID_ARGUMENT,"Failed to construct data from Base64 string: "+n)}}static fromUint8Array(t){return new Ns(Ua.fromUint8Array(t))}toBase64(){return this._byteString.toBase64()}toUint8Array(){return this._byteString.toUint8Array()}toString(){return"Bytes(base64: "+this.toBase64()+")"}isEqual(t){return this._byteString.isEqual(t._byteString)}toJSON(){return{type:Ns._jsonSchemaVersion,bytes:this.toBase64()}}static fromJSON(t){if(dv(t,Ns._jsonSchema))return Ns.fromBase64String(t.bytes)}}Ns._jsonSchemaVersion="firestore/bytes/1.0",Ns._jsonSchema={type:ta("string",Ns._jsonSchemaVersion),bytes:ta("string")};/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class N_{constructor(...t){for(let n=0;n<t.length;++n)if(t[n].length===0)throw new Te(ce.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). Field names must not be empty.");this._internalPath=new La(t)}isEqual(t){return this._internalPath.isEqual(t._internalPath)}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class _R{constructor(t){this._methodName=t}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Mi{constructor(t,n){if(!isFinite(t)||t<-90||t>90)throw new Te(ce.INVALID_ARGUMENT,"Latitude must be a number between -90 and 90, but was: "+t);if(!isFinite(n)||n<-180||n>180)throw new Te(ce.INVALID_ARGUMENT,"Longitude must be a number between -180 and 180, but was: "+n);this._lat=t,this._long=n}get latitude(){return this._lat}get longitude(){return this._long}isEqual(t){return this._lat===t._lat&&this._long===t._long}_compareTo(t){return St(this._lat,t._lat)||St(this._long,t._long)}toJSON(){return{latitude:this._lat,longitude:this._long,type:Mi._jsonSchemaVersion}}static fromJSON(t){if(dv(t,Mi._jsonSchema))return new Mi(t.latitude,t.longitude)}}Mi._jsonSchemaVersion="firestore/geoPoint/1.0",Mi._jsonSchema={type:ta("string",Mi._jsonSchemaVersion),latitude:ta("number"),longitude:ta("number")};/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class Oi{constructor(t){this._values=(t||[]).map(n=>n)}toArray(){return this._values.map(t=>t)}isEqual(t){return function(a,r){if(a.length!==r.length)return!1;for(let s=0;s<a.length;++s)if(a[s]!==r[s])return!1;return!0}(this._values,t._values)}toJSON(){return{type:Oi._jsonSchemaVersion,vectorValues:this._values}}static fromJSON(t){if(dv(t,Oi._jsonSchema)){if(Array.isArray(t.vectorValues)&&t.vectorValues.every(n=>typeof n=="number"))return new Oi(t.vectorValues);throw new Te(ce.INVALID_ARGUMENT,"Expected 'vectorValues' field to be a number array")}}}Oi._jsonSchemaVersion="firestore/vectorValue/1.0",Oi._jsonSchema={type:ta("string",Oi._jsonSchemaVersion),vectorValues:ta("object")};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const eze=/^__.*__$/;class tze{constructor(t,n,a){this.data=t,this.fieldMask=n,this.fieldTransforms=a}toMutation(t,n){return this.fieldMask!==null?new Nu(t,this.data,this.fieldMask,n,this.fieldTransforms):new pv(t,this.data,n,this.fieldTransforms)}}class g8{constructor(t,n,a){this.data=t,this.fieldMask=n,this.fieldTransforms=a}toMutation(t,n){return new Nu(t,this.data,this.fieldMask,n,this.fieldTransforms)}}function y8(e){switch(e){case 0:case 2:case 1:return!0;case 3:case 4:return!1;default:throw Ke(40011,{Ac:e})}}class SR{constructor(t,n,a,r,s,i){this.settings=t,this.databaseId=n,this.serializer=a,this.ignoreUndefinedProperties=r,s===void 0&&this.Rc(),this.fieldTransforms=s||[],this.fieldMask=i||[]}get path(){return this.settings.path}get Ac(){return this.settings.Ac}Vc(t){return new SR({...this.settings,...t},this.databaseId,this.serializer,this.ignoreUndefinedProperties,this.fieldTransforms,this.fieldMask)}mc(t){var r;const n=(r=this.path)==null?void 0:r.child(t),a=this.Vc({path:n,fc:!1});return a.gc(t),a}yc(t){var r;const n=(r=this.path)==null?void 0:r.child(t),a=this.Vc({path:n,fc:!1});return a.Rc(),a}wc(t){return this.Vc({path:void 0,fc:!0})}Sc(t){return bw(t,this.settings.methodName,this.settings.bc||!1,this.path,this.settings.Dc)}contains(t){return this.fieldMask.find(n=>t.isPrefixOf(n))!==void 0||this.fieldTransforms.find(n=>t.isPrefixOf(n.field))!==void 0}Rc(){if(this.path)for(let t=0;t<this.path.length;t++)this.gc(this.path.get(t))}gc(t){if(t.length===0)throw this.Sc("Document fields must not be empty");if(y8(this.Ac)&&eze.test(t))throw this.Sc('Document fields cannot begin and end with "__"')}}class nze{constructor(t,n,a){this.databaseId=t,this.ignoreUndefinedProperties=n,this.serializer=a||S_(t)}Cc(t,n,a,r=!1){return new SR({Ac:t,methodName:n,Dc:a,path:La.emptyPath(),fc:!1,bc:r},this.databaseId,this.serializer,this.ignoreUndefinedProperties)}}function IR(e){const t=e._freezeSettings(),n=S_(e._databaseId);return new nze(e._databaseId,!!t.ignoreUndefinedProperties,n)}function b8(e,t,n,a,r,s={}){const i=e.Cc(s.merge||s.mergeFields?2:0,t,n,r);kR("Data must be an object, but it was:",i,a);const o=v8(a,i);let l,c;if(s.merge)l=new ts(i.fieldMask),c=i.fieldTransforms;else if(s.mergeFields){const u=[];for(const h of s.mergeFields){const d=ST(t,h,n);if(!i.contains(d))throw new Te(ce.INVALID_ARGUMENT,`Field '${d}' is specified in your field mask but missing from your input data.`);w8(u,d)||u.push(d)}l=new ts(u),c=i.fieldTransforms.filter(h=>l.covers(h.field))}else l=null,c=i.fieldTransforms;return new tze(new Rr(o),l,c)}class C_ extends _R{_toFieldTransform(t){if(t.Ac!==2)throw t.Ac===1?t.Sc(`${this._methodName}() can only appear at the top level of your update data`):t.Sc(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);return t.fieldMask.push(t.path),null}isEqual(t){return t instanceof C_}}function aze(e,t,n,a){const r=e.Cc(1,t,n);kR("Data must be an object, but it was:",r,a);const s=[],i=Rr.empty();Eu(a,(l,c)=>{const u=TR(t,l,n);c=Vi(c);const h=r.yc(u);if(c instanceof C_)s.push(u);else{const d=bv(c,h);d!=null&&(s.push(u),i.set(u,d))}});const o=new ts(s);return new g8(i,o,r.fieldTransforms)}function rze(e,t,n,a,r,s){const i=e.Cc(1,t,n),o=[ST(t,a,n)],l=[r];if(s.length%2!=0)throw new Te(ce.INVALID_ARGUMENT,`Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`);for(let d=0;d<s.length;d+=2)o.push(ST(t,s[d])),l.push(s[d+1]);const c=[],u=Rr.empty();for(let d=o.length-1;d>=0;--d)if(!w8(c,o[d])){const p=o[d];let f=l[d];f=Vi(f);const m=i.yc(p);if(f instanceof C_)c.push(p);else{const g=bv(f,m);g!=null&&(c.push(p),u.set(p,g))}}const h=new ts(c);return new g8(u,h,i.fieldTransforms)}function sze(e,t,n,a=!1){return bv(n,e.Cc(a?4:3,t))}function bv(e,t){if(x8(e=Vi(e)))return kR("Unsupported field value:",t,e),v8(e,t);if(e instanceof _R)return function(a,r){if(!y8(r.Ac))throw r.Sc(`${a._methodName}() can only be used with update() and set()`);if(!r.path)throw r.Sc(`${a._methodName}() is not currently supported inside arrays`);const s=a._toFieldTransform(r);s&&r.fieldTransforms.push(s)}(e,t),null;if(e===void 0&&t.ignoreUndefinedProperties)return null;if(t.path&&t.fieldMask.push(t.path),e instanceof Array){if(t.settings.fc&&t.Ac!==4)throw t.Sc("Nested arrays are not supported");return function(a,r){const s=[];let i=0;for(const o of a){let l=bv(o,r.wc(i));l==null&&(l={nullValue:"NULL_VALUE"}),s.push(l),i++}return{arrayValue:{values:s}}}(e,t)}return function(a,r){if((a=Vi(a))===null)return{nullValue:"NULL_VALUE"};if(typeof a=="number")return HFe(r.serializer,a);if(typeof a=="boolean")return{booleanValue:a};if(typeof a=="string")return{stringValue:a};if(a instanceof Date){const s=fn.fromDate(a);return{timestampValue:fw(r.serializer,s)}}if(a instanceof fn){const s=new fn(a.seconds,1e3*Math.floor(a.nanoseconds/1e3));return{timestampValue:fw(r.serializer,s)}}if(a instanceof Mi)return{geoPointValue:{latitude:a.latitude,longitude:a.longitude}};if(a instanceof Ns)return{bytesValue:OH(r.serializer,a._byteString)};if(a instanceof na){const s=r.databaseId,i=a.firestore._databaseId;if(!i.isEqual(s))throw r.Sc(`Document reference is for database ${i.projectId}/${i.database} but should be for database ${s.projectId}/${s.database}`);return{referenceValue:lR(a.firestore._databaseId||r.databaseId,a._key.path)}}if(a instanceof Oi)return function(i,o){return{mapValue:{fields:{[cH]:{stringValue:hH},[cw]:{arrayValue:{values:i.toArray().map(c=>{if(typeof c!="number")throw o.Sc("VectorValues must only contain numeric values.");return rR(o.serializer,c)})}}}}}}(a,r);throw r.Sc(`Unsupported field value: ${f_(a)}`)}(e,t)}function v8(e,t){const n={};return rH(e)?t.path&&t.path.length>0&&t.fieldMask.push(t.path):Eu(e,(a,r)=>{const s=bv(r,t.mc(a));s!=null&&(n[a]=s)}),{mapValue:{fields:n}}}function x8(e){return!(typeof e!="object"||e===null||e instanceof Array||e instanceof Date||e instanceof fn||e instanceof Mi||e instanceof Ns||e instanceof na||e instanceof _R||e instanceof Oi)}function kR(e,t,n){if(!x8(n)||!nH(n)){const a=f_(n);throw a==="an object"?t.Sc(e+" a custom object"):t.Sc(e+" "+a)}}function ST(e,t,n){if((t=Vi(t))instanceof N_)return t._internalPath;if(typeof t=="string")return TR(e,t);throw bw("Field path arguments must be of type string or ",e,!1,void 0,n)}const ize=new RegExp("[~\\*/\\[\\]]");function TR(e,t,n){if(t.search(ize)>=0)throw bw(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`,e,!1,void 0,n);try{return new N_(...t.split("."))._internalPath}catch{throw bw(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,e,!1,void 0,n)}}function bw(e,t,n,a,r){const s=a&&!a.isEmpty(),i=r!==void 0;let o=`Function ${t}() called with invalid data`;n&&(o+=" (via `toFirestore()`)"),o+=". ";let l="";return(s||i)&&(l+=" (found",s&&(l+=` in field ${a}`),i&&(l+=` in document ${r}`),l+=")"),new Te(ce.INVALID_ARGUMENT,o+e+l)}function w8(e,t){return e.some(n=>n.isEqual(t))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class _8{constructor(t,n,a,r,s){this._firestore=t,this._userDataWriter=n,this._key=a,this._document=r,this._converter=s}get id(){return this._key.path.lastSegment()}get ref(){return new na(this._firestore,this._converter,this._key)}exists(){return this._document!==null}data(){if(this._document){if(this._converter){const t=new oze(this._firestore,this._userDataWriter,this._key,this._document,null);return this._converter.fromFirestore(t)}return this._userDataWriter.convertValue(this._document.data.value)}}get(t){if(this._document){const n=this._document.data.field(ER("DocumentSnapshot.get",t));if(n!==null)return this._userDataWriter.convertValue(n)}}}class oze extends _8{data(){return super.data()}}function ER(e,t){return typeof t=="string"?TR(e,t):t instanceof N_?t._internalPath:t._delegate._internalPath}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function lze(e){if(e.limitType==="L"&&e.explicitOrderBy.length===0)throw new Te(ce.UNIMPLEMENTED,"limitToLast() queries require specifying at least one orderBy() clause")}class NR{}class S8 extends NR{}function uze(e,t,...n){let a=[];t instanceof NR&&a.push(t),a=a.concat(n),function(s){const i=s.filter(l=>l instanceof AR).length,o=s.filter(l=>l instanceof CR).length;if(i>1||i>0&&o>0)throw new Te(ce.INVALID_ARGUMENT,"InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.")}(a);for(const r of a)e=r._apply(e);return e}class CR extends S8{constructor(t,n,a){super(),this._field=t,this._op=n,this._value=a,this.type="where"}static _create(t,n,a){return new CR(t,n,a)}_apply(t){const n=this._parse(t);return I8(t._query,n),new Ad(t.firestore,t.converter,dT(t._query,n))}_parse(t){const n=IR(t.firestore);return function(s,i,o,l,c,u,h){let d;if(c.isKeyField()){if(u==="array-contains"||u==="array-contains-any")throw new Te(ce.INVALID_ARGUMENT,`Invalid Query. You can't perform '${u}' queries on documentId().`);if(u==="in"||u==="not-in"){yF(h,u);const f=[];for(const m of h)f.push(gF(l,s,m));d={arrayValue:{values:f}}}else d=gF(l,s,h)}else u!=="in"&&u!=="not-in"&&u!=="array-contains-any"||yF(h,u),d=sze(o,i,h,u==="in"||u==="not-in");return Yn.create(c,u,d)}(t._query,"where",n,t.firestore._databaseId,this._field,this._op,this._value)}}class AR extends NR{constructor(t,n){super(),this.type=t,this._queryConstraints=n}static _create(t,n){return new AR(t,n)}_parse(t){const n=this._queryConstraints.map(a=>a._parse(t)).filter(a=>a.getFilters().length>0);return n.length===1?n[0]:ni.create(n,this._getOperator())}_apply(t){const n=this._parse(t);return n.getFilters().length===0?t:(function(r,s){let i=r;const o=s.getFlattenedFilters();for(const l of o)I8(i,l),i=dT(i,l)}(t._query,n),new Ad(t.firestore,t.converter,dT(t._query,n)))}_getQueryConstraints(){return this._queryConstraints}_getOperator(){return this.type==="and"?"and":"or"}}class RR extends S8{constructor(t,n){super(),this._field=t,this._direction=n,this.type="orderBy"}static _create(t,n){return new RR(t,n)}_apply(t){const n=function(r,s,i){if(r.startAt!==null)throw new Te(ce.INVALID_ARGUMENT,"Invalid query. You must not call startAt() or startAfter() before calling orderBy().");if(r.endAt!==null)throw new Te(ce.INVALID_ARGUMENT,"Invalid query. You must not call endAt() or endBefore() before calling orderBy().");return new Hy(s,i)}(t._query,this._field,this._direction);return new Ad(t.firestore,t.converter,function(r,s){const i=r.explicitOrderBy.concat([s]);return new Qm(r.path,r.collectionGroup,i,r.filters.slice(),r.limit,r.limitType,r.startAt,r.endAt)}(t._query,n))}}function cze(e,t="asc"){const n=t,a=ER("orderBy",e);return RR._create(a,n)}function gF(e,t,n){if(typeof(n=Vi(n))=="string"){if(n==="")throw new Te(ce.INVALID_ARGUMENT,"Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");if(!vH(t)&&n.indexOf("/")!==-1)throw new Te(ce.INVALID_ARGUMENT,`Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);const a=t.path.child(un.fromString(n));if(!Ve.isDocumentKey(a))throw new Te(ce.INVALID_ARGUMENT,`Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${a}' is not because it has an odd number of segments (${a.length}).`);return $O(e,new Ve(a))}if(n instanceof na)return $O(e,n._key);throw new Te(ce.INVALID_ARGUMENT,`Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${f_(n)}.`)}function yF(e,t){if(!Array.isArray(e)||e.length===0)throw new Te(ce.INVALID_ARGUMENT,`Invalid Query. A non-empty array is required for '${t.toString()}' filters.`)}function I8(e,t){const n=function(r,s){for(const i of r)for(const o of i.getFlattenedFilters())if(s.indexOf(o.op)>=0)return o.op;return null}(e.filters,function(r){switch(r){case"!=":return["!=","not-in"];case"array-contains-any":case"in":return["not-in"];case"not-in":return["array-contains-any","in","not-in","!="];default:return[]}}(t.op));if(n!==null)throw n===t.op?new Te(ce.INVALID_ARGUMENT,`Invalid query. You cannot use more than one '${t.op.toString()}' filter.`):new Te(ce.INVALID_ARGUMENT,`Invalid query. You cannot use '${t.op.toString()}' filters with '${n.toString()}' filters.`)}class hze{convertValue(t,n="none"){switch(su(t)){case 0:return null;case 1:return t.booleanValue;case 2:return Fn(t.integerValue||t.doubleValue);case 3:return this.convertTimestamp(t.timestampValue);case 4:return this.convertServerTimestamp(t,n);case 5:return t.stringValue;case 6:return this.convertBytes(ru(t.bytesValue));case 7:return this.convertReference(t.referenceValue);case 8:return this.convertGeoPoint(t.geoPointValue);case 9:return this.convertArray(t.arrayValue,n);case 11:return this.convertObject(t.mapValue,n);case 10:return this.convertVectorValue(t.mapValue);default:throw Ke(62114,{value:t})}}convertObject(t,n){return this.convertObjectMap(t.fields,n)}convertObjectMap(t,n="none"){const a={};return Eu(t,(r,s)=>{a[r]=this.convertValue(s,n)}),a}convertVectorValue(t){var a,r,s;const n=(s=(r=(a=t.fields)==null?void 0:a[cw].arrayValue)==null?void 0:r.values)==null?void 0:s.map(i=>Fn(i.doubleValue));return new Oi(n)}convertGeoPoint(t){return new Mi(Fn(t.latitude),Fn(t.longitude))}convertArray(t,n){return(t.values||[]).map(a=>this.convertValue(a,n))}convertServerTimestamp(t,n){switch(n){case"previous":const a=y_(t);return a==null?null:this.convertValue(a,n);case"estimate":return this.convertTimestamp(Wy(t));default:return null}}convertTimestamp(t){const n=au(t);return new fn(n.seconds,n.nanos)}convertDocumentKey(t,n){const a=un.fromString(t);Wt(BH(a),9688,{name:t});const r=new jy(a.get(1),a.get(3)),s=new Ve(a.popFirst(5));return r.isEqual(n)||Ao(`Document ${s} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${n.projectId}/${n.database}) instead.`),s}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function k8(e,t,n){let a;return a=e?n&&(n.merge||n.mergeFields)?e.toFirestore(t,n):e.toFirestore(t):t,a}class Fg{constructor(t,n){this.hasPendingWrites=t,this.fromCache=n}isEqual(t){return this.hasPendingWrites===t.hasPendingWrites&&this.fromCache===t.fromCache}}class bc extends _8{constructor(t,n,a,r,s,i){super(t,n,a,r,i),this._firestore=t,this._firestoreImpl=t,this.metadata=s}exists(){return super.exists()}data(t={}){if(this._document){if(this._converter){const n=new Qx(this._firestore,this._userDataWriter,this._key,this._document,this.metadata,null);return this._converter.fromFirestore(n,t)}return this._userDataWriter.convertValue(this._document.data.value,t.serverTimestamps)}}get(t,n={}){if(this._document){const a=this._document.data.field(ER("DocumentSnapshot.get",t));if(a!==null)return this._userDataWriter.convertValue(a,n.serverTimestamps)}}toJSON(){if(this.metadata.hasPendingWrites)throw new Te(ce.FAILED_PRECONDITION,"DocumentSnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON().");const t=this._document,n={};return n.type=bc._jsonSchemaVersion,n.bundle="",n.bundleSource="DocumentSnapshot",n.bundleName=this._key.toString(),!t||!t.isValidDocument()||!t.isFoundDocument()?n:(this._userDataWriter.convertObjectMap(t.data.value.mapValue.fields,"previous"),n.bundle=(this._firestore,this.ref.path,"NOT SUPPORTED"),n)}}bc._jsonSchemaVersion="firestore/documentSnapshot/1.0",bc._jsonSchema={type:ta("string",bc._jsonSchemaVersion),bundleSource:ta("string","DocumentSnapshot"),bundleName:ta("string"),bundle:ta("string")};class Qx extends bc{data(t={}){return super.data(t)}}class Rp{constructor(t,n,a,r){this._firestore=t,this._userDataWriter=n,this._snapshot=r,this.metadata=new Fg(r.hasPendingWrites,r.fromCache),this.query=a}get docs(){const t=[];return this.forEach(n=>t.push(n)),t}get size(){return this._snapshot.docs.size}get empty(){return this.size===0}forEach(t,n){this._snapshot.docs.forEach(a=>{t.call(n,new Qx(this._firestore,this._userDataWriter,a.key,a,new Fg(this._snapshot.mutatedKeys.has(a.key),this._snapshot.fromCache),this.query.converter))})}docChanges(t={}){const n=!!t.includeMetadataChanges;if(n&&this._snapshot.excludesMetadataChanges)throw new Te(ce.INVALID_ARGUMENT,"To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");return this._cachedChanges&&this._cachedChangesIncludeMetadataChanges===n||(this._cachedChanges=function(r,s){if(r._snapshot.oldDocs.isEmpty()){let i=0;return r._snapshot.docChanges.map(o=>{const l=new Qx(r._firestore,r._userDataWriter,o.doc.key,o.doc,new Fg(r._snapshot.mutatedKeys.has(o.doc.key),r._snapshot.fromCache),r.query.converter);return o.doc,{type:"added",doc:l,oldIndex:-1,newIndex:i++}})}{let i=r._snapshot.oldDocs;return r._snapshot.docChanges.filter(o=>s||o.type!==3).map(o=>{const l=new Qx(r._firestore,r._userDataWriter,o.doc.key,o.doc,new Fg(r._snapshot.mutatedKeys.has(o.doc.key),r._snapshot.fromCache),r.query.converter);let c=-1,u=-1;return o.type!==0&&(c=i.indexOf(o.doc.key),i=i.delete(o.doc.key)),o.type!==1&&(i=i.add(o.doc),u=i.indexOf(o.doc.key)),{type:dze(o.type),doc:l,oldIndex:c,newIndex:u}})}}(this,n),this._cachedChangesIncludeMetadataChanges=n),this._cachedChanges}toJSON(){if(this.metadata.hasPendingWrites)throw new Te(ce.FAILED_PRECONDITION,"QuerySnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON().");const t={};t.type=Rp._jsonSchemaVersion,t.bundleSource="QuerySnapshot",t.bundleName=YA.newId(),this._firestore._databaseId.database,this._firestore._databaseId.projectId;const n=[],a=[],r=[];return this.docs.forEach(s=>{s._document!==null&&(n.push(s._document),a.push(this._userDataWriter.convertObjectMap(s._document.data.value.mapValue.fields,"previous")),r.push(s.ref.path))}),t.bundle=(this._firestore,this.query._query,t.bundleName,"NOT SUPPORTED"),t}}function dze(e){switch(e){case 0:return"added";case 2:case 3:return"modified";case 1:return"removed";default:return Ke(61501,{type:e})}}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function bF(e){e=tu(e,na);const t=tu(e.firestore,yv);return XLe(E_(t),e._key).then(n=>pze(t,e,n))}Rp._jsonSchemaVersion="firestore/querySnapshot/1.0",Rp._jsonSchema={type:ta("string",Rp._jsonSchemaVersion),bundleSource:ta("string","QuerySnapshot"),bundleName:ta("string"),bundle:ta("string")};class T8 extends hze{constructor(t){super(),this.firestore=t}convertBytes(t){return new Ns(t)}convertReference(t){const n=this.convertDocumentKey(t,this.firestore._databaseId);return new na(this.firestore,null,n)}}function xx(e){e=tu(e,Ad);const t=tu(e.firestore,yv),n=E_(t),a=new T8(t);return lze(e._query),QLe(n,e._query).then(r=>new Rp(t,a,e,r))}function vF(e,t,n){e=tu(e,na);const a=tu(e.firestore,yv),r=k8(e.converter,t,n);return E8(a,[b8(IR(a),"setDoc",e._key,r,e.converter!==null,n).toMutation(e._key,Ds.none())])}function E8(e,t){return function(a,r){const s=new wo;return a.asyncQueue.enqueueAndForget(async()=>LLe(await KLe(a),r,s)),s.promise}(E_(e),t)}function pze(e,t,n){const a=n.docs.get(t._key),r=new T8(e);return new bc(e,r,t._key,a,new Fg(n.hasPendingWrites,n.fromCache),t.converter)}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class fze{constructor(t,n){this._firestore=t,this._commitHandler=n,this._mutations=[],this._committed=!1,this._dataReader=IR(t)}set(t,n,a){this._verifyNotCommitted();const r=YS(t,this._firestore),s=k8(r.converter,n,a),i=b8(this._dataReader,"WriteBatch.set",r._key,s,r.converter!==null,a);return this._mutations.push(i.toMutation(r._key,Ds.none())),this}update(t,n,a,...r){this._verifyNotCommitted();const s=YS(t,this._firestore);let i;return i=typeof(n=Vi(n))=="string"||n instanceof N_?rze(this._dataReader,"WriteBatch.update",s._key,n,a,r):aze(this._dataReader,"WriteBatch.update",s._key,n),this._mutations.push(i.toMutation(s._key,Ds.exists(!0))),this}delete(t){this._verifyNotCommitted();const n=YS(t,this._firestore);return this._mutations=this._mutations.concat(new sR(n._key,Ds.none())),this}commit(){return this._verifyNotCommitted(),this._committed=!0,this._mutations.length>0?this._commitHandler(this._mutations):Promise.resolve()}_verifyNotCommitted(){if(this._committed)throw new Te(ce.FAILED_PRECONDITION,"A write batch can no longer be used after commit() has been called.")}}function YS(e,t){if((e=Vi(e)).firestore!==t)throw new Te(ce.INVALID_ARGUMENT,"Provided document reference is from a different Firestore instance.");return e}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function xF(e){return E_(e=tu(e,yv)),new fze(e,t=>E8(e,t))}(function(t,n=!0){(function(r){qm=r})(UOe),ow(new Py("firestore",(a,{instanceIdentifier:r,options:s})=>{const i=a.getProvider("app").getImmediate(),o=new yv(new rFe(a.getProvider("auth-internal")),new oFe(i,a.getProvider("app-check-internal")),function(c,u){if(!Object.prototype.hasOwnProperty.apply(c.options,["projectId"]))throw new Te(ce.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');return new jy(c.options.projectId,u)}(i,r),i);return s={useFetchStreams:n,...s},o._setSettings(s),o},"PUBLIC").setMultipleInstances(!0)),Cp(xO,wO,t),Cp(xO,wO,"esm2020")})();let Ir=null;const N8=e=>{try{const t=WOe().length===0?WG(e):jG();return Ir=ZLe(t),!0}catch(t){return console.error("Firebase Init Error",t),!1}},Qo=()=>{if(!Ir){const e=localStorage.getItem("FIREBASE_CONFIG");if(e)N8(JSON.parse(e));else throw new Error("Firebase not configured")}},Yo={async getUsers(){return Qo(),(await xx(vx(Ir,"users"))).docs.map(t=>t.data())},async saveUsers(e){Qo();const t=await xx(vx(Ir,"users")),n=xF(Ir),a=new Set(e.map(r=>r.id));t.docs.forEach(r=>{a.has(r.id)||n.delete(r.ref)});for(const r of e){const s=qd(Ir,"users",r.id);n.set(s,r)}await n.commit()},async getConfig(){Qo();const e=await bF(qd(Ir,"settings","officeConfig"));return e.exists()?e.data():{latitude:-6.2,longitude:106.81,maxDistance:100}},async saveConfig(e){Qo(),await vF(qd(Ir,"settings","officeConfig"),e)},async getLogs(){Qo();const e=uze(vx(Ir,"logs"),cze("timestamp","desc"));return(await xx(e)).docs.map(n=>n.data())},async addLog(e){Qo(),await vF(qd(Ir,"logs",e.id),e)},async updateLogs(e){Qo();const t=await xx(vx(Ir,"logs")),n=xF(Ir),a=new Set(e.map(r=>String(r.id)));t.docs.forEach(r=>{a.has(r.id)||n.delete(r.ref)});for(const r of e)n.set(qd(Ir,"logs",String(r.id)),r);await n.commit()},async checkHealth(){try{return Qo(),await bF(qd(Ir,"settings","officeConfig")),!0}catch{return!1}}},mze="https://c1jx4415-3000.asse.devtunnels.ms/api",ro=()=>localStorage.getItem("STORAGE_MODE")||"LOCAL",gze=e=>{localStorage.setItem("STORAGE_MODE",e)},yi=()=>localStorage.getItem("SERVER_ENDPOINT")||mze,Hu={"Content-Type":"application/json"},bi={async checkHealth(e){if(ro()==="FIREBASE"&&!e)return Yo.checkHealth();const t=e||yi();try{return(await fetch(`${t}/health`,{method:"GET",signal:AbortSignal.timeout(4e3)})).ok}catch{return!1}},async getUsers(){return ro()==="FIREBASE"?Yo.getUsers():(await fetch(`${yi()}/users`,{headers:Hu})).json()},async saveUsers(e){if(ro()==="FIREBASE")return Yo.saveUsers(e);await fetch(`${yi()}/users`,{method:"POST",headers:Hu,body:JSON.stringify(e)})},async getConfig(){return ro()==="FIREBASE"?Yo.getConfig():(await fetch(`${yi()}/config`,{headers:Hu})).json()},async saveConfig(e){if(ro()==="FIREBASE")return Yo.saveConfig(e);await fetch(`${yi()}/config`,{method:"POST",headers:Hu,body:JSON.stringify(e)})},async getLogs(){return ro()==="FIREBASE"?Yo.getLogs():(await fetch(`${yi()}/logs`,{headers:Hu})).json()},async addLog(e){if(ro()==="FIREBASE")return Yo.addLog(e);await fetch(`${yi()}/logs`,{method:"POST",headers:Hu,body:JSON.stringify(e)})},async updateLogs(e){if(ro()==="FIREBASE")return Yo.updateLogs(e);await fetch(`${yi()}/logs/update`,{method:"POST",headers:Hu,body:JSON.stringify(e)})},async saveEndpoint(e){localStorage.setItem("SERVER_ENDPOINT",e)}},yze=({users:e,config:t,logs:n,onUpdateUsers:a,onUpdateConfig:r,onUpdateLogs:s,onBack:i})=>{const[o,l]=We.useState("logs"),[c,u]=We.useState(""),[h,d]=We.useState("none"),[p,f]=We.useState(!1),[m,g]=We.useState(!1),[y,v]=We.useState(!1),[x,w]=We.useState(!1),[k,M]=We.useState(!1),[S,I]=We.useState("logs"),[E,R]=We.useState([]),[A,_]=We.useState([]),[D,j]=We.useState(""),[q,B]=We.useState(""),[Q,H]=We.useState(""),[J,ae]=We.useState(null),[ne,ue]=We.useState(ro()),[le,he]=We.useState(yi()),[me,Re]=We.useState(localStorage.getItem("FIREBASE_CONFIG")||""),[Ne,xe]=We.useState(!1),[Le,Pe]=We.useState(!1);We.useEffect(()=>{he(yi())},[]);const Xe=async()=>{xe(!0);try{if(ne==="FIREBASE"){const ge=JSON.parse(me);if(!N8(ge))throw new Error("Invalid Firebase Config");localStorage.setItem("FIREBASE_CONFIG",me)}else{if(!await bi.checkHealth(le))throw new Error("Cannot reach local server");bi.saveEndpoint(le)}gze(ne),window.location.reload()}catch{Pe(!0)}finally{xe(!1)}},Ue=We.useMemo(()=>n.filter(ge=>ge.userName.toLowerCase().includes(c.toLowerCase())||ge.userId.toLowerCase().includes(c.toLowerCase())),[n,c]),Et=We.useMemo(()=>e.filter(ge=>ge.name.toLowerCase().includes(c.toLowerCase())||ge.employeeId.toLowerCase().includes(c.toLowerCase())),[e,c]),st=We.useMemo(()=>Ue.length>0&&Ue.every(ge=>E.includes(String(ge.id))),[Ue,E]),bt=()=>{if(st){const ge=Ue.map(Ze=>String(Ze.id));R(Ze=>Ze.filter(ht=>!ge.includes(ht)))}else{const ge=Ue.map(Ze=>String(Ze.id));R(Ze=>Array.from(new Set([...Ze,...ge])))}},je=We.useMemo(()=>{if(h==="none")return{"All Logs":Ue};const ge={};return Ue.forEach(Ze=>{let ht="";h==="name"?ht=Ze.userName:h==="date"&&(ht=new Date(Ze.timestamp).toLocaleDateString("id-ID",{weekday:"long",year:"numeric",month:"long",day:"numeric"})),ge[ht]||(ge[ht]=[]),ge[ht].push(Ze)}),ge},[Ue,h]),gt=We.useMemo(()=>{const ge=n.length,Ze=n.filter(kn=>kn.status==="SUCCESS").length,ht=ge>0?Math.round(Ze/ge*100):0;return{total:ge,success:Ze,failed:ge-Ze,successRate:ht}},[n]),Ot=ge=>{R(Ze=>Ze.includes(ge)?Ze.filter(ht=>ht!==ge):[...Ze,ge])},At=ge=>{I(ge),M(!0)},pt=async()=>{M(!1),w(!0);try{if(S==="logs"){const ge=n.filter(Ze=>!E.includes(String(Ze.id)));await s(ge),R([])}else{const ge=e.filter(Ze=>!A.includes(String(Ze.id)));a(ge),_([])}}catch{alert("Gagal menghapus data.")}finally{setTimeout(()=>w(!1),500)}},Nn=()=>{if(!D||!q||!J||!Q)return;const ge={id:Math.random().toString(36).substr(2,9),name:D,employeeId:q,password:Q,photoBase64:J,createdAt:Date.now()};a([...e,ge]),g(!1),j(""),B(""),ae(null),H("")},Cn=async ge=>{v(!0);const Ze=await gMe(ge);v(!1),Ze?ae(ge):alert("Wajah tidak terdeteksi!")};return P.jsxs("div",{className:"admin-root",children:[Le&&P.jsxs("div",{className:"fixed inset-0 z-[5000] flex items-center justify-center p-4",children:[P.jsx("div",{className:"absolute inset-0 bg-red-950/20 backdrop-blur-md",onClick:()=>Pe(!1)}),P.jsxs("div",{className:"bg-white rounded-[2.5rem] p-8 shadow-2xl relative w-full max-w-sm border border-red-50 animate-in zoom-in-95 duration-300",children:[P.jsx("div",{className:"w-16 h-16 bg-red-50 rounded-full flex items-center justify-center mx-auto mb-6",children:P.jsx("svg",{className:"w-8 h-8 text-red-500 animate-bounce",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2.5",d:"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"})})}),P.jsx("h3",{className:"text-xl font-black text-slate-800 text-center uppercase tracking-tighter mb-2",children:"Save Failed"}),P.jsx("p",{className:"text-slate-400 text-[10px] text-center mb-8 font-bold uppercase tracking-widest leading-relaxed",children:"Pastikan konfigurasi atau URL server benar dan aktif."}),P.jsx("button",{onClick:()=>Pe(!1),className:"w-full py-4 bg-red-600 text-white rounded-2xl font-black uppercase text-[10px] tracking-widest",children:"Tutup"})]})]}),k&&P.jsxs("div",{className:"modal-overlay",children:[P.jsx("div",{className:"modal-backdrop",onClick:()=>M(!1)}),P.jsxs("div",{className:"modal-card animate-in zoom-in-95",children:[P.jsx("h3",{className:"text-lg font-black text-slate-800 text-center uppercase",children:"Konfirmasi Hapus"}),P.jsxs("p",{className:"text-slate-500 text-xs text-center mt-2 leading-relaxed",children:["Hapus ",P.jsx("span",{className:"font-bold text-red-600",children:S==="logs"?E.length:A.length})," data terpilih?"]}),P.jsxs("div",{className:"mt-6 flex flex-col gap-2",children:[P.jsx("button",{onClick:pt,className:"w-full py-3 bg-red-600 text-white rounded-xl font-bold uppercase text-[10px]",children:"Ya, Hapus"}),P.jsx("button",{onClick:()=>M(!1),className:"w-full py-3 bg-slate-50 text-slate-500 rounded-xl font-bold uppercase text-[10px]",children:"Batal"})]})]})]}),x&&P.jsx("div",{className:"fixed inset-0 z-[3000] bg-slate-900/80 backdrop-blur-md flex items-center justify-center",children:P.jsxs("div",{className:"text-center",children:[P.jsx("div",{className:"w-10 h-10 border-4 border-white/20 border-t-white rounded-full animate-spin mx-auto mb-3"}),P.jsx("p",{className:"text-white text-[9px] font-black uppercase tracking-widest",children:"Processing..."})]})}),P.jsx("header",{className:"admin-header",children:P.jsxs("div",{className:"flex flex-col md:flex-row md:items-center justify-between gap-3",children:[P.jsxs("div",{className:"flex items-center gap-4",children:[P.jsx("button",{onClick:i,className:"p-1.5 hover:bg-slate-100 rounded-full",children:P.jsx("svg",{className:"w-5 h-5 text-slate-600",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M10 19l-7-7m0 0l7-7m-7 7h18"})})}),P.jsxs("div",{children:[P.jsx("h2",{className:"text-sm md:text-lg font-bold text-slate-800 leading-tight",children:"Admin Portal"}),P.jsx("div",{className:"admin-tab-group no-scrollbar",children:["dashboard","logs","users","settings"].map(ge=>P.jsx("button",{onClick:()=>l(ge),className:`admin-tab-btn ${o===ge?"active":"inactive"}`,children:ge},ge))})]})]}),P.jsx("div",{className:"flex items-center gap-2",children:P.jsxs("div",{className:"admin-search-box",children:[P.jsx("input",{type:"text",placeholder:"Cari...",value:c,onChange:ge=>u(ge.target.value),className:"admin-input"}),P.jsx("svg",{className:"w-3.5 h-3.5 text-slate-400 absolute left-2.5 top-1/2 -translate-y-1/2",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"})})]})})]})}),P.jsxs("main",{className:"flex-1 overflow-hidden flex flex-col",children:[o==="dashboard"&&P.jsx("div",{className:"p-4 md:p-6 space-y-4 overflow-y-auto",children:P.jsx("div",{className:"grid grid-cols-2 md:grid-cols-4 gap-3",children:[{l:"Total Logs",v:gt.total,c:"slate-800"},{l:"Success Rate",v:`${gt.successRate}%`,c:"green-600"},{l:"Absen OK",v:gt.success,c:"indigo-600"},{l:"Storage Mode",v:ne,c:"orange-600"}].map((ge,Ze)=>P.jsxs("div",{className:"bg-white p-4 rounded-xl border shadow-sm text-center",children:[P.jsx("p",{className:"text-[8px] font-bold text-slate-400 uppercase tracking-widest mb-1",children:ge.l}),P.jsx("h4",{className:`text-xl md:text-2xl font-black text-${ge.c}`,children:ge.v})]},Ze))})}),o==="logs"&&P.jsxs("div",{className:"admin-table-wrapper",children:[P.jsxs("div",{className:"bg-white py-2 border-b flex items-center justify-between",children:[P.jsxs("div",{className:"flex items-center",children:[P.jsx("div",{className:"w-11 md:w-11 flex justify-center",children:P.jsx("input",{type:"checkbox",checked:st,onChange:bt,className:"w-3.5 h-3.5 rounded border-slate-300 text-indigo-600 cursor-pointer"})}),P.jsx("p",{className:"text-[9px] md:text-[11px] font-black text-slate-400 uppercase tracking-widest mr-3",children:"Aktivitas Terbaru"}),P.jsxs("div",{className:"relative",children:[P.jsxs("button",{onClick:()=>f(!p),className:`flex items-center gap-1.5 px-2 py-1 rounded-md text-[8px] font-black uppercase transition-all ${h!=="none"?"bg-indigo-50 text-indigo-600":"bg-slate-50 text-slate-400 hover:bg-slate-100"}`,children:[P.jsx("svg",{className:"w-3 h-3",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M4 6h16M4 10h16M4 14h16M4 18h16"})}),"Group: ",h]}),p&&P.jsx("div",{className:"absolute top-full left-0 mt-1 bg-white border rounded-xl shadow-xl z-[100] py-1 min-w-[120px] animate-in slide-in-from-top-2",children:["none","name","date"].map(ge=>P.jsx("button",{onClick:()=>{d(ge),f(!1)},className:`w-full text-left px-4 py-2 text-[9px] font-black uppercase hover:bg-slate-50 ${h===ge?"text-indigo-600 bg-indigo-50/30":"text-slate-500"}`,children:ge},ge))})]})]}),P.jsx("div",{className:"pr-4 md:pr-6",children:E.length>0&&P.jsx("button",{onClick:()=>At("logs"),className:"p-1 bg-red-50 text-red-600 rounded border border-red-100 animate-in zoom-in-95",children:P.jsx("svg",{className:"w-3.5 h-3.5",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"})})})})]}),P.jsx("div",{className:"admin-table-container admin-custom-scrollbar",children:P.jsxs("table",{className:"admin-table",children:[P.jsx("thead",{className:"admin-thead",children:P.jsxs("tr",{children:[P.jsx("th",{className:"px-3 py-3 w-8 text-center",children:"#"}),P.jsx("th",{className:"px-2 py-3",children:"Nama"}),P.jsx("th",{className:"px-2 py-3",children:"Waktu"}),P.jsx("th",{className:"px-2 py-3 text-center",children:"GPS"})]})}),P.jsx("tbody",{className:"admin-tbody divide-y divide-slate-100",children:Object.entries(je).map(([ge,Ze])=>P.jsxs(RF.Fragment,{children:[h!=="none"&&P.jsx("tr",{className:"bg-slate-50/80 backdrop-blur-sm sticky top-[36px] z-[30]",children:P.jsxs("td",{colSpan:4,className:"px-4 py-1.5 text-[8px] font-black text-indigo-500 uppercase tracking-widest border-y border-slate-100",children:[P.jsx("span",{className:"opacity-50 mr-1",children:"Group:"})," ",ge," (",Ze.length,")"]})}),Ze.map(ht=>{const kn=E.includes(String(ht.id)),vn=new Date(ht.timestamp);return P.jsxs("tr",{className:`hover:bg-[#F8F9FA] transition-colors ${kn?"bg-indigo-50/40":""}`,children:[P.jsx("td",{className:"px-3 py-2 text-center",children:P.jsx("input",{type:"checkbox",checked:kn,onChange:()=>Ot(String(ht.id)),className:"w-3.5 h-3.5 rounded border-slate-300 text-indigo-600 cursor-pointer"})}),P.jsxs("td",{className:"px-2 py-2 flex items-center gap-2",children:[P.jsx("img",{src:ht.capturedPhoto,className:"w-7 h-7 md:w-10 md:h-10 rounded-lg object-cover border",alt:""}),P.jsxs("div",{className:"min-w-0",children:[P.jsx("p",{className:"font-bold truncate text-slate-800",children:ht.userName}),P.jsx("p",{className:"text-[8px] text-slate-400 font-mono",children:ht.userId})]})]}),P.jsxs("td",{className:"px-2 py-2 log-time-display",children:[P.jsx("span",{className:"log-time-bold",children:vn.toLocaleTimeString("id-ID",{hour:"2-digit",minute:"2-digit"}).replace(":",".")}),P.jsx("span",{className:"log-time-separator",children:"|"}),P.jsx("span",{className:"log-date-normal",children:vn.toLocaleDateString("id-ID",{day:"2-digit",month:"2-digit",year:"2-digit"})})]}),P.jsx("td",{className:"px-2 py-2 text-center",children:P.jsxs("div",{className:"gps-icon-wrapper",children:[P.jsxs("svg",{className:"w-3.5 h-3.5",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:[P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"}),P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M15 11a3 3 0 11-6 0 3 3 0 016 0z"})]}),P.jsxs("div",{className:"tooltip-box animate-in fade-in zoom-in-95",children:[P.jsxs("div",{className:"tooltip-content",children:[ht.location.lat.toFixed(6),", ",ht.location.lng.toFixed(6)]}),P.jsx("div",{className:"tooltip-arrow"})]})]})})]},ht.id)})]},ge))})]})})]}),o==="users"&&P.jsxs("div",{className:"p-4 md:p-8 space-y-4 overflow-y-auto",children:[P.jsxs("div",{className:"flex items-center justify-between",children:[P.jsxs("h3",{className:"text-[10px] font-black text-slate-400 uppercase tracking-widest",children:["Data Karyawan (",e.length,")"]}),P.jsx("button",{onClick:()=>g(!0),className:"bg-indigo-600 text-white px-4 py-2 rounded-lg text-[9px] font-black uppercase tracking-widest",children:"+ Baru"})]}),m?P.jsx("div",{className:"bg-white p-6 rounded-2xl border shadow-lg max-w-2xl mx-auto animate-in zoom-in-95",children:P.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-6",children:[P.jsxs("div",{className:"space-y-4",children:[P.jsx("input",{type:"text",placeholder:"Nama Lengkap",value:D,onChange:ge=>j(ge.target.value),className:"w-full bg-white border rounded-lg p-3 text-xs outline-none focus:ring-2 focus:ring-indigo-500/20"}),P.jsx("input",{type:"text",placeholder:"ID Pegawai (NIK)",value:q,onChange:ge=>B(ge.target.value),className:"w-full bg-white border rounded-lg p-3 text-xs outline-none focus:ring-2 focus:ring-indigo-500/20"}),P.jsx("input",{type:"password",placeholder:"Password Login",value:Q,onChange:ge=>H(ge.target.value),className:"w-full bg-white border rounded-lg p-3 text-xs outline-none focus:ring-2 focus:ring-indigo-500/20"}),P.jsxs("div",{className:"flex gap-2",children:[P.jsx("button",{onClick:Nn,disabled:!D||!q||!J||!Q,className:"flex-1 bg-indigo-600 text-white py-3 rounded-xl font-black text-[9px] uppercase disabled:bg-slate-300",children:"Simpan"}),P.jsx("button",{onClick:()=>g(!1),className:"px-4 border py-3 rounded-xl font-black text-[9px] uppercase",children:"Batal"})]})]}),P.jsx("div",{children:J?P.jsxs("div",{className:"relative rounded-xl overflow-hidden shadow-md",children:[P.jsx("img",{src:J,className:"w-full h-32 object-cover"}),P.jsx("button",{onClick:()=>ae(null),className:"absolute top-2 right-2 bg-red-600 text-white p-1 rounded-full",children:P.jsx("svg",{className:"w-4 h-4",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M6 18L18 6M6 6l12 12"})})})]}):P.jsx(kz,{onCapture:Cn,label:"Ambil Foto Master"})})]})}):P.jsx("div",{className:"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3",children:Et.map(ge=>P.jsxs("div",{className:"bg-white border p-3 rounded-xl flex items-center gap-3 relative transition-all group",children:[P.jsx("img",{src:ge.photoBase64,className:"w-10 h-10 rounded-lg object-cover",alt:""}),P.jsxs("div",{className:"flex-1 min-w-0",children:[P.jsx("p",{className:"font-bold text-slate-800 text-[11px] truncate leading-tight",children:ge.name}),P.jsx("p",{className:"text-[9px] text-slate-400 font-black uppercase tracking-widest",children:ge.employeeId})]}),P.jsx("button",{onClick:()=>{_([String(ge.id)]),At("users")},className:"text-slate-300 hover:text-red-500 p-1 opacity-40 group-hover:opacity-100",children:P.jsx("svg",{className:"w-3.5 h-3.5",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"})})})]},ge.id))})]}),o==="settings"&&P.jsxs("div",{className:"p-4 md:p-8 overflow-y-auto space-y-6",children:[P.jsxs("div",{className:"max-w-md mx-auto bg-white border rounded-2xl p-6 shadow-sm space-y-4",children:[P.jsxs("div",{className:"text-center",children:[P.jsx("h3",{className:"text-[10px] font-black text-slate-400 uppercase tracking-widest mb-1",children:"Penyimpanan Utama"}),P.jsx("p",{className:"text-[8px] text-slate-400 leading-tight",children:"Pilih sumber database (Dual Mode)"})]}),P.jsxs("div",{className:"grid grid-cols-2 gap-2 bg-slate-50 p-1 rounded-xl",children:[P.jsx("button",{onClick:()=>ue("LOCAL"),className:`py-2 rounded-lg text-[9px] font-black uppercase transition-all ${ne==="LOCAL"?"bg-white shadow-sm text-indigo-600":"text-slate-400"}`,children:"Node.js (Local)"}),P.jsx("button",{onClick:()=>ue("FIREBASE"),className:`py-2 rounded-lg text-[9px] font-black uppercase transition-all ${ne==="FIREBASE"?"bg-white shadow-sm text-orange-600":"text-slate-400"}`,children:"Firebase (Cloud)"})]}),ne==="LOCAL"?P.jsxs("div",{className:"space-y-3 pt-2",children:[P.jsx("input",{type:"text",value:le,onChange:ge=>he(ge.target.value),placeholder:"https://.../api",className:"w-full bg-slate-50 border rounded-lg px-4 py-3 text-[11px] font-bold outline-none"}),P.jsx("button",{onClick:Xe,disabled:Ne,className:"w-full py-3 bg-indigo-600 text-white rounded-xl font-black text-[9px] uppercase tracking-widest",children:Ne?"Connecting...":"Update Local Server"})]}):P.jsxs("div",{className:"space-y-3 pt-2",children:[P.jsx("textarea",{value:me,onChange:ge=>Re(ge.target.value),placeholder:"Paste firebaseConfig object here...",className:"w-full bg-slate-50 border rounded-lg px-4 py-3 text-[10px] font-mono h-32 outline-none resize-none"}),P.jsx("button",{onClick:Xe,disabled:Ne,className:"w-full py-3 bg-orange-600 text-white rounded-xl font-black text-[9px] uppercase tracking-widest",children:Ne?"Connecting...":"Update Firebase Cloud"}),P.jsx("p",{className:"text-[7px] text-center text-slate-400",children:"Dapatkan di: Firebase Console lalu Project Settings lalu General"})]})]}),P.jsxs("div",{className:"max-w-md mx-auto bg-white border rounded-2xl p-6 shadow-sm space-y-6",children:[P.jsxs("div",{className:"text-center",children:[P.jsx("h3",{className:"text-[10px] font-black text-slate-400 uppercase tracking-widest",children:"Geofencing"}),P.jsx("p",{className:"text-slate-400 text-[8px]",children:"Koordinat Pusat Absen Kantor"})]}),P.jsxs("div",{className:"grid grid-cols-2 gap-4",children:[P.jsxs("div",{className:"space-y-1",children:[P.jsx("label",{className:"text-[8px] font-black text-slate-400 uppercase",children:"Latitude"}),P.jsx("input",{type:"number",step:"any",value:t.latitude,onChange:ge=>r({...t,latitude:parseFloat(ge.target.value)||0}),className:"w-full bg-slate-50 border rounded-lg px-3 py-2 text-[11px] font-bold"})]}),P.jsxs("div",{className:"space-y-1",children:[P.jsx("label",{className:"text-[8px] font-black text-slate-400 uppercase",children:"Longitude"}),P.jsx("input",{type:"number",step:"any",value:t.longitude,onChange:ge=>r({...t,longitude:parseFloat(ge.target.value)||0}),className:"w-full bg-slate-50 border rounded-lg px-3 py-2 text-[11px] font-bold"})]})]}),P.jsxs("div",{className:"space-y-1",children:[P.jsx("label",{className:"text-[8px] font-black text-slate-400 uppercase block text-center",children:"Radius (Meter)"}),P.jsx("input",{type:"number",value:t.maxDistance,onChange:ge=>r({...t,maxDistance:parseInt(ge.target.value)||10}),className:"w-full bg-slate-50 border rounded-lg px-3 py-2 text-center text-lg font-black"})]}),P.jsx("button",{onClick:()=>navigator.geolocation.getCurrentPosition(ge=>r({...t,latitude:ge.coords.latitude,longitude:ge.coords.longitude})),className:"w-full py-3 bg-slate-800 text-white rounded-xl font-black text-[9px] uppercase tracking-widest",children:"Gunakan Lokasi Saya"})]})]})]})]})};function bze(e,t,n,a){const s=e*Math.PI/180,i=n*Math.PI/180,o=(n-e)*Math.PI/180,l=(a-t)*Math.PI/180,c=Math.sin(o/2)*Math.sin(o/2)+Math.cos(s)*Math.cos(i)*Math.sin(l/2)*Math.sin(l/2);return 6371e3*(2*Math.atan2(Math.sqrt(c),Math.sqrt(1-c)))}function vze(){return new Promise((e,t)=>{if(!navigator.geolocation){t(new Error("Geolocation is not supported by your browser"));return}navigator.geolocation.getCurrentPosition(e,t,{enableHighAccuracy:!0,timeout:5e3,maximumAge:0})})}const xze=({users:e,config:t,onAddLog:n,onBack:a})=>{const[r,s]=We.useState(null),[i,o]=We.useState(null),[l,c]=We.useState("loading_models"),[u,h]=We.useState(""),[d,p]=We.useState(null),[f,m]=We.useState(""),[g,y]=We.useState(""),[v,x]=We.useState(!1);We.useEffect(()=>{(async()=>{try{await HA(),c("login")}catch{h("Failed to load AI models."),c("error")}})()},[]);const w=S=>{S.preventDefault();const I=e.find(E=>(E.employeeId===f||E.name.toLowerCase()===f.toLowerCase())&&E.password===g);I?(s(I),c("idle"),h(""),x(!1)):x(!0)},k=async S=>{if(!(!r||l==="verifying"||l==="success")){o(S),c("verifying"),h("Mengecek Lokasi...");try{const I=await vze(),E=bze(I.coords.latitude,I.coords.longitude,t.latitude,t.longitude);if(p(E),E>t.maxDistance){c("error"),h(`Jarak terlalu jauh (${E.toFixed(0)}m). Maksimal ${t.maxDistance}m.`);return}if(h("Menganalisis Wajah..."),(await mMe(r.photoBase64,S)).isMatch){const A={id:Math.random().toString(36).substr(2,9),userId:r.employeeId,userName:r.name,timestamp:Date.now(),status:"SUCCESS",location:{lat:I.coords.latitude,lng:I.coords.longitude},distance:E,capturedPhoto:S};n(A),c("success"),h(`Absensi Berhasil! Halo ${r.name}.`)}else c("error"),h("Wajah tidak sesuai. Pastikan wajah terlihat jelas.")}catch{c("error"),h("Gagal mengakses data lokasi atau sensor.")}}},M=()=>{s(null),o(null),c("login"),h(""),m(""),y(""),p(null)};return l==="loading_models"?P.jsx("div",{className:"min-h-screen bg-slate-900 flex items-center justify-center p-6",children:P.jsxs("div",{className:"text-center",children:[P.jsx("div",{className:"w-10 h-10 border-4 border-indigo-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"}),P.jsx("p",{className:"text-indigo-300 text-[10px] font-black uppercase tracking-widest",children:"Loading AI Engine..."})]})}):P.jsxs("div",{className:"min-h-screen bg-slate-900 text-white p-4 md:p-6 flex flex-col items-center",children:[v&&P.jsxs("div",{className:"fixed inset-0 z-[5000] flex items-center justify-center p-4",children:[P.jsx("div",{className:"absolute inset-0 bg-slate-950/60 backdrop-blur-md",onClick:()=>x(!1)}),P.jsxs("div",{className:"bg-slate-800 rounded-[2rem] p-8 shadow-2xl relative w-full max-w-sm border border-white/5 animate-in zoom-in-95 duration-300",children:[P.jsx("div",{className:"w-16 h-16 bg-red-500/10 rounded-full flex items-center justify-center mx-auto mb-6",children:P.jsx("svg",{className:"w-8 h-8 text-red-500 animate-pulse",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2.5",d:"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"})})}),P.jsx("h3",{className:"text-xl font-black text-slate-100 text-center uppercase tracking-tighter leading-none mb-2",children:"Akses Ditolak"}),P.jsxs("p",{className:"text-slate-500 text-[10px] text-center mb-8 font-bold uppercase tracking-widest leading-relaxed",children:["ID atau Password salah.",P.jsx("br",{}),"Silakan periksa kembali data Anda."]}),P.jsx("div",{className:"space-y-2",children:P.jsx("button",{onClick:()=>x(!1),className:"w-full py-4 bg-red-600 text-white rounded-2xl font-black uppercase text-[10px] tracking-widest shadow-lg shadow-red-900/20 active:scale-95 transition-all",children:"Coba Lagi"})})]})]}),P.jsxs("div",{className:"w-full max-w-lg",children:[P.jsxs("header",{className:"flex items-center justify-between mb-6 md:mb-8",children:[P.jsx("button",{onClick:a,className:"p-2 bg-white/5 hover:bg-white/10 rounded-full transition-colors",children:P.jsx("svg",{className:"w-5 h-5",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M10 19l-7-7m0 0l7-7m-7 7h18"})})}),P.jsxs("div",{className:"text-right",children:[P.jsx("h1",{className:"text-lg md:text-xl font-black bg-gradient-to-r from-indigo-400 to-purple-400 bg-clip-text text-transparent uppercase tracking-tighter",children:"Presence AI"}),P.jsx("p",{className:"text-slate-500 text-[9px] uppercase font-black",children:new Date().toLocaleDateString("id-ID",{weekday:"short",day:"numeric",month:"short"})})]})]}),l==="login"?P.jsxs("div",{className:"bg-slate-800/50 rounded-2xl p-8 border border-white/5 shadow-2xl animate-in fade-in slide-in-from-bottom-4",children:[P.jsxs("div",{className:"text-center mb-8",children:[P.jsx("h2",{className:"text-[12px] font-black text-indigo-400 uppercase tracking-[0.2em] mb-1",children:"User Login"}),P.jsx("p",{className:"text-slate-500 text-[9px] font-bold uppercase tracking-widest",children:"Masukkan Kredensial Absen"})]}),P.jsxs("form",{onSubmit:w,className:"space-y-4",children:[P.jsxs("div",{children:[P.jsx("label",{className:"text-[8px] font-black text-slate-500 uppercase tracking-widest ml-1 mb-1 block",children:"ID Pegawai / Nama"}),P.jsx("input",{type:"text",value:f,onChange:S=>m(S.target.value),className:"w-full bg-slate-900/50 border border-white/10 rounded-xl px-4 py-3.5 text-xs outline-none focus:ring-2 focus:ring-indigo-500/20 transition-all",placeholder:"Contoh: NIK12345",required:!0})]}),P.jsxs("div",{children:[P.jsx("label",{className:"text-[8px] font-black text-slate-500 uppercase tracking-widest ml-1 mb-1 block",children:"Password"}),P.jsx("input",{type:"password",value:g,onChange:S=>y(S.target.value),className:"w-full bg-slate-900/50 border border-white/10 rounded-xl px-4 py-3.5 text-xs outline-none focus:ring-2 focus:ring-indigo-500/20 transition-all",placeholder:"",required:!0})]}),P.jsx("button",{type:"submit",className:"w-full py-4 bg-indigo-600 text-white rounded-2xl font-black uppercase tracking-widest text-[10px] shadow-lg shadow-indigo-900/20 active:scale-95 transition-all",children:"Masuk ke Absensi"})]}),P.jsxs("p",{className:"text-center mt-8 text-slate-500 text-[8px] font-bold uppercase tracking-widest leading-relaxed",children:["Data login dikelola oleh Admin.",P.jsx("br",{}),"Lupa password? Hubungi HRD."]})]}):P.jsxs("div",{className:"space-y-4 animate-in fade-in duration-500",children:[P.jsxs("div",{className:"bg-slate-800/80 rounded-2xl p-5 border border-white/10 shadow-2xl",children:[r&&P.jsxs("div",{className:"flex items-center gap-3 mb-6",children:[P.jsxs("div",{className:"relative",children:[P.jsx("img",{src:r.photoBase64,alt:"",className:"w-12 h-12 rounded-xl object-cover ring-2 ring-indigo-500/30"}),P.jsx("div",{className:"absolute -bottom-1 -right-1 w-4 h-4 bg-indigo-500 rounded-full border-2 border-slate-800 flex items-center justify-center",children:P.jsx("div",{className:"w-1.5 h-1.5 bg-white rounded-full animate-pulse"})})]}),P.jsxs("div",{className:"min-w-0",children:[P.jsx("h3",{className:"text-sm font-bold truncate text-slate-100",children:r.name}),P.jsx("p",{className:"text-slate-500 text-[10px] font-black uppercase tracking-widest",children:r.employeeId})]}),P.jsx("button",{onClick:M,className:"ml-auto text-slate-400 hover:text-white text-[9px] uppercase font-black bg-white/5 px-3 py-1.5 rounded-lg transition-colors",children:"Log Out"})]}),l==="idle"&&P.jsx("div",{className:"animate-in fade-in zoom-in-95 duration-700",children:P.jsx(kz,{onCapture:k,label:"Posisikan wajah Anda di tengah kotak",autoCapture:!0})}),l==="verifying"&&P.jsxs("div",{className:"py-12 flex flex-col items-center justify-center space-y-4 animate-in fade-in",children:[P.jsxs("div",{className:"relative",children:[P.jsx("div",{className:"w-16 h-16 border-4 border-indigo-500/10 rounded-full"}),P.jsx("div",{className:"w-16 h-16 border-4 border-indigo-500 border-t-transparent rounded-full animate-spin absolute inset-0"})]}),P.jsx("p",{className:"text-xs font-black uppercase text-indigo-400 animate-pulse tracking-widest",children:u})]}),l==="success"&&P.jsxs("div",{className:"py-8 text-center space-y-6 animate-in zoom-in-95",children:[P.jsx("div",{className:"w-20 h-20 bg-green-500/10 rounded-full flex items-center justify-center mx-auto ring-4 ring-green-500/5",children:P.jsx("svg",{className:"w-10 h-10 text-green-500",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"3",d:"M5 13l4 4L19 7"})})}),P.jsxs("div",{className:"space-y-1",children:[P.jsx("h4",{className:"text-xl font-black text-green-400 uppercase italic tracking-tighter",children:"SUCCESS!"}),P.jsx("p",{className:"text-slate-300 text-[11px] font-medium max-w-[200px] mx-auto leading-relaxed",children:u})]}),P.jsx("button",{onClick:M,className:"px-10 py-3 bg-white/10 hover:bg-white/20 text-white rounded-xl font-black text-[10px] uppercase tracking-widest transition-all",children:"Selesai"})]}),l==="error"&&P.jsxs("div",{className:"py-8 text-center space-y-6 animate-in zoom-in-95",children:[P.jsx("div",{className:"w-20 h-20 bg-red-500/10 rounded-full flex items-center justify-center mx-auto ring-4 ring-red-500/5",children:P.jsx("svg",{className:"w-10 h-10 text-red-500",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:P.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"3",d:"M6 18L18 6M6 6l12 12"})})}),P.jsxs("div",{className:"space-y-1",children:[P.jsx("h4",{className:"text-xl font-black text-red-400 uppercase italic tracking-tighter",children:"FAILED"}),P.jsx("p",{className:"text-slate-300 text-[11px] px-6 font-medium leading-relaxed",children:u})]}),P.jsx("button",{onClick:()=>c("idle"),className:"px-10 py-3 bg-indigo-600 hover:bg-indigo-500 shadow-xl shadow-indigo-500/20 text-white rounded-xl font-black text-[10px] uppercase tracking-widest transition-all",children:"Coba Lagi"})]})]}),(l==="verifying"||l==="success"||l==="error")&&i&&r&&P.jsxs("div",{className:"grid grid-cols-2 gap-3 animate-in slide-in-from-bottom-2",children:[P.jsxs("div",{className:"bg-slate-800/50 p-2 rounded-xl border border-white/5",children:[P.jsx("p",{className:"text-[7px] uppercase text-slate-500 mb-1.5 font-black tracking-widest",children:"Master ID"}),P.jsx("img",{src:r.photoBase64,alt:"",className:"w-full h-24 object-cover rounded-lg ring-1 ring-white/5"})]}),P.jsxs("div",{className:"bg-slate-800/50 p-2 rounded-xl border border-white/5",children:[P.jsx("p",{className:"text-[7px] uppercase text-slate-500 mb-1.5 font-black tracking-widest",children:"Realtime Capture"}),P.jsx("img",{src:i,alt:"",className:"w-full h-24 object-cover rounded-lg ring-1 ring-white/5"})]})]})]})]})]})},wze=()=>{const[e,t]=We.useState(ao.LOGIN),[n,a]=We.useState([]),[r,s]=We.useState({latitude:-6.2,longitude:106.816666,maxDistance:100}),[i,o]=We.useState([]),[l,c]=We.useState(!0),[u,h]=We.useState(!0),d=async()=>{try{const[x,w,k]=await Promise.all([bi.getUsers(),bi.getConfig(),bi.getLogs()]);a(x||[]),s(w),o(k||[]),h(!0)}catch{h(!1)}finally{c(!1)}};We.useEffect(()=>{d();const x=setInterval(async()=>{const w=await bi.checkHealth();h(w),w&&n.length===0&&d()},5e3);return()=>clearInterval(x)},[n.length]);const p=async x=>{try{await bi.saveUsers(x),a([...x])}catch{alert("Gagal sinkronisasi data.")}},f=async x=>{try{await bi.saveConfig(x),s({...x})}catch{alert("Gagal menyimpan konfigurasi.")}},m=async x=>{if(x.status==="SUCCESS")try{await bi.addLog(x),o(w=>[x,...w])}catch(w){console.error(w)}},g=async x=>{try{await bi.updateLogs(x),o([...x])}catch(w){throw w}},y=()=>P.jsxs("div",{className:"fixed top-4 right-4 z-[9999] flex items-center gap-2 bg-white/80 backdrop-blur-md px-3 py-1.5 rounded-full shadow-sm border border-slate-100",children:[P.jsx("div",{className:`w-2 h-2 rounded-full animate-pulse ${u?"bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.6)]":"bg-red-500 shadow-[0_0_8px_rgba(239,68,68,0.6)]"}`}),P.jsx("span",{className:"text-[9px] font-black uppercase tracking-widest text-slate-500",children:u?"Connected":"Offline"})]});if(l&&u)return P.jsx("div",{className:"min-h-screen flex items-center justify-center bg-slate-50",children:P.jsxs("div",{className:"text-center",children:[P.jsx("div",{className:"w-10 h-10 border-4 border-indigo-600 border-t-transparent rounded-full animate-spin mx-auto mb-3"}),P.jsx("p",{className:"text-slate-400 font-black uppercase text-[9px] tracking-[0.3em]",children:"Smart Presence..."})]})});const v=()=>{switch(e){case ao.LOGIN:return P.jsxs("div",{className:"min-h-screen flex items-center justify-center p-4 bg-[#F1F3F5]",children:[P.jsx(y,{}),P.jsxs("div",{className:"bg-white p-8 md:p-12 rounded-3xl shadow-2xl w-full max-w-xs border border-slate-100 text-center",children:[P.jsx("h1",{className:"text-xl md:text-2xl font-black text-slate-800 mb-1 tracking-tighter uppercase",children:"Presence"}),P.jsx("p",{className:"text-slate-400 text-[9px] font-black mb-10 tracking-[0.2em] uppercase italic",children:"Smart System"}),P.jsxs("div",{className:"space-y-3",children:[P.jsx("button",{onClick:()=>t(ao.ADMIN_PANEL),className:"w-full py-3.5 bg-indigo-600 text-white rounded-2xl font-black uppercase tracking-widest text-[10px] shadow-lg shadow-indigo-100 transition-all active:scale-95",children:"Admin Portal"}),P.jsx("button",{onClick:()=>t(ao.USER_PANEL),className:"w-full py-3.5 bg-white border-2 border-slate-100 text-slate-700 rounded-2xl font-black uppercase tracking-widest text-[10px] transition-all active:scale-95",children:"Check-in"})]}),!u&&P.jsx("p",{className:"mt-4 text-[8px] text-red-500 font-bold uppercase tracking-widest animate-pulse",children:"Server Unreachable - Local Only"})]})]});case ao.ADMIN_PANEL:return P.jsxs(P.Fragment,{children:[P.jsx(y,{}),P.jsx(yze,{users:n,config:r,logs:i,onUpdateUsers:p,onUpdateConfig:f,onUpdateLogs:g,onBack:()=>t(ao.LOGIN)})]});case ao.USER_PANEL:return P.jsxs(P.Fragment,{children:[P.jsx(y,{}),P.jsx(xze,{users:n,config:r,onAddLog:m,onBack:()=>t(ao.LOGIN)})]});default:return P.jsx("div",{className:"p-10 text-center",children:"Not Found"})}};return P.jsx(P.Fragment,{children:v()})},C8=document.getElementById("root");if(!C8)throw new Error("Could not find root element to mount to");const _ze=C7.createRoot(C8);_ze.render(P.jsx(RF.StrictMode,{children:P.jsx(wze,{})}));
